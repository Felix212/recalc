HA$PBExportHeader$uo_cart_diagram.sru
$PBExportComments$Cart Diagramme erzeugen
forward
global type uo_cart_diagram from nonvisualobject
end type
end forward

global type uo_cart_diagram from nonvisualobject
end type
global uo_cart_diagram uo_cart_diagram

type prototypes

end prototypes

type variables


// 09.02.2010 Ulrich Paudler [UP] vor$$HEX1$$fc00$$ENDHEX$$bergehend deaktiviert
boolean			bFloatingContent = FALSE
PUBLIC	boolean			bHasDimensions = FALSE

Long				iCurrentRow
Long				iCurrentColumn

uo_cart_datastore		dsPLContents
uo_cart_datastore		dsLayoutAddObjects
uo_cart_datastore		dsLayoutDimension
uo_cart_datastore		dsObjects

CONSTANT Long EMPTY = 0
CONSTANT Long DRAWER = 1
CONSTANT Long TRAY = 2
CONSTANT Long DRAWERFOOD = 3
CONSTANT Long TRAYNONFOOD= 4
CONSTANT Long FLOATING = 5
CONSTANT Long CONTENTTEXT = 6
CONSTANT Long BLOCKED = 9
CONSTANT Long PACKINGLIST = 10
CONSTANT Long DRAWER_3RUNG = 11
CONSTANT Long DRAWERFOOD_3RUNG = 12
CONSTANT Long DRAWER_MULTI_RUNG = 13

CONSTANT Long LISTOFCOMPONENTS = 99

// 20.10.2009 Ulrich Paudler [UP]
CONSTANT Long KEEPORDER = 0
CONSTANT Long COLUMNORDER		= 1
CONSTANT Long ROWORDER			= 2
CONSTANT Long COLUMNORDERINV	= 3
CONSTANT Long ROWORDERINV		= 4

// 26.10.2009 Ulrich Paudler [UP]
CONSTANT Long CONTAINER			= 0
CONSTANT Long TROLLEY			= 1

CONSTANT Long CONTENT			= 1
CONSTANT Long EXPLOSION			= 2
CONSTANT Long DISTRIBUTION		= 3

CONSTANT Long NAM_BARCODE_OFFSET = 120

Datastore			oDs
Datawindow			oDw
Datawindow			oDwBacklog
Datastore			oDsBacklog

Public	DataStore			ids_TR_Exclusions
// ---------------------------------------------------
// 22.04.2010, KF
// Stauort, zum gezielteren debuggen
// ---------------------------------------------------
string				isStowage	= ""
Long					iTrace		= 0

PUBLIC	Long			il_AirlineKey 


PUBLIC	String		is_TR_Name

Private:
Long					lLayoutKey
Long					il_IndexKey
Long					lDetailKey
String				sUnit						= ""
Long					lXOffSet 				=  50
Long					lYOffSet 				=  30
Long					lDefaultWidth 			= 322
Long					lDefaultWidthSmall 	= 255
Long					lDefaultHeight 		=  52
Long 					lErrorCount				=   0
String				sError
String				sTempPath
String				sRegisteredFiles[]
String				is_LogFile = "cart_diagram.log"
Long					iMaxContent							=  4
Long					iMaxContentDrawer					= 10
Long					iMaxRowsContent					=  6
Long					iMaxRowsContentExplosion	 	=  5

Long					iMaxContentTray					=  2
Long					iMaxContentDrawerFood			=  5

Long					iMaxContentDrawer3Rung			= 18
Long					iMaxRowsContent3Rung				= 10
Long					iMaxRowsContentExplosion3Rung =  9

Long					iMaxRowsContentTray				=  2
Long					iMaxRowsContentTrayNF			=  2
Long					iMaxRowsContentExplosionTray	=  1

Long					iMaxRowsContentTRExplosion		=  7


Boolean				ib_Print_Best_Before = FALSE
Long					il_Best_Before_Minutes
PUBLIC		String				is_Kitchen_Time
PUBLIC		String				is_Departure_Time

// TSC: AuditTrai: zum merken, ob ein reset angefordert wurde, damit er kurz vor dem commit getrackt werden kann
Long					il_audit_reset = -1

//Datetime				dDeparture

PUBLIC	Date			idt_Departure

uo_cart_datastore 	dsAirlineEq
uo_cart_datastore 	dsLayout
PUBLIC	uo_cart_datastore 	dsLayoutDetail
PUBLIC	uo_cart_datastore 	dsLayoutContents

uo_cart_datastore 	dsPL

// 03.09.2009 Ulrich Paudler [UP]
uo_cart_datastore		dsBacklog
boolean					bBacklog = false
Long						iCachedInitValue = 0

// 23.09.2009 Ulrich Paudler [UP]
long						ilCachedAirlineKey
string					isCachedUnit

// 05.10.2009 Ulrich Paudler [UP] Groessenpruefung
uo_cart_datastore 	dsPLSize
Long						llMaxContentLength = 6000

// 20.10.2009 Ulrich Paudler [UP]
string 					isContainerShortName
long 						ilContainerType
Long						il_Equipment_Width = 1

// 05.11.2009 Ulrich Paudler [UP] Distribution mit aufgenommen
uo_cart_distribution 	iuo_CartDistribution

// Cache f$$HEX1$$fc00$$ENDHEX$$r Profilestring
String sCachedUser 	= ""
String sCachedSection= ""
String sCachedKey		= ""
String sCachedValue	= ""

// 18.01.2010 Ulrich Paudler [UP]
CONSTANT Long	INITIALWIDTH 			= 322
CONSTANT Long	INITIALWIDTHSMALL 	= 255

CONSTANT Long	INITIALOFFSET1			= 186
CONSTANT Long	INITIALOFFSET2			=  40

CONSTANT Long	INITIALOFFSETSMALL1	= 186
CONSTANT Long	INITIALOFFSETSMALL2	= 200

CONSTANT Long	TEXTWIDTH1				= 280
CONSTANT Long	TEXTWIDTH2				= 322
CONSTANT Long	TEXTWIDTHSMALL1		= 255
CONSTANT Long	TEXTWIDTHSMALL2		= 255

CONSTANT Long	TEXTWIDTHTRSMALL		= 240



Boolean		ibEdit = FALSE
Long			ilColumnCount				= 0

//cacheing
String isCartDiagramFooter = ""
String isCartDiagramDistribution = ""
String isCartDiagramComponentList = ""
String isCartDiagramComponentDisplay = ""

String isTRCartDiagramFooter = ""
String isTRCartDiagramDistribution = ""
String isTRCartDiagramComponentList = ""
String isTRCartDiagramComponentDisplay = ""

String isCartDiagramBacklog = ""
String isCartDiagramBacklogSection = ""
Long   ilCartDiagramBacklogCounter = 0
Long   ilCartDiagramCompListCounter = 0

String isCartDiagramDownlineSetting = ""
Long   ilCartDiagramDownlineCounter = 0
//String isCartDiagramDownlineSetting = ""


// 02.02.2010 Ulrich Paudler [UP]
CONSTANT Long TEXTOBJECT							= 1
CONSTANT Long BITMAPOBJECT							= 2
CONSTANT Long RECTANGLEOBJECT						= 3
CONSTANT Long CONTENTOBJECT						= 4
CONSTANT Long FLOATCONTENTOBJECT					= 5
CONSTANT Long CONTENT_TEXT_OBJECT				= 6
CONSTANT Long CONTENT_TEXT_OBJECT_EXPLODED	= 7
// 1 = text, 2 = bitmap, 3 = rectangle, 4 = content

// ---------------------------------------------------
// 22.04.2010, KF
// 
// ---------------------------------------------------
Long	ilColumnWidth[]
Long 	ilColumnX[]
Long 	ilColumnY[]


CONSTANT		Integer			BORDER_NONE						= 0
CONSTANT		Integer			BORDER_SHADOW					= 1
CONSTANT		Integer			BORDER_BOX						= 2
CONSTANT		Integer			BORDER_RESIZE					= 3
CONSTANT		Integer			BORDER_UNDERLINE				= 4
CONSTANT		Integer			BORDER_LOWERED					= 5
CONSTANT		Integer			BORDER_RAISED					= 6

CONSTANT		Long				TR_CART							= 2
CONSTANT		Integer			AISLE_FLAG						= 6
CONSTANT		Integer			FONT_BOLD						= 700
CONSTANT		Integer			FONT_NORMAL						= 400
CONSTANT		Integer			WATERMARK_CLASS				= 100
CONSTANT		Integer			WATERMARK_DOWNLINE			= 101
CONSTANT		Integer			WATERMARK_FLIGHT_NUMBER		= 102
CONSTANT		Integer			WATERMARK_KITCHEN_TIME		= 103
CONSTANT		Integer			WATERMARK_RAMP_TIME			= 104
CONSTANT		Integer			WATERMARK_OPS					= 105
CONSTANT		Integer			WATERMARK_PRODRANGE			= 106
PUBLIC	CONSTANT		Integer			ALIGN_LEFT						= 0
PUBLIC	CONSTANT		Integer			ALIGN_CENTER					= 2
PUBLIC	CONSTANT		Integer			ALIGN_RIGHT						= 1

Public		Long				il_TR_DefaultHeight			= 52
Public		Long				il_TR_YOffset					= 10
PUBLIC		Long				il_Routing_ID					= -1
PUBLIC		Integer			ii_Catering_Leg				=  0
PROTECTED	Integer			ii_PL_Leg_Number				=  0

String							is_Ac_Type
String							is_Packinglist
String							is_Loadinglist
String							is_Description
String							is_TR_Cart_Description
String							is_RampBoxFrom
String							is_RampBoxTo
Long								il_Rungs, il_Columns
Long								il_Multiply
Boolean							ib_TR_Use_Class
Boolean							ib_TR_Fill_Top_Down			= FALSE
Boolean							ib_Expand_TR_Cart				= TRUE
Boolean							ib_Discard_Status_Billing	= TRUE
Long								il_Result_Key
Long								il_Transaction

uo_cart_datastore				ids_TR_Cart_Allocation

// Gr$$HEX1$$f600$$ENDHEX$$sse f$$HEX1$$fc00$$ENDHEX$$r neuen Header Footer
// Gr$$HEX1$$f600$$ENDHEX$$sse f$$HEX1$$fc00$$ENDHEX$$r neuen Header Footer
Long								il_Header_Height_Normal = 133
Long								il_Footer_Height_Normal =  76
Long								il_Header_Height_H_in_F = 145
Long								il_Footer_Height_H_in_F =  70

Integer							ii_TR_Cart_Left
Integer							ii_TR_Cart_Width
Integer							ii_TR_Cart_Top
Integer							ii_TR_Cart_Height

Integer							ii_Std_Cart_Left
Integer							ii_Std_Cart_Width
Integer							ii_Std_Cart_Top
Integer							ii_Std_Cart_Height


// Font Calc
ulong lTwipsPerPixelY
ulong lTwipsPerPixelX
uint ihDC

str_label_print istr_values[]


Public	Boolean	ib_Remove_Empty_Drawer = TRUE // FALSE

PUBLIC	String							is_CSC

// --------------------------------------------------------
// 05.05.2011: Cart Wunschliste #133
// wenn bei Distribution eine Komponente mit einem Leg >1
// (Mealcode pos. 1) verteilt wird, soll der Drawer das
// Downline-Watermark bekommen (hier abschaltbar)
// -------------------------------------------------------
Public		Boolean	ib_Downline_by_Mealcode = TRUE // FALSE
Public		Long		il_Disable_Debug = 0 //1 //0
PUBLIC		String	is_User
Protected	String	is_Section					= ""
Public		String	is_TR_Cart_Area_WS		= ""

Protected	n_doc_gen_settings	inv_doc_gen_settings
Public		n_copy_Settings		inv_copy_settings
Public		Boolean					ib_use_doc_gen_settings = FALSE
PUBLIC		Boolean					ib_secondary_distribution_only = FALSE
PUBLIC		Boolean					ib_Mode_TR_Cart = FALSE

PUBLIC		Boolean					ib_Overflow
PUBLIC		Boolean					ib_Content_Spec

Protected	String					is_Overflow_MSG_1	// use content spec
Protected	String					is_Overflow_MSG_2 // see overflow
Protected	String					is_Overflow_MSG_3 // see cs and overflow
PUBLIC		Boolean					ib_Disable_Content_Spec_MSG = FALSE


// -----------------------------------------------------------------------
// Secondary Distribution in DataStores, um Speichern zu erm$$HEX1$$f600$$ENDHEX$$glichen
// 
// -----------------------------------------------------------------------
Public	uo_CBASE_DataStore	ids_SD_Master				// dsCartDiagramSheet
Public	uo_CBASE_DataStore	ids_SD_Components			// Component List
Public	uo_CBASE_DataStore	ids_SD_Cart					// Diagram Page
Public	uo_CBASE_DataStore	ids_SD_Cart_Drawer		// Cart Position - Einschub
Public	uo_CBASE_DataStore	ids_SD_Drawer_Content	// Inhalt des Drawer / Tray
Public	uo_CBASE_DataStore	ids_SD_Message				// Distr. Errors

Protected		Boolean			ib_require_exact_match	= FALSE
Protected		Boolean			ib_suppress_qty_1			= FALSE
Protected		Integer			ii_Current_Page			= 0
Protected		Boolean			ib_exact_match_ignore_SPML
CONSTANT			Integer			MSG_BACKLOG					= 1
CONSTANT			Integer			MSG_ERROR					= 2
CONSTANT			Integer			MSG_UNASSIGNED				= 3
CONSTANT			Integer			MSG_NOSHIFTASSIGNED		= 5

Boolean	ib_Enable_Secondary_Distr_Saving = TRUE
Boolean	ib_Enable_Multirung_Cover_White = TRUE //FALSE

// ------------------------------------------------------------------------------------------------
// NAM-CR-12071 Master Data View - Create CD while ignoring local settings (e.g. Area Allocation)
// ------------------------------------------------------------------------------------------------
Public            Boolean   ib_Enable_Masterdata_View = FALSE

Protected         Boolean   ib_Force_Overflow = FALSE
Protected         Boolean   ib_Print_Overflow = FALSE


CONSTANT			String			FONT_MS_SANS_SERIF					= "MS Sans Serif"
CONSTANT			String			FONT_MICROSOFT_SANS_SERIF			= "Microsoft Sans Serif"

CONSTANT Long EXPLOSION_ON		=  1
CONSTANT Long EXPLOSION_OFF	=  0
CONSTANT Long EXPLOSION_DEF	= -1

CONSTANT Long DEFAULT			= -1

Boolean		ib_Healthmark = FALSE

// CBASE-UK-CR-2013-012
Boolean		ib_Belly_Watermark = FALSE

// CBASE-UK-CR-2013-013
Boolean		ib_Draw_Add_Text = FALSE

// CBASE-UK-CR-2013-006
Boolean		ib_Overflow_on_Main = FALSE

// CBASE-UK-CR-2013-002
Boolean		ib_Extended_TR_Handling = FALSE
Long			il_Workstations[]

uo_CBASE_DataStore	ids_Diagram_Pages

String		is_PL			= ""	
String		is_PL_Desc	= ""

String		is_TR_Area	= ""
String		is_TR_WS  	= ""
PUBLIC	String		is_TR_Freetext	= ""

Public	Integer		ii_tr_counter = 1	

PUBLIC	Boolean		ib_Non_Sky = FALSE
PUBLIC	Boolean		ib_Non_Sky_VIP = FALSE


PUBLIC	datastore 	ids_CSLoadingHeader
PUBLIC	datastore 	ids_CSLoadingContents 
PUBLIC	Long			il_Master_Row

PUBLIC	Boolean		ib_2nd_Dis_Acceleration = FALSE
PUBLIC	Boolean		ib_Enable_Meal_Distribution

// CR 2575 Bookmark & Filter on Cart Diagram
Boolean		ib_Cart_Diagram_Bookmark = FALSE
String							is_Bookmark_Group = ""

PUBLIC Boolean		ib_BarCode_on_CartDiagram = FALSE

Long			il_Aircraft_Key

// Request 6466 Bar codes on Cart Diagrams and TR Cart Diagrams
PUBLIC Boolean		ib_NAM_BarCode_on_CartDiagram = FALSE
PUBLIC Boolean		ib_BarCode_on_TR_CartDiagram = FALSE

// Barcode on CD plus PPM Versorgung
PUBLIC	Boolean		ib_PPMBARCODE4GROUP = FALSE
PUBLIC	Long			il_Printing_Group
PUBLIC	Long			il_Stowage_Keys[]


PUBLIC	Boolean		ib_User_Defined

Integer					ii_Barcode_X = 630
Integer					ii_Barcode_Y = 5
Integer					ii_Barcode_W = 80
Integer					ii_Barcode_H = 80
String					is_Barcode_Band = "header"

uo_pps_barcodes iuoPpsBarcodes

long lRoleID = 3000001
end variables

forward prototypes
public function long of_create_defaults ()
public function long of_create_line (string sobjectname, long lx1, long ly1, long lx2, long ly2, long lcolor)
public function long of_draw_cart ()
public function long of_register (string sobject, long lrow, long lcolumn)
public function long of_unregister (string sobject)
public function Long of_unregister_all ()
public function long of_remove_drawer (long irow, long icolumn)
public function long of_remove_tray (long irow, long icolumn)
public function long of_set_marker (long irow, long icolumn)
public function long of_remove ()
public function long of_modified (datastore omodified)
public function long of_create_text (long lrow)
public function long of_update_objects ()
public function long of_set_position ()
public function long of_blob_to_file (string sfilename, blob bfilebuffer)
public function long of_file_to_blob (string sfilename, ref blob bfilebuffer)
public function long of_add_picture (string sfile, long lx, long ly, long lheight, long lwidth)
public function long of_create_picture (string sobjectname, string spicturename, long lx, long ly, long lheight, long lwidth, long ivisible, long iresize, long imove)
public function long of_get_type (long irow, long icolumn)
public function long of_get_detail_key (long irow, long icolumn)
public function long of_move_object (long inewrow, long inewcolumn, long ioldrow, long ioldcolumn)
public function long of_log (string smessage)
public function long of_remove_object (string sobject, long itype)
public function long of_update ()
public function string of_get_error ()
public function long of_remove_all ()
public function long of_remove_content (long irow, long icolumn)
public function long of_remove_content ()
public function long of_string2array (string sstring, string sseparator, ref string soutputarray[])
public function long of_blob_save_bitmap (ref datawindow arg_dw)
public function long of_delete_layout (long arg_indexkey, long arg_detailkey)
public function long of_copy_layout (s_cartdiagram arg_str_cartdiagram, long arg_oldllayoutkey, long arg_newllayoutkey, ref s_layout_detail_mapper arg_str_layout_mapper_rework[])
public function long of_copy_layout_rework (s_cartdiagram arg_str_cartdiagram_rework, ref s_layout_detail_mapper arg_str_layout_mapper_rework[])
public function string of_generate_filename (string arg_prefix, string arg_suffix)
public function long of_copy_object (long inewrow, long inewcolumn, long ioldrow, long ioldcolumn)
public function long of_update (blob arg_b_datawindow, blob arg_b_backlog)
public function long of_modify_dw (string arg_s_mod)
public subroutine of_chc_trace (long iarg_level, string sarg_trace_text)
public function long of_register_file (string arg_s_file)
public function long of_set_order (long lrow, long lcolumn, long lorder)
public function string of_get_order (long lrow, long lcolumn)
public function long of_renumber_order (long arg_l_style)
public function long of_print_hide ()
public function long of_create_text (string sobjectname, string stext, string sfont, long ifontsize, long ifontweight, long lx, long ly, long lheight, long lwidth, long iborder, long ialign, long lcolor, long ivisible)
public function long of_create_ellipse (string sobjectname, long lx, long ly, long lh, long lw, long lcolor)
public function long of_get_container_type ()
public function string of_get_container_short_name ()
public function long of_create_wheel (string sobjectname, long lx, long ly, long lh, long lw, long lcolor)
public function long of_fill_backlog_page ()
public function boolean of_is_backlog_enabled ()
public function long of_print_init ()
public function long of_print_backlog ()
public function long of_print ()
public function long of_init (long arg_lindexkey, long arg_ldetailkey, long arg_lairlinekey, string arg_sunit, datastore arg_ods, datetime arg_ddeparture, datastore arg_odsbacklog)
public function long of_modify_dw_backlog (string arg_s_mod)
public function long of_set_position (string arg_s_mod, boolean arg_b_flag)
public function long of_getfullstate (ref blob arg_blob)
public function long of_getfullstate_backlog (ref blob arg_blob)
public function long of_get_backlog_rowcount ()
public function string of_profilestring (string suser, string ssection, string skey, string sdefault)
public function long of_get_item_properties (long arg_l_row, long arg_l_column, ref s_distrib_items ref_str_item[])
public function long of_reset_backlog_page (long arg_l_type)
public function long of_copy_text (string arg_l_object)
public function long of_copy_picture (string arg_s_object)
public function long of_create_picture (long lrow, blob arg_b_blob)
public function long of_create_picture (long lrow)
public function long of_draw_tray (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew)
public function long of_draw_drawer (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew)
public function long of_draw_content_tray (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn, ref long arg_ltype)
public function long of_get_maxcontent (long arg_l_row, long arg_l_column)
public function string of_get_item_description (s_component arg_str_component)
public function long of_modify_text (string arg_s_object, string arg_s_text)
public function boolean of_is_editmode ()
public function long of_set_editmode (boolean arg_b_flag)
public function long of_create_component_list (s_component arg_component[])
public function boolean of_is_header_in_footer ()
public function long of_set_xposition (long arg_l_pos)
public function long of_print_deinit ()
public function long of_print_backlog_deinit ()
public function long of_add_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist)
public function long of_draw_content_backlog_drawer (long arg_l_counter, long arg_i_row, long arg_i_column, datastore arg_ds_data, long arg_l_type, string arg_s_header)
public function long of_init (long arg_lindexkey, long arg_ldetailkey, long arg_lairlinekey, string arg_sunit, datawindow arg_odw, datetime arg_ddeparture, datawindow arg_odwbacklog)
public function long of_check_layout (long arg_l_indexkey, long arg_l_detailkey)
public function long of_get_detail_height (datawindow arg_dw)
public function long of_get_detail_height (datastore arg_ds)
public function boolean of_check_boundary (long arg_l_x, long arg_l_y, long arg_l_height, long arg_l_widht)
public function boolean of_check_string (string arg_s_string, string arg_s_check)
public function long of_add_text (string stext, long lx, long ly, long lheight, long lwidth)
public function long of_add_content_floating (long arg_l_x, long arg_l_y, long arg_l_detail, long arg_l_sort)
public function long of_draw_floating (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew)
public function long of_draw_content_floating (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn)
public function long of_draw_content_backlog_tray (long arg_l_counter, long arg_i_row, long arg_i_column, string arg_s_text, long arg_l_type)
public function integer of_check_object_width ()
public function long of_get_xposition (long arg_l_pos, string arg_s_object)
public function long of_create_content_freetext (long lrow)
public function long of_add_content_freetext (long lx, long ly, long lheight, long lwidth, long ldetail, long lsort)
public function integer of_get_objects (ref string sobjects[])
public function integer of_explode_content_remove_subs (string sancestorobject)
public function long of_get_object_x (string sobject)
public function long of_get_object_y (string sobject)
public function long of_get_object_height (string sobject)
public function long of_get_object_width (string sobject)
public function integer of_explode_content_freetext (string sobject, integer icreate)
public function long of_draw_drawer_3_rung (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew)
public function integer of_is_position_change (integer arg_itype, long arg_inewrow, long arg_inewcolumn)
public function datastore of_request_datastore (integer arg_itype)
public function long of_add_rect (long lx, long ly, long lheight, long lwidth)
public function long of_create_rect (long lrow)
public function long of_draw_drawer_multi_rung (long arg_irow, long arg_icolumn, long arg_itype, long arg_no_of_rungs, long arg_no_of_cols, boolean arg_b_init)
public function long of_check_position (long itype, long inewrow, long inewcolumn, integer arg_no_of_rungs, integer arg_no_of_cols)
public function long of_set_marker_insert (long itype, long irow, long icolumn, long lmarkercolor, integer arg_no_of_rungs, integer arg_no_of_cols)
public function long of_draw_header (long al_result_key)
public function long of_create_text (string sobjectname, string stext, string sfont, long ifontsize, long ifontweight, long lx, long ly, long lheight, long lwidth, long iborder, long ialign, long lcolor, long ivisible, string sband)
public function long of_print_prepare_backlog (string arg_s_printer, string arg_s_airline, long arg_l_flightnumber, string arg_s_suffix, string arg_s_header, string arg_s_from, string arg_s_to, string arg_s_actype, string arg_s_stowage, long arg_l_page, long arg_l_belly, date arg_d_departure, string arg_s_time, string arg_s_class, string arg_s_container, string arg_s_owner, string arg_s_version, string arg_s_area, string arg_s_workstation, string arg_s_loadinglist)
public function long of_draw_footer (long al_result_key)
public function long of_init_tr (long arg_lindexkey, long arg_ldetailkey, long arg_lairlinekey, string arg_sunit, datastore arg_ods, datetime arg_ddeparture, datastore arg_odsbacklog)
public function long of_create_text (string sobjectname, string stext, string sfont, long ifontsize, long ifontweight, long lx, long ly, long lheight, long lwidth, long iborder, long ialign, long lcolor, long ivisible, string sband, boolean ab_backlog)
public function long of_draw_footer (long al_result_key, boolean ab_backlog)
public function long of_draw_header (long al_result_key, boolean ab_backlog)
public function integer of_clean_band (string as_band, boolean ab_backlog)
public function long of_set_position (string arg_s_mod, boolean arg_b_flag, boolean ab_backlog)
public function long of_print_prepare_new_h_f (string arg_s_loadinglist, string arg_s_packinglist, string arg_s_pl_description, string arg_s_rampbox, string arg_s_stowage, string arg_s_class, string arg_s_workstation, string arg_s_currentpage, boolean ab_backlog)
public function integer of_check_object_sizes (boolean ab_backlog)
public function integer zzz_debug_box (boolean ab_backlog)
public function integer of_modify (string as_modify, boolean ab_backlog)
public function integer of_get_multiply ()
public function integer of_get_rungs ()
public function integer of_get_columns ()
public function string of_get_tr_cart_description ()
public function boolean of_is_use_class_enabled ()
public function boolean of_is_fill_top_down_enabled ()
public function long of_draw_tr_stowage_pos (long arg_irow, long arg_icolumn, long arg_itype, string arg_stowage)
public function long of_draw_watermark_downline (long arg_irow, long arg_icolumn, integer arg_ltype)
public function long of_draw_segment_indicator (long arg_irow, long arg_icolumn, long arg_itype, long arg_lnumber)
public function integer of_move_objects (string as_band, integer ai_offset_v, integer ai_offset_h, boolean ab_backlog)
public function integer of_get_min_offset (string as_band, boolean ab_backlog)
public function integer of_remove_contents_billing (ref datastore rads_contents)
public function boolean of_is_tr_componentlist_enabled ()
public function long of_create_line (string sobjectname, long lx1, long ly1, long lx2, long ly2, long lcolor, long al_width)
public function long of_draw_tr_background_col (long arg_irow, long arg_icolumn, long arg_color)
public function long of_draw_tr_segment_indicator (long arg_irow, long arg_icolumn, long arg_itype, long arg_lnumber)
public function integer of_move_to_background (boolean ab_backlog)
public function long of_draw_tr_drawer (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew, string as_description)
public function string of_describe_dw_backlog (string arg_s_mod)
public function string of_describe_dw (string arg_s_mod)
public function string of_describe (string as_modify, boolean ab_backlog)
public function boolean of_suppress_class_watermark (long al_airline_key, string as_unit, long al_routing, string as_class)
public function boolean of_is_downline_enabled (long al_airline_key, long al_routing_id, string as_unit)
public function boolean of_is_backcol_enabled (long al_airline_key, long al_routing_id, string as_unit)
public function integer of_get_watermark_type (long al_airline_key, long al_routing_id, string as_unit)
public function long of_draw_tr_cart (string as_unit)
public function long of_init_tr (string as_unit)
public function integer of_get_explosion_setting (long al_pl_index_key, string as_unit)
public function long of_draw_content (long irow, long icolumn, string as_unit)
public function boolean of_is_aisle_enabled (long al_index_key, long al_detail_key)
public function long of_draw_watermark_aisle (boolean ab_tr_cart)
public function long of_draw_watermark_downline (long arg_irow, long arg_icolumn, integer arg_ltype, boolean ab_transporter)
public function long of_init ()
public function long of_draw_watermark (integer ai_type, long al_flight_number, string as_ramp_time, string as_kitchen_time, string as_ops, string as_class, string as_prodrange, long al_airline_key, string as_unit, long al_routing, boolean ab_tr_cart)
public function integer of_get_print_width (string as_text, string as_font, integer ai_fontsize, boolean ab_bold, boolean ab_italic, boolean ab_underline, ref integer rai_height, ref integer rai_width)
protected function boolean of_is_downline_enabled (string as_unit)
public function integer of_get_rungs_and_cols (long al_row, long al_column, ref long ral_rungs, ref long ral_columns)
public function integer of_get_relevant_row_column (long al_row, long al_column, ref long ral_master_row, ref long ral_master_column)
public function integer of_is_position_in_use (integer arg_itype, long arg_inewrow, long arg_inewcolumn, integer arg_irungs, integer arg_icolumns)
public function long of_get_content_length (long arg_l_index, long arg_l_detail)
public function boolean of_explode (long al_index_key, string as_unit, integer ai_parent_setting, integer ai_content)
public function long of_draw_content_drawer_multi (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit)
public function boolean of_valid_airline_equipment (long al_airline_key, long al_packinglist_index_key, long al_packinglist_detail_key)
public function boolean of_check_eq (long al_airline_key, string as_unit_of_measure)
public function boolean of_has_contents (long arg_irow, long arg_icolumn)
public function long of_add_content (long irow, long icolumn, long ldetail, long lsort, long lheader_flag)
public function boolean of_is_content_sheet_header (long al_layout_detail_key, string as_cpackinglist)
public function long of_get_content_sheet_contents (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_header_flag)
public function integer of_align_objects (string as_match, long al_align_mode, boolean ab_backlog)
public function long of_get_explosion_content (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[])
public function boolean of_is_explosion_enabled (long al_index_key, string as_unit, date ad_departure)
public function boolean of_exists_content_sheet_header (long al_column, long al_row)
public function long of_get_fixed_content (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_do_not_explode)
protected function long of_draw_content_drawer (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_sunit)
public function long of_draw_content_backlog_tray (long arg_l_counter, long arg_i_row, long arg_i_column, string arg_s_text, long arg_l_type, decimal arg_dec_qty)
public function long of_print_prepare (string arg_s_printer, string arg_s_airline, long arg_l_flightnumber, string arg_s_suffix, string arg_s_header, string arg_s_from, string arg_s_to, string arg_s_actype, string arg_s_stowage, long arg_l_page, long arg_l_belly, date arg_d_departure, string arg_s_time, string arg_s_class, string arg_s_container, string arg_s_owner, string arg_s_version, string arg_s_area, string arg_s_workstation, string arg_s_loadinglist, long arg_l_leg)
public function integer of_fill_component_list (ref uo_distribution rauodistribution, ref s_component rastr_component[], string arg_s_stowage, string arg_s_pl, long arg_l_lbelly)
public function integer of_init_slot (ref uo_cart_distribution rauocartdistribution, long al_row, long al_column, long al_maxlength)
public function integer of_distr_content_4_contentsheet (ref datastore rads_distribution_contents, ref uo_cart_distribution rauocartdistribution, long al_row, long al_column, long al_content_master_row_id)
public function long of_draw_watermark_downline (long arg_irow, long arg_icolumn, integer arg_ltype, long arg_lcolour)
public function long of_remove_distribution (long irow, long icolumn)
public function long of_remove_distribution ()
public function long of_remove_content (long irow, long icolumn, boolean ab_remove_distr_parms_4_multi)
public function integer of_handle_empty_contents (long al_row, long al_column, ref boolean rab_empty, ref boolean rab_entire_container_empty)
public function boolean of_set_user (string as_user)
protected function long of_adjust_xposition (long arg_l_pos, string arg_s_object)
public function integer of_clean_tr_diagram (ref datastore rads_diagramm)
public function long of_draw_watermark (integer ai_type, long al_flight_number, string as_ramp_time, string as_kitchen_time, string as_ops, string as_class, string as_prodrange, long al_airline_key, string as_unit, long al_routing, boolean ab_tr_cart, string as_suffix)
public function integer of_use_doc_gen_settings (n_doc_gen_settings anv_doc_gen_settings)
public function boolean of_set_section (string as_section)
public function integer of_sd_fill_component_list (ref uo_distribution rauodistribution, long al_row_id, string arg_s_stowage, string arg_s_pl, long arg_l_lbelly)
public function long of_sd_create_component_list (long al_row_id)
public function integer of_sd_save_distr_contents (s_distrib_items astr_distrib_items[], long al_rowid, long al_sd_cart_key, long al_page, long al_sd_drawer_key)
public function long of_sd_draw_distributed_components (uo_distribution arg_uo_distribution, string arg_s_stowage, string arg_s_pl, long arg_l_lbelly, string arg_s_carttype, string arg_unit, date arg_departure, boolean arg_bexplode_parent, ref uo_content_sheet rauo_content_sheet, boolean ab_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents)
public function integer of_sd_init (string as_unit, long al_index_key, long al_detail_key, long al_airline_key, date adt_departure)
public function long of_sd_init ()
public function integer of_sd_get_distr_content (long al_column, long al_row, ref s_distrib_items astr_item[])
protected function integer of_sd_handle_empty_contents (long al_row, long al_column, ref boolean rab_empty, ref boolean rab_entire_container_empty, long al_sd_rowid, long al_sd_cart_key)
public function long of_sd_add_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist, long arg_l_row_id)
public function integer of_sd_fill_backlog_data (long arg_l_row_id)
public function long of_sd_add_content_backlog_tray (long arg_l_counter, long arg_i_row, long arg_i_column, string arg_s_text, long arg_l_type, decimal arg_dec_qty, long arg_l_row_id)
public function long of_sd_add_content_backlog_drawer (long arg_l_counter, long arg_i_row, long arg_i_column, datastore arg_ds_data, long arg_l_type, string arg_s_header, long arg_l_rowid)
public function long of_sd_distribute_components (uo_distribution arg_uo_distribution, string arg_s_galley, string arg_s_stowage_only, string arg_s_stowage, string arg_s_pl, long arg_l_lbelly, string arg_s_carttype, string arg_unit, date arg_departure, boolean arg_bexplode_parent, ref uo_content_sheet rauo_content_sheet, boolean ab_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents, long al_sd_rowid, long al_sd_cart_key, long al_page, string as_loadinglist)
public function long of_sd_add_error (long al_row_id, string as_galley, string as_stowage, string as_cart, string as_loadinglist, string as_component, string as_text, long al_distribution, string as_parameter, string as_definition, string as_unit, string as_information)
public function integer of_sd_set_filter_rowid (long al_content_master_row_id)
public function integer of_sd_add_content_sheet_header (string arg_s_carttype, string arg_unit, uo_content_sheet rauo_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents)
protected function integer of_sd_distribute_components_alloc (long al_min_fit_factor_setting, date arg_departure, string arg_unit, long al_content_master_row_id, long al_sd_cart_key, string arg_s_galley, string arg_s_stowage_only, string arg_s_pl, string as_loadinglist, ref boolean ab_entire_container_empty)
public function integer of_sd_distribute_components_tray (long al_column, long al_row, string arg_unit, ref datastore rads_distribution_contents, long al_content_master_row_id, long al_sd_cart_key, long al_page, ref boolean rab_watermark_downline, ref boolean rab_suppress_watermark_downline)
public function integer of_sd_distribute_components_multi (long al_column, long al_row, string arg_unit, ref datastore rads_distribution_contents, long al_content_master_row_id, long al_sd_cart_key, long al_page, ref boolean rab_watermark_downline, ref boolean rab_suppress_watermark_downline)
protected function integer of_sd_distribute_components_empty (ref boolean rab_entire_container_empty, long al_maxcolumns, long al_maxrows, ref uo_cart_distribution rauo_cart_distribution, long al_sd_rowid, long al_sd_cart_key, boolean ab_no_components, string arg_s_pl, date arg_departure, string arg_s_stowage)
public function string of_get_ramp_box (string as_box_from, string as_box_to, long al_box_mode)
public function integer of_sd_remove_empty_drawers (long al_row_id)
public function integer of_sd_draw_comp_tray (long al_column, long al_row, ref datastore rads_distribution_contents, long al_content_master_row_id, string arg_unit)
public function integer of_init_cd_tripticket (string as_unit, long al_airline_key, ref uo_tripticket rauo_tripticket)
public function integer of_count_cart_diagram_pages (string as_unit, long al_airline_key, ref datastore rads_unassigned, ref datastore rads_eq, ref datastore rads_cartdiagramsheet, ref uo_tripticket rauo_tripticket)
public function integer of_create_or_load_sec_distr (long al_result_key, long al_transaction, ref uo_distribution rauo_distribution, long al_airline_key, string as_unit, ref datastore rads_unassigned, ref datastore rads_eq, boolean ab_contentsheet, ref datastore rads_cartdiagramsheet, ref uo_tripticket rauo_tripticket, ref uo_content_sheet rauo_contentsheet)
public function integer of_create_acrobat (ref datastore dsacrobat, string as_file_name)
public function integer of_cart_diagram_merge (ref uo_documents rauo_product, string as_pdffiles[], boolean ab_printdirectly, boolean ab_use_printer_allocation, string as_printer_cart_diagram)
public function integer of_cart_diagram_content_sheet (boolean ab_contentsheet, long al_rowid, ref uo_content_sheet rauo_contentsheet)
public function integer of_create_cart_diagram_page (long al_row, long al_rowid, long al_airline_key, string as_unit, ref long ral_cartpages, boolean ab_contentsheet, string as_current_printer_1, ref uo_documents rauo_product, long al_flightnumber, string as_suffix, string as_from, string as_to, string as_actype, string as_time, string as_owner, string as_version, long al_leg_nr, long al_number_of_pages, string as_fbox_from, string as_fbox_to, long al_watermark, string as_ramp_time, string as_kitchen_time, string as_ops, long al_routing_id, ref long ral_filecounter, ref string ras_pdffiles[], ref long ral_backlogpages, ref uo_content_sheet rauo_contentsheet, ref uo_distribution rauo_distribution)
public function integer of_tr_remove_entries (ref uo_distribution rauo_distribution, string as_unit, datastore ads_exclusions, ref datastore rads_cartdiagramsheet)
public function integer of_count_tr_cart_pages (string as_unit, ref uo_tr_cart_allocation rauo_tr_alloc, long al_airline_key, long al_routing_id, integer ai_fill_type, ref datastore rads_cartdiagramsheet)
public function integer of_create_tr_cartdigram_cs (boolean ab_content_sheet, long al_result_key, ref uo_distribution rauo_distribution, ref uo_content_sheet rauo_contentsheet, ref datastore rads_loading)
public function integer of_create_unassigned_cart_report (boolean ab_unassignedcarts, ref datastore rads_unassigned, ref uo_documents rauo_product, ref long ral_filecounter, ref string ras_pdffiles[])
public function boolean of_is_tr_header_in_footer ()
public function integer of_get_level_of_service (ref string ras_los[])
public function boolean of_is_content_spec_enabled (long arg_l_index, string arg_s_unit, date arg_d_departure)
public function integer of_distr_content_4_cs (ref datastore rads_distribution_contents, long al_row, long al_column, long al_content_master_row_id)
public function string of_overflow_message (string as_packinglist)
public function long of_adjust_font (string arg_s_object[], long arg_l_size, boolean arg_b_bold, boolean arg_b_italic)
public function long of_adjust_text_size (string arg_s_object[], long arg_l_height_factor)
public function integer of_calc_font_size (string as_text, ref long al_height, ref long al_width, string as_font_name, boolean ab_bold, boolean ab_italic, boolean ab_underline, boolean ab_wrap)
public function integer of_delete_secondary_distribution (long al_result_key, long al_transaction)
public function long of_is_cartdiagram_enabled (long arg_l_index, string arg_s_client, string arg_s_unit, ref boolean rab_no_entry)
public function long of_print (string as_printer, boolean ab_preview)
public function long of_get_fixed_content_drawer (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_do_not_explode)
public function boolean of_check_explode (long al_index_key, string as_unit)
public function boolean of_check_workstation_exclude (long al_workstation_key, long al_airline_key)
public function long of_adjust_text_size_small_big (string arg_s_object[], long arg_l_height_factor)
public function integer of_sd_draw_comp_multi (long al_row, long al_column, string arg_unit, long al_master_row_id)
public function long of_get_fixed_content_tray (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_do_not_explode)
public function boolean of_check_center_setting ()
public function string of_get_item_description (s_component arg_str_component, boolean ab_fixed)
public function integer of_vertical_center_text_within_drawer (string as_object[], long al_column, long al_row)
public function integer of_apply_tr_workstation_exclusions (string as_unit, ref uo_tr_cart_allocation rauo_tr_alloc, long al_airline_key, long al_routing_id, integer ai_fill_type, ref datastore rads_cartdiagramsheet)
public function integer of_sd_draw_comp_drawer (long al_column, long al_row, ref datastore rads_distribution_contents, long al_content_master_row_id, string arg_unit, long al_master_content_setting)
public function boolean of_is_backlog_enabled_by_setup ()
public function long of_sd_create_tr_component_list (long al_row_id[], ref uo_distribution rauo_distribution, ref datastore rads_trcartdiagram)
public function integer of_sd_init_flight (long al_result_key, long al_transaction, boolean ab_require_exact_match, string as_csc, long al_airline_key)
public function boolean of_exists_tr_cart_per_unit (string as_unit)
public function boolean of_is_healthmark_enabled (string as_unit)
public function integer of_create_cd_backlog_page (ref long ral_backlogpages, long al_row, long al_cartpages, ref long ral_filecounter, ref string ras_pdffiles[], ref uo_documents rauo_product, string as_rampbox, string as_stowage, string as_packinglist, string as_pl_description, string as_loadinglist, string as_class, string as_workstation, string as_version, string as_container, integer ai_flightnumber, string as_suffix, string as_header, string as_from, string as_to, string as_actype, long al_belly, string as_time, string as_owner, string as_area, string as_class_string, long al_backlogpages, string as_current_printer_1, string as_unit)
public function integer of_draw_healthmark (string as_unit, boolean ab_backlog)
public function long of_add_content_explosion (long irow, long icolumn, long ldetail, long lsort, boolean ab_header_flag)
public function long of_add_content_explosion (long irow, long icolumn, long ldetail, long lsort)
public function long of_sd_find_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist, long arg_l_row_id)
public function integer of_set_pl (string as_pl, string as_pl_desc)
public function long of_draw_watermark_belly (long al_belly)
public function boolean of_is_add_on_text_enabled ()
public function string of_get_additional_label_text (long al_packinglist_index_key, string as_unit, date adt_departure)
public function long of_draw_additional_text (string as_text_1, string as_label_text_2)
public function long of_draw_backlog_on_main ()
public function integer of_get_label_group (string as_unit)
public function integer of_create_unassigned_tr_cart_report (ref datastore rads_unassigned, ref long ral_filecounter, ref string ras_pdffiles[], long al_flight_number, string as_airline)
public function long of_draw_tr_add_text_indicator (long arg_irow, long arg_icolumn, string arg_text)
public function long of_draw_tr_freetext (string as_text)
public function integer of_create_tr_backlog_page (ref long ral_backlogpages, long al_row, long al_cartpages, ref long ral_filecounter, ref string ras_pdffiles[], string as_rampbox, string as_stowage, string as_packinglist, string as_pl_description, string as_loadinglist, string as_class, string as_workstation, string as_version, string as_container, integer ai_flightnumber, string as_suffix, string as_header, string as_from, string as_to, string as_actype, long al_belly, string as_time, string as_owner, string as_area, string as_class_string, long al_backlogpages, string as_current_printer_1, string as_unit, string as_airline)
public function long of_sd_add_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist, long arg_l_row_id, string arg_s_stowage)
protected function string of_get_cd_sort (string as_section)
public function boolean of_check_non_sky (string as_unit)
public function integer of_fill_non_sky_content_spec (string arg_s_carttype, string arg_unit, uo_content_sheet rauo_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents)
public function integer of_add_backlog_as_content_sheet (string as_packinglist, string as_text, long al_qty, long al_row, long al_column)
public function long of_draw_tr_content_drawer (long arg_index_key, long arg_detailkey, long arg_irow, long arg_icolumn, long arg_ltype, boolean ab_explode, string as_unit, s_component as_distribution_items[], string as_suppressed_items[], string as_stowage)
public function integer of_add_backlog_as_content_sheet (string as_packinglist, string as_text, long al_qty, long al_row, long al_column, boolean ab_header)
public function integer of_create_jasper_from_datastore (datastore ads_diagram, string as_filename)
public function long of_get_bestbefore_minutes (string as_client, string as_unit, long al_airlinekey)
public function integer of_draw_best_before_date ()
public function integer of_draw_barcode (long al_pl_index_key, long al_stowage_key)
public function boolean of_is_barcode_enabled (string as_unit)
public function long of_add_text (string stext, long lx, long ly, long lheight, long lwidth, string as_font, boolean ab_bold, integer ai_size, integer ai_align)
public function integer zzz_of_draw_barcode (long al_pl_index_key, long al_stowage_key)
public function integer of_create_barcode (long ai_type, string as_file, string as_text, long ai_width, long ai_height, long ai_dpi)
public function long of_get_tr_cart_key (string as_unit, long al_index_key, date adt_ref_date, ref long ral_number_of_rungs, ref long ral_number_of_columns, ref long ral_number_of_pages, long al_airline_key)
public function long of_get_tr_cart_key_old (string as_unit, long al_index_key, date adt_ref_date, ref long ral_number_of_rungs, ref long ral_number_of_columns, ref long ral_number_of_pages)
public function long of_get_tr_cart_type_old (string as_client, string as_unit, long al_airline_key, long al_routing_id)
public function long of_set_file_to_blob (longlong arg_laddkey, string arg_sfile)
public function integer of_draw_tr_nam_barcode (long al_trolley_label_key)
public function integer of_draw_nam_barcode (long al_pl_index_key, long al_stowage_key, string as_readable_part)
public function long of_sd_add_noshiftassignment (long al_row_id, string as_galley, string as_stowage, string as_cart, string as_component, string as_text, string as_unit, string as_information)
public function boolean of_is_tr_barcode_enabled ()
public function long of_get_blob_to_file (longlong arg_lladdkey, string arg_stemppath, string arg_sfile)
end prototypes

public function long of_create_defaults ();/* 
* Funktion/Event: of_create_defaults
* Beschreibung: 	Erstellt die Defaulteintr$$HEX1$$e400$$ENDHEX$$ge f$$HEX1$$fc00$$ENDHEX$$r eine St$$HEX1$$fc00$$ENDHEX$$ckliste
*						falls nicht vorhanden
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008		Erstellung
*	1.1				U.Paudler  	03.09.2009		Backlog
*	1.2				U.Paudler  	05.10.2009		Backlog deaktivieren
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long 	lSequence, lRows, lColumns
Long	a, i, j		


this.lLayoutKey = f_sequence("seq_cen_packinglist_layout", sqlca)

// Header Eintr$$HEX1$$e400$$ENDHEX$$ge 
a = this.dsLayout.InsertRow(0)
this.dsLayout.SetItem(a, "nlayout_key", this.lLayoutKey)
this.dsLayout.SetItem(a, "npackinglist_index_key", this.il_IndexKey)
this.dsLayout.SetItem(a, "npackinglist_detail_key", this.lDetailKey)
this.dsLayout.SetItem(a, "nequipment_key", this.dsAirlineEq.GetItemNumber(1, "nequipment_key"))

If bHasDimensions Then
	this.dsLayout.SetItem(a, "ncomponentlist", 1)
Else
	this.dsLayout.SetItem(a, "ncomponentlist", 0)
End If

// Detail Eintr$$HEX1$$e400$$ENDHEX$$ge 
lRows 	= this.dsAirlineEq.GetItemNumber(1, "nrows")
lColumns = this.dsAirlineEq.GetItemNumber(1, "ncolumns")
// 19.01.2010 Ulrich Paudler [UP]
ilColumnCount = lColumns

isContainerShortName = this.dsAirlineEq.GetItemString(1, "cunit")
ilContainerType= this.dsAirlineEq.GetItemNumber(1, "ntype")
For i = 0 to lColumns // 0 = Eiseinschub
	for j = 1 to lRows
		lSequence = f_sequence("seq_cen_pl_layout_detail", sqlca)
		a = this.dsLayoutDetail.InsertRow(0)
		this.dsLayoutDetail.SetItem(a, "nlayout_detail_key", lSequence)
		this.dsLayoutDetail.SetItem(a, "nlayout_key", this.lLayoutKey)
		this.dsLayoutDetail.SetItem(a, "ncolumn", i)
		this.dsLayoutDetail.SetItem(a, "nrow", j)
		this.dsLayoutDetail.SetItem(a, "ntype", EMPTY)
	next
Next

// Speichern
if this.dsLayout.Update() <> 1 Then
	rollback;
	return -1
Else
		if this.dsLayoutDetail.Update() <> 1 Then
			rollback;
			return -1
		Else
			commit;
			return 1
		End If
End If

return 1

end function

public function long of_create_line (string sobjectname, long lx1, long ly1, long lx2, long ly2, long lcolor);/* 
* Funktion/Event: of_create_line
* Beschreibung: 	Linie anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	sObjectName			= Name der Objects
*	lX1					= X1Pos der Linie im Datawindow
*	lY1					= Y1Pos
*	lX2					= X2Pos der Linie im Datawindow
*	lY2					= Y2Pos
*	lColor				= Farbe der Linie
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	26.08.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet

sCreate = "create line(band=detail x1='" + string(lX1) + "' y1='" + &
			 string(lY1) + "' x2='" + string(lX2) + "' y2='" + string(lY2) + &
			 "' name=" + sObjectName + "  moveable=0" + &
			 " visible='1'" + &
			 " pen.style='0' pen.width='1'" + &
			 " pen.color='" + String(lColor) + "'" + &
			 " background.mode='2' background.color='1073741824' )"


of_modify_dw(sCreate)


return 1

end function

public function long of_draw_cart ();/* 
* Funktion/Event: of_draw_cart
* Beschreibung: 	Zeichnen des Trolleys
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 				K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008	Erstellung
*	1.1				U.Paudler	29.04.2009  	Eis Einschub entfernen
*	1.2				U.Paudler	19.10.2009  	Eis Einschub Umriss entfernen, unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
*	1.3				U.Paudler	21.10.2009  	Druck Zentrieren
*	1.4				U.Paudler	26.10.2009  	Reifen
*	1.5		      U.Paudler	18.01.2010  	Front/Rear Bezeichnung
*	1.6		      O.H$$HEX1$$f600$$ENDHEX$$fer  	05.08.2010  	CBASE-NAM-CR-0029 Numbered Rungs
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/

Boolean lb_HasDimensions
Long lRows
Long lColumns
Long lWidth
Long i, j
Long lX
Long lY
String	sDWObject
Long lWheelsize = 11
Long lWheelXOffset = 5
Long lWheelYOffset = 1
Long lWheelHeight = 23
Long llTextWidth
Integer	li_Succ

lb_HasDimensions = bHasDimensions

IF ib_NAM_BarCode_on_CartDiagram THEN
	lb_HasDimensions = TRUE
END IF

lRows 	= this.dsAirlineEq.GetItemNumber(1, "nrows")
lColumns = this.dsAirlineEq.GetItemNumber(1, "ncolumns")
// 19.01.2010 Ulrich Paudler [UP]
ilColumnCount = lColumns
isContainerShortName = this.dsAirlineEq.GetItemString(1, "cunit")
ilContainerType =  this.dsAirlineEq.GetItemNumber(1, "ntype")

il_Equipment_Width = lColumns

// 21.10.2009 Ulrich Paudler [UP] F$$HEX1$$fc00$$ENDHEX$$r Druck zentrieren bzw. verschieben
if lColumns <= 1 Then
	if lb_HasDimensions Then
		lXOffSet = INITIALOFFSET1
		lXOffSet = INITIALOFFSETSMALL2
		lDefaultWidth = INITIALWIDTH
	Else
		lXOffSet =INITIALOFFSETSMALL1
		lDefaultWidth = INITIALWIDTH
	End If
Else
	if lb_HasDimensions Then
		lXOffSet = INITIALOFFSETSMALL2
		lDefaultWidth = INITIALWIDTHSMALL
	Else
		lXOffSet =INITIALOFFSET2
		lDefaultWidth = INITIALWIDTH
	End If
End If

// -------------------------
// Der Eiseinschub
// -------------------------
lX = lXOffSet
lY = lYOffset


For i = 1 to lColumns
	
	sDWObject = "l_line_4_" + string(i)
	of_create_line(sDWObject, lX , lYOffset + lDefaultHeight / 2 , lX + lDefaultWidth , lYOffset + lDefaultHeight / 2, RGB(0, 0, 0))
	of_register(sDWObject, -1, -1)
	
	// ---------------------------------------------------------
	// 22.04.2010, KF
	// Breite und xPosition der Spalten merken um sp$$HEX1$$e400$$ENDHEX$$ter
	// $$HEX1$$fc00$$ENDHEX$$berh$$HEX1$$e400$$ENDHEX$$ngenden Text zu k$$HEX1$$fc00$$ENDHEX$$rzen
	// ---------------------------------------------------------
	ilColumnWidth[i]	=	lDefaultWidth
	ilColumnX[i]			=  lX 
	ilColumnY[i]			=  lYOffset + lDefaultHeight / 2
	
	lX += lDefaultWidth
Next

ii_Std_Cart_Left		= lXOffSet
ii_Std_Cart_Top 		= lYOffset + lDefaultHeight / 2
ii_Std_Cart_Width		= lColumns * lDefaultWidth
ii_Std_Cart_Height	= (lRows + 0.2) * lDefaultHeight


// -------------------------
// Rahmen f$$HEX1$$fc00$$ENDHEX$$r Cart / Trolleys
// zeichnen
// -------------------------
lYOffset += lDefaultHeight / 2
lX = lXOffSet 
lY = lYOffset

For i = 1 to lColumns
	// Vertikale Linien
	sDWObject = "l_line_5_" + string(i)
	// 19.10.2009 Ulrich Paudler [UP] Unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
	//of_create_line(sDWObject, lX, lYOffset, lX, lYOffset + (lRows + 1) * lDefaultHeight, RGB(128, 128, 128))
	of_create_line(sDWObject, lX, lYOffset, lX, lYOffset + (lRows + 0.2) * lDefaultHeight, RGB(128, 128, 128))
	of_register(sDWObject, -1, -1)
	
	sDWObject = "l_line_6_" + string(i)
	// 19.10.2009 Ulrich Paudler [UP] Unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
	//of_create_line(sDWObject, lX + lDefaultWidth , lYOffset, lX + lDefaultWidth , lYOffset + (lRows + 1) * lDefaultHeight, RGB(128, 128, 128))
	of_create_line(sDWObject, lX + lDefaultWidth , lYOffset, lX + lDefaultWidth , lYOffset + (lRows + 0.2) * lDefaultHeight, RGB(128, 128, 128))
	of_register(sDWObject, -1, -1)
	
	// ---------------------------------
	// Drag Drop Target anlegen
	// Schienen zeichnen
	// ---------------------------------
	For j = 1 to lRows
		// Das DragDrop Target 20 pixel hoch zeichnen
		sDWObject = "t_drag_target_col_" + string(i, "00") + "_row_" + string(j, "00")
		of_create_text(sDWObject, "",FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, lX + 10, lY + (j * lDefaultHeight) - 40, 50, lDefaultWidth - 20, 0, 0, RGB(0,0,0), 1)
		of_register(sDWObject, -1, -1)
		
		sDWObject = "p_lane_left_col_" + string(i) + "_row_" + string(j)
		of_create_picture(sDWObject, "..\Resource\Lane_left.jpg", lX + 1, lY + (j * lDefaultHeight) - 5, 8, 5, 1, 0, 0)
		of_register(sDWObject, -1, -1)
		
		sDWObject = "p_lane_right_col_" + string(i) + "_row_" + string(j)
		of_create_picture(sDWObject, "..\Resource\Lane_right.jpg", lX + lDefaultWidth - 5 , lY + (j * lDefaultHeight) - 5, 8, 5, 1, 0, 0)
		of_register(sDWObject, -1, -1)

		// -------------------------------------------------------------
		// Rechte Spalte: Rungs mit Nummer
		// -------------------------------------------------------------		
		If i = lColumns Then
			sDWObject = "t_rungnumber_col_" + string(i) + "_row_" + string(j)
			li_Succ = of_create_text(sDWObject,String(j) ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, lX + lDefaultWidth - 5 + 10 , lY + (j * lDefaultHeight) - 5 , 14, 14 , 0, 2, RGB(200,200,200), 1, "detail", FALSE)	
			//li_Succ = of_create_text(sDWObject,String(j) ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, lX + lDefaultWidth - 5 + 10 , lY + (j * lDefaultHeight) - 5 , 10, 10 , 0, 2, RGB(200,200,200), 1, "detail", FALSE)	
			of_register(sDWObject, -1, -1)
		End If

	Next
	
	// Horizontale Linie
	sDWObject = "l_line_7_" + string(i)
	// 19.10.2009 Ulrich Paudler [UP] Unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
	//of_create_line(sDWObject, lX , lYOffset + (lRows + 1) * lDefaultHeight, lX + lDefaultWidth , lYOffset + (lRows + 1) * lDefaultHeight, RGB(128, 128, 128))
	of_create_line(sDWObject, lX , lYOffset + (lRows + 0.2) * lDefaultHeight, lX + lDefaultWidth , lYOffset + (lRows + 0.2) * lDefaultHeight, RGB(128, 128, 128))
	of_register(sDWObject, -1, -1)
		
	// 26.10.2009 Ulrich Paudler [UP] R$$HEX1$$e400$$ENDHEX$$der unter dem Trolley zeichen
	if of_get_container_type() = TROLLEY Then
		sDWObject = "r_wheel_left_1_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lWheelXOffset , lYOffset + (lRows * lDefaultHeight) +  lWheelHeight / 2 + lWheelYOffset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		sDWObject = "r_wheel_left_2_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lWheelXOffset + lWheelsize  , lYOffset + (lRows * lDefaultHeight) +  lWheelHeight / 2 + lWheelYOffset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		
		sDWObject = "r_wheel_right_1_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lDefaultWidth - lWheelsize - lWheelXOffset  , lYOffset + (lRows * lDefaultHeight) +  lWheelHeight / 2 + lWheelYOffset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		sDWObject = "r_wheel_right_2_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lDefaultWidth - lWheelsize * 2  - lWheelXOffset, lYOffset + (lRows * lDefaultHeight) +  lWheelHeight / 2 + lWheelYOffset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		
	End If

	lX += lDefaultWidth
Next

// 18.01.2010 Ulrich Paudler [UP] Textobjekte Front und Rear
if lColumns = 2 Then
	
	lX = lXOffSet
	if of_get_container_type() = TROLLEY Then
		lY = lYOffset + (lRows * lDefaultHeight) +  (lWheelHeight / 2)
	Else
		lY = lYOffset + (lRows * lDefaultHeight)
	End If
	
	sDWObject = "t_front_" + string(i)
	of_create_text(sDWObject, uf.translate("Front"),FONT_MICROSOFT_SANS_SERIF, 12, FONT_BOLD, lX + 1, lY + 1 , lDefaultHeight / 2 - 2, lDefaultWidth - 2, 0, 2, 0, 1)
	of_register(sDWObject, -1, -1)
	lX += lDefaultWidth
		
	sDWObject = "t_rear_" + string(i)
	of_create_text(sDWObject, uf.translate("Rear"),FONT_MICROSOFT_SANS_SERIF, 12, FONT_BOLD, lX + 1, lY + 1 , lDefaultHeight / 2 - 2, lDefaultWidth - 2, 0, 2, 0, 1)
	of_register(sDWObject, -1, -1)

End If


Return 1
end function

public function long of_register (string sobject, long lrow, long lcolumn);/* 
* Funktion/Event: of_register
* Beschreibung: 	Object registrieren
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	26.08.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/

Long a
Long lFound


lFound = this.dsObjects.Find("cobject = '" + sObject + "'", 1, this.dsObjects.RowCount())

if lFound = 0 Then
	a = this.dsObjects.InsertRow(0)
	this.dsObjects.SetItem(a, "cobject", sObject)
	this.dsObjects.SetItem(a, "nrow", lRow)
	this.dsObjects.SetItem(a, "ncolumn", lColumn)
Else
	this.sError = "Object - [" + sObject + "]  register failed, object already existing. Found = " + string(lFound) 
	guoLog.uf_debug("["+ this.classname( )+".of_register] "  +  this.isStowage +" - " + sObject + "| - " + this.sError)
	//this.dsObjects.saveas("c:\temp\cbase\aaaaxxxxxxxxx.xls", Excel!, true)
	return -1
End If

return 1

end function

public function long of_unregister (string sobject);/* 
* Funktion/Event: of_unregister
* Beschreibung: 	Object l$$HEX1$$f600$$ENDHEX$$schen
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	26.08.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long 		lFound
String	sRet

//this.dsObjects.SetFilter("")
//this.dsObjects.Filter()

lFound = this.dsObjects.Find("cobject='" + sObject + "'", 1, this.dsObjects.RowCount())

if lFound > 0 Then
	this.dsObjects.DeleteRow(lFound)
	
	if isValid(oDw) Then
		sRet = oDw.modify("Destroy " + sObject)
		if sRet <> "" Then 
			guoLog.uf_error("["+ this.classname( )+".of_unregister] "  +  this.isStowage +" - " + sObject + "| - unregister oDW faild")
		Else
			guoLog.uf_debug("["+ this.classname( )+".of_unregister] "  +  this.isStowage +" - " + sObject + "| - oDW unregistered")
		End If
	End If

	if isValid(oDS) Then
		sRet = oDS.modify("Destroy " + sObject)
		if sRet <> "" Then 
			guoLog.uf_error("["+ this.classname( )+".of_unregister] "  +  this.isStowage +" - " + sObject + "| - oDS unregister faild")
		Else
			guoLog.uf_debug("["+ this.classname( )+".of_unregister] "  +  this.isStowage +" - " + sObject + "| - oDS unregistered")
		End If
	End If
	
Else
	guoLog.uf_error("["+ this.classname( )+".of_unregister] "  +  this.isStowage +" - " + sObject + "| - not found")
	return -1
End If

return 1
end function

public function Long of_unregister_all ();/* 
* Funktion/Event: of_unregister_all
* Beschreibung: 	Alle Object l$$HEX1$$f600$$ENDHEX$$schen
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	26.08.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long i

for i = this.dsObjects.RowCount() to 1 Step -1
	this.of_unregister(this.dsObjects.GetItemString(i, "cobject"))
next

return 1
end function

public function long of_remove_drawer (long irow, long icolumn);/* 
* Funktion/Event: of_remove_drawer
* Beschreibung: 	Entfernt einen Einschub
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 iRow				Zeile
**	 iColumn			"Spalte"
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	26.08.2008	Erstellung
*	1.1			U.Paudler	17.04.2009	Row/Column als Parameter
*	1.2			U.Paudler	02.09.2009	Backlog entfernen
*  1.3			K.F$$HEX1$$f600$$ENDHEX$$rster	20.10.2010	3 Rung Drawer implementiert
*	1.4			O.H$$HEX1$$f600$$ENDHEX$$fer		14.12.2010	Besondergeiten bei Multi Rung ber$$HEX1$$fc00$$ENDHEX$$cksichtigen
*	1.5			O.H$$HEX1$$f600$$ENDHEX$$fer		23.05.2011	Multi Rung: auch distr parms l$$HEX1$$f600$$ENDHEX$$schen
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long		i
Long		lFound, lFoundNext, lFoundPrev, lAncestorKey, lNull
Long		iType, iTypeNext, iTypePrev
Integer	li_Succ 
Long		ll_rungs, ll_columns

Setnull(lNull)

// Die Position(en) im Trolley muss als geblockt markiert werden
lFoundPrev 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow -1), 1, this.dsLayoutDetail.Rowcount())
lFound 			= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())
lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow + 1), 1, this.dsLayoutDetail.Rowcount())

if lFound > 0 Then
	iType 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
	guoLog.uf_debug( "["+ this.classname( )+".of_remove_drawer] type " + String(iType) +  " C" + String(icolumn) + " R" + String(irow ))			
Else
	sError = "Error, Type not identified"
	guoLog.uf_error( "["+ this.classname( )+".of_remove_drawer] " + sError + " C" + String(icolumn) + " R" + String(irow ))			
	return -1
End If

Choose Case iType 
	Case DRAWER, DRAWERFOOD

	if lFound > 0 and lFound <= this.dsLayoutDetail.RowCount() and &
		lFoundNext > 0 and lFoundNext <= this.dsLayoutDetail.RowCount() Then
	
		this.dsLayoutDetail.Setitem(lFound, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFoundNext, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFound, "nancestor", EMPTY)
		this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", EMPTY)		
	End If
	
Case DRAWER_3RUNG, DRAWERFOOD_3RUNG

	if lFound > 0 and lFound <= this.dsLayoutDetail.RowCount() and &
		lFoundNext > 0 and lFoundNext <= this.dsLayoutDetail.RowCount() and &
		lFoundPrev > 0 and lFoundPrev <= this.dsLayoutDetail.RowCount() 	then

		this.dsLayoutDetail.Setitem(lFoundPrev, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFound, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFoundNext, "ntype", EMPTY)
		
		this.dsLayoutDetail.Setitem(lFoundPrev, "nancestor", EMPTY)
		this.dsLayoutDetail.Setitem(lFound, "nancestor", EMPTY)
		this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", EMPTY)
	End If
	
Case DRAWER_MULTI_RUNG
	
	lAncestorKey = this.dsLayoutDetail.GetitemNumber(lFound, "nancestor")
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_remove_drawer type] DRAWER_MULTI_RUNG ancestorkey " + String(lAncestorKey) +  " C" + String(icolumn) + " R" + String(irow ))			
	end if
	// Zwei Spalten?
	li_Succ = of_get_rungs_and_cols(irow, icolumn, ll_rungs, ll_columns)
	
		
Case Else

	this.sError = "Invalid Type " + String(iType) + " for this function" 
	guoLog.uf_error( "["+ this.classname( )+".of_remove_drawer]  " + sError + " C" + String(icolumn) + " R" + String(irow ))			
	
	return -1

end Choose

// Die Inhalte wegl$$HEX1$$f600$$ENDHEX$$schen
If iType <> DRAWER_MULTI_RUNG Then
	if this.of_remove_content(iRow, iColumn) <> 0 Then
		this.sError = "Remove content failed!"
		guoLog.uf_error( "["+ this.classname( )+".of_remove_drawer]  " + sError + " C" + String(icolumn) + " R" + String(irow ))			
		return -1
	end if
Else
	if this.of_remove_content(iRow, iColumn, TRUE) <> 0 Then
		this.sError = "Remove content failed!"
		guoLog.uf_error( "["+ this.classname( )+".of_remove_drawer]  " + sError + " C" + String(icolumn) + " R" + String(irow ))			
		return -1
	end if
	
End If

// ----------------------------------------------------
// Watermark
// ----------------------------------------------------
li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(iColumn, "00") + "_r_" + string(irow, "00"), FALSE)


// ----------------------------------------------------
// Anschliessend bei Multi-Rung alles platt machen
// ----------------------------------------------------
If iType = DRAWER_MULTI_RUNG Then
	If lAncestorKey > 0 Then
		For i = 1 to this.dsLayoutDetail.RowCount()
			If lAncestorKey = this.dsLayoutDetail.GetitemNumber(i, "nancestor") Then
				this.dsLayoutDetail.Setitem(i, "ntype",		EMPTY)
				this.dsLayoutDetail.Setitem(i, "nancestor",	EMPTY)
				this.dsLayoutDetail.Setitem(i, "ncontent",	lNull)
				this.dsLayoutDetail.Setitem(i, "ncolumns",	lNull)
				this.dsLayoutDetail.Setitem(i, "nrungs",		lNull)
				this.dsLayoutDetail.Setitem(i, "norder",		lNull)		
				guoLog.uf_debug( "["+ this.classname( )+".of_remove_drawer]  #" + String(i) +  "  lAncestorKey=" + String(lAncestorKey) + " C" + String(icolumn) + " R" + String(irow ))			
			End If
		Next
	Else
		guoLog.uf_debug( "["+ this.classname( )+".of_remove_drawer]  lFound " + String(lFound)  + " NO VALID lAncestorKey=" + String(lAncestorKey) + " C" + String(icolumn) + " R" + String(irow ))			
		if lFound > 0 Then
			this.dsLayoutDetail.Setitem(lFound, "ntype",			EMPTY)
			this.dsLayoutDetail.Setitem(lFound, "nancestor",	EMPTY)
			this.dsLayoutDetail.Setitem(lFound, "ncontent",		lNull)
			this.dsLayoutDetail.Setitem(lFound, "ncolumns",		lNull)
			this.dsLayoutDetail.Setitem(lFound, "nrungs",		lNull)
			this.dsLayoutDetail.Setitem(lFound, "norder",		lNull)		
		end if
	End If
End If

// ----------------------------------------------------
// Alle Objekte der Drawers aus der Anzeige l$$HEX1$$f600$$ENDHEX$$schen
// ----------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(icolumn) + " and nrow=" + string(irow)) 
// Multi Rung & 2 Columns breit?
If iType = DRAWER_MULTI_RUNG AND iColumn = 1 AND ll_Columns > 1 Then
	li_Succ = dsObjects.SetFilter("ncolumn in (1 , 2) and nrow=" + string(iRow)) 
End If

this.dsObjects.Filter()

for i = this.dsObjects.RowCount() to 1 Step -1
	if this.of_unregister(this.dsObjects.GetItemString(i, "cobject")) <> 1 Then
		guoLog.uf_error("["+ this.classname( )+".of_remove_drawer] "  +  this.isStowage +" - " + this.dsObjects.GetItemString(i, "cobject") + "| - unregister failed")
	End If
next

this.dsObjects.SetFilter("") 
this.dsObjects.Filter()
this.dsObjects.Sort()


return 1
end function

public function long of_remove_tray (long irow, long icolumn);/* 
* Funktion/Event: of_removw_drawer
* Beschreibung: 	Entfernt einen Einschub
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 iRow				Zeile
**	 iColumn			"Spalte"
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008 	Erstellung
*	1.1			U.Paudler	17.04.2009	Filter wieder zur$$HEX1$$fc00$$ENDHEX$$cksetzen, Rw/Column als Parameter
*	1.2			U.Paudler	02.09.2009	Backlog entfernen
*	1.3			U.Paudler  	19.11.2009		Drawerfood und Traynonfood eingebaut
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	i
Long	lFound
Long iType

// Die Position(en) im Trolley muss als geblockt markiert werden
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if lFound > 0 and lFound <= this.dsLayoutDetail.RowCount() Then

	// Aktuelle Position merken
//	this.iCurrentRow = iRow
//	this.iCurrentColumn = iColumn
	
	// ---------------------------------------------------------------------------
	// Typen
	// ---------------------------------------------------------------------------
	iType 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
	if iType = EMPTY Then return 0
	
	// in Position ist kein Tray
	if iType <> TRAY and iType <> TRAYNONFOOD Then
		sError = "Positon in use"
		return -1
	End If

	
	this.dsLayoutDetail.Setitem(lFound, "ntype", EMPTY)
	
	//// Verteilung?
	//this.dsLayoutDetail.Setitem(lFound, "ncontent", EMPTY)
	
	
	// Die Inhalte wegl$$HEX1$$f600$$ENDHEX$$schen
	if this.of_remove_content(irow, icolumn) <> 0 Then
		this.sError = "Remove content failed!"
		return -1
	End If
	
	
End If


// ----------------------------------------------------
// Alle Objekte der Tray aus der Anzeige l$$HEX1$$f600$$ENDHEX$$schen
// ----------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(icolumn) + " and nrow=" + string(irow)) 
this.dsObjects.Filter()

for i = this.dsObjects.RowCount() to 1 Step -1
	this.of_unregister(this.dsObjects.GetItemString(i, "cobject"))
next

// 17.04.2009 Ulrich Paudler [UP]
// Filter soll gel$$HEX1$$f600$$ENDHEX$$scht werden
//this.dsObjects.SetFilter("ncolumn=" + string(icolumn) + " and nrow=" + string(irow)) 
this.dsObjects.SetFilter("") 
this.dsObjects.Filter()
this.dsObjects.Sort()



return 1
end function

public function long of_set_marker (long irow, long icolumn);/* 
* Funktion/Event: of_set_marker
* Beschreibung: 	Setzen des Zeilenmarkers
*						 
* Besonderheit: 	keine
*
* Argumente:
* 	iRow			Zeile
* 	iRow			Spalte 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	26.08.2008		Erstellung
*	1.1			U.Paudler  	19.11.2009		Drawerfood und Traynonfood eingebaut
*	1.2			O.Hoefer  	30.05.2012		4.84 Error #30: it is very difficult to click into a Multirung Drawer to get the green plus 
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/



Long		lFound, lX1, lX2, lY1, i
Long	iType
String	sDWObject
Integer	li_Succ
Long		ll_rungs, ll_columns, ll_Ancestor
Integer	li_Ancestor_Column, li_Ancestor_Row


if iRow = 0 and iColumn = 0 Then
	oDW.Modify("t_marker_left.visible=0")
	oDW.Modify("t_marker_right.visible=0")
	oDW.Modify("t_marker_top.visible=0")
	oDW.Modify("t_marker_bottom.visible=0")
End If

lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
End If

odw.SetRedraw(false)

// Alle "Buttons" ausblenden
this.dsObjects.SetFilter("")
this.dsObjects.Filter()

for i = 1 to this.dsObjects.RowCount()
	sDWObject = this.dsObjects.GetItemString(i, "cobject")
	if of_check_string(sDWObject,"p_button_" ) Then
		oDW.Modify(sDWObject + ".visible=0")
	End If
next

//sDWObject = "p_button_col_" + string(iColumn, "00") + "_row_" + string(iRow, "00")

//  Farbe setzen
oDW.setitem(1,"nmarkercolor",RGB(255,255,183))
 
// Aktuelle Position merken
this.iCurrentRow = iRow
this.iCurrentColumn = iColumn


// 06.10.2009 Ulrich Paudler [UP]
// ---------------------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
// Typ 1=Drawer 2=Tray  9=Blocked
// ---------------------------------------------------------------------------
iType 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")

if iType = BLOCKED Then 
	odw.SetRedraw(True)
	// Bei BLOCKED evtl trotzdem p_button... einschalten
	//return 0
End If

// 08.10.2009 Ulrich Paudler [UP] nicht im Stand
//oDW.Modify("t_marker_left.visible=1")
//oDW.Modify("t_marker_right.visible=1")
//oDW.Modify("t_marker_top.visible=1")
//oDW.Modify("t_marker_bottom.visible=1")
oDW.Modify("t_marker_left.visible=0")
oDW.Modify("t_marker_right.visible=0")
oDW.Modify("t_marker_top.visible=0")
oDW.Modify("t_marker_bottom.visible=0")

lX1 = lXOffset + ((iColumn -1) * lDefaultWidth) - 10
lX2 = lX1 + lDefaultWidth + 15

Choose Case iType
	Case DRAWER, DRAWERFOOD
	lY1 = lYOffset + (iRow * lDefaultHeight) - lDefaultHeight

	oDW.Modify("t_marker_left.x=" + string(lX1))
	oDW.Modify("t_marker_left.y=" + string(lY1))
	oDW.Modify("t_marker_left.height=" + string(lDefaultHeight * 2))
		
	oDW.Modify("t_marker_right.x=" + string(lX2))
	oDW.Modify("t_marker_right.y=" + string(lY1))
	oDW.Modify("t_marker_right.height=" + string(lDefaultHeight * 2))
	
	oDW.Modify("t_marker_top.x=" + string(lX1) )
	oDW.Modify("t_marker_top.y=" + string(lY1))
	oDW.Modify("t_marker_top.width=" + string(lX2 - lX1))
	
	oDW.Modify("t_marker_bottom.x=" + string(lX1))
	oDW.Modify("t_marker_bottom.y=" + string(lY1 + (lDefaultHeight * 2) - 5))
	oDW.Modify("t_marker_bottom.width=" + string(lX2 - lX1))
	// nach oben holen
	of_set_position("t_marker_left", TRUE)
	of_set_position("t_marker_right",  TRUE)
	of_set_position("t_marker_top", TRUE)
	of_set_position("t_marker_bottom", TRUE)

Case TRAY, TRAYNONFOOD
	
	lY1 = lYOffset + (iRow * lDefaultHeight) - lDefaultHeight + 10

	oDW.Modify("t_marker_left.x=" + string(lX1))
	oDW.Modify("t_marker_left.y=" + string(lY1))
	oDW.Modify("t_marker_left.height=" + string(lDefaultHeight * 2 - 40) )
		
	oDW.Modify("t_marker_right.x=" + string(lX2))
	oDW.Modify("t_marker_right.y=" + string(lY1))
	oDW.Modify("t_marker_right.height=" + string(lDefaultHeight * 2 - 40))
	
	oDW.Modify("t_marker_top.x=" + string(lX1) )
	oDW.Modify("t_marker_top.y=" + string(lY1))
	oDW.Modify("t_marker_top.width=" + string(lX2 - lX1))
	
	oDW.Modify("t_marker_bottom.x=" + string(lX1))
	oDW.Modify("t_marker_bottom.y=" + string(lY1 + (lDefaultHeight * 2) - 45))
	oDW.Modify("t_marker_bottom.width=" + string(lX2 - lX1))
	// nach oben holen
	of_set_position("t_marker_left", TRUE)
	of_set_position("t_marker_right",  TRUE)
	of_set_position("t_marker_top", TRUE)
	of_set_position("t_marker_bottom", TRUE)


Case DRawer_multi_rung
	
	lY1 = lYOffset + (iRow * lDefaultHeight) - lDefaultHeight + 10

	oDW.Modify("t_marker_left.x=" + string(lX1))
	oDW.Modify("t_marker_left.y=" + string(lY1))
	oDW.Modify("t_marker_left.height=" + string(lDefaultHeight * 2 - 40) )
		
	oDW.Modify("t_marker_right.x=" + string(lX2))
	oDW.Modify("t_marker_right.y=" + string(lY1))
	oDW.Modify("t_marker_right.height=" + string(lDefaultHeight * 2 - 40))
	
	oDW.Modify("t_marker_top.x=" + string(lX1) )
	oDW.Modify("t_marker_top.y=" + string(lY1))
	oDW.Modify("t_marker_top.width=" + string(lX2 - lX1))
	
	oDW.Modify("t_marker_bottom.x=" + string(lX1))
	oDW.Modify("t_marker_bottom.y=" + string(lY1 + (lDefaultHeight * 2) - 45))
	oDW.Modify("t_marker_bottom.width=" + string(lX2 - lX1))
	// nach oben holen
	of_set_position("t_marker_left", TRUE)
	of_set_position("t_marker_right",  TRUE)
	of_set_position("t_marker_top", TRUE)
	of_set_position("t_marker_bottom", TRUE)
end Choose	

// den richtigen "Button" einblenden
of_modify_dw("p_button_col_" + string(iColumn, "00") + "_row_" + string(iRow, "00") + ".visible=1")
of_set_position("p_button_col_" + string(iColumn, "00") + "_row_" + string(iRow, "00"),  True)

// -------------------------------------------------------------------
// das "Green Plus" auch bei klick auf column 2 zeigen
// -------------------------------------------------------------------
ll_Ancestor = dsLayoutDetail.GetItemNumber(lFound, "nancestor")
// Bei Multi Rung nach dem Mastersatz suchen
if iType = BLOCKED AND ll_Ancestor > 0 Then
	lFound 	= this.dsLayoutDetail.Find("Nlayout_Detail_Key=" + string(ll_Ancestor) + " and ntype=" + string( DRAWER_MULTI_RUNG ), 1, this.dsLayoutDetail.Rowcount())
	If lFound > 0 Then
		li_Ancestor_Row = this.dsLayoutDetail.GetItemNumber(lFound, "nrow") 
		li_Ancestor_Column = this.dsLayoutDetail.GetItemNumber(lFound, "Ncolumn") 
		iType = this.dsLayoutDetail.GetItemNumber(lFound, "ntype") 
		li_Succ =  of_get_rungs_and_cols(li_Ancestor_Row, li_Ancestor_Column, ll_rungs, ll_columns)
		If iColumn = 2 and ll_columns = 2 AND li_Ancestor_Column = 1 Then
			of_modify_dw("p_button_col_" + string(1, "00") + "_row_" + string(li_Ancestor_Row, "00") + ".visible=1")
			of_set_position("p_button_col_" + string(1, "00") + "_row_" + string(iRow, "00"),  True)
		ElseIf iColumn = 1 and ll_columns = 2 AND li_Ancestor_Column = 1 AND li_Ancestor_Row <> iRow Then
			// das "Green Plus" auch bei klick auf column 1 blocked zeigen
			of_modify_dw("p_button_col_" + string(1, "00") + "_row_" + string(li_Ancestor_Row, "00") + ".visible=1")
			of_set_position("p_button_col_" + string(1, "00") + "_row_" + string(li_Ancestor_Row, "00"),  True)
		End If
	End If
End If

odw.SetRedraw(True)

return 1
end function

public function long of_remove ();/* 
* Funktion/Event: of_remove
* Beschreibung: 	Entfernt einen Einschub oder Drawer an der aktuellen Position
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		05.09.2008		Erstellung
*	1.1				U.Paudler  	19.11.2009		Drawerfood und Traynonfood eingebaut
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	i
Long	lFound
Long	iType


// Rausfinden, was sich in der Position befindet (Drawer/Tray)
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(this.iCurrentColumn) + " and nrow=" + string(this.iCurrentRow), 1, this.dsLayoutDetail.Rowcount())

if lFound > 0 Then
	iType 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
	Choose Case iType 
		Case  DRAWER, DRAWERFOOD, DRAWER_3RUNG, DRAWERFOOD_3RUNG, DRAWER_MULTI_RUNG
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_remove type " + String(iType) +  " C" + String(this.iCurrentColumn) + " R" + String(this.iCurrentRow ))			
			end if
			this.of_remove_drawer(this.iCurrentRow, this.iCurrentColumn)
		Case TRAY, TRAYNONFOOD
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_remove type " + String(iType) +  " C" + String(this.iCurrentColumn) + " R" + String(this.iCurrentRow ))			
			end if
			this.of_remove_tray(this.iCurrentRow, this.iCurrentColumn)
		Case Else 
			this.sError = "Unknown type " + string(iType)
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_remove Unknown type C" + String(this.iCurrentColumn) + " R" + String(this.iCurrentRow ))			
			end if
			return -1
	end Choose
Else
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_remove lFound=0 C" + String(this.iCurrentColumn) + " R" + String(this.iCurrentRow ))			
	end if

End If

return 1

end function

public function long of_modified (datastore omodified);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_modified (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 23.11.2009
* Argument(e):
* datastore omodified
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
* ???			1.0          ???				Erstellung
*
*************************************************************/


return oModified.deletedcount() + oModified.modifiedcount()
end function

public function long of_create_text (long lrow);/* 
* Funktion/Event: of_create_text
* Beschreibung: 	Text anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	lRow			= Zeile aus dsLayoutAddObjects f$$HEX1$$fc00$$ENDHEX$$r die der Text gezeichnet werden soll
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008		Erstellung
*	1.1 			U.Paudler	18.01.2010		Mit dem Cart verschieben
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet

Long		iAlign, iBorder, iColor, lX, lY, lHeight, lWidth, iFontSize, iFontWeight,iMove, iResize
String	sObjectName, sFont, sText, sTag
LongLong lllAddKey

iAlign				= this.dsLayoutAddObjects.GetItemNumber(lRow, "ntextalign")
iBorder			= 0 //this.dsLayoutAddObjects.GetItemNumber(lRow, "nborderstyle")
iColor				= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontcolor")

// 27.04.2010, KF 
// sObjectName wurde hier nie ermittelt, deshalb ging es
// immer in die of_set_xposition Funktion
sObjectName = this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")


// 08.02.2010 Ulrich Paudler [UP]
if of_check_string(sObjectName,"t_content_floating_") Then
	lX = this.dsLayoutAddObjects.GetItemnumber(lRow, "nxpos")
	lY = this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
	
	lx = of_adjust_xposition( lx, sObjectName)
	
Elseif of_check_string(sObjectName,"t_content_") Then
	lX = this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos")
	lY = this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
	
Elseif of_check_string(sObjectName,"t_text_0") Then
	lX = this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos")
	lY = this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")

	lx = of_adjust_xposition( lx, sObjectName)
	
Elseif of_check_string(sObjectName,"t_text_") Then
	lX = this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos")
	lY = this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
	
	lx = of_adjust_xposition( lx, sObjectName)
	
Elseif of_check_string(sObjectName,"t_freetext_content") Then
	lX = this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos")
	lY = this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
	lx = of_adjust_xposition( lx, sObjectName)
	
Else // Hier wird die Xpos ggf. korrigiert
	lX = of_set_xposition(this.dsLayoutAddObjects.GetItemnumber(lRow, "nxpos"))
	lY = this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
End If
// nicht nach links abdriften!
if lX < 0 Then lX = 0
	//lX					= this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos")
	//lY					= this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
	lHeight			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nheight")
	lWidth			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nwidth")
	iFontSize			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontsize")
	iFontWeight		= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontweight")
	iMove				= this.dsLayoutAddObjects.GetItemNumber(lRow, "nmoveable")
	iResize			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nresizeable")
	sObjectName	= this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")
	sFont				= this.dsLayoutAddObjects.GetItemString(lRow, "cfontname")
	// Content nicht f$$HEX1$$fc00$$ENDHEX$$llen
	if of_check_string(sobjectname,"t_content_") Then
		sText			= ""
		
		sFont = FONT_MS_SANS_SERIF
	Else
		sText			= this.dsLayoutAddObjects.GetItemString(lRow, "cvalue")
	End If
	sTag				= String(this.dsLayoutAddObjects.GetItemNumber(lRow, "nlayer"))
	lllAddKey			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nadd_object_key")
	
	if isnull(sTag) Then sTag = ""
	
	if iFontSize > 0 Then iFontSize = iFontSize * -1
	Integer	li_Succ
	li_Succ =  f_replace_string(stext, "'", "~'")
	
	sCreate = "create text(band=detail alignment='" + string(iAlign) + "' " + &
				"text='" + sText + "' border='" + string(iBorder) + "' color='" + String(iColor) + "' " + &
				"x='" + string(lX) +  "' y='" + string(lY) + "' " + &
				" height='"+ String(lHeight) + "' width='" + string(lWidth) + "' " + &
				" name=" + sObjectName+&
				" tag='" + sTag + "'" + &
				" visible='1' resizeable=" + String(iResize) + "  moveable=" + String(iMove) + " font.face='" + sFont + "' " + &
				" font.height='" + String(iFontSize) + "' font.weight='" + String(iFontWeight) + "' font.family='2' font.pitch='2'" + &
				" font.charset='0' font.italic='0' font.underline='0'" +&
				" background.mode='1'" + &
				" background.color='536870912')"
	
	//of_modify_dw(sCreate)
	
	if isValid(oDw) Then
		if oDw.Describe(sObjectName +".Text")<> "!" Then
			return 0
		Else
			sRet = oDw.modify(sCreate)
			if left(sObjectName,len("t_drag_target_")) = "t_drag_target_" Then
				oDw.SetPosition(sObjectName, "", FALSE)
			Else
				oDw.SetPosition(sObjectName, "", TRUE)
			End If
		End If
	End If
	
	if isValid(oDS) Then
		if oDS.Describe(sObjectName +".Text")<> "!" Then
			return 0
		Else
		sRet = oDS.modify(sCreate)
		if left(sObjectName,len("t_drag_target_")) = "t_drag_target_" Then
			oDS.SetPosition(sObjectName, "", FALSE)
		Else
			oDS.SetPosition(sObjectName, "", TRUE)
		End If
	End If
End If


return 1

end function

public function long of_update_objects ();/* 
* Funktion/Event: of_update_objects
* Beschreibung: 	Aktualisieren der Freetextobjekte
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	     22.09.2008		Erstellung
*	1.1			U.Paudler     25.01.2010		Editm$$HEX1$$f600$$ENDHEX$$glichkeit der Drawer/Tray Texte
*	1.2			O.Hoefer         06.05.2014		Rectangle Send To Back
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/

//----------------------------------------------------
// Alle Objecte im DW analysieren
//----------------------------------------------------
Long 		i, j, iCount,iPos
Long		llX, llY, llHeight, llWidth
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
 sDWObjects = oDw.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If

// ---------------------------------------
// Die Freitextobjekte suchen
// und Attribute wegschreiben
// ---------------------------------------

for i = 1 to UpperBound(sObjects)
	sBand 	= oDw.Describe(sObjects[i] + ".band")
	sType 	= oDw.Describe(sObjects[i] + ".type")
	lFound = this.dsLayoutAddObjects.Find("cobject_name='" + sObjects[i] + "'", 1, this.dsLayoutAddObjects.RowCount())
	if lFound <= 0 Then
		//Messagebox("", "Object " + sObjects[i] + " not found!")
		continue
	End If
	
	if Pos(sObjects[i], "t_text_2200") > 0 Then
		lFound = lFound
	End If
	
	// ----------------------------------------------------------------------------------------------------------
	// 27.04.2010, KF
	// Keine Boundarypr$$HEX1$$fc00$$ENDHEX$$fung mehr f$$HEX1$$fc00$$ENDHEX$$r reine Textobjekte
	// ----------------------------------------------------------------------------------------------------------
	if of_check_string(sObjects[i],"t_content_") or of_check_string(sObjects[i],"t_text_") or of_check_string(sObjects[i],"t_freetext_content") Then
		llX			= long(oDw.describe(sObjects[i] + ".x"))
		llY			= long(oDw.describe(sObjects[i] + ".y"))
		llHeight	= long(oDw.describe(sObjects[i] + ".height"))
		llWidth	= long(oDw.describe(sObjects[i] + ".width"))
	
		// 02.02.2010 Ulrich Paudler [UP] Maximale xPosition ermitteln
		// 27.04.2010, KF - Keine Pr$$HEX1$$fc00$$ENDHEX$$fung f$$HEX1$$fc00$$ENDHEX$$r Freitextobjekte CBASE-NAM-EM-0063
		if of_check_string(sObjects[i],"t_content_") Then
			if not of_check_boundary(llX, llY, llHeight, llWidth) Then
				llX = long(oDw.object.r_frame.Width) - llWidth
			End If		
		End If
				
		// 19.01.2010 Ulrich Paudler [UP]
		// 08.02.2010 Ulrich Paudler [UP]
		if of_check_string(sObjects[i],"t_content_floating_") Then
			this.dsLayoutAddObjects.SetItem(lFound, "nxpos", llX)
		Elseif of_check_string(sObjects[i],"t_content_") Then
			this.dsLayoutAddObjects.SetItem(lFound, "nxpos", llX)
		Elseif of_check_string(sObjects[i],"t_text_") Then
			this.dsLayoutAddObjects.SetItem(lFound, "nxpos", llX)
		Elseif of_check_string(sObjects[i],"t_freetext_content") Then
			this.dsLayoutAddObjects.SetItem(lFound, "nxpos", llX)
		Else
			this.dsLayoutAddObjects.SetItem(lFound, "nxpos", of_get_xposition(llX, sObjects[i]))
		End If
	
		this.dsLayoutAddObjects.SetItem(lFound, "nypos",  llY)
		this.dsLayoutAddObjects.SetItem(lFound, "nheight", llHeight)
		this.dsLayoutAddObjects.SetItem(lFound, "nwidth", llWidth)
		
		this.dsLayoutAddObjects.SetItem(lFound, "ntextalign", long(oDw.describe(sObjects[i] + ".alignment")) )
		this.dsLayoutAddObjects.SetItem(lFound, "nborderstyle", long(oDw.describe(sObjects[i] + ".border")) )
		this.dsLayoutAddObjects.SetItem(lFound, "nfontcolor", long(oDw.describe(sObjects[i] + ".color")) )
		this.dsLayoutAddObjects.SetItem(lFound, "nfontsize", long(oDw.describe(sObjects[i] + ".font.height")) * -1 )
		this.dsLayoutAddObjects.SetItem(lFound, "nfontweight", long(oDw.describe(sObjects[i] + ".font.weight")) )
		this.dsLayoutAddObjects.SetItem(lFound, "cfontname", oDw.describe(sObjects[i] + ".font.face"))
		// keine contents wegschreiben
		//if left(sObjects[i], len("t_text_")) = "t_text_" Then
		if of_check_string(sObjects[i],"t_text_") Then
			this.dsLayoutAddObjects.SetItem(lFound, "cvalue", oDw.describe(sObjects[i] + ".text"))
		Else
			this.dsLayoutAddObjects.SetItem(lFound, "cvalue", "")
		End If
		this.dsLayoutAddObjects.SetItem(lFound, "nlayer", Long(oDw.describe(sObjects[i] + ".tag")))
		
	Elseif of_check_string(sObjects[i],"r_rect_" ) Then
		
		
		llX			= long(oDw.describe(sObjects[i] + ".x"))
		llY			= long(oDw.describe(sObjects[i] + ".y"))
		llHeight	= long(oDw.describe(sObjects[i] + ".height"))
		llWidth	= long(oDw.describe(sObjects[i] + ".width"))
		
		this.dsLayoutAddObjects.SetItem(lFound, "nxpos",  llX)
		this.dsLayoutAddObjects.SetItem(lFound, "nypos",  llY)
		this.dsLayoutAddObjects.SetItem(lFound, "nheight", llHeight)
		this.dsLayoutAddObjects.SetItem(lFound, "nwidth", llWidth)
				
		this.dsLayoutAddObjects.SetItem(lFound, "nborderstyle", long(oDw.describe(sObjects[i] + ".alignment")))
		this.dsLayoutAddObjects.SetItem(lFound, "nbackgroundmode", Long(oDw.describe(sObjects[i] + ".background.mode")))
		this.dsLayoutAddObjects.SetItem(lFound, "nbackgroundcolor", long(oDw.describe(sObjects[i] + ".background.color")))
		this.dsLayoutAddObjects.SetItem(lFound, "nbrushcolor", long(oDw.describe(sObjects[i] + ".brush.color")))
		this.dsLayoutAddObjects.SetItem(lFound, "npencolor", long(oDw.describe(sObjects[i] + ".pen.color")))
		this.dsLayoutAddObjects.SetItem(lFound, "npenwidth", long(oDw.describe(sObjects[i] + ".pen.width")))
		this.dsLayoutAddObjects.SetItem(lFound, "nbrushhatch", long(oDw.describe(sObjects[i] + ".brush.hatch")))
		// 06.05.14
		this.dsLayoutAddObjects.SetItem(lFound, "nlayer", Long(oDw.describe(sObjects[i] + ".tag")))
		
		
	Elseif of_check_string(sObjects[i],"p_picture_") Then

		llX			= long(oDw.describe(sObjects[i] + ".x"))
		llY			= long(oDw.describe(sObjects[i] + ".y"))
		llHeight	= long(oDw.describe(sObjects[i] + ".height"))
		llWidth	= long(oDw.describe(sObjects[i] + ".width"))
	
		// 02.02.2010 Ulrich Paudler [UP] Maximale xPosition ermitteln
		if not of_check_boundary(llX, llY, llHeight, llWidth) Then
			llX = long(oDw.object.r_frame.Width) - llWidth
		End If		
		
		// 19.01.2010 Ulrich Paudler [UP]
		this.dsLayoutAddObjects.SetItem(lFound, "nxpos", of_get_xposition(llX, sObjects[i]))
		this.dsLayoutAddObjects.SetItem(lFound, "nypos",  llY)
		this.dsLayoutAddObjects.SetItem(lFound, "nheight", llHeight)
		this.dsLayoutAddObjects.SetItem(lFound, "nwidth", llWidth)		
		
	End If
		
Next

return 1
end function

public function long of_set_position ();/* 
* Funktion/Event: of_set_position
* Beschreibung: 	Objekte in den Vordergrund/Hintergrund setzen
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	22.09.2008		Erstellung
*	1.1			O.Hoefer    06.05.2014		Layer 2, Send To Back zuletzt durchf$$HEX1$$fc00$$ENDHEX$$hren
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/

String sLayer, sObject
Boolean	lb_Breakpoint
Long i

// Schleife 1: OHNE Layer 2
for i = 1 to  this.dsLayoutAddObjects.RowCount()
	sObject 	= this.dsLayoutAddObjects.GetItemString(i, "cobject_name")
	sLayer 		= String(this.dsLayoutAddObjects.GetItemNumber(i, "nlayer"))
	
	If pos(sObject, "r_rect") > 0 then
		lb_Breakpoint = TRUE
	end if
	
	Choose Case sLayer
		Case "0"
			of_set_position(sObject, False)
			//of_set_position(sObject, True)
		Case "1"
			of_set_position(sObject, True)
		Case "2"
//			of_set_position(sObject, False)
		Case Else
			// lassen
			//of_set_position(sObject, False)
	end Choose
	
	// "Abdeckung" der Mittellinie bei Einsch$$HEX1$$fc00$$ENDHEX$$ben $$HEX1$$fc00$$ENDHEX$$ber 2 Spalten
	if of_check_string(sObject,"p_pic_content_cover_" ) Then
		of_set_position(sObject, True)
	End If

	
	// Texte immer ganz nach oben
	if of_check_string(sObject,"t_text_") Then
		of_set_position(sObject, True)
	End If
	
	
	
Next

// Layer 2 nachtr$$HEX1$$e400$$ENDHEX$$glich
for i = 1 to  this.dsLayoutAddObjects.RowCount()
	sObject 	= this.dsLayoutAddObjects.GetItemString(i, "cobject_name")
	sLayer 		= String(this.dsLayoutAddObjects.GetItemNumber(i, "nlayer"))
	
	If pos(sObject, "r_rect") > 0 then
		lb_Breakpoint = TRUE
	end if
	
	Choose Case sLayer
//		Case "0"
//			of_set_position(sObject, False)
//			//of_set_position(sObject, True)
//		Case "1"
//			of_set_position(sObject, True)
		Case "2"
			of_set_position(sObject, False)
		Case Else
			// lassen
			//of_set_position(sObject, False)
	end Choose
Next

for i = 1 to this.dsObjects.RowCount()
	sObject = this.dsObjects.GetItemString(i, "cobject")
	
	// Drag Target nach hinten!
	if of_check_string(sObject,"t_drag_target" ) Then
		of_set_position(sObject, False)
	End If
	
	// Schienen in den Hintergrund
	if of_check_string(sObject,"p_lane_") Then
//		of_set_position(sObject, False)
//		Messagebox("", "Bingo...")
	End If
		
next

return 1
end function

public function long of_blob_to_file (string sfilename, blob bfilebuffer);/* 
* Funktion/Event: of_blob_to_file
* Beschreibung: Diese Funktion speichert einen Blob in eine Datei
*					welcher $$HEX1$$fc00$$ENDHEX$$bergeben wurde.
*
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 sfilename		Dateiname
*	 bfilebuffer	Bin$$HEX1$$e400$$ENDHEX$$rdaten
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	22.09.2008		Erstellung
*	 
*
* Return Codes:
*	 n		Antahl Bytes
*	-1		Fehler
*  
*/

// -------------------------------------------------
//
// der R$$HEX1$$fc00$$ENDHEX$$ckgabewert ist die Anzahl der geschriebenen
// Bytes
// -------------------------------------------------

Blob		bBuffer
Long		lFileLength, &
			lBytesWrite, &
			lAnzSchreibLoops, &
			l
			
Long	iFileHandleSource

// ----------------
// Dateigr$$HEX2$$f600df00$$ENDHEX$$e
// ----------------
If Len(bfilebuffer) <= 0 or isnull(Len(bfilebuffer)) Then
	 uf.mbox ("Fehler","Dateigr$$HEX2$$f600df00$$ENDHEX$$e der Ausgabedatei ist null!")
End If	

lFileLength = Len(bfilebuffer)

iFileHandleSource = FileOpen(sfilename, StreamMode!, Write!, LockReadWrite!, Replace!)

If iFileHandleSource = -1 Then
	uf.mbox ("Fehler","Ausgabedatei kann nicht geschrieben werden!~r${" + sfilename + "}" )
End If

// ------------------------------------------
// Wir schreiben den Blob
//
// FileRead und Write verarbeitet nur Chunks 
// mit 32K ggf. mehrere Loops
// ------------------------------------------

lAnzSchreibLoops = Mod (lFileLength, 32765)
If lAnzSchreibLoops = 0 Then
	lAnzSchreibLoops = lFileLength / 32765
Elseif lAnzSchreibLoops > 0 Then 
	lAnzSchreibLoops = (lFileLength / 32765) + 1
End If

For l = 1 To lAnzSchreibLoops
	bBuffer   = BlobMid(bfilebuffer, (((l - 1) * 32765) + 1), 32765)
	lBytesWrite = lBytesWrite + FileWrite(iFileHandleSource, bBuffer) 
next

FileClose(iFileHandleSource)

return lBytesWrite

end function

public function long of_file_to_blob (string sfilename, ref blob bfilebuffer);/* 
* Funktion/Event: of_file_to
* Beschreibung:  Diese Funktion l$$HEX1$$e400$$ENDHEX$$dt eine Datei in einen Blob,
*					  welcher per Referenz $$HEX1$$fc00$$ENDHEX$$bergeben wurde.
*
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 sfilename		Dateiname
*	 bfilebuffer	Bin$$HEX1$$e400$$ENDHEX$$rdaten
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	22.09.2008		Erstellung
*	 
*
* Return Codes:
*	 n		Antahl Bytes
*	-1		Fehler
*  
*/

Blob		bBuffer
Long		lFileLength, &
			lBytesRead, &
			lBytesRet, &
			lAnzLeseLoops, &
			l
			
Long	iFileHandleSource

SetPointer(Hourglass!)

// ----------------
// Dateigr$$HEX1$$f600$$ENDHEX$$sse
// ----------------

lFileLength = FileLength(sFileName)

// ----------------------------------------------------
// FileRead und Write verarbeitet nur Chunks mit 32K
// ggf. mehrere Loops
// ----------------------------------------------------

lAnzLeseLoops = Mod (lFileLength,  32765)
If lAnzLeseLoops = 0 Then
	lAnzLeseLoops = lFileLength /  32765
Elseif lAnzLeseLoops > 0 Then 
	lAnzLeseLoops = (lFileLength /  32765) + 1
End If

//iFileHandleSource  = FileOpen(sFileName, StreamMode!, Read!, LockReadWrite!)
iFileHandleSource  = FileOpen(sFileName, StreamMode!, Read!, Shared!)

if iFileHandleSource = -1 Then
	Return -1
End If 

bFileBuffer = Blob("")

For l = 1 To lAnzLeseLoops
	lBytesRead = FileRead(iFileHandleSource, bBuffer) 
	if lBytesRead <> -1 Then
		bFileBuffer += bBuffer
		lBytesRet 	+= lBytesRead
		bBuffer		 = Blob("")
	End If
Next

FileClose(iFileHandleSource)

return lBytesRet

end function

public function long of_add_picture (string sfile, long lx, long ly, long lheight, long lwidth);/*
	* Funktion/Event: of_add_text
	* Beschreibung: 	Freitext platzieren
	*
	* Besonderheit: 	keine
	*
	* Argumente:
	* 	Name				Beschreibung
	*	 bPicture		das Bils
	* 	 sText			Anzuzeigender Text
	*
	* Aenderungshistorie:
	* 	Version 		Wer			Wann			Was und warum
	*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	22.09.2008		Erstellung
	*
	*
	* Return Codes:
	*	 1		Alles OK
	*	-1		Fehler
	*
	*/
Long			lFound, llNewRow
String			sTempFile, sSuffix, sPName
Blob			bBlob
Long			i
LongLong	lllSequence

// 02.02.2010 Ulrich Paudler [UP] Maximale xPosition ermitteln
if not of_check_boundary(lx, ly, lheight, lwidth) Then
	lx = (long(oDw.object.r_frame.x) + long(oDw.object.r_frame.Width)) - lwidth
End If

// --------------------------------------------------------------------------------------------------------------------
// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
// --------------------------------------------------------------------------------------------------------------------
lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)
if lllSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

this.of_file_to_blob(sFile, bBlob)
for i = len(sFile) to 1 Step -1
	if Mid(sFile, i, 1) = "." Then
		sSuffix = Mid(sFile, i + 1)
		exit
	End If
next

if Right(sTemppath, 1) <> "\" Then sTemppath += "\"
sTempFile = of_generate_filename("p_", sSuffix)
//sTempFile = "p_" + string(cpu()) + "_" + string(today(), "yyyymmmdd") + String(now(), "hhmmss") + sSuffix

this.of_blob_to_file(sTemppath + sTempFile, bBlob)

// 30.09.2009 Ulrich Paudler [UP]
of_register_file(sTemppath + sTempFile) 
//sRegisteredFiles[Upperbound(sRegisteredFiles) + 1] = sTemppath + sTempFile

sPName =  "p_picture_" + string(llNewRow) + "_" + string(now(), "hhmmss")

llNewRow = this.dsLayoutAddObjects.InsertRow(0)
this.dsLayoutAddObjects.SetItem(llNewRow, "nadd_object_key", lllSequence)
this.dsLayoutAddObjects.SetItem(llNewRow, "nlayout_key", this.lLayoutKey)
this.dsLayoutAddObjects.SetItem(llNewRow, "nobject_type", BITMAPOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle
this.dsLayoutAddObjects.SetItem(llNewRow, "cobject_name", sPNAME)
this.dsLayoutAddObjects.SetItem(llNewRow, "nheight", lheight)
this.dsLayoutAddObjects.SetItem(llNewRow, "nwidth", lwidth)
// 19.01.2010 Ulrich Paudler [UP]
this.dsLayoutAddObjects.SetItem(llNewRow, "nxpos", of_get_xposition(lX, sPName))
this.dsLayoutAddObjects.SetItem(llNewRow, "nypos", lY)
this.dsLayoutAddObjects.SetItem(llNewRow, "nborderstyle", 0)
this.dsLayoutAddObjects.SetItem(llNewRow, "cvalue", sTempFile)
this.dsLayoutAddObjects.SetItem(llNewRow, "cfullname", sTemppath + sTempFile)
this.dsLayoutAddObjects.SetItem(llNewRow, "nresizeable", 1)
this.dsLayoutAddObjects.SetItem(llNewRow, "nmoveable", 1)
this.dsLayoutAddObjects.SetItem(llNewRow, "nnew", 1)

this.of_create_picture(this.dsLayoutAddObjects.GetItemString(llNewRow, "cobject_name"), this.dsLayoutAddObjects.GetItemString(llNewRow, "cfullname"), lX, lY, lWidth, lHeight, 1, 1, 1)

return 1
end function

public function long of_create_picture (string sobjectname, string spicturename, long lx, long ly, long lheight, long lwidth, long ivisible, long iresize, long imove);/* 
* Funktion/Event: of_create_picture
* Beschreibung: 	Bild anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	sObjectName			= Name der PictureObjects
* 	sPictureName		= Name der Bilddatei
*	lX						= XPos des Bildes im Datawindow
*	lY						= YPos
*	lWidth				= Breite
*	lHeight				= H$$HEX1$$f600$$ENDHEX$$he des Bildes im Datawindow
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	256.08.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet
String	ls_Mod

sCreate = "create bitmap(name=" + sObjectName + " visible='" + String(iVisible)  + "' resizeable=" + String(iResize) + "  moveable=" + String(iMove)  + &
			 " band=detail filename='" + sPictureName + "'" + &
			 " x='" + string(lX, "0") + "' y='" + string(lY) + &
			 "' height='" + String(lHeight) + "' width='" + String(lWidth) + "' border='9' )"

of_modify_dw(sCreate)
of_set_position(sObjectName, FALSE)

ls_mod = sObjectName + ".tag='NOSUBREPORT'"
of_modify(ls_mod , false)


return 1

end function

public function long of_get_type (long irow, long icolumn);// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_get_type (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
// Long irow
//  Long icolumn
// --------------------------------------------------------------------------------
// Return: Long
// --------------------------------------------------------------------------------
//  Beschreibung:
//	Feststellen, was sich in einer Trolleyposition befindet
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  05.12.2008	            Klaus F$$HEX1$$f600$$ENDHEX$$rster        Erstellung
//
// --------------------------------------------------------------------------------

Long	i
Long	lFound
Long iType

lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if lFound > 0  Then
	iType 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
	return iType
End If

return -1
end function

public function long of_get_detail_key (long irow, long icolumn);// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_get_detail_key (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
// Long irow
//  Long icolumn
// --------------------------------------------------------------------------------
// Return: Long
// --------------------------------------------------------------------------------
//  Beschreibung:
// Detailkey der Trollayposition ermitteln
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  05.12.2008	            Klaus F$$HEX1$$f600$$ENDHEX$$rster        Erstellung
//
// --------------------------------------------------------------------------------

Long	i
Long	lFound
Long	lDetail


lFound = this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if lFound > 0  Then
	lDetail 		= this.dsLayoutDetail.Getitemnumber(lFound, "nlayout_detail_key")

	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_detail_key  CurrentRow " + String(iRow) + &
			" Column " + String(icolumn) + " nlayout_detail_key=" + String(lDetail))
	End If
	
	return lDetail
End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_detail_key  CurrentRow " + String(iRow) + &
		" Column " + String(icolumn) + " nlayout_detail_key=NOT FOUND")
End If

return -1

end function

public function long of_move_object (long inewrow, long inewcolumn, long ioldrow, long ioldcolumn);// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_move_object (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
// Long inewrow
//  Long inewcolumn
//  Long ioldrow
//  Long ioldcolumn
// --------------------------------------------------------------------------------
// Return: Long
// --------------------------------------------------------------------------------
//  Beschreibung:
//
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  05.12.2008	            Klaus F$$HEX1$$f600$$ENDHEX$$rster       Erstellung
//  02.09.2009	            Ulrich Paudler      Backlog mit verschieben
//  19.11.2009					Ulrich Paudler 	  Drawerfood und Traynonfood eingebaut
//  25.01.2010					Ulrich Paudler  	  Editm$$HEX1$$f600$$ENDHEX$$glichkeit der Drawer/Tray Texte
//  25.10.2010					Klaus F$$HEX1$$f600$$ENDHEX$$rster		  3 Schienen Einschub eingebaut
//  22.11.2010					Oliver H$$HEX1$$f600$$ENDHEX$$fer		  Multi Rung
//  18.03.2014					Oliver H$$HEX1$$f600$$ENDHEX$$fer		  Multi Rung, 2HE Move (IM10691692)
// --------------------------------------------------------------------------------

Long		lFound,  lFoundNext, lLayoutDetailKey,llFindRow, lFoundPrev
Long		iType, iTypeNext, iTypePrev,  iContent, iTypeNew, iTypeNewNext,iTypeNewPrev
String	sMod, sFilter, sText
Long		ll_Rungs, ll_Columns
Long		ll_Check_Position_R
Long		ll_Check_Position_C
Long		ll_Type_To_Check
Long		ll_Rung_From, ll_RungTo
Integer	li_Succ
Long		ll_Ancestor, ll_Order


// Die Position(en) im Trolley muss als geblockt markiert werden
this.dsLayoutDetail.SetFilter("") 
this.dsLayoutDetail.Filter()
this.dsLayoutDetail.Sort()

lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
		//sError = "Error: Row/Column mismatch"
		sError = "Cannot be placed here"
	return -1
End If

// ---------------------------------------------------------------------------
// Contenttyp ermitteln
// ---------------------------------------------------------------------------
iType 				= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
iContent				= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
lLayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(lFound, "nlayout_detail_key")


// ---------------------------------------------------------------------------
// Bei Multi-Rung: ABmessungen sichern
// ---------------------------------------------------------------------------
If iType = DRAWER_MULTI_RUNG Then
	ll_Rungs		= this.dsLayoutDetail.Getitemnumber(lFound, "nrungs")
	ll_Columns	= this.dsLayoutDetail.Getitemnumber(lFound, "ncolumns")
	ll_Order		= this.dsLayoutDetail.Getitemnumber(lFound, "norder")
End If

// --------------------------------------------------------------------------------
// 05.12.2008, KF: Pr$$HEX1$$fc00$$ENDHEX$$fen, ob das Ziel unbelegt ist
// --------------------------------------------------------------------------------
Choose Case iType
	Case DRAWER, DRAWERFOOD
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if lFound = 0 or lFoundNext = 0 Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		
		// ---------------------------------------------------------------------------
		// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
		// ---------------------------------------------------------------------------
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		iTypeNewNext 	= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		
		// Position ist bereits benutzt, nur bei Neuanlage pr$$HEX1$$fc00$$ENDHEX$$fen
		if  this.of_is_position_change(iType, iNewRow, iNewColumn)  = 0 Then
		    // OK
		
		Elseif (iTypeNew <> EMPTY or iTypeNewNext <> EMPTY) Then
			sError = "Position in use"
			return -1
		End If
		
	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
		
		lFoundPrev 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if lFoundPrev = 0 or lFound = 0 or lFoundNext = 0 Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		
		// ---------------------------------------------------------------------------
		// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
		// ---------------------------------------------------------------------------
		iTypeNewPrev	= this.dsLayoutDetail.Getitemnumber(lFoundPrev, "ntype")
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		iTypeNewNext 	= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		
		if  this.of_is_position_change(iType, iNewRow, iNewColumn)  = 0 Then
		    // OK
		
		Elseif ( iTypeNewPrev <> EMPTY or iTypeNew <> EMPTY or iTypeNewNext <> EMPTY) Then
			sError = "Position in use"
			return -1
		End If
	
		
	Case TRAY, TRAYNONFOOD	
			lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
			if lFound = 0  Then
				//sError = "Error: Row/Column mismatch"
				sError = "Cannot be placed here"
				return -1
			End If
		
		// ---------------------------------------------------------------------------
		// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
		// ---------------------------------------------------------------------------
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		
		// Position ist bereits benutzt, nur bei Neuanlage pr$$HEX1$$fc00$$ENDHEX$$fen
		if iTypeNew <> 0 Then
			sError = "Position in use"
			return -1
		End If
	
	Case DRAWER_MULTI_RUNG
			
		lFoundPrev 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		//if lFoundPrev = 0 or lFound = 0 or lFoundNext = 0 Then
		if lFound = 0  Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		
		// Ab 2 Rungs: eins nach unten hinzu 
		if ll_Rungs > 1 AND lFoundNext = 0  Then
			sError = "Cannot be placed here"
			return -1
		End If
		
		// Ab 3 Rungs: eins nach oben hinzu 
		if ll_Rungs > 2 AND lFoundPrev = 0  Then
			sError = "Cannot be placed here"
			return -1
		End If
		
	
		ll_RungTo		= iNewRow + 1
		If ll_Rungs = 1 Then
			ll_RungTo = iNewRow 
		End If
		ll_Rung_From	= ll_RungTo - ll_Rungs + 1	

		For ll_Check_Position_C = iNewColumn To iNewColumn +  (ll_Columns - 1)
			// Pr$$HEX1$$fc00$$ENDHEX$$fe Spalte X
			For ll_Check_Position_R = ll_Rung_From To ll_RungTo	
				// Pr$$HEX1$$fc00$$ENDHEX$$fe H$$HEX1$$f600$$ENDHEX$$heneinheit X
				lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(ll_Check_Position_C) + " and nrow=" + string(ll_Check_Position_R), 1, this.dsLayoutDetail.Rowcount())
				If lFound > 0 Then 
					ll_Type_To_Check = this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
					if ll_Type_To_Check <> EMPTY Then
						sError = "Position in use"
						return -1
					End If
				Else
					sError = "Position in use"
					return -1
				End If
			Next
		Next
			
		// ---------------------------------------------------------------------------
		// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
		// ---------------------------------------------------------------------------
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		
		If ll_rungs > 2 Then 	
			iTypeNewPrev	= this.dsLayoutDetail.Getitemnumber(lFoundPrev, "ntype")
		End If
		
		If ll_rungs > 1 Then 	
			iTypeNewNext 	= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		End If
		
//		
//		if  this.of_is_position_change(iType, iNewRow, iNewColumn)  = 0 Then
//		    // OK
//		
//		Else
//		if ( iTypeNewPrev <> EMPTY or iTypeNew <> EMPTY or iTypeNewNext <> EMPTY) Then
//			sError = "Position in use"
//			return -1
//		End If
	
	
Case Else
	return 0
end Choose
	

// --------------------------------------------------------------------------------
// 05.12.2008, KF: Die Position ist frei, jetzt die Position des Objekts 
//                 $$HEX1$$e400$$ENDHEX$$ndern
// --------------------------------------------------------------------------------
Long I
datastore dsTemp
string sObject, sRet
dsTemp = create datastore
dsTemp.dataobject = this.dsObjects.dataobject

this.dsObjects.Setfilter("")
this.dsObjects.Filter()
this.dsObjects.RowsCopy(1, this.dsObjects.RowCount(), Primary!, dsTemp, 1, Primary!)

dsTemp.SetFilter("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow)) 
dsTemp.Filter()

// MULTI RUNG rechte Spalte
If iType = DRAWER_MULTI_RUNG AND ll_Columns = 2 Then
	dsTemp.SetFilter("(ncolumn=" + string(iOldColumn) + " OR ncolumn=2) and nrow=" + string(iOldRow)) 
	dsTemp.Filter()	
End If

// --------------------------------------------------------------------------------
// 12.12.2008, KF: Objekte auf der alten Position l$$HEX1$$f600$$ENDHEX$$schen
// --------------------------------------------------------------------------------

for i = dsTemp.RowCount() to 1 Step -1
	sObject = dsTemp.GetItemString(i, "cobject")
	// 25.01.2010 Ulrich Paudler [UP] Objekt entfernen (= zur$$HEX1$$fc00$$ENDHEX$$cksetzen auf standardformat)
	llFindRow = this.dsLayoutAddObjects.Find("cobject_name='" + sObject + "'",1,dsLayoutAddObjects.Rowcount())
	if llFindrow > 0 Then
		this.dsLayoutAddObjects.deleterow(llFindRow)
	End If 
	if this.of_unregister(sObject) = -1 Then
		this.sError = "Unregister Object Failed"
		Destroy(dsTemp)
		return -1
	End If
next

Destroy(dsTemp)

// --------------------------------------------------------------------------------
// 12.12.2008, KF: alte Belegung entfernen
// -------------------------------------------------------------------------------
Long	lOldDetailKey
Long	lNewDetailKey
Long	lOldContent
Long	lNewContent

Choose Case iType 
	Case DRAWER, DRAWERFOOD
		lFound 			= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if lFound = 0 or lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while removing"
			return -1
		End If
		
		lOldDetailKey 	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		lOldContent 	= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
		
		this.dsLayoutDetail.Setitem(lFound, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFound, "ncontent", 0)
		this.dsLayoutDetail.Setitem(lFoundNext, "ntype", EMPTY)

		guoLog.uf_debug("["+ this.classname( )+".of_move_object] "  +  this.isStowage +" - " + "Set Type = EMPTY for  " + String(iOldRow) + " AND "+ String(iOldRow + 1) )
		this.dsLayoutDetail.Setitem(lFound, "nancestor", EMPTY)
		this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", EMPTY)

	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
		
		lFoundPrev 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 			= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if  lFoundPrev = 0 or lFound = 0 or lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while removing"
			return -1
		End If
		
		lOldDetailKey 	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		lOldContent 	= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
		
		this.dsLayoutDetail.Setitem(lFound, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFound, "ncontent", 0)
		
		this.dsLayoutDetail.Setitem(lFoundPrev, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFoundNext, "ntype", EMPTY)
		
		this.dsLayoutDetail.Setitem(lFoundPrev, "nancestor", EMPTY)
		this.dsLayoutDetail.Setitem(lFound, "nancestor", EMPTY)
		this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", EMPTY)
		

	Case TRAY, TRAYNONFOOD
		
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0  Then
			sError = "Error: Row/Column mismatch while removing"
			return -1
		End If
		
		lOldDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")	
		lOldContent 	= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
		
		this.dsLayoutDetail.Setitem(lFound, "ntype", EMPTY)
		this.dsLayoutDetail.Setitem(lFound, "ncontent", 0)
		this.dsLayoutDetail.Setitem(lFound, "nancestor", EMPTY)


	Case DRAWER_MULTI_RUNG
		
		lFoundPrev 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 			= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if ll_Rungs > 2 AND (lFoundPrev = 0 or lFound = 0 or lFoundNext = 0) Then
			sError = "Error: Row/Column mismatch while removing"
			return -1
		End If
		
		if ll_Rungs = 1 AND lFound = 0 Then
			sError = "Error: Row/Column mismatch while removing"
			return -1
		End If

		if ll_Rungs > 1 AND (lFound = 0 or lFoundNext = 0) Then
			sError = "Error: Row/Column mismatch while removing"
			return -1
		End If
		
		lOldDetailKey 	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		lOldContent 	= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
		ll_Ancestor		= this.dsLayoutDetail.Getitemnumber(lFound, "nancestor")
		
//		this.dsLayoutDetail.Setitem(lFound, "ntype", EMPTY)
//		this.dsLayoutDetail.Setitem(lFound, "ncontent", 0)
//		
//		if ll_Rungs > 2 Then
//			this.dsLayoutDetail.Setitem(lFoundPrev, "ntype", EMPTY)
//		End If
//		if ll_Rungs > 1 Then
//			this.dsLayoutDetail.Setitem(lFoundNext, "ntype", EMPTY)
//		End If
		
//		this.dsLayoutDetail.Setitem(lFoundPrev, "nancestor", EMPTY)
//		this.dsLayoutDetail.Setitem(lFound, "nancestor", EMPTY)
//		this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", EMPTY)

		// Abmessungen 
		li_Succ = this.dsLayoutDetail.Setitem(lFound, "nrungs", EMPTY)
		li_Succ = this.dsLayoutDetail.Setitem(lFound, "ncolumns", EMPTY)
		// Order
		li_Succ = this.dsLayoutDetail.Setitem(lFound, "norder", EMPTY)


		// Alle weiteren Zeilen l$$HEX1$$f600$$ENDHEX$$schen
		lFoundNext 		= this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor) , 1, this.dsLayoutDetail.Rowcount())		
		Do While lFoundNext > 0
			li_Succ = this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", EMPTY)
			li_Succ = this.dsLayoutDetail.Setitem(lFoundNext, "ntype", EMPTY)
			li_Succ = this.dsLayoutDetail.Setitem(lFoundNext, "ncontent", 0)
			li_Succ = this.dsLayoutDetail.Setitem(lFoundNext, "norder", EMPTY)
			lFoundNext 		= this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor) , 1, this.dsLayoutDetail.Rowcount())		
		Loop
		
	
end Choose
// --------------------------------------------------------------------------------
// 12.12.2008, KF: Neue Belegung registrieren
// --------------------------------------------------------------------------------
Choose Case iType 
		
	Case DRAWER, DRAWERFOOD
		
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if lFound = 0 or lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while moving"
			return -1
		End If
		
		lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		this.dsLayoutDetail.Setitem(lFound, "ntype", iType)
		this.dsLayoutDetail.Setitem(lFound, "ncontent", lOldContent)
		this.dsLayoutDetail.Setitem(lFoundNext, "ntype", BLOCKED)
		
		this.dsLayoutDetail.Setitem(lFound, "nancestor", lNewDetailKey)
		this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", lNewDetailKey)
		

Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
		
		lFoundPrev 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if  lFoundNext = 0 or lFound = 0 or lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while moving"
			return -1
		End If
		
		lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		this.dsLayoutDetail.Setitem(lFound, "ntype", iType)
		this.dsLayoutDetail.Setitem(lFound, "ncontent", lOldContent)
		this.dsLayoutDetail.Setitem(lFoundNext, "ntype", BLOCKED)
		this.dsLayoutDetail.Setitem(lFoundPrev, "ntype", BLOCKED)
		
		this.dsLayoutDetail.Setitem(lFoundPrev, "nancestor", lNewDetailKey)
		this.dsLayoutDetail.Setitem(lFound, "nancestor", lNewDetailKey)
		this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", lNewDetailKey)
		
		

Case TRAY, TRAYNONFOOD
	lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
	if lFound = 0  Then
		sError = "Error: Row/Column mismatch while moving"
		return -1
	End If
	
	lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
	this.dsLayoutDetail.Setitem(lFound, "ntype", iType)
	this.dsLayoutDetail.Setitem(lFound, "ncontent", lOldContent)
	this.dsLayoutDetail.Setitem(lFound, "nancestor", lNewDetailKey)
	
	
Case DRAWER_MULTI_RUNG
		
		lFoundPrev 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		// Ab 3: Nach oben und unten suchen
		if ll_Rungs > 2 and (lFoundPrev = 0 or lFound = 0 ) Then
			sError = "Error: Row/Column mismatch while moving"
			return -1
		End If

		// ab H$$HEX1$$f600$$ENDHEX$$he 2: eins nach unten
		if ll_Rungs > 1 and (lFound = 0 or lFoundNext = 0) Then
			sError = "Error: Row/Column mismatch while moving"
			return -1
		End If

		// H$$HEX1$$f600$$ENDHEX$$he 1: keine Pr$$HEX1$$fc00$$ENDHEX$$fung nach oben / unten
		if ll_Rungs =1 AND lFound = 0 Then
			sError = "Error: Row/Column mismatch while moving"
			return -1
		End If


		lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		this.dsLayoutDetail.Setitem(lFound, "ntype", iType)
		this.dsLayoutDetail.Setitem(lFound, "ncontent", lOldContent)
		
		this.dsLayoutDetail.Setitem(lFound, "ncontent", lOldContent)
		this.dsLayoutDetail.Setitem(lFound, "ncontent", lOldContent)
		
		li_Succ = this.dsLayoutDetail.Setitem(lFound, "nrungs", ll_Rungs)
		li_Succ = this.dsLayoutDetail.Setitem(lFound, "ncolumns", ll_Columns)

		// Order
		li_Succ = this.dsLayoutDetail.Setitem(lFound, "norder", ll_Order)
		
		
		//this.dsLayoutDetail.Setitem(lFoundPrev, "nancestor", lNewDetailKey)
		this.dsLayoutDetail.Setitem(lFound, "nancestor", lNewDetailKey)
		//this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", lNewDetailKey)
		
		If ll_Rungs > 2 Then
			ll_RungTo		= iNewRow + 1
			ll_Rung_From	= ll_RungTo - ll_Rungs + 1	

		ElseIf ll_Rungs = 1 Then
			ll_RungTo		= iNewRow 
			ll_Rung_From	= ll_RungTo 
		ElseIf ll_Rungs = 2 Then
			ll_RungTo		= iNewRow + 1
			ll_Rung_From	= ll_RungTo - ll_Rungs + 1	
		End If

		For ll_Check_Position_C = iNewColumn To iNewColumn + (ll_Columns - 1)
			// Spalte 
			For ll_Check_Position_R = ll_Rung_From To ll_RungTo	
				// H$$HEX1$$f600$$ENDHEX$$heneinheit 
				lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(ll_Check_Position_C) + " and nrow=" + string(ll_Check_Position_R), 1, this.dsLayoutDetail.Rowcount())
				If lFoundNext > 0 Then
					li_Succ = this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", lNewDetailKey)
					If lFoundNext <> lFound Then
						li_Succ = this.dsLayoutDetail.Setitem(lFoundNext, "ntype", BLOCKED)
					End If
				End If
			Next
		Next
		
		
end Choose

// --------------------------------------------------------------------------------
// 12.12.2008, KF: Zuordnungen umziehen
// --------------------------------------------------------------------------------
// Die Contents
this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(lOldDetailKey)) 
this.dsLayoutContents.Filter()

for i = 1 to this.dsLayoutContents.RowCount()
	this.dsLayoutContents.SetItem(i, "nlayout_detail_key", lNewDetailKey)
next

this.dsLayoutContents.SetFilter("") 
this.dsLayoutContents.Filter()

// Die MZV - Parameter
this.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(lOldDetailKey)) 
this.dsLayoutDimension.Filter()

for i = 1 to this.dsLayoutDimension.RowCount()
	this.dsLayoutDimension.SetItem(i, "nlayout_detail_key", lNewDetailKey)
next

this.dsLayoutDimension.SetFilter("") 
this.dsLayoutDimension.Filter()

this.dsLayoutDetail.SetFilter("") 
this.dsLayoutDetail.Filter()
this.dsLayoutDetail.Sort()

Choose Case iType
	Case DRAWER, DRAWERFOOD 
		this.of_draw_drawer(iNewRow, iNewColumn, iType, FALSE)
		
	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG 
		this.of_draw_drawer_3_rung(iNewRow, iNewColumn, iType, FALSE)
		
	Case TRAY, TRAYNONFOOD
		this.of_draw_tray(iNewRow, iNewColumn, iType, FALSE)
		
	Case DRAWER_MULTI_RUNG
		this.of_draw_drawer_multi_rung(iNewRow, iNewColumn, iType, ll_Rungs,  ll_columns, TRUE) 
		
end Choose

this.of_draw_content(iNewRow, iNewColumn, is_CSC)

this.iCurrentRow 		= iNewRow
this.iCurrentColumn 	= iNewColumn

return 0

end function

public function long of_log (string smessage);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_log (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 16.02.2010
* Argument(e):
* string smessage
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  ??			1.0           ??			     Erstellung
*
*************************************************************/
//----------------------------------------------------
// 
// Logging
//
//----------------------------------------------------
Long iFile
string  sPrefix


if iTrace <> 1 Then return 0

sPrefix = String(today(), "dd.mm.yyyy") + " " + string(now(), "hh:mm:ss") + " : " + this.isStowage +" - "
/*
if isnull(this.is_Logfile) or this.is_Logfile = "" Then
	return 0
End If

iFile = FileOpen( this.is_Logfile, LineMode!, Write!, Shared!)
FileWrite(iFile,  sPrefix + sMessage)
FileClose(iFile)
*/
guoLog.uf_allways("["+ this.classname( )+".of_log] " +  this.isStowage +" - " + sMessage)

return 0

end function

public function long of_remove_object (string sobject, long itype);// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_removw_object (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
// string sobject
//  Long itype
// --------------------------------------------------------------------------------
// Return: Long
// --------------------------------------------------------------------------------
//  Beschreibung:
//
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  12.12.2008	            Klaus F$$HEX1$$f600$$ENDHEX$$rster        Erstellung
//
// --------------------------------------------------------------------------------

Long lFound, lFoundContent, lContentLayoutKey
Long lRow, lNull
Long lSequence
String	sRet

Setnull(lNull)

this.dsLayoutAddObjects.SetFilter("")
this.dsLayoutAddObjects.Filter()

lFound = this.dsLayoutAddObjects.Find("cobject_name='" + sObject + "'", 1, dsLayoutAddObjects.RowCount())

if lFound > 0 Then		
	
	// --------------------------------------------------------------------------------------------------------
	// 07.05.2010, KF
	// Bei Freitextobjekten mit link zu Details$$HEX1$$e400$$ENDHEX$$tzen, den Link in cen_packinglist_detail entfernen
	// --------------------------------------------------------------------------------------------------------
	lContentLayoutKey = this.dsLayoutAddObjects.GetItemNumber(lFound, "nlayout_content_key")
	if  this.dsLayoutAddObjects.GetItemNumber(lFound, "nobject_type") = CONTENT_TEXT_OBJECT Then
		
		this.of_explode_content_remove_subs(sObject)
		
		lFoundContent = this.dsPLContents.Find("nlayout_content_key=" + string(lContentLayoutKey), 1, dsPLContents.RowCount())
		if lFoundContent <= 0 Then
			guoLog.uf_error("["+ this.classname( )+".of_remove_object] "  +  this.isStowage +" - " + "Error deleting text object " + sObject)
			//return -1
		Else
			this.dsPLContents.SetItem(lFoundContent, "nlayout_content_key", lNull)
		End If
	End If
	
	this.dsLayoutAddObjects.DeleteRow(lFound)
	of_modify_dw("Destroy " + sObject)	
End If

return 0
end function

public function long of_update ();/* 
* Funktion/Event: of_update
* Beschreibung: 	Speichern, werr h$$HEX1$$e400$$ENDHEX$$ts gedacht 
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		22.09.2008	Erstellung
*   1.1				U.Paudler	16.04.2009	Blobhandling ausgelagert
*   1.2				U.Paudler	03.09.2009	Backlog
*   1.3				U.Paudler	05.10.2009	Backlog nicht updaten
*   1.4				T.Schaefer	10.04.2014	Audit Cart Diagram Reset eingebaut
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
longlong lllAddKey
long		i
String 	sFile
Long		ll_Count, ll_Original_Sort
dwItemStatus l_status
Integer	li_Succ
Long		ll_sequence


// Layout
If dsLayout.RowCOunt() > 0 Then	
	If bHasDimensions Then
		li_Succ = this.dsLayout.SetItem(1, "ncomponentlist", 1)
	Else
		li_Succ = this.dsLayout.SetItem(1, "ncomponentlist", 0)
	End If
End If

if this.of_modified(this.dsLayout) > 0 Then
	if this.dsLayout.Update() <> 1 Then
		Rollback;
		this.sError = "Error: Save failed. dsLayout"
		return -1
	End If
End If

// Details
if this.of_modified(this.dsLayoutDetail ) > 0 Then
	if this.dsLayoutDetail.Update() <> 1 Then
		Rollback;
		this.sError = "Error: Save failed. dsLayoutDetail "
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_update dsLayoutDetail FAILED " + sError)			
		end if		
		return -1
	End If
End If


//dsLayoutContents.idebug=1

// Details der Details ;))
if this.of_modified(this.dsLayoutContents ) > 0 Then
	if this.dsLayoutContents.Update() <> 1 Then
		Rollback;
		this.sError = "Error: Save failed. this.dsLayoutContents "
		return -1
	End If
End If

//dsLayoutContents.idebug=0


// Details: Verteilungsparameter
if this.of_modified(this.dsLayoutDimension) > 0 Then
	if this.dsLayoutDimension.Update() <> 1 Then
		Rollback;
		this.sError = "Error: Save failed. dsLayoutDimension "
		return -1
	End If
End If

dsPLContents.idebug=1
// Details: Inhalte
// 06.10.2009 Ulrich Paudler [UP]
// Mit dem Constraint FK_CEN_PACKINGLIST_DETAIL11 funktioniert der Update beim l$$HEX1$$f600$$ENDHEX$$schen nicht
// -> Constraint deaktivieren/l$$HEX1$$f600$$ENDHEX$$schen
if this.of_modified(this.dsPLContents) > 0 Then
	
	For ll_Count = 1 To dsPLContents.RowCount()
		l_status = dsPLContents.GetItemStatus( ll_Count, "nsort", Primary!)
		If l_status = DataModified! then
			ll_Original_Sort = dsPLContents.GetItemNumber(ll_Count, "nsort", Primary!, TRUE)
			li_Succ = dsPLContents.SetItem(ll_Count, "nsort", ll_Original_Sort)
			li_Succ = dsPLContents.SetItemStatus(ll_Count, "nsort", Primary!, NotModified!	 )
		End if
		
	Next
	
	
	if this.dsPLContents.Update() <> 1 Then
		Rollback;
		this.sError = "Error: Save failed. this.dsPLContents"
		return -1
	End If
End If
dsPLContents.idebug=0

// Textobjecte, Bitmaps etc.
this.of_update_objects()
if this.of_modified(this.dsLayoutAddObjects) > 0 Then
	if this.dsLayoutAddObjects.Update() <> 1 Then
		
		Rollback;
		this.sError = "Error: Save failed. this.dsLayoutAddObjects "
		return -1
	Else // Die neuen Bilder noch speichern...
	
		for i = 1 to this.dsLayoutAddObjects.RowCount()
			if this.dsLayoutAddObjects.GetItemNumber(i, "nnew") =  1 Then
				lllAddKey	= this.dsLayoutAddObjects.GetItemNumber(i, "nadd_object_key")
				sFile 	= this.dsLayoutAddObjects.GetItemString(i, "cfullname")
				// 16.04.2009 Ulrich Paudler [UP]
				of_set_file_to_blob(lllAddKey, sFile)				
			End If
		next
		
	End If
End If

//f_print_datastore( this.dsLayoutAddObjects)

// TSC: wenn es ein Reset war und er getrackt werden soll, dann dies jetzt tun
IF il_audit_reset > -1 THEN
	ll_sequence = f_Sequence ("seq_sys_audit_item_list", sqlca)
	IF ll_Sequence = -1 THEN
		uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden", StopSign!)
		Rollback;
		this.sError = "Error: Save failed. seq_sys_audit_item_list"
		il_audit_reset = -1
		return -1
	ELSE
		INSERT INTO sys_audit_item_list (	naudit_item_list_key,
														naudit_type_key, 
														naudit_column_key, 
														cdb_action, 
														npackinglist_index_key, 
														npackinglist_detail_key, 
														nairline_key, 
														cunit, 
														caudit_message, 
														nupdated, 
														cupdated_by, 
														dupdated_date)
		VALUES (	:ll_sequence,
						1,
						:il_audit_reset,
						'D',
						:il_IndexKey, 
						:lDetailKey, 
						:il_AirlineKey, 
						:sUnit, 
						'Cart Diagram Reset', 
						1, 
						user, 
						sysdate);
		IF SQLCA.SQLCode < 0 THEN
			Rollback;
			this.sError = "Error: Save failed. (Insert into sys_audit_item_list for cart diagram reset)"
			il_audit_reset = -1
			return -1
		END IF
	END IF
	il_audit_reset = -1
END IF

commit;

return 1

end function

public function string of_get_error ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_error (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 16.04.2009
*
* Argument(e):	none
* Return: string
*
*
*
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*
*************************************************************/


return sError
end function

public function long of_remove_all ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_remove_all (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 17.04.2009
*
* Argument(e):	none
* Return: Long
*
*
* entfernt alle Objekte vom Typ Drawer und Tray
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*	1.1			U.Paudler  	19.11.2009		Drawer und Tray l$$HEX1$$f600$$ENDHEX$$schen
*	1.2			U.Paudler  	14.01.2010		Bilder und Texte entfernen
*  1.3			T.Schaefer	10.04.2014		Audit Cart Diagram Reset eingebaut
*************************************************************/

Long llLoopRow, i
Long llRow, llCol
Long iType, lFound
Integer	li_audit = 0;
String lsObject

// Rausfinden, was sich in der Position befindet (Drawer/Tray)
//do 
//	lFound 		= this.dsLayoutDetail.Find("ntype in (" + string(DRAWER) + ","+   string(DRAWER_3RUNG) + "," +  string(DRAWERFOOD_3RUNG) + "," + string(DRAWERFOOD) + ","+ string(TRAY) + ","+ string(TRAYNONFOOD) +  ","+ string(DRAWER_MULTI_RUNG) + ")", 1, this.dsLayoutDetail.Rowcount())
//	if lFound > 0 Then
//		for llLoopRow = 1 to this.dsLayoutDetail.Rowcount()
//		llCol 	= dsLayoutDetail.GetitemNumber(llLoopRow, "ncolumn")
//		llRow 		= dsLayoutDetail.GetitemNumber(llLoopRow, "nrow")
//		iType 		= dsLayoutDetail.Getitemnumber(llLoopRow, "ntype")
//		Choose Case iType
//			Case DRAWER, DRAWERFOOD, DRAWER_3RUNG, DRAWERFOOD_3RUNG, DRAWER_MULTI_RUNG
//				this.of_remove_drawer(llRow, llCol)
//			Case TRAY , TRAYNONFOOD
//				this.of_remove_tray(llRow, llCol)
//			Case Else 
//		end Choose
//	next
//	End If
//loop while lFound > 0


For i = 1 to  this.dsLayoutDetail.Rowcount()
	iType 		= dsLayoutDetail.Getitemnumber(i, "ntype")
	llCol 	= dsLayoutDetail.GetitemNumber(i, "ncolumn")
	llRow 		= dsLayoutDetail.GetitemNumber(i, "nrow")
	Choose Case iType
		Case DRAWER, DRAWERFOOD, DRAWER_3RUNG, DRAWERFOOD_3RUNG, DRAWER_MULTI_RUNG
			this.of_remove_drawer(llRow, llCol)
		Case TRAY , TRAYNONFOOD
			this.of_remove_tray(llRow, llCol)
		Case EMPTY, BLOCKED
			// Mach nix
		Case Else 
			//messagebox("", "Can't remove unknown type: " + string(iType))
	end Choose
Next

// -------------------------------------
// Reste auch weg (BLOCKED) - falls noch $$HEX1$$fc00$$ENDHEX$$brig
// -------------------------------------
For i = 1 to  this.dsLayoutDetail.Rowcount()
	iType 	= dsLayoutDetail.Getitemnumber(i, "ntype")
//	llCol 	= dsLayoutDetail.GetitemNumber(i, "ncolumn")
//	llRow 	= dsLayoutDetail.GetitemNumber(i, "nrow")
	If iType	= BLOCKED Then
		this.dsLayoutDetail.Setitem(i, "ntype", EMPTY)
	End If
Next

// 14.01.2010 Ulrich Paudler [UP]
// Alle anderen Objekte entfernen
this.dsLayoutAddObjects.SetFilter("")
this.dsLayoutAddObjects.Filter()

for llRow =this.dsLayoutAddObjects.Rowcount() to 1 step -1
	lsObject = this.dsLayoutAddObjects.getitemstring( llRow, "cobject_name")
	of_modify_dw("Destroy " + lsObject)	
	this.dsLayoutAddObjects.DeleteRow(llRow)
next

// Alle Verkn$$HEX1$$fc00$$ENDHEX$$pfungen der Details entfernen. 
Long lNull
SetNull(lNull)
for llRow = 1 to this.dsPLContents.Rowcount() 
	this.dsPLContents.SetItem(llRow, "nlayout_content_key", lNull)
next

// Verteilungsparameter l$$HEX1$$f600$$ENDHEX$$schen
this.dsLayoutDimension.SetFilter("")
this.dsLayoutDimension.Filter()
for llRow =this.dsLayoutDimension.Rowcount() to 1 step -1
	this.dsLayoutDimension.DeleteRow(llRow)
next

// TSC: falls cart diagram reset getrackt werden soll, dann dies hier merken, damit of_update am Ende tracken kann
SELECT nactive, naudit_column_key INTO :li_audit, :il_audit_reset FROM sys_audit_columns WHERE naudit_type_key = 1 AND ccolumn = '*Cart-Diagram-Reset*';
IF SQLCA.SQLCode = 100 THEN
	il_audit_reset = -1
ELSEIF SQLCA.SQLCode < 0 THEN
	il_audit_reset = -1
ELSE
	IF li_audit < 1 THEN il_audit_reset = -1
END IF

return 1

end function

public function long of_remove_content (long irow, long icolumn);// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_remove_content (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
// long llayoutdetailkey
// --------------------------------------------------------------------------------
// Return: Long
// --------------------------------------------------------------------------------
//  Beschreibung:
//  L$$HEX1$$f600$$ENDHEX$$schen der zugeordneten Inhalte eines Einschubs/Tabletts
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  04.12.2008	           Klaus F$$HEX1$$f600$$ENDHEX$$rster     Erstellung
//  17.04.2009		      U.Paudler		Filter zur$$HEX1$$fc00$$ENDHEX$$cksetzen, Postion als $$HEX1$$dc00$$ENDHEX$$bergabeparameter
//  03.09.2009			Ulrich Paudler	Backlog hinzugef$$HEX1$$fc00$$ENDHEX$$gt
//  08.02.2010			Ulrich Paudler	Formatierungen zur$$HEX1$$fc00$$ENDHEX$$cksetzen
//  23.05.2011            Funktionsvariante mit Boolean Parameter (Erzwinge Entfernen der Distribution Parms f$$HEX1$$fc00$$ENDHEX$$r Multirungs)
// --------------------------------------------------------------------------------


Return of_remove_content(irow, icolumn, FALSE)


end function

public function long of_remove_content ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_remove_content (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 17.04.2009
*
* Argument(e):	none
* Return: Long
*
*
*
* Entfernen des Contents an der aktuellen Stelle
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*
*************************************************************/


return of_remove_content(iCurrentRow, iCurrentColumn)
end function

public function long of_string2array (string sstring, string sseparator, ref string soutputarray[]);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_string2array (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 20.04.2009
*
* Argument(e):	string sstring
*	 string sseparator
*	 ref string soutputarray[]
* Return: long
*
*
*
* Erzeugt aus einem Separator getrennten String ein Array von Strings
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*
*************************************************************/
Long lPosEnd, lPosStart = 1, lSeparatorLen, lCounter = 1

IF UpperBound(sOutputArray) > 0 Then sOutputArray = {""}
lSeparatorLen = len(sSeparator)

lPosEnd = Pos (sString, sSeparator, 1)

DO WHILE lPosEnd > 0
     sOutputArray[lCounter] = Mid (sString, lPosStart, lPosEnd - lPosStart)
     lPosStart = lPosEnd + lSeparatorLen
     lPosEnd = Pos (sString, sSeparator, lPosStart)
     lCounter++
LOOP

sOutputArray[lCounter] = Right (sString, Len(sString) - lPosStart + 1)

RETURN lCounter
end function

public function long of_blob_save_bitmap (ref datawindow arg_dw);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_blob_save_bitmap (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 20.04.2009
*
* Argument(e):	blob arg_blob
* Return: Long
*
*
* Bitmaps im DW finden, Filename extrahieren, Bitmap aus DB laden und in Temp speichern
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
* ???
*************************************************************/
Long 	i
string 	lsObjects[]			
String lsFindResource, lsFindPicture, lsPathSeparator
long llPosStart=1, llPosEnd, llLengthPath
String lsFullPath, lsFilename
longlong lllAddKey

lsFindResource = "..\Resource\"
lsFindPicture  	= "p_"
lsPathSeparator="\"

// Alle Objekte in ein Array schreiben
of_string2array(arg_dw.describe("datawindow.objects"),"~t",lsObjects)


for i = 1 to UpperBound(lsObjects)
	// nur was wie ein Picture heist speichern
	if left(upper(lsObjects[i]),len(lsFindPicture)) <> upper(lsFindPicture) Then continue
	// Filenamen auslesen
	lsFullPath  = arg_dw.Describe(lsObjects[i] + ".filename")
	// War doch kein Picture 
	if lsFullPath = "!" Then continue
	// ist schon im Resourcefile
	if left(upper(lsFullPath),len(lsFindResource)) = upper(lsFindResource) Then continue
	
	llLengthPath = len(lsFullPath)
	if llLengthPath > 0 Then
		//kompletten Pfad ausschneiden
		lsFullPath = Mid(lsFullPath, 1, llLengthPath)
		// Position des Dateinamen ermitteln (nach letztem \)
		llPosEnd =  LastPos(lsFullPath, lsPathSeparator) + len(lsPathSeparator)
		// Dateiname ausschneiden
		lsFilename = Mid(lsFullPath, llPosEnd) 
		// Nun noch den Filenamen in der DB finden und das Blob in eine Datei Speichern
		select nadd_object_key
			into :lllAddKey
			from cen_pl_layout_add_obj
			where cvalue 	= :lsFilename;
		if sqlca.sqlcode <> 0 Then
			f_db_error(sqlca, "of_blob_save_bitmap()")
			return -1	
		End If
		// die gefundene Grafik in den Temppath schreiben
		if of_get_blob_to_file(lllAddKey, sTemppath, lsFilename) < 0 Then return -1
		// Jetzt noch den gerade Aktuellen Temp Pfad in das DW schreiben
		arg_dw.Modify(lsObjects[i] + ".filename='" + sTemppath + lsFilename + "' ")
		
	End If
next

return 0
end function

public function long of_delete_layout (long arg_indexkey, long arg_detailkey);/*************************************************************
	* Objekt : uo_cart_diagram
	* Methode: of_delete_layout (Function)
	* Autor  : Ulrich Paudler [UP]
	* Datum  : 22.04.2009
	*
	* Argument(e):	none
	* Return: Long
	*
	* L$$HEX1$$f600$$ENDHEX$$scht das Layout einer St$$HEX1$$fc00$$ENDHEX$$ckliste
	*
	*
	*
	*************************************************************
	* Modifikationen:
	* Datum    Version        Autor              Kommentar
	*------------------------------------------------------------
	*03.09.2009	1.1			Ulrich Paudler	Backlog
	*05.10.2009	1.2			Ulrich Paudler	Kein Backlog l$$HEX1$$f600$$ENDHEX$$schen, wird immer 'frisch' geladen
	*************************************************************/
Long	llRow, llLayoutKey,  llLayoutDetailKey
Long   llKey[] 

// Layout entfernen
dsLayout.retrieve(arg_indexkey, arg_detailkey)
if dsLayout.Rowcount() > 0 Then
	llLayoutKey = dsLayout.getitemnumber(1,"nlayout_key")
	// 03.09.2009 Ulrich Paudler [UP] Zeile 1 l$$HEX1$$f600$$ENDHEX$$schen, nicht 0
	//dsLayout.deleterow(llRow)
	dsLayout.deleterow(1)
Else
	return 0
End If

// 03.09.2009 Ulrich Paudler [UP] Backlog entfernen
//dsBacklog.retrieve(llLayoutKey)
//if dsBacklog.Rowcount() > 0 Then
//	dsBacklog.deleterow(1)
//End If

// LayoutDetails entfernen
dsLayoutDetail.retrieve(llLayoutKey)
for llRow = 1 to dsLayoutDetail.Rowcount()
	llLayoutDetailKey = dsLayoutDetail.getitemnumber(llRow,"nlayout_detail_key")
	dsLayoutDetail.deleterow(llRow)
	// LayoutContents entfernen
	llKey[1] = llLayoutDetailKey
	dsLayoutContents.retrieve(llKey)
	for llRow = 1 to dsLayoutContents.Rowcount()
		dsLayoutContents.deleterow(llRow)
	next
	// LayoutDimension entfernen
	llKey[1] = llLayoutDetailKey
	dsLayoutDimension.retrieve(llKey)
	dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey))
	dsLayoutDimension.Filter()
	for llRow = 1 to dsLayoutDimension.Rowcount()
		dsLayoutDimension.deleterow(llRow)
	next
next

// LayoutAddObjects entfernen
dsLayoutAddObjects.retrieve(llLayoutKey)
for llRow = 1 to dsLayoutAddObjects.Rowcount()
	dsLayoutAddObjects.deleterow(llRow)
next

////////////////////////////////////////////
// Speichern
if this.dsLayoutContents.Update() <> 1 Then
	rollback;
	return -1
Else
	if this.dsLayoutDimension.Update() <> 1 Then
		rollback;
		return -1
	Else
		if this.dsLayoutAddObjects.Update() <> 1 Then
			rollback;
			return -1
		Else
			if this.dsLayoutDetail.Update() <> 1 Then
				rollback;
				return -1
			Else
					if this.dsLayout.Update() <> 1 Then
						rollback;
						return -1
					Else
						//commit;
					End If
			End If
		End If
	End If
End If


return 1
end function

public function long of_copy_layout (s_cartdiagram arg_str_cartdiagram, long arg_oldllayoutkey, long arg_newllayoutkey, ref s_layout_detail_mapper arg_str_layout_mapper_rework[]);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_copy_layout (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 22.04.2009
*
* Argument(e):	none
* Return: Long
*
* Kopiert das Layout einer St$$HEX1$$fc00$$ENDHEX$$ckliste in ein neues Layout
*
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*03.09.2009	1.1			Ulrich Paudler	Backlog hinzugef$$HEX1$$fc00$$ENDHEX$$gt
*21.10.2009	1.2			Ulrich Paudler	Kein Backlog hier / norder mit kopieren
*19.01.2010	1.3			Ulrich Paudler	nlimit mit kopieren
*15.02.2010	1.4			Ulrich Paudler	Kopieren wieder eingeschaltet, Details der Objekte mit kopieren
*07.03.2011 	1.5         	Oliver H$$HEX1$$f600$$ENDHEX$$fer   Kopieren mit Drawer-Gr$$HEX2$$f600df00$$ENDHEX$$e (Multi Rung)
*07.06.2011 	1.6         	Oliver H$$HEX1$$f600$$ENDHEX$$fer   Kopieren f$$HEX1$$fc00$$ENDHEX$$r freischwebende Inhalte
*21.11.2012	1.7			T.Brackmann	2 x DateTime() f$$HEX1$$fc00$$ENDHEX$$r idt_Departure eingesetzt
*************************************************************/
LongLong lllSequence
Long 	llSequence, llRowCount, llColumnCount
Long	llNewRow, llRow, llColumn, llFoundRow, llCopyCount, llPos
Long  llLayoutDetailKey, llKey[]
String lsFile
Blob lbBlob
Long	ll_Count, ll_Original_Sort
Integer	li_Succ
dwitemstatus l_status
String	ls_Find
Long		ll_Rows
Long		ll_Original_Key, ll_New_Key, ll_Found
uo_cart_datastore	lds_New_Contents


lds_New_Contents = CREATE uo_cart_datastore
lds_New_Contents.DataObject = dsPLContents.DataObject
lds_New_Contents.SetTransObject(SQLCA)

s_layout_detail_mapper l_str_layout_mapper[]
s_layout_objects_mapper str_objects_mapper[]


// 15.02.2010 Ulrich Paudler [UP]
//IF arg_newllayoutkey > 0  Then return -1

uo_cart_datastore dsCopyFromLayoutDetail
uo_cart_datastore dsCopyFromLayoutContents
uo_cart_datastore dsCopyFromLayoutDimension
uo_cart_datastore dsCopyFromLayoutAddObjects
uo_cart_datastore dsCopyFromPLContents


dsCopyFromLayoutDetail = create uo_cart_datastore
//dsCopyFromLayoutDetail.sLogfile = this.is_Logfile
dsCopyFromLayoutDetail.of_set_log_file(this.is_Logfile)
dsCopyFromLayoutDetail.Dataobject = "dw_uo_packinglist_layout_detail"
dsCopyFromLayoutDetail.Settransobject(sqlca)

dsCopyFromLayoutContents = create uo_cart_datastore
//dsCopyFromLayoutContents.sLogfile = this.is_Logfile
dsCopyFromLayoutContents.of_set_log_file( this.is_Logfile)
dsCopyFromLayoutContents.Dataobject = "dw_uo_packinglist_layout_contents"
dsCopyFromLayoutContents.Settransobject(sqlca)

dsCopyFromLayoutDimension = create uo_cart_datastore
//dsCopyFromLayoutDimension.sLogfile = this.is_Logfile
dsCopyFromLayoutDimension.of_set_log_file( this.is_Logfile)
dsCopyFromLayoutDimension.Dataobject = "dw_uo_packinglist_layout_dimensions"
dsCopyFromLayoutDimension.Settransobject(sqlca)


dsCopyFromLayoutAddObjects = create uo_cart_datastore
//dsCopyFromLayoutAddObjects.sLogfile = this.is_Logfile
dsCopyFromLayoutAddObjects.of_set_log_file (this.is_Logfile)
dsCopyFromLayoutAddObjects.Dataobject = "dw_uo_packinglist_layout_add_objects"
dsCopyFromLayoutAddObjects.Settransobject(sqlca)

dsCopyFromPLContents = create uo_cart_datastore
//dsCopyFromPLContents.sLogfile = this.is_Logfile
dsCopyFromPLContents.of_set_log_file( this.is_Logfile)
dsCopyFromPLContents.Dataobject = "dw_uo_packinglist_detail"
dsCopyFromPLContents.Settransobject(sqlca)

il_IndexKey	= arg_str_cartdiagram.lIndex_Key_new
lDetailKey	= arg_str_cartdiagram.lDetail_Key_new
il_AirlineKey	= arg_str_cartdiagram.lAirline_Key
sUnit			= arg_str_cartdiagram.sUnit

// Soll der Satz neu angelegt werden
if arg_newllayoutkey = 0 Then
	this.lLayoutKey = f_sequence("seq_cen_packinglist_layout", sqlca)
	if this.lLayoutKey  = -1 Then
		sError = "Error: Sequence seq_cen_packinglist_layout failed"
		return -1
	End If
	// Header Eintr$$HEX1$$e400$$ENDHEX$$ge
	llNewRow = this.dsLayout.InsertRow(0)
	this.dsLayout.SetItem(llNewRow, "nlayout_key", this.lLayoutKey)
	this.dsLayout.SetItem(llNewRow, "npackinglist_index_key", this.il_IndexKey)
	this.dsLayout.SetItem(llNewRow, "npackinglist_detail_key", this.lDetailKey)
	this.dsLayout.SetItem(llNewRow, "nequipment_key", this.dsAirlineEq.GetItemNumber(1, "nequipment_key"))

Else
	// Dr$$HEX1$$fc00$$ENDHEX$$berkopieren $$HEX1$$fc00$$ENDHEX$$ber bestehenden Satz
	this.lLayoutKey  = arg_newllayoutkey
End If

// Detail Eintr$$HEX1$$e400$$ENDHEX$$ge Konfiguration
llRowCount 					= this.dsAirlineEq.GetItemNumber(1, "nrows")
llColumnCount 				= this.dsAirlineEq.GetItemNumber(1, "ncolumns")
isContainerShortName 	= this.dsAirlineEq.GetItemString(1, "cunit")
ilContainerType 			= this.dsAirlineEq.GetItemNumber(1, "ntype")

// LayoutDetails kopieren
dsCopyFromLayoutDetail.retrieve(arg_oldllayoutkey)
For llColumn = 0 to llColumnCount // 0 = Eiseinschub
	for llRow = 1 to llRowCount
		llLayoutDetailKey = f_sequence("seq_cen_pl_layout_detail", sqlca)
		if llLayoutDetailKey = -1 Then
			sError = "Error: Sequence seq_cen_pl_layout_detail failed"
			return -1
		End If
		llNewRow = this.dsLayoutDetail.InsertRow(0)
		this.dsLayoutDetail.SetItem(llNewRow, "nlayout_detail_key", llLayoutDetailKey)
		this.dsLayoutDetail.SetItem(llNewRow, "nlayout_key", this.lLayoutKey)
		this.dsLayoutDetail.SetItem(llNewRow, "ncolumn", llColumn)
		this.dsLayoutDetail.SetItem(llNewRow, "nrow", llRow)
		// Alten Eintrag finden und ggf. kopieren
		llFoundRow = dsCopyFromLayoutDetail.find( "ncolumn=" + String(llColumn)+ " AND nrow=" + String(llRow) + " AND ntype > 0", 1,dsCopyFromLayoutDetail.Rowcount())
		if llFoundRow > 0 Then
			// nur die gef$$HEX1$$fc00$$ENDHEX$$llten kopieren und merken
			this.dsLayoutDetail.SetItem(llNewRow, "ntype", dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"ntype"))
			this.dsLayoutDetail.SetItem(llNewRow, "ncontent", dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"ncontent"))

			
			// weitere Felder
			this.dsLayoutDetail.SetItem(llNewRow, "nrungs", dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"nrungs"))
			this.dsLayoutDetail.SetItem(llNewRow, "ncolumns", dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"ncolumns"))

			
			// 21.10.2009 Ulrich Paudler [UP]
			this.dsLayoutDetail.SetItem(llNewRow, "norder", dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"norder"))
			llCopyCount = UpperBound(l_str_layout_mapper) + 1
			l_str_layout_mapper[llCopyCount].loldcontentkey 			=  dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"ncontent")
			l_str_layout_mapper[llCopyCount].loldlayoutdetailkey 	=  dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"nlayout_detail_key")
			l_str_layout_mapper[llCopyCount].loldlayoutkey 			=  dsCopyFromLayoutDetail.getitemnumber(llFoundRow,"nlayout_key")
			l_str_layout_mapper[llCopyCount].lnewlayoutdetailkey 	=  llLayoutDetailKey
			l_str_layout_mapper[llCopyCount].lnewlayoutkey 			=  this.lLayoutKey
		Else
			this.dsLayoutDetail.SetItem(llNewRow, "ntype",EMPTY)
			// 21.10.2009 Ulrich Paudler [UP]
			this.dsLayoutDetail.SetItem(llNewRow, "norder", 0)
		End If
	next
Next


// LayoutDimension kopieren
for llPos = 1 to upperbound(l_str_layout_mapper)
	llKey[1] = l_str_layout_mapper[llPos].loldlayoutdetailkey
	dsCopyFromLayoutDimension.retrieve(llKey)
	// jaja ist verr$$HEX1$$fc00$$ENDHEX$$ckt, die where Bedingung l$$HEX1$$e400$$ENDHEX$$sst aber zu viele Treffer zu...
	dsCopyFromLayoutDimension.SetFilter("nlayout_detail_key=" + string(l_str_layout_mapper[llPos].loldlayoutdetailkey))
	dsCopyFromLayoutDimension.Filter()
	for llRow = 1 to dsCopyFromLayoutDimension.RowCount()
		llSequence = f_sequence("seq_cen_object_equipment", sqlca)
		if llSequence = -1 Then
			sError = "Error: Sequence seq_cen_object_equipment failed"
			return -1
		End If
		llNewRow = this.dsLayoutDimension.InsertRow(0)
		this.dsLayoutDimension.setitem(llNewRow,"nlayout_dim_key",llSequence)
		this.dsLayoutDimension.setitem(llNewRow,"nlayout_detail_key",l_str_layout_mapper[llPos].lnewlayoutdetailkey)
		this.dsLayoutDimension.setitem(llNewRow,"npltype_key",dsCopyFromLayoutDimension.getitemnumber(llRow,"npltype_key"))
		this.dsLayoutDimension.setitem(llNewRow,"cmeal_control_code",dsCopyFromLayoutDimension.getitemstring(llRow,"cmeal_control_code"))
		this.dsLayoutDimension.setitem(llNewRow,"nspml",dsCopyFromLayoutDimension.getitemnumber(llRow,"nspml"))
		this.dsLayoutDimension.setitem(llNewRow,"norder",dsCopyFromLayoutDimension.getitemnumber(llRow,"norder"))
		this.dsLayoutDimension.setitem(llNewRow,"cclass",dsCopyFromLayoutDimension.getitemstring(llRow,"cclass"))
		// 19.01.2010 Ulrich Paudler [UP]
		this.dsLayoutDimension.setitem(llNewRow,"nlimit",dsCopyFromLayoutDimension.getitemnumber(llRow,"nlimit"))
	next
next
dsCopyFromLayoutDimension.SetFilter("")
dsCopyFromLayoutDimension.Filter()


// LayoutAddObjects kopieren - Bitmap BLOB wird separat aktualisiert
dsCopyFromLayoutAddObjects.retrieve(arg_oldllayoutkey)
for llRow = 1 to dsCopyFromLayoutAddObjects.Rowcount()
	// --------------------------------------------------------------------------------------------------------------------
	// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
	// --------------------------------------------------------------------------------------------------------------------
	lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)
	if lllSequence = -1 Then
		sError = "Error: Sequence seq_cen_pl_layout_add_obj failed"
		return -1
	End If
	llNewRow = this.dsLayoutAddObjects.InsertRow(0)
	this.dsLayoutAddObjects.setitem(llNewRow,"nadd_object_key", lllSequence)
	this.dsLayoutAddObjects.setitem(llNewRow,"nlayout_key", this.lLayoutKey)
	this.dsLayoutAddObjects.setitem(llNewRow,"nobject_type", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nobject_type"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nheight", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nheight"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nwidth", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nwidth"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nxpos", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nxpos"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nypos", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nypos"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nborderstyle", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nborderstyle"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nbackgroundmode", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nbackgroundmode"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nbackgroundcolor", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nbackgroundcolor"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nbrushcolor", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nbrushcolor"))
	this.dsLayoutAddObjects.setitem(llNewRow,"npencolor", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"npencolor"))
	this.dsLayoutAddObjects.setitem(llNewRow,"npenwidth", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"npenwidth"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nbrushhatch", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nbrushhatch"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nresizeable", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nresizeable"))
	this.dsLayoutAddObjects.setitem(llNewRow,"nmoveable", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nmoveable"))
	
	Choose Case dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nobject_type")
		

		CASE RECTANGLEOBJECT
			this.dsLayoutAddObjects.setitem(llNewRow,"cobject_name", "r_rect_" + string(llNewRow) + "_" + string(now(), "hhmmss"))
			
		Case TEXTOBJECT // textreferenzen umziehen
			this.dsLayoutAddObjects.setitem(llNewRow,"cobject_name", "t_text_" + string(llNewRow) + "_" + string(now(), "hhmmss"))
			this.dsLayoutAddObjects.setitem(llNewRow,"cvalue", dsCopyFromLayoutAddObjects.getitemstring(llRow,"cvalue"))
			this.dsLayoutAddObjects.setitem(llNewRow,"ntextalign", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"ntextalign"))
			this.dsLayoutAddObjects.setitem(llNewRow,"cfontname", dsCopyFromLayoutAddObjects.getitemstring(llRow,"cfontname"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontitalic", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontitalic"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontunderline", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontunderline"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontcolor", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontcolor"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontweight", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontweight"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontsize", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontsize"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nlayer", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nlayer"))
		
		Case BITMAPOBJECT // bildreferenzen umziehen
			this.dsLayoutAddObjects.setitem(llNewRow,"cobject_name", "p_picture_" + string(llNewRow) + "_" +string(now(), "hhmmss"))
			// filenamen $$HEX1$$e400$$ENDHEX$$ndern
			lsFile = dsCopyFromLayoutAddObjects.getitemstring(llRow,"cvalue")
			lsFile = of_generate_filename("p_", Mid(lsFile, lastpos(lsFile,".") + 1))
			this.dsLayoutAddObjects.setitem(llNewRow,"cvalue", lsFile)
			// Daten zum sp$$HEX1$$e400$$ENDHEX$$teren kopieren des Blobs merken
			llCopyCount = upperbound(str_objects_mapper) + 1
			str_objects_mapper[llCopyCount].loldobjectkey = dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nadd_object_key")
			str_objects_mapper[llCopyCount].lnewobjectkey = lllSequence
			// 15.02.2010 Ulrich Paudler [UP]
		
		Case CONTENTOBJECT, FLOATCONTENTOBJECT
			this.dsLayoutAddObjects.setitem(llNewRow,"cobject_name", dsCopyFromLayoutAddObjects.getitemstring(llRow,"cobject_name"))
			this.dsLayoutAddObjects.setitem(llNewRow,"cvalue", dsCopyFromLayoutAddObjects.getitemstring(llRow,"cvalue"))
			this.dsLayoutAddObjects.setitem(llNewRow,"ntextalign", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"ntextalign"))
			this.dsLayoutAddObjects.setitem(llNewRow,"cfontname", dsCopyFromLayoutAddObjects.getitemstring(llRow,"cfontname"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontitalic", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontitalic"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontunderline", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontunderline"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontcolor", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontcolor"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontweight", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontweight"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontsize", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontsize"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nlayer", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nlayer"))

		CASE CONTENT_TEXT_OBJECT
			//sTName = "t_freetext_content_" + string(a) + "_" + string(now(), "hhmmss")
			this.dsLayoutAddObjects.setitem(llNewRow,"cobject_name", "t_freetext_content_" + string(llNewRow) + "_" + string(now(), "hhmmss"))
			
			this.dsLayoutAddObjects.setitem(llNewRow,"cvalue", dsCopyFromLayoutAddObjects.getitemstring(llRow,"cvalue"))
			this.dsLayoutAddObjects.setitem(llNewRow,"ntextalign", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"ntextalign"))
			this.dsLayoutAddObjects.setitem(llNewRow,"cfontname", dsCopyFromLayoutAddObjects.getitemstring(llRow,"cfontname"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontitalic", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontitalic"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontunderline", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontunderline"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontcolor", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontcolor"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontweight", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontweight"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nfontsize", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nfontsize"))
			this.dsLayoutAddObjects.setitem(llNewRow,"nlayer", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nlayer"))
			// Der Key muss angepasst werden
			//this.dsLayoutAddObjects.setitem(llNewRow,"nlayout_content_key", dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nlayout_content_key"))
			
			ll_Original_Key = dsCopyFromLayoutAddObjects.getitemnumber(llRow,"nlayout_content_key")
			ll_New_Key = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)
			If ll_New_Key > 0 Then
				this.dsLayoutAddObjects.setitem(llNewRow,"nlayout_content_key",ll_New_Key)
				ll_Found = dsPLContents.Find("nlayout_content_key=" + String(ll_Original_Key), 1, dsPLContents.Rowcount())
				If ll_Found > 0 Then
					ll_Rows = lds_New_Contents.Retrieve(il_IndexKey, lDetailKey, DateTime(this.idt_Departure))  // TBR 21.11.2012
					//ll_Found = lds_New_Contents.Find("nlayout_content_key=" + String(ll_Original_Key), 1, dsPLContents.Rowcount())
					//ls_Find = "npackinglist_index_key=" + String(dsPLContents.GetitemNumber(ll_Found, "npackinglist_index_key"))
					//ls_Find += " AND npackinglist_detail_key=" + String(dsPLContents.GetitemNumber(ll_Found, "npackinglist_detail_key"))
					ls_Find = "ndetail_key=" + String(dsPLContents.GetitemNumber(ll_Found, "ndetail_key"))
					ls_Find += " AND nsort=" + String(dsPLContents.GetitemNumber(ll_Found, "nsort"))
					//"nlayout_content_key=" + String(ll_Original_Key)
					ll_Found = lds_New_Contents.Find(ls_Find, 1, dsPLContents.Rowcount())
					If ll_Found > 0 Then
						li_Succ = lds_New_Contents.SetItem(ll_Found, "nlayout_content_key", ll_New_Key)
						li_Succ = lds_New_Contents.update()
					End If
				End If
			End If

	end Choose
next

// Remapping Nacharbeit von PackinglistsContent f$$HEX1$$fc00$$ENDHEX$$llen
dsCopyFromPLContents.retrieve(arg_str_cartdiagram.lindex_key, arg_str_cartdiagram.ldetail_key, DateTime(this.idt_Departure)) // TBR 21.11.2012
for llRow = 1 to upperbound(l_str_layout_mapper)
	if not isnull(l_str_layout_mapper[llRow].loldcontentkey) Then
		llFoundRow = dsCopyFromPLContents.Find("nlayout_content_key=" + String(l_str_layout_mapper[llRow].loldcontentkey), 1, dsCopyFromPLContents.Rowcount())
		if llFoundRow > 0 Then
			l_str_layout_mapper[llRow].loldcontentkey		= dsCopyFromPLContents.getitemnumber(llFoundRow,"nlayout_content_key")
		End If
	End If
next

// Merken f$$HEX1$$fc00$$ENDHEX$$r die Nacharbeit von PackinglistsContents (of_copy_layout_rework)
// Nacharbeit ist notwendig da dw_2 zuerst gespeichert werden muss, anschliessend k$$HEX1$$f600$$ENDHEX$$nnen Referenzen angepasst werden
for llRow = 1 to upperbound(l_str_layout_mapper)
	arg_str_layout_mapper_rework[llRow].lnewcontentkey 		= l_str_layout_mapper[llRow].lnewcontentkey
	arg_str_layout_mapper_rework[llRow].lnewdetailkey 		= l_str_layout_mapper[llRow].lnewdetailkey
	arg_str_layout_mapper_rework[llRow].lnewlayoutdetailkey 	= l_str_layout_mapper[llRow].lnewlayoutdetailkey
	arg_str_layout_mapper_rework[llRow].lnewlayoutkey 		= l_str_layout_mapper[llRow].lnewlayoutkey
	arg_str_layout_mapper_rework[llRow].loldcontentkey 		= l_str_layout_mapper[llRow].loldcontentkey
	arg_str_layout_mapper_rework[llRow].lolddetailkey 			= l_str_layout_mapper[llRow].lolddetailkey
	arg_str_layout_mapper_rework[llRow].loldlayoutdetailkey 	= l_str_layout_mapper[llRow].loldlayoutdetailkey
	arg_str_layout_mapper_rework[llRow].loldlayoutkey 			= l_str_layout_mapper[llRow].loldlayoutkey
next

////////////////////////////////////////////
// Speichern
if this.dsLayout.Update() <> 1 Then
	rollback;
	return -1
Else
	if this.dsLayoutDetail.Update() <> 1 Then
		rollback;
		return -1
	Else
		
		For ll_Count = 1 To dsPLContents.RowCount()
			l_status = dsPLContents.GetItemStatus( ll_Count, "nsort", Primary!)
			If l_status = DataModified! then
				ll_Original_Sort = dsPLContents.GetItemNumber(ll_Count, "nsort", Primary!, TRUE)
				li_Succ = dsPLContents.SetItem(ll_Count, "nsort", ll_Original_Sort)
				li_Succ = dsPLContents.SetItemStatus(ll_Count, "nsort", Primary!, NotModified!	 )
			End if
		Next
	
		if this.dsPLContents.Update() <> 1 Then
			rollback;
			return -1
		Else
			if this.dsLayoutAddObjects.Update() <> 1 Then
				rollback;
				return -1
			Else
				if this.dsLayoutDimension.Update() <> 1 Then
					rollback;
					return -1
				Else
					if this.dsLayoutContents.Update() <> 1 Then
						rollback;
						return -1 
					Else
						commit;
					End If
				End If
			End If
		End If
	End If
End If

// Nachbearbeitung LayoutAddObjects  Bitmap Blobhandling
for llCopyCount = 1 to upperbound(str_objects_mapper)
	// Blob mit alter Referenz holen
	SELECTBLOB bbitmap
	INTO :lbBlob
	FROM cen_pl_layout_add_obj
	WHERE nadd_object_key = :str_objects_mapper[llCopyCount].loldobjectkey;
	if SQLCA.SQLCode= 0 Then
		// Blob unter neuer Referenz speichern
		UPDATEBLOB cen_pl_layout_add_obj
		SET bbitmap = :lbBlob
		WHERE nadd_object_key = :str_objects_mapper[llCopyCount].lnewobjectkey;
		if SQLCA.SQLCode= 0 Then
			COMMIT;
		End If
	End If
	SetNull(lbBlob)
next

destroy dsCopyFromLayoutDetail
destroy dsCopyFromLayoutContents
destroy dsCopyFromLayoutDimension
destroy dsCopyFromLayoutAddObjects
destroy dsCopyFromPLContents
DESTROY	lds_New_Contents

return 1
end function

public function long of_copy_layout_rework (s_cartdiagram arg_str_cartdiagram_rework, ref s_layout_detail_mapper arg_str_layout_mapper_rework[]);/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_copy_layout_rework (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.04.2009
*
* Argument(e):	
* Return: Long
*
* Achtung: Leider etwas unsauber gel$$HEX1$$f600$$ENDHEX$$st, besser w$$HEX1$$e400$$ENDHEX$$re ein totaler Umbau
* von uo_cart_diagram gewesen (dw_share mit w_packinglist_master)
*
* Nacharbeiten an der cen_packinglist_detail, remapping der contents
* Methode muss nach dem Speichern des dw_2 in w_packinglist_master aufgerufen werden (aktuell: ue_masterupdate)
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
*
* 23.05.2011   1.1        	Oliver Hoefer   Header Flag
* 07.06.2011   1.2        	Oliver Hoefer   bei der Zuordnung ALT => NEU nicht nur auf nSort verlassen
* 21.11.2012	1.3		T.Brackmann	DateTime() f$$HEX1$$fc00$$ENDHEX$$r idt_Departure eingesetzt
* 04.11.2013   1.4        	Oliver Hoefer   Content Copy auch wenn kein verkn$$HEX1$$fc00$$ENDHEX$$pfter Content
************************************************************************************************/
Long	llPos, llRow, llNewRow, llFindRow, llKey[] ,llFindRowTarget
long llContentKey, llSequenz,llSort
Integer		li_Succ
Long	ll_Header_Flag
Long	ll_Count, ll_original_Sort
Long		ll_Content_index_Key, ll_Content_Target_Index_Key
Long		ll_Target_Sort
dwitemstatus l_status
uo_cart_datastore dsCopyFromPLContents
uo_cart_datastore dsCopyFromLayoutContents


dsCopyFromPLContents = create uo_cart_datastore
//dsCopyFromPLContents.sLogfile = this.is_Logfile
dsCopyFromPLContents.of_set_log_file(  this.is_Logfile)
dsCopyFromPLContents.Dataobject = "dw_uo_packinglist_detail"
dsCopyFromPLContents.Settransobject(sqlca)

dsCopyFromLayoutContents = create uo_cart_datastore 
//dsCopyFromLayoutContents.sLogfile = this.is_Logfile
dsCopyFromLayoutContents.of_set_log_file( this.is_Logfile)
dsCopyFromLayoutContents.Dataobject = "dw_uo_packinglist_layout_contents"
dsCopyFromLayoutContents.Settransobject(sqlca)

// eventuelle Filter zur$$HEX1$$fc00$$ENDHEX$$cksetzen
this.dsLayoutContents.setFilter("")
this.dsLayoutContents.Filter()
this.dsPLContents.setFilter("")
this.dsPLContents.Filter()

// PackinglistsContents laden
dsCopyFromPLContents.retrieve(arg_str_cartdiagram_rework.lindex_key, arg_str_cartdiagram_rework.ldetail_key, DateTime(this.idt_Departure)) // TBR 21.11.2012
// --------------------------------------------------------------
// Display of items on status $$HEX1$$1c20$$ENDHEX$$Billing$$HEX4$$1d20200020002000$$ENDHEX$$added 08/18/2010
// Items that are on status billing in any drawer should 
// not be displayed in the cart diagram.
// --------------------------------------------------------------
If ib_discard_status_billing Then
	li_Succ = of_remove_contents_billing(dsCopyFromPLContents)
End If

this.dsPLContents.retrieve(arg_str_cartdiagram_rework.lindex_key_new, arg_str_cartdiagram_rework.ldetail_key_new, DateTime(this.idt_Departure)) // TBR 23.11.2012
// --------------------------------------------------------------
// Display of items on status $$HEX1$$1c20$$ENDHEX$$Billing$$HEX4$$1d20200020002000$$ENDHEX$$added 08/18/2010
// Items that are on status billing in any drawer should 
// not be displayed in the cart diagram.
// --------------------------------------------------------------
If ib_discard_status_billing Then
	li_Succ = of_remove_contents_billing(dsPLContents)
End If

// alle gemerkten Positionen durchlaufen
for llPos = 1 to upperbound(arg_str_layout_mapper_rework)
	llFindRow = 0
	llKey[1] = arg_str_layout_mapper_rework[llPos].loldlayoutdetailkey
	// Ursprungslayout laden
	dsCopyFromLayoutContents.retrieve(llKey)
	for llRow = 1 to dsCopyFromLayoutContents.RowCount()
		llContentKey = dsCopyFromLayoutContents.getitemnumber(llRow,"nlayout_content_key")
		
		ll_Header_Flag = dsCopyFromLayoutContents.getitemnumber(llRow,"nHeader_Flag")
		// Ursprungsreferenz finden
		llFindRow  = dsCopyFromPLContents.Find("nlayout_content_key=" + string(llContentKey) ,1,dsCopyFromPLContents.Rowcount())
		if llFindRow > 0 Then
//			// nsort ist der Aufh$$HEX1$$e400$$ENDHEX$$nger, diesen nur noch in den neuen Datens$$HEX1$$e400$$ENDHEX$$tzen finden
//			// (ndetailkey kann nicht verwendet werden, er ist nicht eindeutig!)
//			 llSort=dsCopyFromPLContents.getitemnumber(llFindRow,"nsort")
//			 llFindRowTarget = this.dsPLContents.Find("nsort=" + string(llSort) ,1,this.dsPLContents.Rowcount())
			 llSort=dsCopyFromPLContents.getitemnumber(llFindRow,"nsort")
		 
			 ll_Content_Index_Key = dsCopyFromPLContents.getitemnumber(llFindRow,"ndetail_key")
			 ll_Content_Target_Index_Key = 0
			 ll_Target_Sort = 0
			 If dsPLContents.rowcount() >= llFindRow Then
			 	ll_Content_Target_Index_Key = dsPLContents.getitemnumber(llFindRow,"ndetail_key") 
				ll_Target_Sort = dsPLContents.GetItemNumber(llFindRow, "nsort")
			End if
			 
			 // Am besten: Key und Sort stimmen in der gleichen Row $$HEX1$$fc00$$ENDHEX$$berein
			If ll_Content_Index_Key = ll_Content_Target_Index_Key AND llSort = ll_Target_Sort Then
				llFindRowTarget = llFindRow
			Else
				// gleiche St$$HEX1$$fc00$$ENDHEX$$ckliste an gleicher Position - auch noch OK
				If ll_Content_Index_Key = ll_Content_Target_Index_Key Then
					llFindRowTarget = llFindRow
				Else
					// Pr$$HEX1$$fc00$$ENDHEX$$fe Sort (alte Methode)
					llFindRowTarget = this.dsPLContents.Find("nsort=" + string(llSort), 1, this.dsPLContents.Rowcount())
				End If
			End If
			
//			if llFindRowTarget < 1 Then
//				// nsort passt nicht
//			End If
//			
			if llFindRowTarget > 0 Then
				// nun nur noch die neue Referenz in cen_pl_layout_contents Anlegen
				llSequenz = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)
				if llSequenz = -1 Then
					sError = "Error: Sequence SEQ_CEN_PL_LAYOUT_CONTENTS failed"
				End If
				// Anegen der Contents
				llNewRow = this.dsLayoutContents.InsertRow(0)		
				this.dsLayoutContents.setitem(llNewRow,"nlayout_content_key", llSequenz)
				this.dsLayoutContents.setitem(llNewRow,"nlayout_detail_key", arg_str_layout_mapper_rework[llPos].lnewlayoutdetailkey)	
				
				// Header Flag
				this.dsLayoutContents.setitem(llNewRow,"nHeader_Flag", ll_Header_Flag)
				
				// Mapping der neuen Referenz
				this.dsPLContents.setitem(llFindRowTarget,"nlayout_content_key", llSequenz)			
			 End If
			 
		else
			// ------------------------------------------------------
			// 04.11.2013: kein Content trotzdem Satz anlegen
			// ------------------------------------------------------
			llSequenz = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)
			if llSequenz = -1 Then
				sError = "Error: Sequence SEQ_CEN_PL_LAYOUT_CONTENTS failed"
			End If
			// Anegen der Contents
			llNewRow = this.dsLayoutContents.InsertRow(0)		
			this.dsLayoutContents.setitem(llNewRow,"nlayout_content_key", llSequenz)
			this.dsLayoutContents.setitem(llNewRow,"nlayout_detail_key", arg_str_layout_mapper_rework[llPos].lnewlayoutdetailkey)	
			this.dsLayoutContents.setitem(llNewRow,"nHeader_Flag", 0)
		  		 
		End If
	next
next

destroy dsCopyFromPLContents
destroy dsCopyFromLayoutContents
	
////////////////////////////////////////////
// Speichern
if this.dsLayoutContents.Update() <> 1 Then
	rollback;
	return -1
Else
	
	For ll_Count = 1 To dsPLContents.RowCount()
		l_status = dsPLContents.GetItemStatus( ll_Count, "nsort", Primary!)
		If l_status = DataModified! then
			ll_Original_Sort = dsPLContents.GetItemNumber(ll_Count, "nsort", Primary!, TRUE)
			li_Succ = dsPLContents.SetItem(ll_Count, "nsort", ll_Original_Sort)
			li_Succ = dsPLContents.SetItemStatus(ll_Count, "nsort", Primary!, NotModified!	 )
		End if
	Next
	
	if this.dsPLContents.Update() <> 1 Then
		rollback;
		return -1
	Else
		commit;
	End If
End If


return 1


end function

public function string of_generate_filename (string arg_prefix, string arg_suffix);/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_generate_filename (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.04.2009
*
* Argument(e):	string arg_suffix
* Return: string
*
*
* der Name der Dateil wird mit einer Zufallszahl ermittelt.
* Die Aufl$$HEX1$$f600$$ENDHEX$$sung von CPU() (Millisekunden) war an dieser Stelle nicht eindeutig, zumindest auf meinen Notebook
*
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
*
************************************************************************************************/
string lsName

lsName = arg_prefix + string(Rand(1000000)) + "_" + string(today(), "yyyymmmdd") + String(now(), "hhmmss") + "." + arg_suffix

Return lsName
end function

public function long of_copy_object (long inewrow, long inewcolumn, long ioldrow, long ioldcolumn);/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_copy_object (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 26.05.2009
*
* Argument(e):	Long inewrow
*	 Long inewcolumn
*	 Long ioldrow
*	 Long ioldcolumn
* Return: Long
*
*
*
*
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
*
************************************************************************************************/

// --------------------------------------------------------------------------------
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.1 			O.Hoefer	01.09.2017		Issue #2835 Copy Food Drawer, Non Food Tray enabled 
//
//
// Return: long
//
// --------------------------------------------------------------------------------


Long		lFound,  lFoundNext, lOldLayoutDetailKey
Long	 	iType, iTypeNext, iContent, iTypeNew, iTypeNewNext, lFoundPrev, iTypePrev, iTypeCurrent
Long 		lSequence, llRetVal, llNull
String	sMod, sFilter, sText
Long I
datastore dsTemp
string sObject, sRet
Long	lOldDetailKey
Long	lNewDetailKey
Long	lOldContent
Long	lNewContent
Long	llCount
Long 	iTypeNew_2
Integer	 li_Check
Long	ll_Height, ll_Width, ll_Counter_V, ll_Counter_H, ll_Check

// Die Position(en) im Trolley muss als geblockt markiert werden
this.dsLayoutDetail.SetFilter("") 
this.dsLayoutDetail.Filter()
this.dsLayoutDetail.Sort()
SetNull(llNull)




lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
		//sError = "Error: Row/Column mismatch"
		sError = "Cannot be placed here"
	return -1
End If

// ---------------------------------------------------------------------------
// Contenttyp ermitteln
// Typ 1=Drawer 2=Tray  9=Blocked   3=DRAWERFOOD 4=TRAYNONFOOD
// ---------------------------------------------------------------------------
iType 					= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
iContent					= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
lOldLayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(lFound, "nlayout_detail_key")


// --------------------------------------------------------------------------------
// 05.12.2008, KF: Pr$$HEX1$$fc00$$ENDHEX$$fen, ob das Ziel unbelegt ist
// --------------------------------------------------------------------------------
Choose Case iType
		
	Case DRAWER
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		// issue #2835 
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
		//lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow + 1), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0 or lFoundNext = 0   Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		// Position ist bereits benutzt
		if iTypeNew <> EMPTY Then
			sError = "Position in use"
			return -1
		End If
		
		// issue #2835 
		iTypeNew_2 		= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		// Position ist bereits benutzt
		if iTypeNew_2 <> EMPTY Then
			sError = "Position in use"
			return -1
		End If	
		
	Case TRAYNONFOOD	
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0  Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		// Position ist bereits benutzt
		if iTypeNew <> EMPTY Then
			sError = "Position in use"
			return -1
		End If	

	Case TRAY	
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0  Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		// Position ist bereits benutzt
		if iTypeNew <> EMPTY Then
			sError = "Position in use"
			return -1
		End If
		
	Case DRAWERFOOD
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		// issue #2835 
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
		//lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow + 1), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0 or lFoundNext = 0   Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		// Position ist bereits benutzt
		if iTypeNew <> EMPTY Then
			sError = "Position in use"
			return -1
		End If
		
		// issue #2835 
		iTypeNew_2 		= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		// Position ist bereits benutzt
		if iTypeNew_2 <> EMPTY Then
			sError = "Position in use"
			return -1
		End If
	
		
	Case DRAWERFOOD_3RUNG
		lFoundPrev 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow -1), 1, this.dsLayoutDetail.Rowcount())
		lFound 			= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
		if lFoundPrev = 0 or lFound = 0 or lFoundNext = 0   Then
			//sError = "Error: Row/Column mismatch"
			sError = "Cannot be placed here"
			return -1
		End If
		
		iTypePrev		= this.dsLayoutDetail.Getitemnumber(lFoundPrev, "ntype")
		iTypeCurrent				= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		iTypeNew 		= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		// Position ist bereits benutzt
		if iTypePrev <> EMPTY or iTypeCurrent <> EMPTY or iTypeNew <> EMPTY Then
			sError = "Position in use"
			return -1
		End If
		
	Case DRAWER_MULTI_RUNG
		//	ermittle H$$HEX1$$f600$$ENDHEX$$he 2, 3, ...n Einheiten?
		//	ermittle Breite (1,2?)		
		ll_Height = this.dsLayoutDetail.Getitemnumber(lFound, "nrungs")
		ll_Width = this.dsLayoutDetail.Getitemnumber(lFound, "ncolumns")
		If ll_Width < 1 Then ll_Width = 1
		If ll_Width > 2 Then ll_Width = 2
		If ll_Height < 1 Then ll_Height = 1		
		// "Master" Position
		ll_Check = this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		if of_check_position(iType, iNewRow, iNewColumn, ll_Height, ll_Width) <> EMPTY Then
			sError = "Position in use"
			return -1
		End If
		
	Case Else
		return 0
end Choose
	

dsTemp = create datastore
dsTemp.dataobject = this.dsObjects.dataobject

this.dsObjects.Setfilter("")
this.dsObjects.Filter() 
this.dsObjects.RowsCopy(1, this.dsObjects.RowCount(), Primary!, dsTemp, 1, Primary!)

dsTemp.SetFilter("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow)) 
dsTemp.Filter()


// --------------------------------------------------------------------------------
//  alte Belegung ermitteln
// -------------------------------------------------------------------------------
Choose Case iType
	Case DRAWER, DRAWERFOOD, DRAWERFOOD_3RUNG
		lFound 			= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow + 1), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0 or lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while moving"
			if isvalid(dsTemp) Then destroy dsTemp
			return -1
		End If	
		lOldDetailKey 	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		lOldContent 	= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
		
	Case TRAY, TRAYNONFOOD
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0  Then
			sError = "Error: Row/Column mismatch while moving"
			if isvalid(dsTemp) Then destroy dsTemp
			return -1
		End If
		lOldDetailKey	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")	
		lOldContent 	= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
	
	
	Case DRAWER_MULTI_RUNG
		lFound 			= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 		= this.dsLayoutDetail.Find("ncolumn=" + string(iOldColumn) + " and nrow=" + string(iOldRow + 1), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0 or lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while moving"
			if isvalid(dsTemp) Then destroy dsTemp
			return -1
		End If	
		lOldDetailKey 	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		lOldContent 	= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
	
end Choose

// --------------------------------------------------------------------------------
//  Neue Belegung registrieren
// --------------------------------------------------------------------------------
Choose Case iType
	Case DRAWER, DRAWERFOOD
	//if iType = DRAWER Then // Einschub
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if lFound = 0 or lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while copying"
			if isvalid(dsTemp) Then destroy dsTemp
			return -1
		End If
		lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		this.dsLayoutDetail.SetItem(lFound, "ncontent",lOldContent)
		this.dsLayoutDetail.SetItem(lFound, "ntype",iType)	
		this.dsLayoutDetail.SetItem(lFoundNext, "ncontent",llNull)
		this.dsLayoutDetail.SetItem(lFoundNext, "ntype",BLOCKED)	
	
	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
	//if iType = DRAWER Then // Einschub
		lFoundPrev 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
	
		if lFoundPrev = 0 or lFound = 0 or  lFoundNext = 0 Then
			sError = "Error: Row/Column mismatch while copying"
			if isvalid(dsTemp) Then destroy dsTemp
			return -1
		End If
		
		lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		this.dsLayoutDetail.SetItem(lFound, "ncontent",lOldContent)
		this.dsLayoutDetail.SetItem(lFound, "ntype",iType)	
		this.dsLayoutDetail.SetItem(lFoundNext, "ncontent",llNull)
		this.dsLayoutDetail.SetItem(lFoundNext, "ntype",BLOCKED)	
		this.dsLayoutDetail.SetItem(lFoundNext, "nancestor",lNewDetailKey)	
		
	
	Case TRAY, TRAYNONFOOD
		//Elseif iType = TRAY Then // Tray
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0  Then
			sError = "Error: Row/Column mismatch while copying"
			if isvalid(dsTemp) Then destroy dsTemp
			return -1
		End If
		lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		this.dsLayoutDetail.SetItem(lFound, "ntype",iType)	
		this.dsLayoutDetail.SetItem(lFound, "ncontent",lOldContent)	
		
	Case DRAWER_MULTI_RUNG		
		//lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
		
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
//		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
//	
//		if lFound = 0 or lFoundNext = 0 Then
//			sError = "Error: Row/Column mismatch while copying"
//			if isvalid(dsTemp) Then destroy dsTemp
//			return -1
//		End If
		lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
				
		// Belegung erfolgt in of_draw...
	
end Choose

// --------------------------------------------------------------------------------
// Zuordnungen erstellen
// --------------------------------------------------------------------------------
// Die Contents
this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(lOldDetailKey)) 
this.dsLayoutContents.Filter()
llCount = dsLayoutContents.RowCount() 

//if iType <> DRAWER_MULTI_RUNG Then

	if llCount > 0 Then
		// Neue Rows ans Ende
		llRetVal = this.dsLayoutContents.RowsCopy(1, this.dsLayoutContents.RowCount(), Primary!, this.dsLayoutContents, dsLayoutContents.RowCount() + 1, Primary!)
		lSequence = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)
		if lSequence = -1 Then
			sError = "Error: Sequence failed"
			if isvalid(dsTemp) Then destroy dsTemp
			return -1
		End If
		for i = llCount + 1 to dsLayoutContents.RowCount() 
			this.dsLayoutContents.SetItem(i, "nlayout_content_key", lSequence)
			li_Check = this.dsLayoutContents.SetItem(i, "nlayout_detail_key", lNewDetailKey)
		next
	End If

//End If

this.dsLayoutContents.SetFilter("") 
this.dsLayoutContents.Filter()

// Die MZV - Parameter

//if iType <> DRAWER_MULTI_RUNG Then
	
	this.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(lOldDetailKey)) 
	this.dsLayoutDimension.Filter()
	llCount = this.dsLayoutDimension.RowCount()
	if llCount > 0 Then
		// Neue Rows ans Ende
		llRetVal = this.dsLayoutDimension.RowsCopy(1, this.dsLayoutDimension.RowCount(), Primary!, this.dsLayoutDimension,  this.dsLayoutDimension.RowCount() + 1, Primary!)
		for i = llCount + 1 to  this.dsLayoutDimension.RowCount()
			lSequence = f_sequence("seq_cen_object_equipment", sqlca)
			if lSequence = -1 Then
				sError = "Error: Sequence failed"
				if isvalid(dsTemp) Then destroy dsTemp
				return -1
			End If
			this.dsLayoutDimension.SetItem(i, "nlayout_dim_key", lSequence)
			this.dsLayoutDimension.SetItem(i, "nlayout_detail_key", lNewDetailKey)
		next
	End If
	
	this.dsLayoutDimension.SetFilter("") 
	this.dsLayoutDimension.Filter()

//End If

this.dsLayoutDetail.SetFilter("") 
this.dsLayoutDetail.Filter()
this.dsLayoutDetail.Sort()

Choose Case iType
	Case DRAWER, DRAWERFOOD
		this.of_draw_drawer(iNewRow, iNewColumn, iType, FALSE)
	Case DRAWERFOOD_3RUNG
		this.of_draw_drawer_3_rung(iNewRow, iNewColumn, iType, FALSE)
	Case TRAY, TRAYNONFOOD 
		this.of_draw_tray(iNewRow, iNewColumn,  iType, FALSE)
		
	Case DRAWER_MULTI_RUNG
		this.of_draw_drawer_multi_rung( iNewRow, iNewColumn, iType, ll_Height , ll_Width , FALSE)		
		//this.of_draw_drawer_multi_rung( iNewRow, iNewColumn, iType, ll_Height , ll_Width , TRUE)		
				
end Choose

this.of_draw_content(iNewRow, iNewColumn, is_CSC)

this.iCurrentRow 		= iNewRow
this.iCurrentColumn 	= iNewColumn

if isvalid(dsTemp) Then destroy dsTemp

return 0

end function

public function long of_update (blob arg_b_datawindow, blob arg_b_backlog);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_update (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 14.04.2009
*
* Argument(e):	blob arg_b_datawindow
* Return: Long
*
*
* Speichern des Datawindow damit beim Massendruck (z.b. im Service) kein Retrieve mehr n$$HEX1$$f600$$ENDHEX$$tig ist
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*03.09.2009	1.1			Ulrich Paudler	Backlog sichern
*24.09.2009	1.2			Ulrich Paudler	Kein Backlog Blob
*************************************************************/

long ll_RetVal 

// erstmal 'normal' updaten
ll_RetVal  = this.of_update() 

// wenn das update erfolgreich war dann noch das Datawindow sichern
if ll_RetVal  = 1 and len(arg_b_datawindow) > 0 Then
	UPDATEBLOB CEN_PACKINGLIST_LAYOUT
		SET BDATAWINDOW = :arg_b_datawindow
   		WHERE NLAYOUT_KEY = :this.lLayoutKey;
	if SQLCA.SQLCode= 0 Then 
		COMMIT;
	End If
End If

return ll_RetVal 

end function

public function long of_modify_dw (string arg_s_mod);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_modify_dw (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 09.09.2009
* Argument(e):
* string arg_s_mod
*
* Return: long
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fen und $$HEX1$$c400$$ENDHEX$$ndern
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  09.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
String sRet
	
if isValid(oDw) Then
	sRet = oDw.modify(arg_s_mod)
End If

if isValid(oDS) Then
	sRet = oDS.modify(arg_s_mod)
End If

If Trim(sRet) > "" Then
	// Error Occurred
	sRet += "!"
	if il_Disable_Debug = 0 Then
	//	guoLog.uf_debug( "["+ this.classname( )+".of_modify_dw ERROR " + sRet + ": " + arg_s_mod)
	End If
	return -1
End If
			
return 0

end function

public subroutine of_chc_trace (long iarg_level, string sarg_trace_text);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_chc_trace (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 24.09.2009
* Argument(e):
* Long iarg_level
*  string sarg_trace_text
*
* Return: none
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  24.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
Long	iTraceFile
String sTraceFile
long lResultKey

if s_app.iTrace = 0 Then
	return
End If
/*
sTraceFile=  f_gettemppath() +  "Trace_" + classname() + "_" + String(Today(), "yyyy-mm-dd") + ".log"

iTraceFile	= FileOpen(sTraceFile, LineMode!, Write!, LockWrite!, Append!)

FileWrite(iTraceFile, s_app.shost + "|"+ String(Today())+"|"+String(Now(),"hh:mm:ss fff")+ "|" + string(lResultKey) + "|" + sarg_trace_text)

FileClose(iTraceFile)
*/

guoLog.uf_allways("["+ this.classname( )+".of_chc_trace] " +  sarg_trace_text)
return
end subroutine

public function long of_register_file (string arg_s_file);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_register_file (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 30.09.2009
* Argument(e):
* string arg_s_file
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  30.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
long llIndex, llFound


llFound = 0

// ist das file schon registriert?
for llIndex = 1 to Upperbound(sRegisteredFiles)
	if  sRegisteredFiles[llIndex] = arg_s_file Then
		llFound = llIndex
		exit
	End If
next

// noch nicht vorhanden dann hinzuf$$HEX1$$fc00$$ENDHEX$$gen
if llFound = 0 Then
	llFound = Upperbound(sRegisteredFiles) + 1
	sRegisteredFiles[llFound] =arg_s_file
End If

Return llFound

end function

public function long of_set_order (long lrow, long lcolumn, long lorder);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_set_order (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 20.10.2009
* Argument(e):
* long lrow
*  long lcolumn
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  20.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
Long	lFound
Boolean	lb_Not_Found

lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(lcolumn) + " and nrow=" + string(lrow), 1, this.dsLayoutDetail.Rowcount())
if lFound > 0  Then
	this.dsLayoutDetail.Setitem(lFound, "norder", lOrder)
Else
	lb_Not_Found = TRUE
End If

return 0
end function

public function string of_get_order (long lrow, long lcolumn);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_order (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 20.10.2009
* Argument(e):
* long lrow
*  long lcolumn
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  20.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
Long		llFound
Long		llOrder
String	lsOrder = "" 


llFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(lcolumn) + " and nrow=" + string(lrow), 1, this.dsLayoutDetail.Rowcount())
if llFound > 0  Then
	llOrder = this.dsLayoutDetail.Getitemnumber(llFound, "norder")
Else
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_order col" + String(lcolumn) + "/row " + String(lrow) + " NOT FOUND " + String(dsLayoutDetail.Rowcount()) )			
	end if
End If
if isNull(llOrder) or llOrder < 0 Then
	lsOrder = "0"
Else
	lsOrder = String(llOrder)
End If

If il_Disable_Debug = 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_order col" + String(lcolumn) + "/row " + String(lrow) + " lsOrder " + lsOrder)			
end if

If lsOrder = "0" Then lsOrder = " "

return lsOrder

end function

public function long of_renumber_order (long arg_l_style);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_renumber_order (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 20.10.2009
* Argument(e):
* long arg_l_style
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  20.10.2009	1.0           Ulrich Paudler     Erstellung
*  28.05.2018	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       request #3448
*
*************************************************************/
long llOrder
long llRow
Long llRowCurrent, llColCurrent
String lsSort, lsDWObject

llOrder = 0

//CONSTANT Long KEEPORDER = 0
//CONSTANT Long COLUMNORDER		= 1
//CONSTANT Long ROWORDER			= 2
//CONSTANT Long COLUMNORDERINV	= 3
//CONSTANT Long ROWORDERINV		= 4


Choose Case arg_l_style
	
Case COLUMNORDER
		// Spaltenweise AUFSTEIGEND
		lsSort = "ncolumn ASC, nrow ASC"
	Case ROWORDER
		// Zeilenweise AUFSTEIGEND
		lsSort = "nrow ASC, ncolumn ASC"
		
		
		// request #3448
	Case COLUMNORDERINV
		// Spaltenweise von UNTEN AUFSTEIGEND
		lsSort = "ncolumn ASC, nrow DESC"
	Case ROWORDERINV
		// Zeilenweise con UNTEN AUFSTEIGEND
		lsSort = "nrow DESC, ncolumn ASC"


	Case KEEPORDER
		return 0
	Case Else
		return -1
end Choose

this.dsLayoutDetail.setsort(lsSort)
this.dsLayoutDetail.sort()

For llRow = 1 to this.dsLayoutDetail.RowCount()
	Choose Case this.dsLayoutDetail.Getitemnumber(llRow, "ntype")
		//Case TRAY, DRAWERFOOD
		Case TRAY, DRAWERFOOD, DRAWER_MULTI_RUNG
			llColCurrent 	 = dsLayoutDetail.GetitemNumber(llRow,"ncolumn")
			llRowCurrent = dsLayoutDetail.GetitemNumber(llRow,"nrow")
			llOrder ++
			this.dsLayoutDetail.Setitem(llRow, "norder", llOrder)
			dsLayoutDimension.SetFilter("")
			dsLayoutDimension.Filter()
			// Anzeige erneuern
			// 21.10.2009 Ulrich Paudler [UP] Order aktualisieren
			lsDWObject = "t_content_order_col_" + string(llColCurrent, "00") + "_row_" + string(llRowCurrent, "00")
			of_modify_dw(lsDWObject + ".text='" + of_get_order(llRowCurrent, llColCurrent)   + "'")
		Case Else
			this.dsLayoutDetail.Setitem(llRow, "norder", 0)
	end Choose
next

this.dsLayoutDetail.setsort("")
this.dsLayoutDetail.sort()

return llOrder

end function

public function long of_print_hide ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print_hide (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 21.10.2009
* Argument(e):
* none
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  21.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

long ll_Row
String ls_Object

this.dsObjects.SetFilter("Match(cobject, 't_content_order_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()

// -------------------------------------------------
// gefundene Objekte unsichtbar schalten
// -------------------------------------------------
For ll_Row = this.dsObjects.RowCount() to 1 step -1
	ls_Object = this.dsObjects.Getitemstring(ll_Row, "cobject")
	of_modify_dw(ls_Object + ".visible='0'")
Next

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

of_modify_dw("r_frame.visible='1'")

return 0

end function

public function long of_create_text (string sobjectname, string stext, string sfont, long ifontsize, long ifontweight, long lx, long ly, long lheight, long lwidth, long iborder, long ialign, long lcolor, long ivisible);/* 
* Funktion/Event: of_create_text
* Beschreibung: 	Text anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	sObjectName		= Name des TextObjects
* 	sText					= Anzuzeigender Text
*	sFont					= Schriftart
*	iFontSize				= Schriftgr$$HEX2$$f600df00$$ENDHEX$$e
*	iFontweight			= Fett oder Normal, 700 oder 400
*	lX						= XPos des Textes im Datawindow
*	lY						= YPos
*	lHeight				= H$$HEX1$$f600$$ENDHEX$$he des Textes im Datawindow
*	lWidth				= Breite
*	iBorder				= Rahmen An = 2 / Aus = 0
*	iAlign					= Ausrichtung / Left = 0, Right = 1, Center = 2
*	ivisible				= Sichtbarkeit / sichtbar = 1, unsichtbar = 0
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008	Erstellung
*	1.1 			U.Paudler	20.08.2009	Sichtbar flag eingef$$HEX1$$fc00$$ENDHEX$$gt
*	1.2 			U.Paudler	22.10.2009	Farbe mit $$HEX1$$fc00$$ENDHEX$$bergeben
*	1.3 			U.Paudler	25.01.2010	Editm$$HEX1$$f600$$ENDHEX$$glichkeit der Drawer/Tray Texte 
*	1.4 			O.Hoefer 	16.06.2010	Maskieren von Single Quotes
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet
Integer	li_Replace
Long	lFound, llNewRow, llFindrow, iResize, iMove
Boolean lb_Breakpoint
LongLong lllSequence

// Nur bestimmte objekte
if of_check_string(sObjectName,"t_content_") Then
	llFindRow = this.dsLayoutAddObjects.Find("cobject_name='" + sobjectname + "'",1,dsLayoutAddObjects.Rowcount())
	if llFindrow > 0 Then
		lheight = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nheight")
		//lwidth = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nwidth")
		if of_check_string(sObjectName,"t_content_floating_") Then
			lX = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nxpos")
			lY = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nypos")
			lwidth = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nwidth")
		Else
			//lX = of_set_xposition(this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nxpos"))
			//lY = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nypos")
		End If
		iborder = 0 //this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nborderstyle")
		ialign = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "ntextalign")
		sfont = this.dsLayoutAddObjects.GetItemString(llFindrow, "cfontname")
		lcolor = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nfontcolor")
		ifontweight = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nfontweight") 
		ifontsize = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nfontsize")
		stext = "" // this.dsLayoutAddObjects.GetItemString(llFindrow, "cvalue")
		iResize =		this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nresizeable")
		iMove = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nmoveable")
		
		if of_check_string(sobjectname,"t_content_") Then
			sFont = FONT_MS_SANS_SERIF
		End If
		
	Else
		
//		if of_check_string(sObjectName,"t_content_floating_") Then
//			
//		end if
		// --------------------------------------------------------------------------------------------------------------------
		// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
		// --------------------------------------------------------------------------------------------------------------------
		lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)
		if lllSequence = -1 Then
			sError = "Error: Sequence failed"
			return -1
		End If
		llNewRow = this.dsLayoutAddObjects.InsertRow(0)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nadd_object_key", lllSequence)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nlayout_key", this.lLayoutKey)
		if of_check_string(sObjectName,"t_content_floating_") Then
			this.dsLayoutAddObjects.SetItem(llNewRow, "nobject_type", FLOATCONTENTOBJECT) 
			this.dsLayoutAddObjects.SetItem(llNewRow, "nxpos", lX)
			iResize = 1
			iMove = 1
		Else
			this.dsLayoutAddObjects.SetItem(llNewRow, "nobject_type", CONTENTOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle
			this.dsLayoutAddObjects.SetItem(llNewRow, "nxpos", of_get_xposition(lX, sObjectName))
			iResize = 0
			iMove = 0
		End If
		this.dsLayoutAddObjects.SetItem(llNewRow, "cobject_name", sobjectname)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nheight", lheight)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nwidth", lwidth)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nypos", lY)	
		this.dsLayoutAddObjects.SetItem(llNewRow, "nborderstyle", 0) //iborder
		this.dsLayoutAddObjects.SetItem(llNewRow, "ntextalign", ialign)
		this.dsLayoutAddObjects.SetItem(llNewRow, "cfontname", sfont)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nfontcolor", lcolor)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nfontweight", ifontweight) 
		this.dsLayoutAddObjects.SetItem(llNewRow, "nfontsize", ifontsize)
		this.dsLayoutAddObjects.SetItem(llNewRow, "cvalue", "")
		this.dsLayoutAddObjects.SetItem(llNewRow, "nresizeable", iResize)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nmoveable", iMove)
	End If
End If

// nicht nach links abdriften!
if lX < 0 Then lX = 0

//if isnull(sTag) Then sTag = ""
if iFontSize > 0 Then iFontSize = iFontSize * -1

// ----------------------------------------------------------------------------
// Maskieren von Single Quotes (') - UK Problem bei "...O'Brian..."
// ----------------------------------------------------------------------------
If pos(sText, "'")  > 0 then
	lb_breakpoint=true
	li_Replace = f_replace_string(sText, "'", "~~~'")
End If

sCreate = "create text(band=detail alignment='" + string(iAlign) + "' " + &
			"text='" + sText + "' border='" + string(iBorder) + "' color='" + String(lColor) + "' " + &
			"x='" + string(lX) +  "' y='" + string(lY) + "' " + &
			" height='"+ String(lHeight) + "' width='" + string(lWidth) + "' " + &
			" name=" + sObjectName + &
			" visible='" + string(ivisible) + "' resizeable=" + String(iResize) + "  moveable=" + String(iMove) + " font.face='" + sFont + "' " + &
			" font.height='" + String(iFontSize) + "' font.weight='" + String(iFontWeight) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"
			

if isValid(oDw) Then
	if oDw.Describe(sObjectName +".Text")<> "!" Then
		return 0
	Else
		sRet = oDw.modify(sCreate)
		if of_check_string(sObjectName,"t_drag_target_") Then
		//if left(sObjectName,len("t_drag_target_")) = "t_drag_target_" Then
			oDw.SetPosition(sObjectName, "", FALSE)
		Else
			oDw.SetPosition(sObjectName, "", TRUE)
		End If
	End If
End If

if isValid(oDS) Then
		if oDS.Describe(sObjectName +".Text")<> "!" Then
		return 0
	Else
		sRet = oDS.modify(sCreate)
		if of_check_string(sObjectName,"t_drag_target_") Then
		//if left(sObjectName,len("t_drag_target_")) = "t_drag_target_" Then
			oDS.SetPosition(sObjectName, "", FALSE)
		Else
			oDS.SetPosition(sObjectName, "", TRUE)
		End If
	End If
End If

return 1

end function

public function long of_create_ellipse (string sobjectname, long lx, long ly, long lh, long lw, long lcolor);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_create_ellipse (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 26.10.2009
* Argument(e):
* 	sObjectName	= Name der Objects
*	lX1					= X1Pos der Linie im Datawindow
*	lY1					= Y1Pos
*	lX2					= X2Pos der Linie im Datawindow
*	lY2					= Y2Pos
*	lColor				= Farbe der Linie
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  26.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

String 	sCreate
String	sRet

sCreate = "create ellipse(band=detail x='" + string(lX) + "' y='" + &
			 string(lY) + "' height='" + string(lh) + "' width='" + string(lw) + &
			 "' name=" + sobjectname + "  moveable=0" + &
			 " visible='1'" + &
			 " brush.hatch='7' brush.color='570425344'" + &
			 " pen.style='0' pen.width='5'" + &
			 " pen.color='" + String(lColor) + "'" + &
			 " background.mode='2' background.color='1073741824' )"


of_modify_dw(sCreate)

//ellipse(band=detail x="380" y="92" height="30" width="30"  name=oval_1 visible="1" brush.hatch="7" brush.color="570425344" pen.style="0" pen.width="5" pen.color="0"  background.mode="2" background.color="33554432" )


return 1

end function

public function long of_get_container_type ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_container_type (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 26.10.2009
* Argument(e):
* none
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  26.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/


return ilContainerType

end function

public function string of_get_container_short_name ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_container_short_name (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 26.10.2009
* Argument(e):
* none
*
* Return: string
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  26.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/


return isContainerShortName

end function

public function long of_create_wheel (string sobjectname, long lx, long ly, long lh, long lw, long lcolor);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_create_wheel (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 26.10.2009
* Argument(e):
* 	sObjectName	= Name der Objects
*	lX1					= X1Pos 
*	lY1					= Y1Pos

*
* Return: long
*
*
* Zeichnen der R$$HEX1$$e400$$ENDHEX$$der unter dem Trolley
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  26.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

String 	sCreate
String	sRet

//sCreate = "create ellipse(band=detail x='" + string(lX) + "' y='" + &
//			 string(lY) + "' height='" + string(lh) + "' width='" + string(lw) + &
//			 "' name=" + sobjectname + "  moveable=0" + &
//			 " visible='1'" + &
//			 " brush.hatch='7' brush.color='570425344'" + &
//			 " pen.style='0' pen.width='5'" + &
//			 " pen.color='" + String(lColor) + "'" + &
//			 " background.mode='2' background.color='1073741824' )"
sCreate = "create roundrectangle(band=detail ellipseheight='10' ellipsewidth='10' x='" + string(lX) + "' y='" + string(lY) + "'" + &
			" height='" + string(lh) + "' width='" + string(lw) + "'  name=" + sobjectname + " visible='1' brush.hatch='6' brush.color='" + string(lcolor) + "'" + &
			" pen.style='0' pen.width='1' pen.color='1073741824'  background.mode='2' background.color='33554432' )"


of_modify_dw(sCreate)

return 1

end function

public function long of_fill_backlog_page ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_fill_backlog_page (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 28.10.2009
* Argument(e):
* none
*
* Return: long
*
*
* Auff$$HEX1$$fc00$$ENDHEX$$llen bis zur Seitengr$$HEX2$$f600df00$$ENDHEX$$e
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  28.10.2009	1.0           Ulrich Paudler     Erstellung
*  03.11.2009	1.1           Ulrich Paudler     Anpassung auf Letterformat
*  18.01.2010	1.2           Ulrich Paudler     Nochmals Anpassung auf Letterformat
*  28.07.2010	1.3           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Letterformat auch wenn LEER
*************************************************************/
Long llFillLoops = 0, llLoop, llDetailheight
Long llHeader, llFooter
long llRow = 1
long llTotalGroupBreaks = 0
Long  llGap = 0
//							il_Header_Height_Normal = 133
//							il_Footer_Height_Normal =  76
//							il_Header_Height_H_in_F = 138
//							il_Footer_Height_H_in_F =  70


If ib_non_sky then
	dsbacklog.reset()
	guoLog.uf_debug( "["+ this.classname( )+".of_fill_backlog_page NON SKY => no backlog")
	return 0
End If


// nur wenn etwas enthalten ist
if dsBacklog.Rowcount() > 0 Then
	// (Seitengr$$HEX2$$f600df00$$ENDHEX$$e - (Headerbacklog - Headercart) - Groupheader  - Groupfooter) /Detailh$$HEX1$$f600$$ENDHEX$$he
	dsBacklog.Sort()
	dsBacklog.Groupcalc()
	if of_is_header_in_footer() Then
		llGap = 15
		// Neuer Header/Footer: andere Gr$$HEX2$$f600df00$$ENDHEX$$e
		llHeader = il_Footer_Height_H_in_F
		llFooter = il_Header_Height_H_in_F
	Else
		llGap = 0
		// Neuer Header/Footer: andere Gr$$HEX2$$f600df00$$ENDHEX$$e
		llHeader = il_Header_Height_Normal
		llFooter = il_Footer_Height_Normal
	End If
	
	llDetailheight = of_get_detail_height(dsBacklog) - llGap
	
	do while llRow > 0
	   llRow = dsBacklog.FindGroupChange(llRow + 1, 1)
	   llTotalGroupBreaks++
	loop
	
	llFillLoops= (llDetailheight - (llHeader + (22 * llTotalGroupBreaks) + llFooter)) / 17
	
	// 12.02.2010, KF
	// llFillLoops auf -3 gesetzt, war vorher auf -1
	for llLoop= dsBacklog.Rowcount() + 1 to llFillLoops -3
		dsBacklog.insertrow(0)
	next

Else
	// ggf. Format => Letter
	llDetailheight = of_get_detail_height(dsBacklog) - llGap
End If

return llFillLoops

end function

public function boolean of_is_backlog_enabled ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_backlog_enabled (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 28.10.2009
* Argument(e):
* none
*
* Return: boolean
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fung ob die Backlogliste eingeschaltet ist
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  28.10.2009	1.0           Ulrich Paudler     Erstellung
*  02.02.2012	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter "Parameter statt Profile" (Service)
*                                               Variante "Section aus Instanzvariable" (WEB)
*  09.05.2016	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       NON Sky => CBASE-NAM-CR-16008
*
*************************************************************/

string sValue, ssection
Integer	iConfig


// ----------------------------------------------------------------------
// CBASE-NAM-CR-16008 Non-Sky => Backlog as Content Spec
// ----------------------------------------------------------------------
If ib_non_sky Then
	//guoLog.uf_debug( "["+ this.classname( )+".of_is_backlog_enabled NON Sky => TRUE")
	return TRUE
End If


// ----------------------------------------------------------------------
// 24.01.2012 bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_nenable_overflow = 1 then
		return TRUE
	ELSE
		return FALSE
	end if
End If

ilCartDiagramBacklogCounter++


// ----------------------------------------------------------------------
// 17.01.2013 Airline Schalter: Always Show Indicator 
// ----------------------------------------------------------------------
If ib_Force_Overflow Then 
   //guoLog.uf_debug( "["+ this.classname( )+".of_is_backlog_enabled Always Show Indicator for Airline")
   RETURN TRUE	
END IF





If is_section > "" Then
	sSection = is_section
Else
	sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
	if trim(sSection) = "" Then sSection = "docbrowser"
	is_section = sSection
End If

If isCartDiagramBacklogSection = sSection Then
	If Trim(isCartDiagramBacklog) > "" AND NOT IsNULL(isCartDiagramBacklog) then
		// Use cached value
		if isCartDiagramBacklog = "1" Then 
			return True
		ElseIf isCartDiagramBacklog = "0" Then 
			return FALSE			
		End if
	End if
End If

If isCartDiagramBacklogSection = "" Then isCartDiagramBacklogSection = sSection

//if sSection <> "docbrowser" Then
//	iConfig = integer(Mid(sSection,11))
//	sSection ="Default" +string(iConfig)
//Else
//	sSection ="Default"
//End If
//

sValue = of_profilestring(s_app.suser, sSection, "PRINTCARTDIAGRAMBACKLOG","0") 

isCartDiagramBacklog = sValue

if sValue = "1" Then
	return True
End If

return False

end function

public function long of_print_init ();/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print_init (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.05.2009
*
* Argument(e):	none
* Return: Long
*
*
*
*
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
* 09.09.2009		1.1			Ulrich Paudler	Erweiterung f$$HEX1$$fc00$$ENDHEX$$r Backlog
* 21.10.2009		1.2			Ulrich Paudler	Objekte beim Druck nicht anzeigen
* 03.11.2009		1.3			Ulrich Paudler	Anpassung auf Letterformat
* 11.01.2010		1.4			Ulrich Paudler	Weitere Anpassung auf Letterformat
* 19.01.2010		1.5			Ulrich Paudler	Header im Footer
* 16.02.2010		1.6			Ulrich Paudler	Header im Footer - Gap entfernt
* 28.07.2010		1.7			Oliver H$$HEX1$$f600$$ENDHEX$$fer	per Schalter: neuer Header CBASE-NAM-CR-0029
* 02.08.2010		1.8			Oliver H$$HEX1$$f600$$ENDHEX$$fer	Neuer Input: viele $$HEX1$$c400$$ENDHEX$$nderungen an Gr$$HEX2$$f600df00$$ENDHEX$$e / Position etc.
* 12.09.2012		1.9			Oliver H$$HEX1$$f600$$ENDHEX$$fer	Header-in-Footer TR & Normal
* 16.01.2013		1.10			Oliver H$$HEX1$$f600$$ENDHEX$$fer	Mehr Platz f$$HEX1$$fc00$$ENDHEX$$r "Report date and time"
* 22.102.013		1.11 			Oliver Hoefer	4.96 Error 21 - Print Packinglist (Header)

************************************************************************************************/
long llDetailheight, llHeader, llFooter, llGap
Integer	li_Succ
Boolean	lb_Header_in_Footer	
//							il_Header_Height_Normal = 133
//							il_Footer_Height_Normal =  76
//							il_Header_Height_H_in_F = 138
//							il_Footer_Height_H_in_F =  70


// Wohin zeichnen - oben oder unten?
If NOT ib_Mode_TR_Cart Then
	lb_Header_in_Footer =  of_is_header_in_footer()
Else
	lb_Header_in_Footer = of_is_tr_header_in_footer()
End If

llGap = 10

if lb_Header_in_Footer Then
	//Cart
	llHeader =	il_Footer_Height_H_in_F
	
	llFooter =	il_Header_Height_H_in_F
	
	if isValid(oDw) Then
		llDetailheight = of_get_detail_height(oDw)  - (llHeader + llFooter + llGap)
		oDw.object.r_frame.Height  	= string(llDetailheight)
	Elseif isValid(oDS) Then
		llDetailheight = of_get_detail_height(oDs) - (llHeader + llFooter + llGap)
		oDs.object.r_frame.Height  	= string(llDetailheight)
	End If
	of_modify_dw("DataWindow.Header.Height='" + String(llHeader) + "'")
//	of_modify_dw("DataWindow.Summary.Height='0'")
	of_modify_dw("DataWindow.Footer.Height='" + String (llFooter) + "'")
	of_modify_dw("DataWindow.Detail.Height='" +String(llDetailheight) + "'")
	
	//backlog

	of_modify_dw_backlog("DataWindow.Header.Height='" + String(llHeader + 3) + "'")
	of_modify_dw_backlog("DataWindow.Header.1.Height='22'")
	of_modify_dw_backlog("DataWindow.Detail.Height='17'")
	of_modify_dw_backlog("DataWindow.Trailer.1.Height='0'")

	of_modify_dw_backlog("DataWindow.Footer.Height='" + String(llFooter) + "'")
	of_modify_dw_backlog("DataWindow.Summary.Height='0'")
	// Backlog r_detail
	of_modify_dw_backlog("r_detail.y=" + String(llHeader))
	of_modify_dw_backlog("r_detail.height=" + String(llDetailheight))
	
Else
	// Cart
	llHeader =	il_Header_Height_Normal 
	llFooter =	il_Footer_Height_Normal 

	if isValid(oDw) Then
		llDetailheight = of_get_detail_height(oDw) - (llHeader + llFooter + llGap)
		oDw.object.r_frame.Height  	= string(llDetailheight - llGap)
	Elseif isValid(oDS) Then
		llDetailheight = of_get_detail_height(oDs) - (llHeader + llFooter + llGap)
		oDs.object.r_frame.Height  	= string(llDetailheight - llGap)
	End If

	of_modify_dw("DataWindow.Header.Height='" + String(llHeader) + "'")
//	of_modify_dw("DataWindow.Summary.Height='0'")
	of_modify_dw("DataWindow.Footer.Height='" + String (llFooter) + "'")
	of_modify_dw("DataWindow.Detail.Height='" +String(llDetailheight) + "'")
	
	// Backlog

	of_modify_dw_backlog("DataWindow.Header.Height='" + String (llHeader + 3) + "'")
	of_modify_dw_backlog("DataWindow.Header.1.Height='22'")
	of_modify_dw_backlog("DataWindow.Detail.Height='17'")
	of_modify_dw_backlog("DataWindow.Trailer.1.Height='0'")

	of_modify_dw_backlog("DataWindow.Footer.Height='" + String(llFooter) + "'")
//	of_modify_dw_backlog("DataWindow.Summary.Height='0'")
	// Backlog r_detail
	of_modify_dw_backlog("r_detail.y=" + String(llHeader))
	of_modify_dw_backlog("r_detail.height=" + String(llDetailheight))

End If

of_print_hide()

// ---------------------------------------------------------------
// Zeichne neuen Header und Footer 
// ---------------------------------------------------------------
If il_Result_Key < 1 Then
	
	if isnull(is_PL_Desc) then is_PL_Desc =""
	if isnull(is_PL) then is_PL =""
	
	li_Succ = of_print_prepare_new_h_f( "", is_PL, is_PL_Desc, "", "", "", "", "", FALSE)
	li_Succ = of_print_prepare_new_h_f( "", is_PL, is_PL_Desc, "", "", "", "", "", TRUE)	
End If

li_Succ = of_draw_header(il_Result_Key) 
li_Succ = of_draw_footer(il_Result_Key)

// ----------------------
// Auch f$$HEX1$$fc00$$ENDHEX$$r Backlog
// ----------------------
li_Succ = of_draw_header(il_Result_Key, TRUE) 
li_Succ = of_draw_footer(il_Result_Key, TRUE) 


return 0

end function

public function long of_print_backlog ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print_backlog (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 14.09.2009
* Argument(e):
* none
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  14.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

long ll_Rowcount


of_modify_dw_backlog("l_4.visible='0'")
of_modify_dw_backlog("l_5.visible='0'")
of_modify_dw_backlog("l_6.visible='0'")
of_modify_dw_backlog("l_7.visible='0'")
of_modify_dw_backlog("r_frame.visible='0'")
of_modify_dw_backlog("r_detail.visible='0'")

of_check_object_sizes(TRUE)
	

if isValid(oDwbacklog) Then
	ll_Rowcount = oDwbacklog.Rowcount() 
	
	if ll_Rowcount> 0 Then
		oDwbacklog.print()
	End If
	oDwbacklog.SetRedraw(true)
End If

if isValid(oDsbacklog) Then
	ll_Rowcount = oDsbacklog.Rowcount() 
	
	if ll_Rowcount> 0 Then
		oDsbacklog.print()
	End If
End If

// Anzeigelayout
//of_modify_dw_backlog("DataWindow.Header.Height='0'")
//of_modify_dw_backlog("DataWindow.Footer.Height='0'")
of_print_backlog_deinit()

return ll_Rowcount

end function

public function long of_print ();/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.04.2009
*
* Argument(e):	none
* Return: Long
*
*
*
*
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
*03.09.2009		1.1			Ulrich Paudler	Backlog hinzugef$$HEX1$$fc00$$ENDHEX$$gt
************************************************************************************************/
long ll_Rowcount


// Drucklayout
of_print_init()

if isValid(oDw) Then
	of_modify_dw("r_frame.visible='0'")
	of_modify_dw("r_detail.visible='0'")
	oDw.SetRedraw(false)
	oDw.print()
	of_modify_dw("r_frame.visible='0'")
	oDw.SetRedraw(true)
	ll_Rowcount = oDw.Rowcount() 
End If


if isValid(oDs) Then
	of_modify_dw("r_frame.visible='0'")
	of_modify_dw("r_detail.visible='0'")
	oDs.print()
	ll_Rowcount = oDs.Rowcount() 
End If
	
// Anzeigelayout
of_print_deinit()

return ll_Rowcount

end function

public function long of_init (long arg_lindexkey, long arg_ldetailkey, long arg_lairlinekey, string arg_sunit, datastore arg_ods, datetime arg_ddeparture, datastore arg_odsbacklog);
/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_init (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 16.04.2009
*
* Argument(e):	* long arg_llayoutkey
*  long arg_lindexkey
*  long arg_ldetailkey
*  long arg_lairlinekey
*  string arg_sunit
*  datastore arg_ods
*  datetime arg_ddeparture
*  datastore arg_odsbacklog
*
* Return: long
*
*
* wrapper zum weiterleiten des funktionsaufrufes
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*30.09.2009	1.1			Ulrich Paudler	sauberes initialisieren 
*19.01.2010	1.2			Ulrich Paudler	Unterscheidung Header im Footer
*08.02.2010	1.3			Ulrich Paudler	Backlog nach zuweisung $$HEX1$$fc00$$ENDHEX$$bersetzen
*************************************************************/
Long lRetval


is_CSC = arg_sunit

this.il_IndexKey	= arg_lIndexKey
this.lDetailKey	= arg_lDetailKey
il_AirlineKey	= arg_lAirlineKey
//this.sUnit			= arg_sUnit
this.oDs				= arg_ods
this.idt_departure	= date(arg_dDeparture)
this.oDsBacklog	= arg_odsbacklog
this.bBacklog     = of_is_backlog_enabled()

SELECT  max(NLAYOUT_KEY) 
INTO :this.lLayoutKey
FROM CEN_PACKINGLIST_LAYOUT
WHERE NPACKINGLIST_INDEX_KEY =:arg_lindexkey AND NPACKINGLIST_DETAIL_KEY=:arg_ldetailkey 
USING SQLCA;
if SQLCA.SQLCode <> 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".NO CEN_PACKINGLIST_LAYOUT for " + String(arg_lindexkey) + " / " + String(arg_ldetailkey))
	return -1
End If	

// Dies ist jetzt die andere Unit (Einheit statt CSC)
SELECT  CUNIT
INTO :this.sUnit
FROM CEN_PACKINGLISTS
WHERE NPACKINGLIST_INDEX_KEY =:arg_lindexkey AND NPACKINGLIST_DETAIL_KEY=:arg_ldetailkey 
USING SQLCA;
if SQLCA.SQLCode <> 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".NO CEN_PACKINGLISTS for " + String(arg_lindexkey) + " / " + String(arg_ldetailkey))
	return -1
End If		

// 19.01.2010 Ulrich Paudler [UP] Header im Footer
//Cartdiagram
if of_is_header_in_footer() Then
	arg_ods.dataobject = "dw_uo_layout_footer_n"
Else
	arg_ods.dataobject = "dw_uo_layout_n"
End If
arg_ods.InsertRow(0)

// Backlog
if of_is_header_in_footer() Then
	arg_odsbacklog.dataobject = "dw_uo_layout_backlog_footer_n"
Else
	arg_odsbacklog.dataobject = "dw_uo_layout_backlog_n"
End If
//arg_odsbacklog.InsertRow(0)

// 08.02.2010 Ulrich Paudler [UP] Backlog auch $$HEX1$$fc00$$ENDHEX$$bersetzen
// uf.translate_datastore(arg_odsbacklog)

// 30.09.2009 Ulrich Paudler [UP] initialisieren
iCurrentRow = 0
iCurrentColumn = 0
lErrorCount = 0
sError =""

//// 10.12.2009 Ulrich Paudler [UP]
////lXOffSet 	= 50
lYOffSet 	= 30 //1 //5 // war 50
//// 10.12.2009 Ulrich Paudler [UP]
////lDefaultWidth 	= 322
lDefaultHeight = 52 //48 // war 54

// Datastores zur$$HEX1$$fc00$$ENDHEX$$cksetzen
dsLayoutDetail.Reset()
dsLayoutContents.Reset()
dsLayoutDimension.Reset()
dsLayoutAddObjects.Reset()
dsPL.Reset()
dsPLContents.Reset()
dsObjects.Reset()

// 03.09.2009 Ulrich Paudler [UP]
dsBacklog.Reset()

lRetval = 	this.of_init()

return lRetval


end function

public function long of_modify_dw_backlog (string arg_s_mod);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_modify_dw_backlog (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 28.10.2009
* Argument(e):
* string arg_s_mod
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  28.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
if isValid(oDwBacklog) Then
	oDwBacklog.modify(arg_s_mod)
End If

if isValid(oDsBacklog) Then
	oDsBacklog.modify(arg_s_mod)
End If
			
return 0
end function

public function long of_set_position (string arg_s_mod, boolean arg_b_flag);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_set_position (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.10.2009
* Argument(e):
* string arg_s_mod
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  29.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/


Return of_set_position( arg_s_mod, arg_b_flag, FALSE)
end function

public function long of_getfullstate (ref blob arg_blob);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_getfullstate (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.10.2009
* Argument(e):
* ref blob arg_blob
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  29.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

long ll_RetVal
	
if isValid(oDw) Then
	ll_RetVal = oDw.getfullstate(arg_blob)
Else
	ll_RetVal = oDS.getfullstate(arg_blob)
End If
			
return ll_RetVal
end function

public function long of_getfullstate_backlog (ref blob arg_blob);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_getfullstate_backlog (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.10.2009
* Argument(e):
* ref blob arg_blob
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  29.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
long ll_RetVal
	
if isValid(oDw) Then
	 uf.translate_datawindow(oDwBacklog)
	ll_RetVal = oDwBacklog.getfullstate(arg_blob)
Else
	 uf.translate_datastore(oDsBacklog)
	ll_RetVal = oDSBacklog.getfullstate(arg_blob)
End If
			
return ll_RetVal

end function

public function long of_get_backlog_rowcount ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_backlog_rowcount (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.10.2009
* Argument(e):
* none
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  29.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

long llRetVal
	
if isValid(oDw) Then
	llRetVal = oDwBacklog.rowcount()
Else
	llRetVal = oDSBacklog.rowcount()
End If
			
return llRetVal

end function

public function string of_profilestring (string suser, string ssection, string skey, string sdefault);// --------------------------------------------------------------------------------
// Objekt : 
// Methode: of_profilestring (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
// none
// --------------------------------------------------------------------------------
// Return: integer
// --------------------------------------------------------------------------------
//  Beschreibung:
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  27.03.2009	            Klaus F$$HEX1$$f600$$ENDHEX$$rster        Erstellung
//  30.10.2014	            Oliver Hoefer        Kein Insert, wenn nicht gefunden
//
// --------------------------------------------------------------------------------
string	sValue
Long lUserID


If trim(ssection)  = "" OR isnull(ssection) then
	guoLog.uf_error("["+ this.classname( )+".of_profilestring] "  +  this.isStowage +" - " + "EMPTY SECTION " )
	return sDefault
End If


If Isnull(suser) OR suser = "" Then
	If is_user > "" Then
		suser = is_user
	End If
End If

if sUser  =  sCachedUser and ssection = sCachedSection and skey = sCachedKey Then
	return sCachedValue
End If

Select nuser_id into :lUserID from sys_login where cusername = :sUser;

if sqlca.sqlcode <> 0 Then
	sCachedUser = ""
	sCachedSection = ""
	sCachedKey = ""
	sCachedValue = ""
	guoLog.uf_error("["+ this.classname( )+".of_profilestring] "  +  this.isStowage +" - " + "failed: " + sqlca.sqlerrtext)
	guoLog.uf_error("["+ this.classname( )+".of_profilestring] "  +  this.isStowage +" - " + "failed: " + sqlca.sqlerrtext)
	return sDefault
End If

Select 	cValue 
into 		:sValue 
from		loc_setup
where		nuser_id		= :lUserID	and
			cSection		= :sSection			and
			cKey			= :sKey;

If SQLCA.SQLCode = 100 Then
	sValue = sDefault
End If	

// Cache f$$HEX1$$fc00$$ENDHEX$$llen
sCachedUser = sUser
sCachedSection = sSection 
sCachedKey = sKey 
sCachedValue = sValue

return sValue

end function

public function long of_get_item_properties (long arg_l_row, long arg_l_column, ref s_distrib_items ref_str_item[]);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_itemproperties (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 09.11.2009
* Argument(e):
* long arg_l_row
*  long arg_l_column
*  s_distrib_items arg_str_item[]
*
* Return: string
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  09.11.2009	1.0           Ulrich Paudler     Erstellung
*  19.01.2010	1.1           Ulrich Paudler     nlimit hinzu
*
*************************************************************/

Long	llFound, llRow, llMaxContent
Long 	llDetailkey
Long	ll_Distribution_Rows


dsLayoutDetail.SetFilter("")
dsLayoutDetail.Filter()

llFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_l_column) + " and nrow=" + string(arg_l_row), 1, this.dsLayoutDetail.Rowcount())
if llFound > 0  Then
	llDetailkey 		= this.dsLayoutDetail.Getitemnumber(llFound, "nlayout_detail_key")
	
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties dsLayoutDetail FOUND ncolumn=" + string(arg_l_column) + " and nrow=" + string(arg_l_row) )
	End If

Else
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties dsLayoutDetail NOT FOUND ncolumn=" + string(arg_l_column) + " and nrow=" + string(arg_l_row) )
	End If
End If

If il_Disable_Debug = 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties llDetailkey=" + string(llDetailkey) )
End If

this.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(llDetailkey))
this.dsLayoutDimension.Filter()
this.dsLayoutDimension.Sort()

ll_Distribution_Rows = dsLayoutDimension.RowCount()
If ll_Distribution_Rows < 1 Then
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties dsLayoutDimension.RowCount()<1")
	End If
End If

llMaxContent = of_get_maxcontent(arg_l_row, arg_l_column)
//  ### Anzahl nicht auf Max Anzeigerows begrenzen
//llMaxContent = ll_Distribution_Rows //of_get_maxcontent(arg_l_row, arg_l_column)

If ll_Distribution_Rows > llMaxContent Then
	llMaxContent = ll_Distribution_Rows
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties/of_get_maxcontent MORE Row " + String(arg_l_row) + " Col " + String(arg_l_column) + ": " + String(llMaxContent))
	End If
Else
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties/of_get_maxcontent Row " + String(arg_l_row) + " Col " + String(arg_l_column) + ": " + String(llMaxContent))
	End If
End if

for llRow = 1 to llMaxContent 
	if llRow <= this.dsLayoutDimension.RowCount() Then
		ref_str_item[llRow].str_prop.stext					= f_check_null(this.dsLayoutDimension.GetItemString(llRow, "ctext"))
		ref_str_item[llRow].str_prop.smeal_control_code	= f_check_null(this.dsLayoutDimension.GetItemString(llRow, "cmeal_control_code"))
		ref_str_item[llRow].str_prop.sclass					= f_check_null(this.dsLayoutDimension.GetItemString(llRow, "cclass"))
		if this.dsLayoutDimension.GetItemNumber(llRow, "nspml") = 1 Then
			ref_str_item[llRow].str_prop.lspml = 1
		Else
			ref_str_item[llRow].str_prop.lspml = 0
		End If
		// 19.01.2010 Ulrich Paudler [UP]
		ref_str_item[llRow].str_prop.llimit						= this.dsLayoutDimension.GetItemNumber(llRow, "nlimit")
		// ################ test only
		If ref_str_item[llRow].str_prop.llimit = 0 then
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties Row " + String(arg_l_row) + " Col " + String(arg_l_column) + ": ref_str_item[llRow].str_prop.llimit 0=> 999")
			End If
			ref_str_item[llRow].str_prop.llimit = 999
		end if
		
		If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties " + ref_str_item[llRow].str_prop.stext)
	End If
		
	Else
		ref_str_item[llRow].str_prop.stext					= ""
		ref_str_item[llRow].str_prop.smeal_control_code	= ""
		ref_str_item[llRow].str_prop.sclass					= ""
		ref_str_item[llRow].str_prop.lspml 					= 0
		ref_str_item[llRow].str_prop.llimit					= 0
	End If
	If il_Disable_Debug = 0 Then
		If Trim(ref_str_item[llRow].str_prop.stext) > "" Then
			guoLog.uf_debug( "["+ this.classname( )+".of_get_itemproperties " +String(llRow) + ": " + ref_str_item[llRow].str_prop.stext)
		End If
	End If
next

return llRow

end function

public function long of_reset_backlog_page (long arg_l_type);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_reset_backlog_page (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 17.11.2009
* Argument(e):
* none
*
* Return: long
*
*
* Entleeren der Zeilen, ben$$HEX1$$f600$$ENDHEX$$tigt f$$HEX1$$fc00$$ENDHEX$$r das Backlog der Trays in der Mahlzeitenverteilung
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  17.11.2009	1.0          Ulrich Paudler   Erstellung
*  19.11.2009	1.1          Ulrich Paudler  	Drawerfood und Traynonfood eingebaut
*  19.11.2009	1.2          Oliver H$$HEX1$$f600$$ENDHEX$$fer     DRAWER_MULTI_RUNG hinzu
*
*************************************************************/

long llRow

Choose Case arg_l_type
	Case EMPTY
//		dsBacklog.setfilter("")
//		dsBacklog.filter()
		dsBacklog.Reset()
		
	Case TRAY, DRAWER, TRAYNONFOOD, DRAWERFOOD
		dsBacklog.setfilter("ntype=" + String(arg_l_type) + " or isNull(ntype)")
		dsBacklog.filter()
		for llRow = dsBacklog.Rowcount() to 1 step -1
			dsBacklog.deleterow(llRow)
		next

	Case DRAWER_MULTI_RUNG
		dsBacklog.setfilter("ntype=" + String(arg_l_type) + " or isNull(ntype)") 
		dsBacklog.filter()
		for llRow = dsBacklog.Rowcount() to 1 step -1
			dsBacklog.deleterow(llRow)
		next
		
	Case Else
end Choose

dsBacklog.setfilter("")
dsBacklog.filter()

return dsBacklog.Rowcount()
end function

public function long of_copy_text (string arg_l_object);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_copy_text (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 18.11.2009
* Argument(e):
* string arg_l_object
*
* Return: long
*	 1		Alles OK
*	-1		Fehler
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  18.11.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
Long llRow
LongLong lllSequence

// --------------------------------------------------------------------------------------------------------------------
// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
// --------------------------------------------------------------------------------------------------------------------
lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)

if lllSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

llRow = this.dsLayoutAddObjects.insertrow(0)

this.dsLayoutAddObjects.SetItem(llRow, "nadd_object_key", lllSequence)
this.dsLayoutAddObjects.SetItem(llRow, "nlayout_key", this.lLayoutKey)
this.dsLayoutAddObjects.SetItem(llRow, "cobject_name", "t_text_" + string(llRow) + string(now(), "hhmmss"))
this.dsLayoutAddObjects.SetItem(llRow, "nobject_type", TEXTOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle
// 19.01.2010 Ulrich Paudler [UP]
this.dsLayoutAddObjects.SetItem(llRow, "nxpos", of_get_xposition(long(oDw.describe(arg_l_object + ".x")), arg_l_object ))
this.dsLayoutAddObjects.SetItem(llRow, "nypos",  long(oDw.describe(arg_l_object + ".y")))
this.dsLayoutAddObjects.SetItem(llRow, "nheight", long(oDw.describe(arg_l_object + ".height")))
this.dsLayoutAddObjects.SetItem(llRow, "nwidth", long(oDw.describe(arg_l_object + ".width")) )
this.dsLayoutAddObjects.SetItem(llRow, "ntextalign", long(oDw.describe(arg_l_object + ".alignment")) )
this.dsLayoutAddObjects.SetItem(llRow, "nborderstyle", long(oDw.describe(arg_l_object + ".border")) )
this.dsLayoutAddObjects.SetItem(llRow, "nfontcolor", long(oDw.describe(arg_l_object + ".color")) )
this.dsLayoutAddObjects.SetItem(llRow, "nfontsize", long(oDw.describe(arg_l_object + ".font.height")) * -1 )
this.dsLayoutAddObjects.SetItem(llRow, "nfontweight", long(oDw.describe(arg_l_object + ".font.weight")) )
this.dsLayoutAddObjects.SetItem(llRow, "cfontname", oDw.describe(arg_l_object + ".font.face"))
this.dsLayoutAddObjects.SetItem(llRow, "cvalue", oDw.describe(arg_l_object + ".text"))
this.dsLayoutAddObjects.SetItem(llRow, "nlayer", Long(oDw.describe(arg_l_object + ".tag")))
this.dsLayoutAddObjects.SetItem(llRow, "nresizeable", 1)
this.dsLayoutAddObjects.SetItem(llRow, "nmoveable", 1)


this.of_create_text(llRow)
	
return 1
end function

public function long of_copy_picture (string arg_s_object);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_copy_picture (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 18.11.2009
* Argument(e):
* string arg_s_object
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  18.11.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

Long		llFound, llRow
String		lsFile, lsTempFile, lsSuffix
Blob		lbBlob
Long		llIndex
LongLong lllSequence
// --------------------------------------------------------------------------------------------------------------------
// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
// --------------------------------------------------------------------------------------------------------------------
lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)
if lllSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

if Right(sTemppath, 1) <> "\" Then sTemppath += "\"

lsFile = oDw.describe(arg_s_object + ".filename")

this.of_file_to_blob(lsFile, lbBlob)
for llIndex = len(lsFile) to 1 Step -1
	if Mid(lsFile, llIndex, 1) = "." Then
		lsSuffix = Mid(lsFile, llIndex + 1)
		exit
	End If
next

lsTempFile = of_generate_filename("p_", lsSuffix)

this.of_blob_to_file(sTemppath + lsTempFile, lbBlob)

of_register_file(sTemppath + lsTempFile) 

// File noch in die DB schreiben
of_set_file_to_blob(lllSequence, sTemppath + lsTempFile)


llRow = this.dsLayoutAddObjects.InsertRow(0)
this.dsLayoutAddObjects.SetItem(llRow, "nadd_object_key", lllSequence)
this.dsLayoutAddObjects.SetItem(llRow, "nlayout_key", this.lLayoutKey)
this.dsLayoutAddObjects.SetItem(llRow, "nobject_type", BITMAPOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle
this.dsLayoutAddObjects.SetItem(llRow, "cobject_name", "p_picture_" + string(llRow) + "_" + string(now(), "hhmmss"))
this.dsLayoutAddObjects.SetItem(llRow, "nheight", long(oDw.describe(arg_s_object + ".height")))
this.dsLayoutAddObjects.SetItem(llRow, "nwidth", long(oDw.describe(arg_s_object + ".width")) )
// 19.01.2010 Ulrich Paudler [UP]
this.dsLayoutAddObjects.SetItem(llRow, "nxpos", of_get_xposition(long(oDw.describe(arg_s_object + ".x")), arg_s_object))
this.dsLayoutAddObjects.SetItem(llRow, "nypos",  long(oDw.describe(arg_s_object + ".y")))
this.dsLayoutAddObjects.SetItem(llRow, "nborderstyle", 0)
this.dsLayoutAddObjects.SetItem(llRow, "cvalue", lsTempFile)
this.dsLayoutAddObjects.SetItem(llRow, "cfullname", sTemppath + lsTempFile)
this.dsLayoutAddObjects.SetItem(llRow, "nresizeable", 1)
this.dsLayoutAddObjects.SetItem(llRow, "nmoveable", 1)
this.dsLayoutAddObjects.SetItem(llRow, "nnew", 1)

this.of_create_picture(llRow, lbBlob)

return 1
end function

public function long of_create_picture (long lrow, blob arg_b_blob);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_create_picture (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 18.11.2009
* Argument(e):
* long lrow
*  blob arg_b_blob
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  18.11.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

String 	sCreate
String	sRet
Long  iRet
Long		iAlign, iBorder, iColor, lX, lY, lHeight, lWidth, iFontSize, iFontWeight,iMove, iResize
LongLong lllAddKey
String	sObjectName, sFont, sFile, sTag, sTempfile
String	ls_Mod

iAlign			= this.dsLayoutAddObjects.GetItemNumber(lRow, "ntextalign")
iBorder			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nborderstyle")
iColor			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontcolor")
// 19.01.2010 Ulrich Paudler [UP]
lX					= of_set_xposition(this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos"))
lY					= this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
lHeight			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nheight")
lWidth			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nwidth")
iFontSize		= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontsize")
iFontWeight		= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontweight")
iMove				= this.dsLayoutAddObjects.GetItemNumber(lRow, "nmoveable")
iResize			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nresizeable")
sObjectName		= this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")
sFont				= this.dsLayoutAddObjects.GetItemString(lRow, "cfontname")
sFile				= this.dsLayoutAddObjects.GetItemString(lRow, "cvalue")
sTag				= String(this.dsLayoutAddObjects.GetItemNumber(lRow, "nlayer"))
lllAddKey			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nadd_object_key")

if isnull(sTag) Then sTag = ""

of_register_file(sTemppath + sFile) 

sCreate = "create bitmap(name=" + sObjectName + " visible='" + String(1)  + "' resizeable=" + String(iResize) + "  moveable=" + String(iMove)  + &
			 " band=detail filename='" + sTemppath + sFile + "'" + &
			 " x='" + string(lX, "0") + "' y='" + string(lY) + &
			 "' height='" + String(lHeight) + "' width='" + String(lWidth) + "' border='9' )"

of_modify_dw(sCreate)

lllAddKey			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nadd_object_key")
ls_mod = sObjectName + ".tag='nadd_object_key=" + String(lllAddKey) + "'"
of_modify(ls_mod , false)
guoLog.uf_debug( "["+ this.classname( )+".of_create_picture] " + ls_mod)


iRet = of_set_position(sObjectName, FALSE)

return 1

end function

public function long of_create_picture (long lrow);/* 
* Funktion/Event: of_create_picture
* Beschreibung: 	Bild anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	lRow			= Zeile aus dsLayoutAddObjects f$$HEX1$$fc00$$ENDHEX$$r die das Bild gezeichnet werden soll
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008	Erstellung
*	1.1				U.Paudler	16.04.2009	Blob auslagern
*	1.2 			U.Paudler	18.01.2010	Mit dem Cart verschieben
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet
Long		iRet
Long		iAlign, iBorder, iColor, lX, lY, lHeight, lWidth, iFontSize, iFontWeight,iMove, iResize
LongLong lllAddKey
String	sObjectName, sFont, sFile, sTag, sTempfile
String	ls_Mod


iAlign			= this.dsLayoutAddObjects.GetItemNumber(lRow, "ntextalign")
iBorder			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nborderstyle")
iColor			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontcolor")
// 19.01.2010 Ulrich Paudler [UP]
lX					= of_set_xposition(this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos"))
lY					= this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
lHeight			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nheight")
lWidth			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nwidth")
iFontSize		= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontsize")
iFontWeight		= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontweight")
iMove				= this.dsLayoutAddObjects.GetItemNumber(lRow, "nmoveable")
iResize			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nresizeable")
sObjectName		= this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")
sFont				= this.dsLayoutAddObjects.GetItemString(lRow, "cfontname")
sFile				= this.dsLayoutAddObjects.GetItemString(lRow, "cvalue")
sTag				= String(this.dsLayoutAddObjects.GetItemNumber(lRow, "nlayer"))
lllAddKey			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nadd_object_key")

if isnull(sTag) Then sTag = ""

// 16.04.2009 Ulrich Paudler [UP]

if of_get_blob_to_file(lllAddKey, sTemppath, sFile) < 0 Then return -1

// 30.09.2009 Ulrich Paudler [UP]
of_register_file(sTemppath + sFile) 
//sRegisteredFiles[Upperbound(sRegisteredFiles) + 1] = sTemppath + sFile

sCreate = "create bitmap(name=" + sObjectName + " visible='" + String(1)  + "' resizeable=" + String(iResize) + "  moveable=" + String(iMove)  + &
			 " band=detail filename='" + sTemppath + sFile + "'" + &
			 " x='" + string(lX, "0") + "' y='" + string(lY) + &
			 "' height='" + String(lHeight) + "' width='" + String(lWidth) + "' border='9' )"

of_modify_dw(sCreate)

lllAddKey			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nadd_object_key")
ls_mod = sObjectName + ".tag='nadd_object_key=" + String(lllAddKey) + "'"
of_modify(ls_mod , false)
guoLog.uf_debug( "["+ this.classname( )+".of_create_picture] " + ls_mod)


iRet = of_set_position(sObjectName, FALSE)

return 1

end function

public function long of_draw_tray (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew);/* 
* Funktion/Event: of_draw_tray
* Beschreibung: 	Zeichnet ein Tray
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 iRow				Zeile
**	 iColumn			"Spalte"
*   iArgType      Neuanlage = -1, sonst 3
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 		K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008	Erstellung
*	1.1			U.Paudler	20.04.2009	Refactoring
*	1.2			U.Paudler	22.06.2009	Tray in den Hintergrund
*	1.3			U.Paudler	21.10.2009	Order anzeigen
*	1.4			U.Paudler	19.11.2009	Drawerfood und Traynonfood eingebaut
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	lX1
Long	lX2
Long	lFound, lRowHeight, i, lYCounter, lNewDetailKey
String sDWObject,sDWButtonObject
Long iType
long lY, lW
Long	ll_DefaultWidth 
Long	ll_DefaultWidthSmall 
Long	ll_max_Content


ll_DefaultWidth = lDefaultWidth
ll_DefaultWidthSmall = lDefaultWidthSmall

// ####test####
if bHasDimensions Then
////	llTextWidth = TEXTWIDTH1
//	ll_DefaultWidth = lDefaultWidthSmall
Else
//	llTextWidth = TEXTWIDTHSMALL1
	ll_DefaultWidthSmall = lDefaultWidth
End If

// Die Position(en) im Trolley muss als geblockt markiert werden
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_icolumn) + " and nrow=" + string(arg_irow), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0  Then
	sError = "Error: Row/Column mismatch"
	return -1
End If

// ---------------------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
// ---------------------------------------------------------------------------
iType 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")

// Position ist bereits benutzt, nur bei Neuanlage pr$$HEX1$$fc00$$ENDHEX$$fen
//if iType <> 0  and arg_iType >=0 Then
if arg_bNew and iType <> EMPTY   Then
	sError = "Positon in use"
	return -1
End If

// Aktuelle Position merken
this.iCurrentRow = arg_iRow
this.iCurrentColumn = arg_iColumn

this.dsLayoutDetail.Setitem(lFound, "ntype", arg_itype)

lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
this.dsLayoutDetail.Setitem(lFound, "nancestor", lNewDetailKey)


// Seitenteile des Trays sind 15 x 18 Pixel
lX1 = lXOffset + ((arg_iColumn -1) * ll_DefaultWidth) + 2
sDWObject = "p_left_tray_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\tray_left_1.jpg", lX1, lYOffset + (arg_iRow * lDefaultHeight) - 18 - 8,  18, 15, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1

of_set_position(sDWObject, False)

lX2 = lXOffset + ((arg_iColumn -1) * ll_DefaultWidth) +  ll_DefaultWidth - 16
sDWObject = "p_right_tray_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\tray_right_1.jpg", lX2, lYOffset + (arg_iRow * lDefaultHeight) - 18 - 8, 18, 15, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject,False)

// Boden des Trays ist 5 Pixel hoch, die Breite aufziehen
sDWObject = "p_bottom_tray_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\drawer_bottom.jpg", lXOffset + ((arg_iColumn -1) * ll_DefaultWidth) + 15 + 2, lYOffset + (arg_iRow * lDefaultHeight) - 15 + 2, 5,lX2 - lX1 - 14, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject,  False)

// Bild, dient als Button zum sp$$HEX1$$e400$$ENDHEX$$teren $$HEX1$$f600$$ENDHEX$$ffnen der Contents
// in einem eigenen Dialog
sDWButtonObject = "p_button_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 20 ,lYOffset + (arg_iRow * lDefaultHeight)  - 30 , 14, 14, 0, 0, 0)
//of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 15 ,lYOffset + (arg_iRow * lDefaultHeight)  - 30 , 14, 14, 0, 0, 0)
if of_register(sDWButtonObject, arg_iRow, arg_iColumn) = -1 Then return -1

// 21.10.2009 Ulrich Paudler [UP]
// Order des Tray beim f$$HEX1$$fc00$$ENDHEX$$llen mit Mahlzeiten
Choose Case arg_itype
	Case TRAY
		sDWObject = "t_content_order_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
		of_create_text(sDWObject, of_get_order(arg_iRow, arg_iColumn) ,FONT_MS_SANS_SERIF, 8, FONT_BOLD, lX2 - 20 ,lYOffset + (arg_iRow * lDefaultHeight)  - 40  , 15 ,   25, 0, 1,  RGB(0,0,0), 1)
		if ibedit then
			of_modify_text(sDWObject, of_get_order(arg_iRow, arg_iColumn))
		end if
		if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then
			// Register Failed
			//return -1
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung REGISTER FAILED " + sDWObject)			
			end if
		Else
			
			of_set_position(sDWObject, true)
		End if		
		
		// ----------------------------------------------------------
		// iMaxContent  Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
		// ----------------------------------------------------------
		lX1 = lXOffset + ((arg_iColumn -1) * ll_DefaultWidth) + 20
		lX2 = lXOffset + ((arg_iColumn -1) * ll_DefaultWidth) +  ll_DefaultWidth / 2
		lRowHeight = 15
		lYCounter = 1
		lY = lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 10
		// 11.01.2010 Ulrich Paudler [UP]
		
		//lW =  ll_DefaultWidth / 2 - 30
		//lW =  ll_DefaultWidthSmall / 2 - 30
		
		lW =  ll_DefaultWidthSmall - 30	
		
		//ll_max_Content = iMaxContent
		ll_max_Content = iMaxContentTray
		
		//For i = 1 to iMaxContent
		For i = 1 to ll_max_Content 
			sDWObject = "t_content_tray_" + string(I) + "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
			
			// ##### TEST t_content_tray_
			of_unregister(sDWObject)
			
			of_create_text(sDWObject, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lY + (lRowHeight * (lYCounter - 1)), 15 , lW,0, 0,  RGB(0,0,0), 1)
			if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then
				//return -1
			End If
//			// 2 Reihig
//			if i = Long(iMaxContent/2) Then
//				lX1 = lX2
//				lYCounter = 0
//			End If
			lYCounter ++
		Next
	Case TRAYNONFOOD
		// keine Mahlzeiten
end Choose

// -----------------------------------
// Den Button nach oben, sonst kann
// er nicht angeklickt werden
// -----------------------------------
of_set_position(sDWButtonObject, True)


return 1

end function

public function long of_draw_drawer (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew);/* 
* Funktion/Event: of_add_content
* Beschreibung: 	Ordnet einen Inhalt zu
*							
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 arg_iRow				Zeile
**	 arg_iColumn			"Spalte"
*	 iargtype     Neuanlage = -1, sonst 1 oder 2
*	 
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		22.08.2008	Erstellung
*	1.1			U.Paudler	20.04.2009	Refactoring
*	1.2			U.Paudler	22.06.2009	Drawer in den Hintergrund
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/

Long	lX1
Long	lX2
Long	lFound, lFoundNext, lRowHeight, i, lYCounter, lNewDetailKey
String sDWObject, sDWButtonObject
Long iType, iTypeNext
long lY, lW
Boolean	lb_error


if arg_iRow >= dsAirlineEq.GetItemNumber(1, "nrows") Then
	// Letzte Schiene kann nicht genutzt werden f$$HEX1$$fc00$$ENDHEX$$r Trolleys
	sError = "Position cannot be used for drawers"
	return -1
End If

// Die Position(en) im Trolley muss als geblockt markiert werden
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_iColumn) + " and nrow=" + string(arg_iRow), 1, this.dsLayoutDetail.Rowcount())
lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(arg_iColumn) + " and nrow=" + string(arg_iRow + 1), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 or lFoundNext = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
End If

// ---------------------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
// ---------------------------------------------------------------------------
iType 		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
iTypeNext 	= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")

// Position ist bereits benutzt, nur bei Neuanlage pr$$HEX1$$fc00$$ENDHEX$$fen
//if (iType <> 0 or iTypeNext <> 0) and arg_iType >= 0 Then
if arg_bNew and (iType <> EMPTY or iTypeNext <> EMPTY)  Then
	sError = "Positon in use"
	return -1
End If

// Aktuelle Position merken
this.iCurrentRow = arg_iRow
this.iCurrentColumn = arg_iColumn

this.dsLayoutDetail.Setitem(lFound, "ntype", arg_itype)
this.dsLayoutDetail.Setitem(lFoundNext, "ntype", BLOCKED)

lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
this.dsLayoutDetail.Setitem(lFound, "nancestor", lNewDetailKey)
this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", lNewDetailKey)

// Seitenteile des Drawers sind 12 x 90 Pixel
lX1 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 1
sDWObject = "p_left_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
//of_create_picture(sDWObject, "..\Resource\Drawer_left_1.jpg", lX1, lYOffset + (arg_iRow * lDefaultHeight) - (45 * (ldefaultheight / 52)) - 1,  90 * (ldefaultheight / 52), 12, 1, 0, 0)
of_create_picture(sDWObject, "..\Resource\Drawer_left_1.jpg", lX1, lYOffset + (arg_iRow * lDefaultHeight) - 45 - 1,  90, 12, 1, 0, 0)

if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth - 12
sDWObject = "p_right_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
//of_create_picture(sDWObject, "..\Resource\Drawer_right_1.jpg", lX2, lYOffset + (arg_iRow * lDefaultHeight) - 45 - 1, 90, 12, 1, 0, 0)
of_create_picture(sDWObject, "..\Resource\Drawer_right_1.jpg", lX2, lYOffset + (arg_iRow * lDefaultHeight) - 45 - 1, 90, 12, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject,  False)

// Boden des Drawers sind 5 Pixel hoch, die Breite aufziehen
sDWObject = "p_bottom_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\drawer_bottom.jpg", lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 12, lYOffset + (arg_iRow * lDefaultHeight) + 45 - 6, 5,lX2 - lX1 - 10, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)


// Bild, dient als Button zum sp$$HEX1$$e400$$ENDHEX$$teren $$HEX1$$f600$$ENDHEX$$ffnen der Contents
// in einem eigenen Dialog
sDWButtonObject = "p_button_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
//of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 15 ,lYOffset + (arg_iRow * lDefaultHeight) - 45 - 1, 14, 14, 0, 0, 0)
//of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 15 ,lYOffset + (arg_iRow * lDefaultHeight)  - 30 , 14, 14, 0, 0, 0)

of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 20 ,lYOffset + (arg_iRow * lDefaultHeight)  - 30 , 14, 14, 0, 0, 0)

if of_register(sDWButtonObject, arg_iRow, arg_iColumn) = -1 Then return -1


// 19.11.2009 Ulrich Paudler [UP]
// Order  beim f$$HEX1$$fc00$$ENDHEX$$llen mit Mahlzeiten
Choose Case arg_itype
	Case DRAWERFOOD
		sDWObject = "t_content_order_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
		of_create_text(sDWObject, of_get_order(arg_iRow, arg_iColumn) ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD, lX2 - 25 ,lYOffset + (arg_iRow * lDefaultHeight)  - 40  , 15 ,   25, 0, 1,  RGB(0,0,0), 1)
		if ibedit then
			of_modify_text(sDWObject, of_get_order(arg_iRow, arg_iColumn))
		end if
		if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then
			// Reister failed?
			//return -1
			lb_error = TRUE
		End If
		// ----------------------------------------------------------
		// iMaxContent  Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
		// ----------------------------------------------------------
		lX1 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 20
		lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth/2
		lRowHeight = 15
		lYCounter = 1
		lY = lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 10
		// 11.01.2010 Ulrich Paudler [UP] Breite reduzieren - hier den !!!t_content_tray_!!! f$$HEX1$$fc00$$ENDHEX$$llen
		//lW =  lDefaultWidth / 2 - 30
		//lW =  (lDefaultWidth - 30)  / 2
		lW =  lDefaultWidth - 30  
		//For i = 1 to iMaxContentDrawer
		For i = 1 to iMaxContentDrawerfood
			sDWObject = "t_content_tray_" + string(I) + "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
			of_unregister(sDWObject)
			//of_create_text(sDWObject, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lY + (lRowHeight * (lYCounter - 1)), 15 , lW, 0, 0,  RGB(0,0,0), 1)
			
			// issue #2835 Teil 1: "Drei Punkte"
			of_create_text(sDWObject, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lY + (lRowHeight * (lYCounter - 1)), 15 , lW, 0, 0,  RGB(0,0,0), 1)
						
			
			if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then
				//return -1
			End If
//			// 2 Reihig
//			if i = Long(iMaxContentDrawer/2) Then
//				lX1 = lX2
//				lYCounter = 0
//			End If
			lYCounter ++
		Next
	Case Else
end Choose

// -----------------------------------
// Den Button nach oben, sonst kann
// er nicht angeklickt werden
// -----------------------------------
of_set_position(sDWButtonObject, True)

Return 1

end function

public function long of_draw_content_tray (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn, ref long arg_ltype);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_content_tray (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 15.04.2009
*
* Argument(e):	long arg_llayoutdetailkey
* Return: Long
*
*
*
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
* ???			1.0		??					Erstellung
*20.08.2009	1.1			Ulrich Paudler	 Leere Werte zulassen
*21.09.2009	1.2			Ulrich Paudler	 Order Felder nicht l$$HEX1$$f600$$ENDHEX$$schen
*07.02.2010 1.3			Oliver H$$HEX1$$f600$$ENDHEX$$fer    wenn nichts mehr zugeordnet (dsLayoutDimension.RowCount = 0 dann evtl. existierende alt-Werte l$$HEX1$$f600$$ENDHEX$$schen
*
*************************************************************/

String ls_Filter, ls_Object,  ls_DWObject, ls_Mod, ls_Text
long ll_Row, lX1, lX2, lRowHeight, lYCounter, lPercentUnit, lPercentText,  lWidthQuantity, lWidthtUnit,  lWidthText
long lContentIndexKey,  lContentDetailKey, llMaxContent
Integer	li_Succ

this.dsObjects.SetFilter("ncolumn=" + string(arg_iColumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()

this.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(arg_llayoutdetailkey))
this.dsLayoutDimension.Filter()
this.dsLayoutDimension.Sort()


if this.dsLayoutDimension.RowCount() = 0 Then
	// [Noch] nichts zugeordnet ODER "nichts mehr"
	// -------------------------------------------------
	// Alle Textobjekte l$$HEX1$$f600$$ENDHEX$$schen
	// -------------------------------------------------
	For ll_Row = this.dsObjects.RowCount() to 1 step -1
		ls_Object = this.dsObjects.Getitemstring(ll_Row, "cobject")
		if of_check_string(ls_Object,"t_content_tray_" ) Then
			of_modify_dw(ls_Object + ".text='...'")
			of_modify (ls_Object + ".width='" + String(ldefaultwidth  - 30 ) + "'", FALSE)
		End If
	Next
	return 1
End If

llMaxContent = of_get_maxcontent(arg_irow, arg_icolumn)

// -------------------------------------------------
// Alle Textobjekte l$$HEX1$$f600$$ENDHEX$$schen
// -------------------------------------------------
For ll_Row = this.dsObjects.RowCount() to 1 step -1
	ls_Object = this.dsObjects.Getitemstring(ll_Row, "cobject")
	if of_check_string(ls_Object,"t_content_tray_" ) Then
		of_modify_dw(ls_Object + ".text='...'")

		of_modify (ls_Object + ".width='" + String(ldefaultwidth  - 30 ) + "'", FALSE)
		
	End If
Next

// 20.08.2009 Ulrich Paudler [UP] NULL Werte zulassen
for ll_Row = 1 to this.dsLayoutDimension.RowCount()
	ls_Text = ""
	if this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit") > 0 Then
		ls_Text +=  f_check_null(string(this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit")) + " x ")
	End If
	ls_Text += f_check_null(this.dsLayoutDimension.GetItemString(ll_Row, "ctext")  )
	ls_Text += f_check_null("/"  + this.dsLayoutDimension.GetItemString(ll_Row, "cmeal_control_code")  )
	ls_Text += f_check_null("/"  + this.dsLayoutDimension.GetItemString(ll_Row, "cclass"))

	if this.dsLayoutDimension.GetItemNumber(ll_Row, "nspml") = 1 Then
		ls_Text += "/SPML"
	End If

	ls_DWObject = "t_content_tray_" + string(ll_Row) + "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

	if ll_Row > llMaxContent Then
		of_draw_content_backlog_tray(ll_Row,  arg_iRow, arg_icolumn, ls_Text , of_get_type(arg_iRow, arg_icolumn))
		if il_Disable_Debug= 0 then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_tray l_Row > llMaxContent => BACKLOG " + ls_Text)
		End If
		
		// ########### BACKLOG bei MZV OFF
		if ib_Enable_Meal_Distribution = FALSE Then
			li_Succ = of_sd_add_backlog( arg_iRow, arg_icolumn, ls_DWObject, 1, ""  , ls_Text,1, tray , ls_Text , il_master_row  )
		End If

	
	End If
	// 12.01.2010 Ulrich Paudler [UP]
	
	// Keine Distr. Parameter wenn nicht im Painter 
	If NOT ibedit then ls_Text = ""
	
	of_modify_text(ls_DWObject, ls_Text)
	// width  ll_DefaultWidthSmall - 30
next

// 21.10.2009 Ulrich Paudler [UP] Order aktualisieren
ls_DWObject = "t_content_order_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
if ibedit then
	of_modify_dw(ls_DWObject + ".text='" + of_get_order(arg_iRow, arg_iColumn)   + "'")
end if

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

return 0
end function

public function long of_get_maxcontent (long arg_l_row, long arg_l_column);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_maxcontent (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.11.2009
* Argument(e):
* long irow
*  long icolumn
*
* Return: long
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.11.2009	1.0           Ulrich Paudler     Erstellung
*  08.12.2010	1.1           Oliver Hoefer      Hinzu: DRAWER_MULTI_RUNG
*  23.11.2012	1.2           Oliver Hoefer      DRAWER_MULTI_RUNG mit H$$HEX1$$f600$$ENDHEX$$he 1 ge$$HEX1$$e400$$ENDHEX$$ndert
*  26.11.2012	1.3           Oliver Hoefer      Tray repariert
*  15.01.2013	1.4           Oliver Hoefer      Drawer
*
*************************************************************/

long		llMaxContent
Integer	li_Rows
Integer	li_Cols
Long		ll_Found


iMaxContent = 4
iMaxContentDrawer = 10

Choose Case of_get_type(arg_l_row, arg_l_column)
	Case TRAY, TRAYNONFOOD
		//llMaxContent = iMaxContent
		llMaxContent = iMaxContentTray

	Case DRAWERFOOD
		//llMaxContent = iMaxContentDrawer
		llMaxContent = iMaxContentDrawerFood
		
	Case DRAWER
		// 15.01.2013
		//llMaxContent = 5	
		llMaxContent = 6	
		
				
	Case DRAWER_MULTI_RUNG
		// Ermittle MaxContent f$$HEX1$$fc00$$ENDHEX$$r Multi Rung Drawer		
		llMaxContent = iMaxContent	
		ll_Found 		= this.dsLayoutDetail.Find("ncolumn=" + string( arg_l_column ) + " and nrow=" + string(arg_l_row), 1, this.dsLayoutDetail.Rowcount())
		if ll_Found > 0  Then
			li_Rows = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrungs")
			li_Cols = this.dsLayoutDetail.Getitemnumber(ll_Found, "ncolumns")
			If li_Rows > 1 Then
				// Wie ein Drawer
				//llMaxContent = (li_Rows * li_Cols * iMaxContentDrawer) / 2				
				// 3 => 8
				// 2 => 5
				llMaxContent = ((li_Rows * 3) - 1) * li_Cols 
				
				If li_Rows = 2 Then
					llMaxContent = ((li_Rows * 3)) * li_Cols 
				End If
				
				If li_Rows = 3 Then
					llMaxContent = ((li_Rows * 3)) * li_Cols 
				End If
				
				If li_Rows = 4 Then
					llMaxContent = ((li_Rows * 3) + 1) * li_Cols 
				End If

				If li_Rows > 4 Then
					llMaxContent = ((li_Rows * 3) + 2) * li_Cols 
				End If
				
				If li_Rows > 6 Then
					llMaxContent = ((li_Rows * 3) + 4) * li_Cols 
				End If
				
				//guoLog.uf_debug( "["+ this.classname( )+".of_get_maxcontent DRAWER_MULTI_RUNG column=" + string( arg_l_column ) + " and row=" + string(arg_l_row) + " Rows: " + String(li_Rows) + " cols:" + String(li_Cols)+ " " + String(llMaxContent))
			Else
				// Wie ein Tray 
				//llMaxContent = (li_Rows * li_Cols * iMaxContent) / 2
				llMaxContent = ((li_Rows * 3) - 1) * li_Cols 
				
				//guoLog.uf_debug( "["+ this.classname( )+".of_get_maxcontent DRAWER_MULTI_RUNG column=" + string( arg_l_column ) + " and row=" + string(arg_l_row) + " Rows: " + String(li_Rows) + " cols:" + String(li_Cols)+ " " + String(llMaxContent))
				
			End If
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_maxcontent " + String(llMaxContent))
			End If
		End If
		
	Case Else
		llMaxContent = 0
end Choose

Return llMaxContent

end function

public function string of_get_item_description (s_component arg_str_component);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_item_description (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 11.01.2010
* Argument(e):
* s_component arg_str_component
*
* Return: integer
*
*
* Aus dem Profil die Konfiguration laden und anwenden 
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  11.01.2010	1.0           Ulrich Paudler     Erstellung
*  10.02.2010	1.1           Ulrich Paudler     Quantity, wenn vorhanden, hinzuf$$HEX1$$fc00$$ENDHEX$$gen
*  15.02.2010	1.2           Ulrich Paudler     Im Editmode auf Standard schalten
*  02.02.2012	1.3           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter "Parameter statt Profile" (Service)
*                                               Variante "Section aus Instanzvariable" (WEB)
*  22.08.2012	1.4           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter "Suppress Qty 1"
*
*************************************************************/
string sValue, ls_ArgItem, ssection, sDefault
integer iconfig


// ----------------------------------------------------------------------
// 24.01.2012 bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	sValue = String(inv_doc_gen_settings.il_ncart_component_display )
	if ibEdit Then		sValue = "0"
Else
	If trim(isCartDiagramComponentDisplay) > "" Then
		sValue = isCartDiagramComponentDisplay		
	Else
		
		If is_section > "" Then
			sSection = is_section
		Else			
			sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		end if	
		
		if sSection <> "docbrowser" Then
			iConfig = integer(Mid(sSection,11))
			sDefault ="Default" +string(iConfig)
		Else
			sDefault ="Default"
		End If
				
		// Ist das Diagram im Editmode
		if ibEdit Then
			sValue = "0"
		Elseif isNull(isCartDiagramComponentDisplay) or  isCartDiagramComponentDisplay= "" Then
			sValue =  of_profilestring(s_app.suser,sDefault,"CartDiagramComponentDisplay","0") 
			isCartDiagramComponentDisplay = sValue
		Else
			sValue = isCartDiagramComponentDisplay
		End If
	End If
End if

if sValue = "0" Then
	ls_ArgItem= arg_str_component.ssnr + " - " + arg_str_component.stext
Elseif sValue = "1" Then
	ls_ArgItem= arg_str_component.ssnr
Elseif sValue = "2" Then
	ls_ArgItem= arg_str_component.stext	
End If

//// 10.02.2010 Ulrich Paudler [UP] 
////if len(arg_str_component.squantity)> 0 and not isNull(arg_str_component.squantity) Then
//if len(arg_str_component.squantity)> 0 and not isNull(arg_str_component.squantity) Then	
//	If isnumber(arg_str_component.squantity) then
//		If Trim(arg_str_component.squantity) <> "1" AND double(arg_str_component.squantity) <> 1 Then
//			ls_ArgItem = arg_str_component.squantity + " x " + ls_ArgItem
//		End If
//	end if
//End If 

// NAM CR 12002 Always show Qty 
If isNull(arg_str_component.squantity) Then arg_str_component.squantity = ""
If ib_suppress_qty_1 = FALSE OR arg_str_component.squantity <> "1" Then
	If arg_str_component.squantity <> "0" AND Trim(arg_str_component.squantity) > "" then
		ls_ArgItem = arg_str_component.squantity + " x " + ls_ArgItem
	End if
End if

if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".uo_cart_distrib_row.of_get_item_description " + ls_ArgItem)


Return ls_ArgItem

end function

public function long of_modify_text (string arg_s_object, string arg_s_text);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_modify_text (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 12.01.2010
* Argument(e):
*  string arg_s_object
*  string arg_s_text
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  12.01.2010	1.0           Ulrich Paudler     Erstellung
*  16.06.2011	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Maskieren von Single Quotes
*
*************************************************************/

String	ls_Error
Integer	li_Succ


// --------------------------------------------------------------------------
// Maskieren von Single Quotes
// --------------------------------------------------------------------------
li_Succ =  f_replace_string(arg_s_text, "'", "~~~'")

if isValid(oDw) Then
	ls_Error = oDw.Modify(arg_s_object +".Text='" + arg_s_text +  "'")
	If ls_Error > "" Then
		if il_Disable_Debug= 0 then
			//guoLog.uf_debug( "["+ this.classname( )+".of_modify_text ODW ERROR " + arg_s_object + ".text " + arg_s_text + " / " + ls_Error)
		End If
	End If
End If

if isValid(oDS) Then
	ls_Error = oDS.Modify(arg_s_object +".Text='" + righttrim(arg_s_text) +  "'")
	If ls_Error > "" Then
		if il_Disable_Debug= 0 then
			//guoLog.uf_debug( "["+ this.classname( )+".of_modify_text ODS ERROR " + arg_s_object + ".text " + arg_s_text + " / " + ls_Error)
		End If
	End If
End If
			
return 0

end function

public function boolean of_is_editmode ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_editmode (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 18.01.2010
* Argument(e):
* none
*
* Return: boolean
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  18.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/


return ibEdit

end function

public function long of_set_editmode (boolean arg_b_flag);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_set_editmode (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 18.01.2010
* Argument(e):
* boolean arg_b_flag
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  18.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

ibedit = arg_b_flag

return 0


end function

public function long of_create_component_list (s_component arg_component[]);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_create_component_list (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 22.10.2009
* Argument(e):
* string arg_s_component[]
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  22.10.2009	1.0           Ulrich Paudler     Erstellung
*  26.10.2009	1.1           Ulrich Paudler     Einstellung im Profil ber$$HEX1$$fc00$$ENDHEX$$cksichtigen
*  14.02.2012	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Combine Items aus of_Fill_Comp... umgezogen
*  23.02.2012	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Combine Items unabh$$HEX1$$e400$$ENDHEX$$ngig von Sortierungseinstellung
*
*************************************************************/

String	lsRet
String	lsObjectName, lsText, sValue
Long llIndex, llMaxIndex
Long llX, llY, llHeight, llWidth, llYMax, llWidthAmount, llSpace
Boolean	lb_Breakpoint


llX = 20
llY = 56
llYMax = 780 // 880 
llHeight = 10
// 11.01.2010 Ulrich Paudler [UP]
llWidth =142

llWidthAmount = 30
llSpace = 5

llMaxIndex = upperbound(arg_component)
Boolean	lb_Sort_by_PL_Class_Leg
Boolean	lb_Consolidate_Entries
Boolean	lb_Found_Double_Entry
String	sSection, sDefault
Integer	iConfig
Long		ll_Comp_Counter, ll_Temp_Counter
String	ls_Temp_text, ls_temp_PL
Long		ll_Temp_Qty
Long		ll_Target_Index
s_component	lstr_Component[]


// ----------------------------------------------------------------------
// bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 1 then
		lb_Sort_by_PL_Class_Leg = TRUE
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_PL_Class_Leg = FALSE
	end if
Else
	
	If is_section > "" Then
		sSection = is_section
	Else
		sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(sSection) = "" Then sSection = "docbrowser"
	End if
	
	if sSection <> "docbrowser" Then
		iConfig = integer(Mid(sSection,11))
		sDefault ="Default" +string(iConfig)
	Else
		sDefault ="Default"
	End If
	
	sValue = of_profilestring(s_app.suser,sDefault,"CartDiagramCompSort","0") 
	If sValue = "1" Then
		lb_Sort_by_PL_Class_Leg = TRUE
	End If
	
	sValue = of_profilestring(s_app.suser,sDefault,"CartDiagramCompDistinct","0") 
	If sValue = "1" Then
		lb_Consolidate_Entries = TRUE
	End if

End if

// Keine Daten dann raus
if  llMaxIndex < 1 Then 
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_create_component_list upperbound(arg_component) < 1 RETURN")
	end if
	return 0
End If

// Umsortieren?
If lb_Consolidate_Entries Then
	//lstr_Component = arg_component[]
	ls_Temp_text = arg_component[1].stext
	ls_Temp_PL   = arg_component[1].ssnr
	lstr_Component[1].stext											= arg_component[1].stext
	lstr_Component[1].ssnr											= arg_component[1].ssnr
	lstr_Component[1].lquantity									= arg_component[1].lquantity
	lstr_Component[1].squantity									= ""
	lstr_Component[1].llength										= arg_component[1].llength
	lstr_Component[1].str_item_props.stext						= arg_component[1].str_item_props.stext
	lstr_Component[1].str_item_props.smeal_control_code	= arg_component[1].str_item_props.smeal_control_code
	lstr_Component[1].str_item_props.sclass					= arg_component[1].str_item_props.sclass
	lstr_Component[1].str_item_props.lspml						= arg_component[1].str_item_props.lspml
	lstr_Component[1].str_item_props.llimit = 0
	If Upperbound(arg_component) > 1 Then
		For ll_Comp_Counter = 2 To Upperbound(arg_component)
			lb_Found_Double_Entry = FALSE
			ls_Temp_text = arg_component[ll_Comp_Counter].stext
			ls_Temp_PL   = arg_component[ll_Comp_Counter].ssnr
			
			If Upperbound(lstr_Component) > 0 then
				For ll_Temp_Counter = 1 To Upperbound(lstr_Component)
					IF lstr_Component[ll_Temp_Counter].stext = ls_Temp_text AND &
						lstr_Component[ll_Temp_Counter].ssnr  = ls_temp_PL Then
						lb_Found_Double_Entry = TRUE
						ll_Temp_Qty = arg_component[ll_Comp_Counter].lquantity
						lstr_Component[ll_Temp_Counter].lquantity = lstr_Component[ll_Temp_Counter].lquantity + ll_Temp_Qty
						
					End If
				Next
			End If
			
			If lb_Found_Double_Entry = FALSE then
				ll_Target_Index = upperbound(lstr_Component) + 1
				lstr_Component[ll_Target_Index].stext		= arg_component[ll_Comp_Counter].stext
				lstr_Component[ll_Target_Index].ssnr  		= arg_component[ll_Comp_Counter].ssnr
				lstr_Component[ll_Target_Index].lquantity = arg_component[ll_Comp_Counter].lquantity
				lstr_Component[ll_Target_Index].squantity = ""
				lstr_Component[ll_Target_Index].llength = arg_component[ll_Comp_Counter].llength
				lstr_Component[ll_Target_Index].str_item_props.stext					= arg_component[ll_Comp_Counter].str_item_props.stext
				lstr_Component[ll_Target_Index].str_item_props.smeal_control_code = arg_component[ll_Comp_Counter].str_item_props.smeal_control_code
				lstr_Component[ll_Target_Index].str_item_props.sclass					= arg_component[ll_Comp_Counter].str_item_props.sclass
				lstr_Component[ll_Target_Index].str_item_props.lspml					= arg_component[ll_Comp_Counter].str_item_props.lspml
				lstr_Component[ll_Target_Index].str_item_props.llimit = 0
				
			end if
		Next
	End if	
Else
	lstr_Component = arg_component[]
End if


llMaxIndex = upperbound(lstr_Component)

//lsObjectName = "l_line_components_vertical_left"
//of_create_line(lsObjectName, llX - 10 , llY, llX - 10  , llYMax, RGB(128, 128, 128))
//
//lsObjectName = "l_line_components_vertical_right"
//of_create_line(lsObjectName, llX+ llWidth , llY, llX + llWidth , llYMax, RGB(128, 128, 128))
//
//lsObjectName = "l_line_components_header"
//of_create_line(lsObjectName,llX - 10 , llY, llX + llWidth , llY, RGB(128, 128, 128))
//llY = llY+  llHeight 




lsObjectName= "t_components_header"
lsText			= uf.translate("Mahlzeitenkomponenten")
of_create_text(lsObjectName, lsText,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD, llX, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)
llY = llY+ 2 * llHeight 

//lsObjectName = "l_line_components_Detail"
//of_create_line(lsObjectName,llX - 10, llY, llX + llWidth , llY, RGB(128, 128, 128))
//llY = llY+ llHeight 

For llIndex = 1 to llMaxIndex
	lsObjectName= "t_components_data_amount_" + string(llIndex)
	lsText = string(lstr_Component[llIndex].lquantity)
	of_create_text(lsObjectName, lsText,FONT_MICROSOFT_SANS_SERIF, 14, FONT_NORMAL, llX   , llY +  0.2 * llHeight , 2 *  llHeight , llWidthAmount, 0, 0,  RGB(0,0,0), 1)
	
	//arg_component[llIndex].ssnr
	If lstr_Component[llIndex].ssnr = "CVXFB2373" Then //"FVS11C009" Then
		lb_Breakpoint=TRUE		
	End If
	
	lsObjectName= "t_components_data_text_" + string(llIndex)
	lsText = lstr_Component[llIndex].stext
	of_create_text(lsObjectName, lsText,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, llX + llWidthAmount +llSpace, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)
	llY = llY+ llHeight
	
	lsObjectName= "t_components_data_snr_" + string(llIndex)
	lsText =lstr_Component[llIndex].ssnr
	of_create_text(lsObjectName,lsText,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, llX +llWidthAmount +llSpace, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)

	llY = llY+2 * llHeight
	if llY > llYMax Then
		exit
	End If
Next


if llY > llYMax Then
	llY =llYMax - 2*  llHeight
	lsObjectName= "t_components_end"
	of_create_line(lsObjectName,llX - 10 , llY, llX + llWidth , llY, RGB(128, 128, 128))
	llY = llY+ llHeight
	
	lsText			= uf.translate("Weitere Elemente existieren...")
	of_create_text(lsObjectName, lsText,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD, llX, llY, llHeight , llWidth, 0, 0,  RGB(255,0,0), 1)
Else
//	lsText			= "End"
End If


return llMaxIndex

end function

public function boolean of_is_header_in_footer ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_header_in_footer (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.01.2010
* Argument(e):
* none
*
* Return: boolean
*
*
* Soll der Header im Footer erscheinen
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.01.2010	1.0           Ulrich Paudler     Erstellung
*  02.02.2012	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter "Parameter statt Profile" (Service)
*                                               Variante "Section aus Instanzvariable" (WEB)
*  12.09.2012	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter je Airline statt je Betrieb (Tabelle CEN_AIRL_DIAG_FLAGS)
*
*************************************************************/

Long		ll_Value	
String	ls_Value

/*select * from CEN_AIRL_DIAG_FLAGS
 	NFLAG_ID	NAIRLINE_KEY	NHEAD_FOOT_CART	NHEAD_FOOT_TCART	NDISP_LOS_CART
1	1012	17988	0	1	1*/

// NEU: per Airline statt per Unit
If NOT isNull(isCartDiagramFooter) AND Trim(isCartDiagramFooter) > "" Then
	ls_Value = isCartDiagramFooter
Else
	select	NHEAD_FOOT_CART
	into		:ll_Value
	from		CEN_AIRL_DIAG_FLAGS
	where		NAIRLINE_KEY	 = :il_airlinekey;
	If SQLCA.SQLCode <> 0 then
		ls_Value = "0"
	Else
		If isNULL(ll_Value) Then ll_Value = 0
		ls_Value = String(ll_Value)
		
	End If
End If

// Cacheing
if isNull(isCartDiagramFooter) or isCartDiagramFooter = "" Then
	isCartDiagramFooter = ls_Value
End If

if ls_Value = "1" Then
	return True
End If


//string sValue, ssection, sDefault
//integer iconfig
//
//// ----------------------------------------------------------------------
//// 24.01.2012 bei Doc Gen Service nicht aus Profile, sondern Parameter
//// ----------------------------------------------------------------------
//If ib_use_doc_gen_settings Then
//	If inv_doc_gen_settings.il_nenable_cart_header_in_footer = 1 then
//		return TRUE
//	ELSE
//		return FALSE
//	end if
//End If
//
//If Trim(isCartDiagramFooter) > "" Then
//	sValue = isCartDiagramFooter
//Else
//	If is_section > "" Then
//		sSection = is_section
//	Else
//		sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
//		if trim(sSection) = "" Then sSection = "docbrowser"
//	End If
//		
//	if sSection <> "docbrowser" Then
//		iConfig = integer(Mid(sSection,11))
//		sDefault ="Default" +string(iConfig)
//	Else
//		sDefault ="Default"
//	End If
//	
//	// Cacheing
//	if isNull(isCartDiagramFooter) or  isCartDiagramFooter = "" Then
//		sValue = of_profilestring(s_app.suser,sDefault,"CartDiagramFooter","0") 
//		isCartDiagramFooter = sValue
//	Else
//		sValue = isCartDiagramFooter
//	End If
//End If

//if sValue = "1" Then
//	return True
//End If

return False

end function

public function long of_set_xposition (long arg_l_pos);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_set_xposition (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.01.2010
* Argument(e):
* long arg_l_pos
*
* Return: long
*
*
* Ermittlung der Position mit Offset
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
Long llPosition = 0

//Nur wenn Koponenten vorhanden sind einr$$HEX1$$fc00$$ENDHEX$$cken
if bHasDimensions Then
	if ilColumnCount > 1 Then
		if arg_l_pos > INITIALWIDTH Then
			llPosition = arg_l_pos + INITIALOFFSETSMALL2 + (INITIALWIDTHSMALL - INITIALWIDTH)
		Else
			llPosition = arg_l_pos + INITIALOFFSETSMALL2
		End If
	Else
		llPosition = arg_l_pos + INITIALOFFSETSMALL1
	End If
Else
	if ilColumnCount > 1 Then
		llPosition = arg_l_pos + INITIALOFFSET2
	Else
		llPosition = arg_l_pos + INITIALOFFSET1
	End If
End If

// blos nicht negativ werden!
if llPosition < 0 Then llPosition = 0

return llPosition


end function

public function long of_print_deinit ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print_deinit (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.01.2010
* Argument(e):
* none
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

	
// Anzeigelayout
of_modify_dw("DataWindow.Header.Height='0'")
of_modify_dw("DataWindow.Detail.Height='850'")
of_modify_dw("DataWindow.Summary.Height='0'")
of_modify_dw("DataWindow.Footer.Height='0'")


return 0
end function

public function long of_print_backlog_deinit ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print_backlog_deinit (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.01.2010
* Argument(e):
* none
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
	
// Anzeigelayout
of_modify_dw_backlog("DataWindow.Header.Height='0'")
of_modify_dw_backlog("DataWindow.Footer.Height='0'")


return 0
end function

public function long of_add_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_add_backlog (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 03.09.2009
* Argument(e):
*	long arg_l_row
*  long arg_l_column
*  string arg_s_object
*  string arg_s_text
*  long arg_l_counter
*  long arg_l_type
*
* Return: long
*
*
* Einf$$HEX1$$fc00$$ENDHEX$$gen einer Backlogzeile
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  03.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
Long		ll_NewRow
String	ls_Text, ls_Backlog



if il_Disable_Debug= 0 then
	guoLog.uf_debug( "["+ this.classname( )+".of_add_backlog Text " + arg_s_text + " / "  + " Qty "+String(arg_dec_items))
End If

// 20.01.2010 Ulrich Paudler [UP]
Choose Case arg_l_type
	Case EMPTY, BLOCKED
	//	ls_Text =uf.translate( "Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		
	Case DRAWER 
	//	ls_Text =uf.translate( "Drawer Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0

	Case TRAYNONFOOD
		ls_Text =uf.translate( "Tray Non Food")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0
	Case DRAWERFOOD
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if
		
	Case TRAY 
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if

	Case PACKINGLIST
		ls_Text =  arg_s_packinglist
		// Keine Menge > raus
		if arg_dec_items = 0.0 Then	
			ls_Backlog = arg_s_text
			//return 0
			arg_dec_items = 1
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
		Else
			If arg_dec_items = 1 Then
				ls_Backlog = arg_s_text
			Else				
				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
				If arg_dec_items = long(arg_dec_items) Then
					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
				Else
					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
				End if
			End If
		End If
		
	Case DRAWER_Multi_rung
//		//ls_Text =uf.translate( "Non Food")
//		ls_Text = ""
//		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0
		ls_Text =  arg_s_packinglist
		
		ls_Backlog = arg_s_text
		// Keine Menge > raus
		if arg_dec_items = 0.0 Then	
			//return 0
			ls_Backlog = arg_s_text
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
		Else
			If arg_dec_items <> 1 Then
				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
				If arg_dec_items = long(arg_dec_items) Then
					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
				Else
					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
				End if
			Else
				ls_Backlog = arg_s_text
			End If
		End if
		
		If Trim(arg_s_packinglist) = "" Then
//			ls_Text = ls_Backlog
//			ls_Backlog = ""
			ls_Text =  uf.translate("Drawer")
			arg_l_type = PACKINGLIST
		End If
		
End Choose


ll_NewRow = dsBacklog.insertrow(0)
dsBacklog.setitem(ll_NewRow, "nrow",				arg_l_row)
dsBacklog.setitem(ll_NewRow, "ncolumn",			arg_l_column)
dsBacklog.setitem(ll_NewRow, "cobject",			arg_s_object)
dsBacklog.setitem(ll_NewRow, "nitems",				arg_dec_items)
dsBacklog.setitem(ll_NewRow, "cunit",				arg_s_unit)
dsBacklog.setitem(ll_NewRow, "ncounter",			arg_l_counter)
dsBacklog.setitem(ll_NewRow, "ntype",				arg_l_type)
dsBacklog.setitem(ll_NewRow, "cbacklog",			ls_Backlog)
dsBacklog.setitem(ll_NewRow, "cpackinglist",		ls_Text)

dsBacklog.setitem(ll_NewRow, "nsort",		ll_NewRow)

dsBacklog.sort()

return ll_NewRow


end function

public function long of_draw_content_backlog_drawer (long arg_l_counter, long arg_i_row, long arg_i_column, datastore arg_ds_data, long arg_l_type, string arg_s_header);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_content_backlog_drawer (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 02.09.2009
* Argument(e):
* long arg_l_counter
*  Long arg_i_row
*  Long arg_i_column
*  datastore arg_ds_data
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  02.09.2009	1.0           Ulrich Paudler     Erstellung
*  13.01.2010	1.1           Ulrich Paudler     Keine Quantity
*
*************************************************************/


String ls_DWObject, ls_text, ls_unit
Decimal ld_items
s_component lstr_component 

// Textfeld
ls_DWObject = "t_content_backlog_drawer_text_" + string(arg_l_counter) + "_col_" + string(arg_i_column, "00") + "_row_" + string(arg_i_row, "00")
if of_register(ls_DWObject, arg_i_row, arg_i_column) = -1 Then
	return -1
End If

ld_items 	= arg_ds_data.GetItemdecimal(arg_l_counter, "nquantity")
ls_unit 	= arg_ds_data.GetItemString(arg_l_counter, "details_cunit")

lstr_component.stext = arg_ds_data.GetItemString(arg_l_counter, "cpackinglist_text")
lstr_component.ssnr = arg_ds_data.GetItemString(arg_l_counter, "cpackinglist_detail")	
lstr_component.squantity = ""

ls_text = of_get_item_description( lstr_component )

if arg_s_header = "" Then
	of_add_backlog( arg_i_row, arg_i_column, ls_DWObject,ld_items, ls_unit, ls_text, arg_l_counter, arg_l_type,"") 
	if il_Disable_Debug = 0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_backlog_drawer of_add_backlog TYPE=" + String(arg_l_type) +  " DS-Row " + String(arg_l_counter) + " / " + ls_text)
	End If
Else
	//of_add_backlog( arg_i_row, arg_i_column, ls_DWObject,ld_items,ls_unit, ls_text, arg_l_counter, PACKINGLIST, arg_s_header) 
	of_add_backlog( arg_i_row, arg_i_column, ls_DWObject,ld_items,ls_unit, ls_text, arg_l_counter, arg_l_type, arg_s_header) 
	if il_Disable_Debug = 0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_backlog_drawer of_add_backlog PACKINGLIST DS-Row " + String(arg_l_counter) + " / arg_s_header=" + arg_s_header + ": " + ls_text)
	End If
End If



return 1

end function

public function long of_init (long arg_lindexkey, long arg_ldetailkey, long arg_lairlinekey, string arg_sunit, datawindow arg_odw, datetime arg_ddeparture, datawindow arg_odwbacklog);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_init (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 16.04.2009
*
* Argument(e):	* long arg_llayoutkey
*  long arg_lindexkey
*  long arg_ldetailkey
*  long arg_lairlinekey
*  string arg_sunit
*  datawindow arg_odw
*  datetime arg_ddeparture
*  datawindow arg_odwbacklog
*  boolean arg_bbacklog
*
* Return: long
*
*
* wrapper zum weiterleiten des funktionsaufrufes
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*30.09.2009	1.1			Ulrich Paudler	sauberes initialisieren 
*19.01.2010	1.2			Ulrich Paudler	Unterscheidung Header im Footer
*08.02.2010	1.3			Ulrich Paudler	Backlog nach zuweisung $$HEX1$$fc00$$ENDHEX$$bersetzen
*************************************************************/
Long ll_RetVal


this.il_IndexKey	= arg_lIndexKey
this.lDetailKey	= arg_lDetailKey
il_AirlineKey	= arg_lAirlineKey
//this.sUnit			= arg_sUnit
this.oDW			= arg_odw
this.idt_Departure	= date(arg_dDeparture)
this.oDWBacklog= arg_odwbacklog
this.bBacklog     = of_is_backlog_enabled()

SELECT  max(NLAYOUT_KEY) 
	INTO :this.lLayoutKey
	FROM CEN_PACKINGLIST_LAYOUT
	WHERE NPACKINGLIST_INDEX_KEY =:arg_lindexkey AND NPACKINGLIST_DETAIL_KEY=:arg_ldetailkey 
	USING SQLCA;
	if SQLCA.SQLCode <> 0 Then
		return -1
	End If	
	
SELECT  CUNIT
	INTO :this.sUnit
	FROM CEN_PACKINGLISTS
	WHERE NPACKINGLIST_INDEX_KEY =:arg_lindexkey AND NPACKINGLIST_DETAIL_KEY=:arg_ldetailkey 
	USING SQLCA;
	if SQLCA.SQLCode <> 0 Then
		return -1
	End If		

// 19.01.2010 Ulrich Paudler [UP] Header im Footer
//Cartdiagram
if of_is_header_in_footer() Then
	arg_odw.dataobject = "dw_uo_layout_footer_n"
Else
	arg_odw.dataobject = "dw_uo_layout_n"
End If
arg_odw.InsertRow(0)

// Backlog
if of_is_header_in_footer() Then
	arg_odwbacklog.dataobject = "dw_uo_layout_backlog_footer_n"
Else
	arg_odwbacklog.dataobject = "dw_uo_layout_backlog_n"
End If

 uf.translate_datawindow(arg_odwbacklog)
//arg_odwbacklog.InsertRow(0)

// 30.09.2009 Ulrich Paudler [UP] initialisieren
iCurrentRow 	= 0
iCurrentColumn	= 0
lErrorCount 		= 0
sError 			= ""

// 10.12.2009 Ulrich Paudler [UP]
//lXOffSet 			= 50
lYOffSet 			= 30 // war 50
// 10.12.2009 Ulrich Paudler [UP]
//lDefaultWidth 	= 322
lDefaultHeight 	= 52 // war 54

// Datastores zur$$HEX1$$fc00$$ENDHEX$$cksetzen
dsLayoutDetail.Reset()
dsLayoutContents.Reset()
dsLayoutDimension.Reset()
dsLayoutAddObjects.Reset()
dsPL.Reset()
dsPLContents.Reset()
dsObjects.Reset()

// 03.09.2009 Ulrich Paudler [UP]
dsBacklog.Reset()

ll_RetVal = 	this.of_init()

return ll_RetVal


end function

public function long of_check_layout (long arg_l_indexkey, long arg_l_detailkey);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_check_layout (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 26.01.2010
* Argument(e):
* long arg_l_indexkey
*  long arg_l_detailkey
*
* Return: long
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fung ob das Layout noch aktuell ist (z.B. $$HEX1$$c400$$ENDHEX$$nderung im Cart)
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  26.01.2010	1.0           Ulrich Paudler     Erstellung
*  11.12.2013	1.1           Oliver Hoefer      Verwaiste Referenzen entfernen
*
*************************************************************/
Long 	 lRows, lColumns, llRow
Long  llMaxRows, llMaxColumns
	

//select pd.nlayout_content_key , pd.* from cen_packinglist_detail pd where pd.npackinglist_index_key = 920900


// Detail Eintr$$HEX1$$e400$$ENDHEX$$ge 
lRows 	= this.dsAirlineEq.GetItemNumber(1, "nrows")
lColumns = this.dsAirlineEq.GetItemNumber(1, "ncolumns") 

// Nur 'echte' zeilen und spalten ber$$HEX1$$fc00$$ENDHEX$$cksichtigen
dsLayoutDetail.SetFilter("ncolumn > 0 and nrow > 0")
dsLayoutDetail.Filter()

// entspricht das gespeicherte Layout dem aktuellen Stand
if dsLayoutDetail.Rowcount() = lRows * lColumns Then
	// check ok
	dsLayoutDetail.SetFilter("")
	dsLayoutDetail.Filter()
	return 0
Else
	for llRow = dsLayout.Rowcount() to 1 step -1
		dsLayout.deleterow(llRow)
	next
	for llRow = dsLayoutDetail.Rowcount() to 1 step -1
		dsLayoutDetail.deleterow(llRow)
	next
End If

dsLayoutDetail.SetFilter("")
dsLayoutDetail.Filter()
// Speichern
if this.dsLayoutDetail.Update() <> 1 Then
	rollback;
	return -2
Else
	if this.dsLayout.Update() <> 1 Then
		rollback;
		return -3
	Else
		commit;
	End If
End If

// aufr$$HEX1$$e400$$ENDHEX$$umen Referenzen
UPDATE	cen_packinglist_detail
SET		nlayout_content_key = NULL
WHERE		npackinglist_index_key = :arg_l_IndexKey
AND		npackinglist_detail_key =  :arg_l_DetailKey
AND 		nlayout_content_key is not NULL 	
USING SQLCA;
IF SQLCA.SQLCODE = 0 Then
	commit;
End If

// neu aufbauen
if this.of_create_defaults() <> 1 Then
	return 1
Else
	this.dsLayout.Retrieve(arg_l_IndexKey, arg_l_DetailKey)
	if this.dsLayout.RowCount() = 0 Then
		return 1
	End If
End If

this.lLayoutKey 		= this.dsLayout.GetItemNumber(1, "nlayout_key")
this.dsLayoutDetail.Retrieve(this.lLayoutKey)

// TSC: war das nur eine Entwickler-Meldung? Soll jedefalls raus...
//uf.mbox("Achtung", "Das Cartdiagram wurde zur$$HEX1$$fc00$$ENDHEX$$ckgesetzt!")

return 0
end function

public function long of_get_detail_height (datawindow arg_dw);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_calc_detail_height (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 20.01.2010
* Argument(e):
* datawindow arg_dw
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  20.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
long		iDWWidth, iDWHeight
long		iUseLetterFormat

// ---------------------------------------------------------------------------
// Quality High
// ---------------------------------------------------------------------------
//arg_dw.object.Print.Quality = "1" 
// ---------------------------------------------------------------------------
// Welche Orientation ? 1 = Landscape	2 = Portrait
// ---------------------------------------------------------------------------
If arg_dw.Object.DataWindow.Print.Orientation = "1" Then
	iDWWidth 	= 1083
	iDWHeight	= 793  
Elseif arg_dw.Object.DataWindow.Print.Orientation = "2" Then
	iDWWidth 	= 793  
	iDWHeight	= 1083
Else
	iDWWidth 	= 793
	iDWHeight	= 1083
End If	


/*************************************************
Papierformat einstellen
		 DIN-A4: Paper.Size=9 / Zoom=100
Letter-Format: Paper.Size=1 / Zoom=94 (Querformat)
*************************************************/
If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"

iUseLetterFormat = integer(f_mandant_profilestring(sqlca, s_app.smandant, "PaperFormat", "UseLetterFormat", "0"))

if iUseLetterFormat = 1 Then
	iDWHeight	= (iDWHeight * .94) 
	arg_dw.Modify("datawindow.print.paper.size=1")
Else
	arg_dw.Modify("datawindow.print.paper.size=9")
End If

return iDWHeight

end function

public function long of_get_detail_height (datastore arg_ds);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_detail_height (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 20.01.2010
* Argument(e):
* datawindow arg_dw
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  20.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
long 		iDWWidth, iDWHeight
long		iUseLetterFormat

// ---------------------------------------------------------------------------
// Quality High
// ---------------------------------------------------------------------------
//arg_ds.object.Print.Quality = "1" 
// ---------------------------------------------------------------------------
// Welche Orientation ? 1 = Landscape	2 = Portrait
// ---------------------------------------------------------------------------
If arg_ds.Object.DataWindow.Print.Orientation = "1" Then
	iDWWidth 	= 1083
	iDWHeight	= 793  
Elseif arg_ds.Object.DataWindow.Print.Orientation = "2" Then
	iDWWidth 	= 793  
	iDWHeight	=1083
Else
	iDWWidth 	= 793  
	iDWHeight	= 1083 
End If	


/*************************************************
Papierformat einstellen
		 DIN-A4: Paper.Size=9 / Zoom=100
Letter-Format: Paper.Size=1 / Zoom=94 (Querformat)
*************************************************/
If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"

iUseLetterFormat = integer(f_mandant_profilestring(sqlca, s_app.smandant, "PaperFormat", "UseLetterFormat", "0"))

if iUseLetterFormat = 1 Then
	iDWHeight	= (iDWHeight * .94) 
	arg_ds.Modify("datawindow.print.paper.size=1")
Else
	arg_ds.Modify("datawindow.print.paper.size=9")
End If

return iDWHeight

end function

public function boolean of_check_boundary (long arg_l_x, long arg_l_y, long arg_l_height, long arg_l_widht);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_check_boundary (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 02.02.2010
* Argument(e):
* long arg_l_x
* long arg_l_y
* long arg_l_height 
* long arg_l_widht
*
* Return: boolean
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fen ob die koordinaten innerhalb von r_frame sind
* ertmal nur die Breite pr$$HEX1$$fc00$$ENDHEX$$fen
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.01.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
long llx, lly, llwidht, llheight
if isValid(oDw) Then
	llx			= long(oDw.object.r_frame.x)
	lly			= long(oDw.object.r_frame.y)
	llwidht	= long(oDw.object.r_frame.Width) 
	llheight	= long(oDw.object.r_frame.Height)
Elseif isValid(oDs) Then
	llx			= long(oDs.object.r_frame.x) 
	lly			= long(oDs.object.r_frame.y)
	llwidht	= long(oDs.object.r_frame.Width) 
	llheight	= long(oDs.object.r_frame.Height)
End If

// rechte Seite testen
if arg_l_x + arg_l_widht > llx + llwidht Then
	return false
End If

// linke Seite testen
if arg_l_x < llx Then
	return false
End If


return true
end function

public function boolean of_check_string (string arg_s_string, string arg_s_check);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_check_string (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 02.02.2010
* Argument(e):
* string arg_s_string
*  string arg_s_check
*
* Return: boolean
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fen ob ein Sting mit der $$HEX1$$fc00$$ENDHEX$$bergebenen Zeichenkette beginnt
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  02.02.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
if Mid(arg_s_string, 1, len(arg_s_check)) = arg_s_check Then
	return TRUE
End If

return FALSE
end function

public function long of_add_text (string stext, long lx, long ly, long lheight, long lwidth);/* 
* Funktion/Event: of_add_text
* Beschreibung: 	Freitext platzieren
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 sText			Anzuzeigender Text
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	22.09.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	lFound,  a
LongLong lllSequence
String		sTName
// 02.02.2010 Ulrich Paudler [UP] Maximale xPosition ermitteln
if not of_check_boundary(lx, ly, lheight, lwidth) Then
	lx = long(oDw.object.r_frame.Width) - lwidth
End If

// --------------------------------------------------------------------------------------------------------------------
// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
// --------------------------------------------------------------------------------------------------------------------
lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)

if lllSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

sTName = "t_text_" + string(a) + "_" + string(now(), "hhmmss")
a = this.dsLayoutAddObjects.InsertRow(0)
this.dsLayoutAddObjects.SetItem(a, "nadd_object_key", lllSequence)
this.dsLayoutAddObjects.SetItem(a, "nlayout_key", this.lLayoutKey)
this.dsLayoutAddObjects.SetItem(a, "nobject_type", TEXTOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle, 4 = content
this.dsLayoutAddObjects.SetItem(a, "cobject_name", sTName)
this.dsLayoutAddObjects.SetItem(a, "nheight", 20)
this.dsLayoutAddObjects.SetItem(a, "nwidth", 100)
// 19.01.2010 Ulrich Paudler [UP]
this.dsLayoutAddObjects.SetItem(a, "nxpos", of_get_xposition(lX, sTName ))
this.dsLayoutAddObjects.SetItem(a, "nypos", lY)
this.dsLayoutAddObjects.SetItem(a, "nborderstyle", 0)
this.dsLayoutAddObjects.SetItem(a, "ntextalign", 0)
this.dsLayoutAddObjects.SetItem(a, "cfontname", "Arial")
this.dsLayoutAddObjects.SetItem(a, "nfontcolor", RGB(0,0,0))
this.dsLayoutAddObjects.SetItem(a, "nfontweight", FONT_NORMAL) 
this.dsLayoutAddObjects.SetItem(a, "nfontsize", 10)
this.dsLayoutAddObjects.SetItem(a, "cvalue", sText)
this.dsLayoutAddObjects.SetItem(a, "nresizeable", 1)
this.dsLayoutAddObjects.SetItem(a, "nmoveable", 1)

this.of_create_text(a)
	
return 1
end function

public function long of_add_content_floating (long arg_l_x, long arg_l_y, long arg_l_detail, long arg_l_sort);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_add_content_floating (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 03.02.2010
* Argument(e):
* long arg_l_x
*  long arg_l_y
*  long arg_l_detail
*  long arg_l_sort
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  03.02.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

Long	lFound, lFoundContent, lSequence, llNewRow, llLayoutDetailKey, llType
Long 	llMaxContent, llColumn, llRow
String ls_Object

if bFloatingContent Then
Else
	return  0
End If

llColumn = 0
llRow =  1

// Den Datensatz der Position suchen
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + String(llColumn) + " and nrow=" + String(llRow) + "", 1, this.dsLayoutDetail.Rowcount())
if lFound = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
Else
	llType 					= this.dsLayoutDetail.GetItemNumber(lFound, "ntype") 	
	llLayoutDetailKey 	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
	// noch nix an der Stelle
	if llType = EMPTY Then
		llType = FLOATING
		 this.dsLayoutDetail.setItem(lFound, "ntype", llType) 	
	End If
End If


Choose Case llType 
	Case FLOATING
		llMaxContent = 99
	Case Else
		return 0
end Choose

// Inhalt suchen
lFoundContent = this.dsPLContents.Find("ndetail_key = " + string(arg_l_detail) + " and nsort = " + string(arg_l_sort), 1, this.dsPLContents.RowCount())

if lFoundContent > 0 Then 
	lSequence = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)
	if lSequence = -1 Then
		sError = "Error: Sequence failed"
		return -1
	End If
	// Aktuelle Position merken
	this.iCurrentRow = llRow
	this.iCurrentColumn = llColumn
	
	llNewRow = this.dsLayoutContents.InsertRow(0)
	dsLayoutContents.SetItem(llNewRow, "nlayout_content_key", lSequence)
	dsLayoutContents.SetItem(llNewRow, "nlayout_detail_key", llLayoutDetailKey)
	
	this.dsPLContents.SetItem(lFoundContent, "nlayout_content_key", lSequence)
	
	ls_Object = "t_content_floating_" + string(llNewRow) + "_col_" + string(llColumn, "00") + "_row_" + string(llRow, "00")
	of_create_text(ls_Object, "...",FONT_MICROSOFT_SANS_SERIF, 10, FONT_BOLD, arg_l_x, arg_l_y, 15 , 100, 0, 0,  0, 1)
	if of_register(ls_Object, llRow, llColumn) = -1 Then return -1
	
	of_draw_content_floating(llLayoutDetailKey, llRow, llColumn)
	
Else
	sError = "Error: Content not found"
	return -1
End If

return 1


end function

public function long of_draw_floating (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_floating (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 03.02.2010
* Argument(e):
* long arg_irow
*  long arg_icolumn
*  long arg_itype
*  boolean arg_bnew
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  03.02.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

Long	lX,  lY, lW
Long	lFound, lRowHeight, i, lYCounter, llLayoutDetailKey
String sDWObject, sDWButtonObject
Long 	llType


// Die Position(en) im Trolley muss als geblockt markiert werden
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_iColumn) + " and nrow=" + string(arg_iRow) + "", 1, this.dsLayoutDetail.Rowcount())
if lFound = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
End If

// ---------------------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
// ---------------------------------------------------------------------------
llType 			= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")

// Position ist bereits benutzt, nur bei Neuanlage pr$$HEX1$$fc00$$ENDHEX$$fen
if arg_bNew and (llType <> EMPTY)  Then
	sError = "Positon in use"
	return -1
End If

this.dsLayoutDetail.Setitem(lFound, "ntype", arg_itype)

llLayoutDetailKey 	= this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")

// Bild, dient als Button zum sp$$HEX1$$e400$$ENDHEX$$teren $$HEX1$$f600$$ENDHEX$$ffnen der Contents
// in einem eigenen Dialog
sDWButtonObject = "p_button_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", 15 , 30 , 14, 14, 0, 0, 0)
//of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", 10 , 30 , 14, 14, 0, 0, 0)
if of_register(sDWButtonObject, arg_iRow, arg_iColumn) = -1 Then return -1


this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey))
this.dsLayoutContents.Filter()
this.dsLayoutContents.Sort()

if this.dsLayoutContents.RowCount() = 0 Then
	// Noch nichts zugeordnet
Else
	of_draw_content_floating( llLayoutDetailKey, arg_iRow, arg_iColumn)
	// -----------------------------------
	// Den Button nach oben, sonst kann
	// er nicht angeklickt werden
	// -----------------------------------
	of_set_position(sDWButtonObject, True)
End If

this.dsLayoutContents.SetFilter("")
this.dsLayoutContents.Filter()
this.dsLayoutContents.Sort()

return 1

end function

public function long of_draw_content_floating (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_content_floating (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 03.02.2010
* Argument(e):
* long arg_llayoutdetailkey
*  long arg_irow
*  long arg_icolumn
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  03.02.2010	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

String ls_Filter, ls_Object, ls_Mod, lsText, lsHeaderText
long ll_Row, lX1, lX2, lRowHeight, lYCounter, lPercentQuantity, lPercentUnit, lPercentText,  lWidthQuantity, lWidthtUnit,  lWidthText
long lContentIndexKey,  lContentDetailKey
long llMaxContent, llMaxContentEx
long llTextWidth
s_component lstr_component


this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter()
this.dsLayoutContents.Sort()

if this.dsLayoutContents.RowCount() = 0 Then
	// Noch nichts zugeordnet
	return 1
End If

ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
Next
this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()


this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_floating_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()
// -------------------------------------------------
// Alle Textobjekte l$$HEX1$$f600$$ENDHEX$$schen
// -------------------------------------------------
For ll_Row = this.dsObjects.RowCount() to 1 step -1
	ls_Object = this.dsObjects.Getitemstring(ll_Row, "cobject")
	if of_check_string(ls_Object,"t_content_floating_" ) Then
		this.of_unregister(ls_Object)
	End If
Next

this.dsObjects.SetFilter("" )
this.dsObjects.Filter()
this.dsObjects.Sort()

// ----------------------------------------------------------
// Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
// ----------------------------------------------------------
llTextWidth = lDefaultWidth - 45
lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth/2
lRowHeight = 14
lYCounter = 0

For ll_Row = 1 to this.dsPLContents.RowCount()
	ls_Object = "t_content_floating_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
	of_create_text(ls_Object, "...",FONT_MICROSOFT_SANS_SERIF, 10, FONT_BOLD, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 10 + (lRowHeight * (lYCounter )), 15 , llTextWidth, 0, 0,  0, 1)
	if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then return -1
	lYCounter ++
Next

// -------------------------------------------------
// Erstmal alle Texte wieder resetten
// -------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_floating_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()

For ll_Row = 1 to this.dsObjects.RowCount()
	if of_check_string(this.dsObjects.GetItemstring(ll_Row, "cobject"),"t_content_floating_" ) Then
		of_modify_text( this.dsObjects.GetItemstring(ll_Row, "cobject") , "")
	End If
Next

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

// ----------------------------------------------------------
// Texte neu eintragen
// ----------------------------------------------------------

this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_floating_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()

For ll_Row = 1 to this.dsPLContents.RowCount()
	ls_Object = this.dsObjects.GetItemstring(ll_Row, "cobject")
	lstr_component.stext = this.dsPLContents.GetItemString(ll_Row, "cen_packinglists_ctext")
	lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
	lstr_component.squantity = ""
	lsText =  of_get_item_description(lstr_component)
	of_modify_text( ls_Object , lsText)
Next

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()


this.dsPLContents.SetFilter("")
this.dsPLContents.Filter()
this.dsPLContents.Sort()

return 0

end function

public function long of_draw_content_backlog_tray (long arg_l_counter, long arg_i_row, long arg_i_column, string arg_s_text, long arg_l_type);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_content_backlog_tray (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 02.09.2009
* Argument(e):
* long arg_l_counter
*  Long arg_i_row
*  Long arg_i_column
*  string arg_s_text
*  Long	arg_l_type
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  02.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
String ls_DWObject

ls_DWObject = "t_content_backlog_tray_text_" + string(arg_l_counter) + "_col_" + string(arg_i_column, "00") + "_row_" + string(arg_i_Row, "00")
if of_register(ls_DWObject, arg_i_row, arg_i_column) = -1 Then
	//return -1
End if

of_add_backlog( arg_i_row, arg_i_column, ls_DWObject, 0,"", arg_s_text, arg_l_counter, arg_l_type,"")

// ----------------------------------------------------------------------------------------------------
// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
//							 should appear automatically and a Content spec should be generated
// ----------------------------------------------------------------------------------------------------
If ib_non_sky then
	of_modify_text(ls_DWObject, is_Overflow_MSG_1)
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_backlog_tray non sky BACKLOG => CONTENT SPEC " + arg_s_text) 
	//lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
	// add content spec ###########					
End If


return 1
end function

public function integer of_check_object_width ();/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_check_object_width (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster [KF]
* Datum  : 22.04.2010
*
* Argument(e):	
* Return: integer
*
*
* Objektbreiten anpassem
*
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
* 22.10.2009	1.1			Klaus F$$HEX1$$f600$$ENDHEX$$rster	Erstellung
* 03.08.2011	1.2			Oliver H$$HEX1$$f600$$ENDHEX$$fer 	Absturz bei lColumn=0
************************************************************************************************/

String 	sLogoPathPictureName
String 	sPicture
String  	 sPictureName

integer 	i, &
			j, &
			iCount, &
			iPos, &
			iY, &
			iLen

Blob		bBlob

string 	sDWObjects, &
			sTemp, &
			sObjects[], &
			sValidObjects[], &
			sBand, &
			sSyntax, &
			sObject, &
			sType, &
			lTaborder, &
			sTag, sFilter

long 		lx, &
			lY, &
			lWidth, &
			lColumn, &
			lFound, &
			lDiff
			
String	ls_temp
Boolean	lb_Break = FALSE

if isvalid(oDs) Then
	 sDWObjects   = oDS.describe("datawindow.objects")
	 sFilter   = this.dsObjects.describe("datawindow.table.filter")
Elseif  isvalid(oDw) Then
	 sDWObjects   = oDW.describe("datawindow.objects")
	 sFilter   =  this.dsObjects.describe("datawindow.table.filter")
Else
	return -1
End If

// ----------------------------------------
// 29.04.2010, KF
// Wenn kein Filter gesetzt ist, dann
// liefert describe ein ?
// ----------------------------------------
if len(sFilter) = 1 Then
	sFilter = ""
End If

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
	
	if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If

next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If

// ---------------------------------------
// Nun Pr$$HEX1$$fc00$$ENDHEX$$fen, ob die Objekte sichtbar
// im Detailband sind
// ---------------------------------------
this.dsObjects.SetFilter("")
this.dsObjects.Filter()

for i = 1 to UpperBound(sObjects)
	
	
	if isvalid(ods) Then
			lX 			= Long(ods.Describe(sObjects[i] + ".X"))
			ly 			= Long(ods.Describe(sObjects[i] + ".Y")) 
			lWidth 	= Long(ods.Describe(sObjects[i] + ".Width")) 
		Elseif isvalid(odw) Then
			lX 			= Long(odw.Describe(sObjects[i] + ".X"))
			ly 			= Long(odw.Describe(sObjects[i] + ".Y")) 
			lWidth 	= Long(odw.Describe(sObjects[i] + ".Width")) 
		End If
		
	
	// --------------------------------------------------------------
	// Pr$$HEX1$$fc00$$ENDHEX$$fen der Freitexte mit link zu Details
	// --------------------------------------------------------------
	if  of_check_string(sObjects[i],"t_freetext_content") Then
		
		if isvalid(ods) Then
			lDiff = long(ods.object.r_frame.Width) - (lX + lWidth)
			if  lDiff < 0  Then
				oDS.Modify(sObjects[i] + ".Width=" + string(lWidth + lDiff))
				guoLog.uf_debug("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " modified in Datastore")
			End If
		End If
		
		if isvalid(odw) Then
			lDiff = long(odw.object.r_frame.Width) - (lX + lWidth)
			if  lDiff < 0  Then
				odw.Modify(sObjects[i] + ".Width=" + string(lWidth + lDiff))
				guoLog.uf_debug("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " modified in datawindow")
			End If
		End If

	End If
	
	// --------------------------------------------------------------
	// Pr$$HEX1$$fc00$$ENDHEX$$fen der statischen Contents innerhalb von
	// Einsch$$HEX1$$fc00$$ENDHEX$$ben und Trays
	// --------------------------------------------------------------
	if Pos(sObjects[i], "t_content_tray") > 0 or &
		Pos(sObjects[i], "t_content_text") > 0 or  &
		Pos(sObjects[i], "t_content_std_text") > 0 or  &
		Pos(sObjects[i], "t_content_header") > 0 Then
	
		guoLog.uf_debug("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Check for Object " + sObjects[i] )
		lFound = this.dsObjects.Find("cobject = '" + Trim(sObjects[i]) + "'", 1, this.dsObjects.RowCount())
		if lFound <= 0 Then 
			guoLog.uf_error("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " not in Datastore +  ???")
			guoLog.uf_error("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Error - lFound says " + string(lFound))
			guoLog.uf_error("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Error - current datastore filter is "  + sFilter)
			//this.dsObjects.SaveAs(f_gettemppath() + sObjects[i] + ".xls" , Excel5!, True)
			return -1
		Else
			lColumn = this.dsObjects.GetItemNumber(lFound, "ncolumn")
		End If
		
		if lColumn > UpperBound(ilColumnWidth) Then
			guoLog.uf_error("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " more Columns Then definied")
			return -1
		End If 			
		
		if lColumn < 1 Then
			guoLog.uf_error("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " lColumn = 0")
			CONTINUE
		End If 
		
		// -------------------------------------------------------------------------------
		// Ausrechnen, ob das Objekt breiter ist als die Spalte in der es steht
		// -------------------------------------------------------------------------------
		lDiff =  (ilColumnX[lColumn] + ilColumnWidth[lColumn]) - (lX + lWidth)
		
		if lDiff < 0 Then
			lWidth = lWidth + lDiff
			if isvalid(ods) Then
				If lWidth > 0 Then
					oDS.Modify(sObjects[i] + ".Width=" + string(lWidth))
					guoLog.uf_debug("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " modified in Datastore")
				End If
			Elseif isvalid(odw) Then
				If lWidth > 0 Then
					oDW.Modify(sObjects[i] + ".Width=" + string(lWidth))
					guoLog.uf_debug("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " modified in Datastore")
				End If
			Else
				guoLog.uf_debug("["+ this.classname( )+".of_check_object_width] "  +  this.isStowage +" - " + "Object " + sObjects[i] + " not modified in Datastore or Datawindow")
			End If
			
		End If
	End If
next 

this.dsObjects.SetFilter(sFilter)
this.dsObjects.Filter()
this.dsObjects.Sort()

return 1
end function

public function long of_get_xposition (long arg_l_pos, string arg_s_object);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_xposition (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.01.2010
* Argument(e):
* long arg_l_pos
*
* Return: long
*
*
* Normierung der Position auf Standard Cart ohne Offset
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.01.2010	1.0           Ulrich Paudler     Erstellung
*	27.04.2010	1.1			Klaus				Keine XPos Anpassung f$$HEX1$$fc00$$ENDHEX$$r Freitexte
*************************************************************/
Long llPosition = 0

if bHasDimensions Then
	if ilColumnCount > 1 Then
		if arg_l_pos > INITIALOFFSET2 + INITIALWIDTHSMALL Then
			llPosition = (arg_l_pos -  (INITIALOFFSETSMALL2 + INITIALWIDTHSMALL)) + INITIALWIDTH
		Else
			llPosition = arg_l_pos -  (INITIALOFFSETSMALL2)
		End If
	Else
		llPosition = arg_l_pos -  (INITIALOFFSETSMALL1)
	End If
Else
	if ilColumnCount > 1 Then
		llPosition = arg_l_pos -  (INITIALOFFSET2)
	Else
		llPosition = arg_l_pos -  (INITIALOFFSET1)
	End If
End If

// Nicht negativ werden
if llPosition < 0 Then llPosition = 0

return llPosition


end function

public function long of_create_content_freetext (long lrow);/* 
* Funktion/Event: of_create_content_freetext
* Beschreibung: 	An Detailzeile gebundendn Freitext anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	lRow			= Zeile aus dsLayoutAddObjects f$$HEX1$$fc00$$ENDHEX$$r die der Text gezeichnet werden soll
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		07.05.2010		Erstellung
*	1.1 			O.H$$HEX1$$f600$$ENDHEX$$fer  		29.08.2011		Not Found Error: Filter entfernen
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String				sRet
s_component 	lstr_component
Long		iAlign, iBorder, iColor, lX, lY, lHeight, lWidth, iFontSize, iFontWeight,iMove, iResize,  lFOund, lLayoutContentKey
LongLong	lllAddKey
String	sObjectName, sFont, sText, sTag
Integer	li_Succ

iAlign				= this.dsLayoutAddObjects.GetItemNumber(lRow, "ntextalign")
iBorder			= 0 //this.dsLayoutAddObjects.GetItemNumber(lRow, "nborderstyle")
iColor				= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontcolor")

sObjectName = this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")
// nicht nach links abdriften!
if lX < 0 Then lX = 0
lX					= this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos")
lY					= this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
lHeight			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nheight")
lWidth			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nwidth")
iFontSize			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontsize")
iFontWeight		= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontweight")
iMove				= this.dsLayoutAddObjects.GetItemNumber(lRow, "nmoveable")
iResize			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nresizeable")
sObjectName	= this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")
sFont				= this.dsLayoutAddObjects.GetItemString(lRow, "cfontname")

lX = of_adjust_xposition(lX , sObjectName)

lLayoutContentKey = this.dsLayoutAddObjects.GetItemNumber(lRow, "nlayout_content_key")

li_Succ = dsPLContents.SetFilter("")
li_Succ = dsPLContents.Filter()

lFound = this.dsPLContents.Find("nlayout_content_key=" + string(lLayoutContentKey), 1 ,this.dsPLContents.RowCount() )

if lFound > 0 Then
	lstr_component.stext 		= this.dsPLContents.GetItemString(lFound, "cen_packinglists_ctext")
	lstr_component.ssnr 		= this.dsPLContents.GetItemString(lFound, "cen_packinglist_index_cpackinglist")
	lstr_component.squantity	= ""
	
	if  this.dsPLContents.GetItemNumber(lFound, "nquantity") > 0.0 and (this.dsPLContents.GetItemNumber(lFound, "nquantity") <> 1.0 OR ib_suppress_qty_1 = FALSE) Then
		lstr_component.squantity	= string( this.dsPLContents.GetItemNumber(lFound, "nquantity"))
	Else
		lstr_component.squantity	= ""
	End If
	
	sText = of_get_item_description(lstr_component)
	
Else
	sText = string(lLayoutContentKey) + " not found!!! "
End If

sTag				= String(this.dsLayoutAddObjects.GetItemNumber(lRow, "nlayer"))
lllAddKey			= this.dsLayoutAddObjects.GetItemNumber(lRow, "nadd_object_key")

if isnull(sTag) Then sTag = ""

if iFontSize > 0 Then iFontSize = iFontSize * -1


sCreate = "create text(band=detail alignment='" + string(iAlign) + "' " + &
			"text='" + sText + "' border='" + string(iBorder) + "' color='" + String(iColor) + "' " + &
			"x='" + string(lX) +  "' y='" + string(lY) + "' " + &
			" height='"+ String(lHeight) + "' width='" + string(lWidth) + "' " + &
			" name=" + sObjectName+&
			" tag='" + sTag + "'" + &
			" visible='1' resizeable=" + String(iResize) + "  moveable=" + String(iMove) + " font.face='" + sFont + "' " + &
			" font.height='" + String(iFontSize) + "' font.weight='" + String(iFontWeight) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"


if isValid(oDw) Then
	if oDw.Describe(sObjectName +".Text")<> "!" Then
		return 0
	Else
		sRet = oDw.modify(sCreate)
	End If
End If

if isValid(oDS) Then
	if oDS.Describe(sObjectName +".Text")<> "!" Then
		return 0
	Else
		sRet = oDS.modify(sCreate)
	End If
	
End If

 if this.dsLayoutAddObjects.GetItemNumber(lRow, "nexploded")> 0 Then
	this.of_explode_content_freetext(sObjectName, 0)
End If

return 1

end function

public function long of_add_content_freetext (long lx, long ly, long lheight, long lwidth, long ldetail, long lsort);/* 
* Funktion/Event: of_add_content_freetext
* Beschreibung: 	An Detailzeile gebundenen Freitext platzieren
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 lx
*	ly
*	lheight
*	lwidth
*	lDetail
*	lSort
*
*
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		07.05.2010		Erstellung
*	1.1 			O.Hoefer			30.05.2011		Sequence Problem repariert
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	lFound, a
String		sTName
Long			ll_Sequence_CONT
LongLong    lll_Sequence_ADD
// 02.02.2010 Ulrich Paudler [UP] Maximale xPosition ermitteln
//if not of_check_boundary(lx, ly, lheight, lwidth) Then
//	lx = long(oDw.object.r_frame.Width) - lwidth
//End If

// --------------------------------------------------------------------------------------------------------------------
// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
// --------------------------------------------------------------------------------------------------------------------
lll_Sequence_ADD = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)

if lll_Sequence_ADD = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

// ----------------------------------------------------------------------------------
// Sequence von Tabelle cen_pl_layout_contents wird hier auch ben$$HEX1$$e400$$ENDHEX$$tigt
// um den Freitext mit der Detaizeile zu verlinken
// ----------------------------------------------------------------------------------
ll_Sequence_CONT = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)
	
if ll_Sequence_CONT = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If


sTName = "t_freetext_content_" + string(a) + "_" + string(now(), "hhmmss")
a = this.dsLayoutAddObjects.InsertRow(0)
this.dsLayoutAddObjects.SetItem(a, "nadd_object_key", lll_Sequence_ADD)
this.dsLayoutAddObjects.SetItem(a, "nlayout_key", this.lLayoutKey)
this.dsLayoutAddObjects.SetItem(a, "nobject_type", CONTENT_TEXT_OBJECT) 
this.dsLayoutAddObjects.SetItem(a, "cobject_name", sTName)
this.dsLayoutAddObjects.SetItem(a, "nheight", 20)
this.dsLayoutAddObjects.SetItem(a, "nwidth", 200)
// 19.01.2010 Ulrich Paudler [UP]
this.dsLayoutAddObjects.SetItem(a, "nxpos", lx) //of_get_xposition(lX, sTName ))
this.dsLayoutAddObjects.SetItem(a, "nypos", lY)
this.dsLayoutAddObjects.SetItem(a, "nborderstyle", 0)
this.dsLayoutAddObjects.SetItem(a, "ntextalign", 0)
this.dsLayoutAddObjects.SetItem(a, "cfontname", "Arial")
this.dsLayoutAddObjects.SetItem(a, "nfontcolor", RGB(0,0,0))
this.dsLayoutAddObjects.SetItem(a, "nfontweight", FONT_NORMAL) 
this.dsLayoutAddObjects.SetItem(a, "nfontsize", 10)
this.dsLayoutAddObjects.SetItem(a, "cvalue", "N/A")
this.dsLayoutAddObjects.SetItem(a, "nresizeable", 1)
this.dsLayoutAddObjects.SetItem(a, "nmoveable", 1)
this.dsLayoutAddObjects.SetItem(a, "nlayout_content_key", ll_Sequence_CONT)
this.dsLayoutAddObjects.SetItem(a, "nexploded", 0)
this.dsLayoutAddObjects.SetItem(a, "nlayer", 1)

this.dsLayoutAddObjects.SetItem(a, "csubfontname", "Arial")
this.dsLayoutAddObjects.SetItem(a, "nsubfontcolor", RGB(0,0,0))
//this.dsLayoutAddObjects.SetItem(a, "nsubtextalign", 0)
this.dsLayoutAddObjects.SetItem(a, "nsubfontweight", FONT_NORMAL) 
this.dsLayoutAddObjects.SetItem(a, "nsubfontsize", 10)


Long lFoundContent
// Inhalt suchen
lFoundContent = this.dsPLContents.Find("ndetail_key = " + string(lDetail) + " and nsort = " + string(lSort), 1, this.dsPLContents.RowCount())

if lFoundContent > 0 Then 
	this.dsPLContents.SetItem(lFoundContent, "nlayout_content_key", ll_Sequence_CONT)
	this.of_create_content_freetext(a)
Else
	sError = "Error: Content not found"
	this.dsLayoutAddObjects.DeleteRow(a)
	return -1
End If


return 1
end function

public function integer of_get_objects (ref string sobjects[]);/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_objects (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster [KF]
* Datum  : 22.04.2010
*
* Argument(e):	
* Return: integer
*
*
* Alle Objekte des DW's in ein Array packen
*
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
* 22.10.2009	1.1			Klaus F$$HEX1$$f600$$ENDHEX$$rster	Erstellung
************************************************************************************************/

String	sPicture
String	sPictureName

integer 	i, &
			j, &
			iCount, &
			iPos, &
			iY, &
			iLen

Blob		bBlob

string 	sDWObjects, &
			sTemp, &
			sValidObjects[], &
			sBand, &
			sSyntax, &
			sObject, &
			sType, &
			lTaborder, &
			sTag, sFilter

long 		lx, &
			lY, &
			lWidth, &
			lColumn, &
			lFound, &
			lDiff
			
String	ls_temp

if isvalid(oDs) Then
	 sDWObjects   = oDS.describe("datawindow.objects")
	 sFilter   = this.dsObjects.describe("datawindow.table.filter")
Elseif  isvalid(oDw) Then
	 sDWObjects   = oDW.describe("datawindow.objects")
	 sFilter   =  this.dsObjects.describe("datawindow.table.filter")
Else
	return -1
End If

// ----------------------------------------
// 29.04.2010, KF
// Wenn kein Filter gesetzt ist, dann
// liefert describe ein ?
// ----------------------------------------
if len(sFilter) = 1 Then
	sFilter = ""
End If

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
	
	if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If

next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If

return 0

end function

public function integer of_explode_content_remove_subs (string sancestorobject);/*********************************************************************************************
* Objekt : uo_cart_diagram
* Methode: of_explode_content_remove_childs (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster [KF]
* Datum  : 22.04.2010
*
* Argument(e):	
* Return: integer
*
*
* Subkomponenten einer ESL l$$HEX1$$f600$$ENDHEX$$schen
*
*
***********************************************************************************************
* Modifikationen:
* Datum			Version    Autor				Kommentar
*-----------------------------------------------------------------------------------------------
* 22.10.2009	1.1			Klaus F$$HEX1$$f600$$ENDHEX$$rster	Erstellung
************************************************************************************************/
Long i
String sObjects[]
String sRet


of_get_objects(sObjects)

for i = 1 to UpperBound(sObjects)
	
	if isValid(oDS) Then
		if lower(ods.Describe(sObjects[i] + ".tag")) = lower(sAncestorObject) Then
			sRet = oDS.modify("Destroy " + sObjects[i])
			if sRet <> "" Then guoLog.uf_error("["+ this.classname( )+".of_explode_content_remove_subs] "  +  this.isStowage +" - " + sObjects[i] + "| - oDS destroy failed")
		End If
	End If
	
	if isValid(oDW) Then
		if lower(oDW.Describe(sObjects[i] + ".tag")) = lower(sAncestorObject) Then
			sRet = oDW.modify("Destroy " + sObjects[i])
			if sRet <> "" Then guoLog.uf_error("["+ this.classname( )+".of_explode_content_remove_subs] "  +  this.isStowage +" - " + sObjects[i] + "| - oDW destroy failed")
		End If
	End If
	
next


return 1

end function

public function long of_get_object_x (string sobject);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_x (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
* Datum  : 10.05.2010
* Argument(e):
* string sObject
*
* Return: long
*
*
* 
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  10.05.2010				Klaus F$$HEX1$$f600$$ENDHEX$$rster     Erstellung
*
*************************************************************/

	
if isValid(oDw) Then
	return Long(oDw.Describe(sObject + ".X"))
End If

if isValid(oDS) Then
	return Long(oDs.Describe(sObject + ".X"))
End If
			
return 0
end function

public function long of_get_object_y (string sobject);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_y (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
* Datum  : 10.05.2010
* Argument(e):
* string sObject
*
* Return: long
*
*
* 
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  10.05.2010				Klaus F$$HEX1$$f600$$ENDHEX$$rster     Erstellung
*
*************************************************************/

	
if isValid(oDw) Then
	return Long(oDw.Describe(sObject + ".Y"))
End If

if isValid(oDS) Then
	return Long(oDs.Describe(sObject + ".Y"))
End If
			
return 0
end function

public function long of_get_object_height (string sobject);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_object_height (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
* Datum  : 10.05.2010
* Argument(e):
* string sObject
*
* Return: long
*
*
* 
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  10.05.2010				Klaus F$$HEX1$$f600$$ENDHEX$$rster     Erstellung
*
*************************************************************/

	
if isValid(oDw) Then
	return Long(oDw.Describe(sObject + ".height"))
End If

if isValid(oDS) Then
	return Long(oDs.Describe(sObject + ".height"))
End If
			
return 0

end function

public function long of_get_object_width (string sobject);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_object_width (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
* Datum  : 10.05.2010
* Argument(e):
* string sObject
*
* Return: long
*
*
* 
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  10.05.2010				Klaus F$$HEX1$$f600$$ENDHEX$$rster     Erstellung
*
*************************************************************/

	
if isValid(oDw) Then
	return Long(oDw.Describe(sObject + ".width"))
End If

if isValid(oDS) Then
	return Long(oDs.Describe(sObject + ".width"))
End If
			
return 0
end function

public function integer of_explode_content_freetext (string sobject, integer icreate);
/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_explode_content_freetext (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
* Datum  : 07.05.2010
* Argument(e):
* 
* sObject 
*
* Return: long
*
*
* Exploden, bzw. implodieren einer St$$HEX1$$fc00$$ENDHEX$$ckliste
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  07.05.2010	1.0         Klaus F$$HEX1$$f600$$ENDHEX$$rster    Erstellung
*  21.11.2012	1.1		T.Brackmann	 DateTime() f$$HEX1$$fc00$$ENDHEX$$r idt_Departure eingesetzt
*  08.05.2014	1.2		Margret N$$HEX1$$fc00$$ENDHEX$$ndel	 dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*************************************************************/
Long lFound, lFoundContent, lContentLayoutKey, lContentIndexKey, lContentDetailKey
Long lRow, lNull
Long lSequence, lExplode
String	sRet, sCreate, sFont, sTag, sObjectName, sText
Long	lX, lY,lHeight,lWidth,lFontSize,lFontWeight,lMove,lResize, lAlign, lBorder, lColor
s_component	lstr_component

datastore	lds_Temp


Setnull(lNull)

this.dsLayoutAddObjects.SetFilter("")
this.dsLayoutAddObjects.Filter()

lFound = this.dsLayoutAddObjects.Find("cobject_name='" + sObject + "'", 1, dsLayoutAddObjects.RowCount())

if lFound <= 0 Then 
	guoLog.uf_error("["+ this.classname( )+".of_explode_content_freetext] "  +  this.isStowage +" - " + "text object not found " + sObject)
	return -1
End If

lExplode = this.dsLayoutAddObjects.GetItemNumber(lFound, "nexploded")

if isnull(lExplode) Then lExplode = 0

if (lExplode = 0 and iCreate = 1)  or (lExplode > 0 and iCreate = 0) Then // Explodieren

	this.of_explode_content_remove_subs(sObject)

	// Index und Detailkey des Inhalts ermitteln
	lContentLayoutKey = this.dsLayoutAddObjects.GetItemNumber(lFound, "nlayout_content_key")
	lFoundContent = this.dsPLContents.Find("nlayout_content_key=" + string(lContentLayoutKey), 1, dsPLContents.RowCount())
	if lFoundContent <= 0 Then
		guoLog.uf_error("["+ this.classname( )+".of_explode_content_freetext] "  +  this.isStowage +" - " + "cant' find link to detail record " + sObject)
		return -1
	End If
	
	lContentIndexKey		= this.dsPLContents.GetItemNumber(lFoundContent, "ndetail_key")
	lContentDetailKey		= this.dsPLContents.GetItemNumber(lFoundContent, "npackinglist_detail_detail_key")

	// Dann die Inhalte des Inhalts :)) retrieven
	lds_Temp = create datastore
	lds_Temp.dataobject = "dw_packinglist_edit_content"
	lds_Temp.SetTransObject(sqlca)
	lds_Temp.Retrieve(lContentIndexKey, lContentDetailKey, DateTime(idt_Departure),0) // TBR 21.11.2012
	lds_Temp.SetSort("nsort a")
	lds_Temp.Sort()
		
	lAlign				= this.dsLayoutAddObjects.GetItemNumber(lFound, "ntextalign")
	lBorder			= 0 //this.dsLayoutAddObjects.GetItemNumber(lFound, "nborderstyle")
	lColor				= this.dsLayoutAddObjects.GetItemNumber(lFound, "nsubfontcolor")
	lX					= this.of_get_object_x(sobject) + 10
	lY					= this.of_get_object_y(sobject) + this.dsLayoutAddObjects.GetItemNumber(lFound, "nheight") + 2
	lHeight			= this.of_get_object_height(sobject)
	lWidth			= this.of_get_object_width(sobject) - 10
	lFontSize			= this.dsLayoutAddObjects.GetItemNumber(lFound, "nsubfontsize")
	if lFontSize > 0 Then lFontSize = lFontSize * -1
	lFontWeight		= this.dsLayoutAddObjects.GetItemNumber(lFound, "nsubfontweight")
	lMove				= 0
	lResize			= 0
	
	sFont				= this.dsLayoutAddObjects.GetItemString(lFound, "csubfontname")
	sTag				= sObject	
	
	// F$$HEX1$$fc00$$ENDHEX$$r jeden Ihnalt des Inhalts ein Textobjekt erzeugen
	For lRow = 1 to lds_Temp.RowCount()
		sObjectName	= "t_child_" + string(lRow) + "_" +  sObject
	
		lstr_component.stext 		= lds_Temp.GetItemString(lRow, "cpackinglist_text")
		lstr_component.ssnr 		= lds_Temp.GetItemString(lRow, "cpackinglist_detail")
		lstr_component.squantity	= ""
		
		if (lds_Temp.GetItemNumber(lRow, "nquantity") <> 1.0 OR ib_suppress_qty_1 = FALSE ) Then
			lstr_component.squantity	= string( lds_Temp.GetItemNumber(lRow, "nquantity"))
		Else
			lstr_component.squantity	= ""
		End If
		
		sText = of_get_item_description(lstr_component)
	
		sCreate = "create text(band=detail alignment='" + string(lAlign) + "' " + &
				"text='" + sText + "' tag='" + sObject + "' border='" + string(lBorder) + "' color='" + String(lColor) + "' " + &
				"x='" + string(lX) +  "' y='" + string(lY) + "' " + &
				" height='"+ String(lHeight) + "' width='" + string(lWidth) + "' " + &
				" name=" + sObjectName + &
				" visible='" + string(1) + "' resizeable=" + String(lResize) + "  moveable=" + String(lMove) + " font.face='" + sFont + "' " + &
				" font.height='" + String(lFontSize) + "' font.weight='" + String(lFontWeight) + "' font.family='2' font.pitch='2'" + &
				" font.charset='0' font.italic='0' font.underline='0'" +&
				" background.mode='1'" + &
				" background.color='536870912')"
			
		lY = lY + lHeight
		if isValid(oDw) Then
			sRet = oDw.modify(sCreate)
		End If
		
		if isValid(oDS) Then
			sRet = oDS.modify(sCreate)
		End If
	Next			
	
	this.dsLayoutAddObjects.SetItem(lFound, "nexploded", lds_Temp.RowCount())
	destroy(lds_Temp)
Else // Implodieren
	
	this.dsLayoutAddObjects.SetItem(lFound, "nexploded", 0)
	this.of_explode_content_remove_subs(sObject)
	
End If
	
if IsValid(lds_Temp) then destroy lds_Temp 

return 0
end function

public function long of_draw_drawer_3_rung (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew);/* 
* Funktion/Event: of_draw_drawer_3_rung
* Beschreibung: 	Einschub zeichnen
*							
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 arg_iRow				Zeile
**	 arg_iColumn			"Spalte"
*	 iargtype     Neuanlage = -1, sonst 1 oder 2
*	 
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		17.05.2010	Erstellung

* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/

Long	lX1
Long	lX2
Long	lFound, lFoundNext, lFoundPrev, lRowHeight, i, lYCounter, lNewDetailKey
String sDWObject, sDWButtonObject
Long iType, iTypeNext, iTypePrev
Long lY, lW


if arg_iRow >= dsAirlineEq.GetItemNumber(1, "nrows") Then
	// Letzte Schiene kann nicht genutzt werde f$$HEX1$$fc00$$ENDHEX$$r Trolleys
	sError = "Position cannot be used for drawers"
	return -1
End If

// Die Position(en) im Trolley muss als geblockt markiert werden
lFoundPrev 	= this.dsLayoutDetail.Find("ncolumn=" + string(arg_iColumn) + " and nrow=" + string(arg_iRow - 1), 1, this.dsLayoutDetail.Rowcount())
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_iColumn) + " and nrow=" + string(arg_iRow), 1, this.dsLayoutDetail.Rowcount())
lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(arg_iColumn) + " and nrow=" + string(arg_iRow + 1), 1, this.dsLayoutDetail.Rowcount())

if lFoundPrev = 0 or lFound = 0 or lFoundNext = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
End If

// ---------------------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob Platz ist
// ---------------------------------------------------------------------------
iTypePrev 	= this.dsLayoutDetail.Getitemnumber(lFoundPrev, "ntype")
iType 			= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
iTypeNext 	= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")

// Position ist bereits benutzt, nur bei Neuanlage pr$$HEX1$$fc00$$ENDHEX$$fen
//if (iType <> 0 or iTypeNext <> 0) and arg_iType >= 0 Then
if arg_bNew and (iTypePrev <> EMPTY or iType <> EMPTY or iTypeNext <> EMPTY)  Then
	sError = "Positon in use"
	return -1
End If

// Aktuelle Position merken
this.iCurrentRow = arg_iRow
this.iCurrentColumn = arg_iColumn

this.dsLayoutDetail.Setitem(lFoundPrev, "ntype", BLOCKED)
this.dsLayoutDetail.Setitem(lFound, "ntype", arg_itype)
this.dsLayoutDetail.Setitem(lFoundNext, "ntype", BLOCKED)

lNewDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
this.dsLayoutDetail.Setitem(lFoundPrev, "nancestor", lNewDetailKey)
this.dsLayoutDetail.Setitem(lFound, "nancestor", lNewDetailKey)
this.dsLayoutDetail.Setitem(lFoundNext, "nancestor", lNewDetailKey)

// Seitenteile des Drawers sind 12 x 90 Pixel
lX1 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 1
sDWObject = "p_left_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\Drawer_left_3_rung.jpg", lX1, lYOffset + ((arg_iRow - 1) * lDefaultHeight) - 45 - 2,  143, 12, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth - 12
sDWObject = "p_right_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\Drawer_right_3_rung.jpg", lX2, lYOffset + ((arg_iRow - 1)* lDefaultHeight) - 45 - 2, 143, 12, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject,  False)

// Boden des Drawers sind 5 Pixel hoch, die Breite aufziehen
sDWObject = "p_bottom_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\drawer_bottom.jpg", lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 12, lYOffset + (arg_iRow * lDefaultHeight) + 45 - 6, 5,lX2 - lX1 - 10, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

// Bild, dient als Button zum sp$$HEX1$$e400$$ENDHEX$$teren $$HEX1$$f600$$ENDHEX$$ffnen der Contents
// in einem eigenen Dialog
sDWButtonObject = "p_button_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 20 ,lYOffset + ((arg_iRow - 1) * lDefaultHeight)  - 30 , 14, 14, 0, 0, 0)

if of_register(sDWButtonObject, arg_iRow, arg_iColumn) = -1 Then return -1

// Order  beim f$$HEX1$$fc00$$ENDHEX$$llen mit Mahlzeiten
Choose Case arg_itype
	Case  DRAWERFOOD_3RUNG 
		sDWObject = "t_content_order_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
		of_create_text(sDWObject, of_get_order(arg_iRow, arg_iColumn) ,FONT_MS_SANS_SERIF, 8, FONT_BOLD, lX2 - 25 ,lYOffset + (arg_iRow * lDefaultHeight)  - 90  , 15 ,   25, 0, 1,  RGB(0,0,0), 1)
		if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
		// ----------------------------------------------------------
		// iMaxContent  Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
		// ----------------------------------------------------------
		lX1 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 20
		lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth/2
		lRowHeight = 15
		lYCounter = 1
		lY = lYOffset + ((arg_iRow - 1) *  lDefaultHeight) - 50 // + 10
		// 11.01.2010 Ulrich Paudler [UP] Breite reduzieren - hier den !!!t_content_tray_!!! f$$HEX1$$fc00$$ENDHEX$$llen
		lW =  (lDefaultWidth - 30)  / 2
		For i = 1 to iMaxContentDrawer3Rung
			sDWObject = "t_content_tray_" + string(I) + "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
			of_create_text(sDWObject, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lY + (lRowHeight * (lYCounter - 1)) , 15 , lW, 0, 0,  RGB(0,0,0), 1)
			if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
			// 2 Reihig
			if i = Long(iMaxContentDrawer3Rung / 2) Then
				lX1 = lX2
				lYCounter = 0
			End If
			lYCounter ++
		Next
	Case Else
end Choose

// -----------------------------------
// Den Button nach oben, sonst kann
// er nicht angeklickt werden
// -----------------------------------
of_set_position(sDWButtonObject, True)

return 1

end function

public function integer of_is_position_change (integer arg_itype, long arg_inewrow, long arg_inewcolumn);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_position_change (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster [KF]
* Datum  : 27.05.2010
* Argument(e):
* Long inewrow
*  Long inewcolumn
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
* 27.05.2010				Klaus F$$HEX1$$f600$$ENDHEX$$rster	Erstellung
*************************************************************/
Integer 	iType, iType2
Long		lFound1, lFound2, lAncestor, lAncestorNew
Long		lFound_MORE

// --------------------------------------------------------------------------------
//  Pr$$HEX1$$fc00$$ENDHEX$$fen, ob das Ziel unbelegt innerhalb des Objekts liegt
// --------------------------------------------------------------------------------
Choose Case arg_iType
	Case DRAWER, DRAWERFOOD
		
		lFound1 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_inewcolumn) + " and nrow=" + string(arg_inewrow), 1, this.dsLayoutDetail.Rowcount())
		lFound2		= this.dsLayoutDetail.Find("ncolumn=" + string( this.iCurrentColumn) + " and nrow=" + string( this.iCurrentRow), 1, this.dsLayoutDetail.Rowcount())
		
		if lFound1 <= 0 Then return 1
		if lFound2 <= 0 Then return 1
		
		iType	= this.dsLayoutDetail.Getitemnumber(lFound1, "ntype")
		
		// issue #2835 check frei drawer zweite Schiene
		lFound_MORE = this.dsLayoutDetail.Find("ncolumn=" + string(arg_inewcolumn) + " and nrow=" + string(arg_inewrow + 1), 1, this.dsLayoutDetail.Rowcount())
		
		If lFound_MORE < 1 then
			guoLog.uf_error("["+ this.classname( )+".of_is_position_change] "  +  this.isStowage +" - " + "DRAWER Schiene 2 Row " + string(arg_inewrow + 1) + " out of range")
			Return 1
		End If
		
		iType2	= this.dsLayoutDetail.Getitemnumber(lFound_MORE, "ntype")
		If iType2 <> EMPTY Then
			guoLog.uf_error("["+ this.classname( )+".of_is_position_change] "  +  this.isStowage +" - " + "DRAWER Schiene 2 Row " + string(arg_inewrow + 1) + " nicht EMPTY")
			Return 1
		End If
		
		lAncestorNew	= this.dsLayoutDetail.GetItemNumber(lFound1, "nancestor")
		lAncestor		= this.dsLayoutDetail.GetItemNumber(lFound2, "nancestor")
				
		if lAncestor = lAncestorNew Then 
			return EMPTY
		Elseif lAncestorNew = 0 Then
			
			if 	lFound1 + 1 > this.dsLayoutDetail.RowCount() Then return 1
						
			if 	(this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) and & 
				(this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "nancestor") = lAncestor) Then
				return EMPTY
			End If
			
		End If

	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
		
		lFound1 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_inewcolumn) + " and nrow=" + string(arg_inewrow), 1, this.dsLayoutDetail.Rowcount())
		lFound2		= this.dsLayoutDetail.Find("ncolumn=" + string( this.iCurrentColumn) + " and nrow=" + string( this.iCurrentRow), 1, this.dsLayoutDetail.Rowcount())
		
		if lFound1 <= 0 Then return 1
		if lFound2 <= 0 Then return 1
		
		iType	= this.dsLayoutDetail.Getitemnumber(lFound1, "ntype")
		
		lAncestorNew	= this.dsLayoutDetail.GetItemNumber(lFound1, "nancestor")
		lAncestor			= this.dsLayoutDetail.GetItemNumber(lFound2, "nancestor")
				
		if  lAncestor = lAncestorNew Then 
			return EMPTY
		Elseif lAncestorNew = 0 Then
			
			if 	lFound1 + 1 > this.dsLayoutDetail.RowCount() Then return 1
			if 	lFound1 - 1 < 1 Then return 1
						
			if 	(this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) and & 
				(this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "nancestor") = lAncestor) and & 
				(this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "nancestor") = lAncestor) Then
				return EMPTY
			End If
			
		End If
		
		
	Case TRAY, TRAYNONFOOD
		
	Case DRAWER_Multi_rung
		
		lFound1 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_inewcolumn) + " and nrow=" + string(arg_inewrow), 1, this.dsLayoutDetail.Rowcount())
		lFound2		= this.dsLayoutDetail.Find("ncolumn=" + string( this.iCurrentColumn) + " and nrow=" + string( this.iCurrentRow), 1, this.dsLayoutDetail.Rowcount())
		
		if lFound1 <= 0 Then return 1
		if lFound2 <= 0 Then return 1
		
		iType	= this.dsLayoutDetail.Getitemnumber(lFound1, "ntype")
		
		lAncestorNew	= this.dsLayoutDetail.GetItemNumber(lFound1, "nancestor")
		lAncestor			= this.dsLayoutDetail.GetItemNumber(lFound2, "nancestor")
				
		if lAncestor = lAncestorNew Then 
			return EMPTY
		Elseif lAncestorNew = 0 Then
			
			//if 	lFound1 + 1 > this.dsLayoutDetail.RowCount() Then return 1
			if 	lFound1 - 1 < 1 Then return 1
						
//			if 	(this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) and & 
//				(this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "nancestor") = lAncestor) and & 
//				(this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "nancestor") = lAncestor) Then
//				return EMPTY
//			End If

			if (this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) Then
				return EMPTY
			End If		
		End If

end Choose

return 1

end function

public function datastore of_request_datastore (integer arg_itype);/*
* Objekt : uo_cart_diagram
* Methode: of_request_datastore (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
* Datum  : 28.05.2010
*
* Argument(e):
* integer arg_itype
*
* Beschreibung:		X
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		28.05.2010		Erstellung
*
*
* Return: datastore
*
*/

Choose Case arg_itype
		
		Case 1
			return  this.dsLayoutDetail
		Case 2
			return  this.dsAirlineEq
		Case 3
			return  this.dsLayout
		Case 4
			return  this.dsLayoutContents
		Case 5
			return  this.dsPLContents
		Case 6
			return  this.dsLayoutContents
		Case 7
			return  this.dsLayoutAddObjects
		Case 8
			return  this.dsLayoutDimension
		Case 9
			return  this.dsObjects
	
end Choose
	
end function

public function long of_add_rect (long lx, long ly, long lheight, long lwidth);/* 
* Funktion/Event: of_add_rect
* Beschreibung: 	Rectangle platzieren
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		08.06.2010		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	lFound, a
LongLong lllSequence
String		sTName

// 02.02.2010 Ulrich Paudler [UP] Maximale xPosition ermitteln
//if not of_check_boundary(lx, ly, lheight, lwidth) Then
//	lx = long(oDw.object.r_frame.Width) - lwidth
//End If

// --------------------------------------------------------------------------------------------------------------------
// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
// --------------------------------------------------------------------------------------------------------------------
lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)

if lllSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

sTName = "r_rect_" + string(a) + "_" + string(now(), "hhmmss")
a = this.dsLayoutAddObjects.InsertRow(0)
this.dsLayoutAddObjects.SetItem(a, "nadd_object_key", lllSequence)
this.dsLayoutAddObjects.SetItem(a, "nlayout_key", this.lLayoutKey)
this.dsLayoutAddObjects.SetItem(a, "nobject_type", RECTANGLEOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle, 4 = content
this.dsLayoutAddObjects.SetItem(a, "cobject_name", sTName)
this.dsLayoutAddObjects.SetItem(a, "nheight", 20)
this.dsLayoutAddObjects.SetItem(a, "nwidth", 100)
this.dsLayoutAddObjects.SetItem(a, "nxpos", of_get_xposition(lX, sTName ))
this.dsLayoutAddObjects.SetItem(a, "nypos", lY)
this.dsLayoutAddObjects.SetItem(a, "nborderstyle", 0)
this.dsLayoutAddObjects.SetItem(a, "nbackgroundmode", 2)
this.dsLayoutAddObjects.SetItem(a, "nbackgroundcolor", RGB(255,255,255))
this.dsLayoutAddObjects.SetItem(a, "nbrushcolor",  RGB(255,255,255))
this.dsLayoutAddObjects.SetItem(a, "npencolor", RGB(0,0,0))
this.dsLayoutAddObjects.SetItem(a, "npenwidth", 1)
this.dsLayoutAddObjects.SetItem(a, "nbrushhatch", 6)

this.dsLayoutAddObjects.SetItem(a, "cvalue", "N/A")
this.dsLayoutAddObjects.SetItem(a, "nresizeable", 1)
this.dsLayoutAddObjects.SetItem(a, "nmoveable", 1)

this.of_create_rect(a)
	
return 1

end function

public function long of_create_rect (long lrow);/* 
* Funktion/Event: of_create_rect
* Beschreibung: 	Rechtexk anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	lRow			= Zeile aus dsLayoutAddObjects f$$HEX1$$fc00$$ENDHEX$$r die der Text gezeichnet werden soll
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		08.06.2010		Erstellung
*	1.1			O.Hoefer       06.05.2014		Rectangle Send To Back
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet
Integer	li_Succ

Long		iAlign, iBorder, iColor, lX, lY, lHeight, lWidth, iFontSize, iFontWeight,iMove, iResize, lAddKey
String	sObjectName, sFont, sText, sTag
Integer	li_Complist_Switch

iAlign				= this.dsLayoutAddObjects.GetItemNumber(lRow, "ntextalign")
iBorder			= 0 //this.dsLayoutAddObjects.GetItemNumber(lRow, "nborderstyle")
iColor				= this.dsLayoutAddObjects.GetItemNumber(lRow, "nfontcolor")

// 27.04.2010, KF 
// sObjectName wurde hier nie ermittelt, deshalb ging es
// immer in die of_set_xposition Funktion
sObjectName = this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")

Long lBorder, lBackMode,lBackColor, lPenColor, lPenWidth, lBrushHatch, lBrushColor

lX =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nxpos")

lx = of_adjust_xposition( lx, sObjectName)

lY =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nypos")
lHeight =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nheight")
lWidth =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nwidth")
lBorder =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nborderstyle") 
sObjectName =  this.dsLayoutAddObjects.GetItemString(lRow, "cobject_name")
lBackMode =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nbackgroundmode")
lBackColor =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nbackgroundcolor")
lBrushColor =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nbrushcolor")
lPenColor =  this.dsLayoutAddObjects.GetItemNumber(lRow, "npencolor")
lPenWidth =  this.dsLayoutAddObjects.GetItemNumber(lRow, "npenwidth")
lBrushHatch =  this.dsLayoutAddObjects.GetItemNumber(lRow, "nbrushhatch")

sTag			= String(this.dsLayoutAddObjects.GetItemNumber(lRow, "nlayer"))
If isnull(sTag) then sTag = ""


sCreate = "create rectangle(band=detail x='" + string(lX) +  &
			   "' y='" + string(lY) + "' height='" + string(lHeight) + &
				"' width='" + string(lWidth) + "' name=" + sObjectName + &
				" tag='" + sTag + "'" + &
				" resizeable=" + string(1)  + "  moveable=" + string(1)  + &
				" visible='1'" + &
				"  brush.hatch='" + string(lBrushHatch) + &
				"' brush.color='" + string(lBrushColor) +  &
				"' pen.style='0' pen.width='" + string(lPenWidth) + &
				"' pen.color='" + string(lPenColor) + &
				"' background.mode='2' background.color='0')"	

//of_modify_dw(sCreate)

if isValid(oDw) Then
	sRet = oDw.modify(sCreate)
End If

if isValid(oDS) Then
	sRet = oDS.modify(sCreate)
End If

li_Succ = of_set_position()

return 1

end function

public function long of_draw_drawer_multi_rung (long arg_irow, long arg_icolumn, long arg_itype, long arg_no_of_rungs, long arg_no_of_cols, boolean arg_b_init);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_drawer_multi_rung (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 14.12.2010
*
* Argument(e):
*	 long arg_irow					Zeile
*	 long arg_icolumn				Spalte
*	 long arg_itype				Typ (DRAWER_MULTI_RUNG = 13)
*	 long arg_no_of_rungs		H$$HEX1$$f600$$ENDHEX$$heneinheiten
*	 long arg_no_of_cols			Breite (Anzahl Spalten)
*	 boolean arg_b_init
*
* Beschreibung:		Zeichne Multi Rung Drawer - kopie von of_draw_drawer_3_rung
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	14.12.2010		Erstellung
*
*
* Return: long
*
*/


Long		lX1
Long		lX2
Long		lFound, lFoundNext, lFoundPrev, lRowHeight, i, j, k, lYCounter, lAncestorDetailKey
String	sDWObject, sDWButtonObject
Long		iType, iTypeNext, iTypePrev
long		lY, lW, lObjectPosY, lObjectPosY_StartPos, lObjectHeight
Integer	li_PictureHeight, iPos, iMaxContentMultiRung
Integer	iRungFrom, iRungTo
Integer	iColumnFrom, iColumnTo
Boolean	lb_error
s_cart_blocked strBlocked []


//if arg_iRow >= dsAirlineEq.GetItemNumber(1, "nrows") Then
//	// Letzte Schiene kann nicht genutzt werde f$$HEX1$$fc00$$ENDHEX$$r Trolleys
//	sError = "Position cannot be used for drawers"
//	return -1
//End If

//If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung START " + " C" + String(arg_icolumn) + " R" + String(arg_irow ) +  " Rungs " + String(arg_no_of_rungs)  + " arg_b_init=FALSE")				

if arg_b_init then
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung START " + " C" + String(arg_icolumn) + " R" + String(arg_irow ) +  " Rungs " + String(arg_no_of_rungs)  + " arg_b_init=TRUE")				
else
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung START " + " C" + String(arg_icolumn) + " R" + String(arg_irow ) +  " Rungs " + String(arg_no_of_rungs)  + " arg_b_init=FALSE")				
end if

// -----------------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob auch alle Einsch$$HEX1$$fc00$$ENDHEX$$be frei sind
// 1. Zuerst den Range der gepr$$HEX1$$fc00$$ENDHEX$$ft werden mu$$HEX2$$df002000$$ENDHEX$$ermitteln
// -----------------------------------------------------------------------
if arg_no_of_rungs = 1 Then
	iRungTo	= arg_irow
	iRungFrom = arg_irow
Else
	iRungTo	= arg_irow + 1
	iRungFrom = iRungTo - arg_no_of_rungs + 1
End If

if arg_no_of_cols = 1 Then
	iColumnTo	= arg_icolumn
	iColumnFrom = arg_icolumn
Else
	iColumnTo	= arg_no_of_cols
	iColumnFrom = 1
End If

For j = iColumnFrom to iColumnTo
	For i = iRungFrom to iRungTo
		iPos = Upperbound(strBlocked)  +1
		strBlocked[iPos].iColumn = J 
		strBlocked[iPos].iRung = I
	Next
Next

// -----------------------------------------------------------------------
// 2. Dann pr$$HEX1$$fc00$$ENDHEX$$fen, ob frei ist
// -----------------------------------------------------------------------
if not arg_b_init Then
	For i = 1 to Upperbound(strBlocked)
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(strBlocked[i].iColumn) + " and nrow=" + string(strBlocked[i].iRung), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0 Then
			sError = "Error: Row/Column mismatch"
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung " + sError + " C" + String(arg_icolumn) + " R" + String(arg_irow ))			
			end if
			return -1
		End If
		
		if this.dsLayoutDetail.Getitemnumber(lFound, "ntype") <> EMPTY Then
			sError = "Row " + string(strBlocked[i].iColumn) + " Rung " + String(strBlocked[i].iRung) + " is already in use"
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung " + sError + " C" + String(arg_icolumn) + " R" + String(arg_irow ))							
			end if
			return -1
		End If
	Next
End If
// -----------------------------------------------------------------------
// 3. Dann Pl$$HEX1$$e400$$ENDHEX$$tze blocken
// -----------------------------------------------------------------------
For i = 1 to Upperbound(strBlocked)
	lFound = this.dsLayoutDetail.Find("ncolumn=" + string(strBlocked[i].iColumn) + " and nrow=" + string(strBlocked[i].iRung), 1, this.dsLayoutDetail.Rowcount())
	if lFound = 0 Then
		sError = "Error: Row/Column mismatch in Row " + string(strBlocked[i].iColumn) + " Rung " + String(strBlocked[i].iRung) 
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung " + sError + " C" + String(arg_icolumn) + " R" + String(arg_irow ))						
		end if
		return -1
	End If
	
	if strBlocked[i].iColumn= arg_icolumn and strBlocked[i].iRung = arg_irow   Then
		this.dsLayoutDetail.Setitem(lFound, "ntype", arg_itype)
		this.dsLayoutDetail.Setitem(lFound, "ncolumns", arg_no_of_cols)
		this.dsLayoutDetail.Setitem(lFound, "nrungs", arg_no_of_rungs)
		lAncestorDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
	Else
		this.dsLayoutDetail.Setitem(lFound, "ntype", BLOCKED)
	End If
Next

// -----------------------------------------------------------------------
// 4. Dann die "Klammer" um die geblockten Zeilen 
// -----------------------------------------------------------------------
For i = 1 to Upperbound(strBlocked)
	lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(strBlocked[i].iColumn) + " and nrow=" + string(strBlocked[i].iRung), 1, this.dsLayoutDetail.Rowcount())
	if lFound = 0 Then
		sError = "Error: Row/Column mismatch in Row " + string(strBlocked[i].iColumn) + " Rung " + String(strBlocked[i].iRung) 
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung " + sError + " C" + String(arg_icolumn) + " R" + String(arg_irow ))				
		end if
		return -1
	End If

	this.dsLayoutDetail.Setitem(lFound, "nancestor", lAncestorDetailKey)

Next

// Aktuelle Position merken
this.iCurrentRow = arg_iRow
this.iCurrentColumn = arg_iColumn

li_PictureHeight = 53

if arg_no_of_rungs = 1 Then
	lObjectPosY = lYOffset +  ((arg_iRow - 1) * lDefaultHeight) + 22 - lDefaultHeight
Else
	lObjectPosY = lYOffset +  ((arg_iRow - 1) * lDefaultHeight) + 22
End If


lX1 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 1

if arg_no_of_cols = 1 Then
	lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth - 12
Else
	lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  (lDefaultWidth * arg_no_of_cols) - 12
End If

If il_Disable_Debug = 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung lx1 " + String(lx2) + " lx2 " + String(lx2))			
end if

// Ecke links unten
sDWObject = "p_left_drawer_dl_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\Drawer_left_down.jpg", lX1 ,lObjectPosY + li_PictureHeight,  20, 12, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

// Ecke rechts unten
sDWObject = "p_right_drawer_dr_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\Drawer_right_down.jpg", lX2 ,lObjectPosY + li_PictureHeight, 20, 12, 1, 0, 0)
If il_Disable_Debug = 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung of_create_picture " + sDWObject + " XPos "  + String(lX2))						
end if
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject,  False)

// F$$HEX1$$fc00$$ENDHEX$$r jede belegte Schiene die Seitenteile zeichnen
For i = 1 to arg_no_of_rungs - 1
	
	sDWObject = "p_left_drawer_rung_"  + string(i) + "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
	of_create_picture(sDWObject, "..\Resource\Drawer_left_rung.jpg", lX1 , lObjectPosY , li_PictureHeight, 12, 1, 0, 0)
	if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
	of_set_position(sDWObject, False)
	
	sDWObject = "p_right_drawer_rung_"  + string(i) + "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
	of_create_picture(sDWObject, "..\Resource\Drawer_right_rung.jpg", lX2 , lObjectPosY , li_PictureHeight, 12, 1, 0, 0)
	if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
	of_set_position(sDWObject, False)
	
	lObjectPosY -= li_PictureHeight - 1
Next

// Ecke links oben
lObjectPosY_StartPos = lObjectPosY + li_PictureHeight - 15

sDWObject = "p_left_drawer_ul_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\Drawer_left_top.jpg", lX1,lObjectPosY + li_PictureHeight - 15,  15, 12, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

// Ecke rechts oben
sDWObject = "p_left_drawer_ur_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, "..\Resource\Drawer_right_top.jpg", lX2,lObjectPosY + li_PictureHeight - 15,  15, 12, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

// Boden des Drawers sind 5 Pixel hoch, die Breite aufziehen
sDWObject = "p_bottom_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

if arg_no_of_rungs = 1 Then
	of_create_picture(sDWObject, "..\Resource\drawer_bottom.jpg", lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 12, lYOffset + (arg_iRow * lDefaultHeight) + 45 - 7 - lDefaultHeight, 5, lX2 - lX1 - 10, 1, 0, 0)
Else
	of_create_picture(sDWObject, "..\Resource\drawer_bottom.jpg", lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 12, lYOffset + (arg_iRow * lDefaultHeight) + 45 - 7, 5, lX2 - lX1 - 10, 1, 0, 0)
End If

if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)


// Bild, dient als Button zum sp$$HEX1$$e400$$ENDHEX$$teren $$HEX1$$d600$$ENDHEX$$ffnen der Contents
// in einem eigenen Dialog
sDWButtonObject = "p_button_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 20 ,lYOffset + ((iRungFrom) * lDefaultHeight)  - 30 , 14, 14, 0, 0, 0)
if of_register(sDWButtonObject, arg_iRow, arg_iColumn) = -1 Then return -1

// Bei 2 spaltiger Darstellung die Linie in der Mitte 
// $$HEX1$$fc00$$ENDHEX$$bermalen.
//                         Obere Ecke      +       untere Ecke      +        Anzahl "Seitenteile                                           -   H$$HEX1$$f600$$ENDHEX$$he des Bodens +   Offset bis zur n$$HEX1$$e400$$ENDHEX$$chsten Schiene  
lObjectHeight = 	20                  +            15              +        ((li_PictureHeight - 1) * (arg_no_of_rungs - 1))      -  5                         +      5

if arg_no_of_cols = 2 Then
	If ib_Enable_Multirung_Cover_White Then
		sDWButtonObject = "p_pic_content_cover_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
		of_create_picture(sDWButtonObject, "..\Resource\drawer_line_cover.jpg",lX1 + lDefaultWidth - 5,lObjectPosY_StartPos - 5, lObjectHeight, 10, 1, 0, 0)
		if of_register(sDWButtonObject, arg_iRow, arg_iColumn) = -1 Then return -1
		of_set_position(sDWButtonObject, true)
	End if
End If

sDWObject = "t_content_order_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_text(sDWObject, of_get_order(arg_iRow, arg_iColumn) ,FONT_MS_SANS_SERIF, 8, FONT_BOLD, lX2 - 25 ,lYOffset + ((iRungFrom + 1) * lDefaultHeight)  - 90  , 15 ,   25,  border_none , 1,  RGB(0,0,0), 1)
if ibedit then
	of_modify_text(sDWObject, of_get_order(arg_iRow, arg_iColumn))
end if
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then
	//return -1
	lb_error = true
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung REGISTER FAILED " + sDWObject)			
	end if
Else
	of_set_position(sDWObject, true)
End if
		

// ------------------------------------------------------------------
//      Anzeigeobjekte innerhalb des Drawers erzeugen 
// ------------------------------------------------------------------
//iMaxContentMultiRung = 2 +  (arg_no_of_rungs - 1) * 3
iMaxContentMultiRung = of_get_maxcontent(arg_iRow, arg_iColumn)

For k = 1 to arg_no_of_cols * 2
			
	// ----------------------------------------------------------
	// iMaxContent  Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
	// ----------------------------------------------------------
	lX1 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 20
	lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth/2
	lRowHeight = 17
	lYCounter = 1
	lY = lYOffset + ((arg_iRow - 1) *  lDefaultHeight) - 50 // + 10
	
	If arg_no_of_rungs = 2  Then
		lY = lYOffset + ((arg_iRow ) *  lDefaultHeight) - 50 
	End If
	
	If arg_no_of_rungs = 1 Then
		lY = lYOffset + ((arg_iRow - 1) *  lDefaultHeight) - 1 
	End If
	
	lW =  (lDefaultWidth - 30)  / 2
	lX1 =  lXOffset + ((k -1) * lW) + 20
	
	if k >= 3 Then
		lX1 += 20
	End If 
	
	//For i = 1 to iMaxContentMultiRung
	For i = 1 to ceiling(iMaxContentMultiRung / arg_no_of_cols)
		//sDWObject = "t_content_multi_rung_" + string(k, "00") + "_" + string(i, "00")+ "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
		sDWObject = "t_content_std_text_" + string(k, "00") + "_" + string(i, "00")+ "_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")	

		If arg_iColumn = 2 AND arg_no_of_cols = 1 Then
			of_create_text(sDWObject, " " ,FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1 + lDefaultWidth , lObjectPosY_StartPos + (lRowHeight * ( i - 1)) , 17 , lW, border_none , 0,  RGB(0,0,0), 1)	
		Else				
			of_create_text(sDWObject, " " ,FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lObjectPosY_StartPos + (lRowHeight * ( i - 1)) , 17 , lW, border_none, 0,  RGB(0,0,0), 1)
		End If
		
		if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_drawer_multi_rung REGISTER FAILED " + sDWObject)			
			end if
			return -1			
		End If
		// 2 Reihig
		lYCounter ++
	Next


Next

// -----------------------------------
// Den Button nach oben, sonst kann
// er nicht angeklickt werden
// -----------------------------------
of_set_position(sDWButtonObject, True)

Return 1

end function

public function long of_check_position (long itype, long inewrow, long inewcolumn, integer arg_no_of_rungs, integer arg_no_of_cols);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_check_position (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 08.10.2009
* Argument(e):
* Long inewrow
*  Long inewcolumn
*  Long ioldrow
*  Long ioldcolumn
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  08.10.2009	1.0           Ulrich Paudler     Erstellung
*  19.11.2009	1.1		    Ulrich Paudler  	Drawerfood und Traynonfood eingebaut
*
*************************************************************/
Long		lFound,  lFoundNext, lFoundPrev
Long iTypeNew, iTypeNewNext, iTypeNewPrev
Integer ino_of_rungs, ino_of_cols, iRungTo, iRungFrom, iColumnTo, iColumnFrom, i, j, iPos
s_cart_blocked strBlocked[]
// --------------------------------------------------------------------------------
//  Pr$$HEX1$$fc00$$ENDHEX$$fen, ob das Ziel unbelegt ist
// --------------------------------------------------------------------------------
guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "start")
Choose Case iType
	Case DRAWER, DRAWERFOOD
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
		guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "drawer " +string(lFound) + "/" + string(lFoundNext) )
		
		if this.of_is_position_change(iType, iNewRow, iNewColumn) = 0 Then
			return EMPTY
		End If
		
		if lFound = 0 or lFoundNext = 0 Then
			return -1
		End If
				
		iTypeNew		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		iTypeNewNext 	= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		if (iTypeNew <> EMPTY or iTypeNewNext <> EMPTY) Then
			guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "Types here " + String(iTypeNew) + string(iTypeNewNext ))
			if iTypeNew <> EMPTY Then
				return iTypeNew
			Else
				return iTypeNewNext
			End If
		End If

	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG

		lFoundPrev 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow - 1), 1, this.dsLayoutDetail.Rowcount())
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		lFoundNext 	= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow + 1), 1, this.dsLayoutDetail.Rowcount())
		guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "DRAWER_3RUNG --- "  + string(lFoundPrev) + "/" +string(lFound) + "/" + string(lFoundNext) )
				
		if  this.of_is_position_change(iType, iNewRow, iNewColumn)  = 0 Then
			return EMPTY
		End If
		
		if lFoundPrev = 0 or lFound = 0 or lFoundNext = 0 Then
			return -1
		End If
		
		iTypeNewPrev 	= this.dsLayoutDetail.Getitemnumber(lFoundPrev, "ntype")
		iTypeNew		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		iTypeNewNext 	= this.dsLayoutDetail.Getitemnumber(lFoundNext, "ntype")
		
		if (iTypeNewPrev <> EMPTY or iTypeNew <>  EMPTY or iTypeNewNext <>  EMPTY) Then
			guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "in row " + string(iNewRow) + "  for DRAWER_3RUNG: Types here " + string(iTypeNewPrev) + String(iTypeNew) + string(iTypeNewNext ))
			
			if iTypeNewPrev <> EMPTY or iTypeNew <> EMPTY or iTypeNewNext <> EMPTY Then
				return -1
			Else
				return iTypeNew
			End If
			
		End If


	Case TRAY, TRAYNONFOOD
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "tray  " +string(lFound) )
		if lFound = 0  Then
			return -1
		End If
		iTypeNew		= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
		if (iTypeNew <>  EMPTY ) Then
			guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "Type here " + String(iTypeNew))
			return iTypeNew
		End If

	Case DRAWER_MULTI_RUNG
		
		lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iNewColumn) + " and nrow=" + string(iNewRow), 1, this.dsLayoutDetail.Rowcount())
		if lFound = 0  Then
			return -1
		End If
		
		If arg_no_of_cols = 2 AND inewcolumn = 2 Then
			sError = "Error: drawer requires 2 columns width. Please start in the left column"
			return -1
		End If
		
		// -----------------------------------------------------------------------
		// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob auch alle Einsch$$HEX1$$fc00$$ENDHEX$$be frei sind
		// 1. Zuerst den Range der gepr$$HEX1$$fc00$$ENDHEX$$ft werden mu$$HEX2$$df002000$$ENDHEX$$ermitteln
		// -----------------------------------------------------------------------
		if arg_no_of_rungs = 1 Then
			iRungTo	= inewrow
			iRungFrom = inewrow
		Elseif arg_no_of_rungs = 2 Then			
			iRungTo	= inewrow + 1
			iRungFrom = iRungTo - 1
		Else
			iRungTo	= inewrow + 1
			iRungFrom = iRungTo - arg_no_of_rungs + 1
		End If
		
		if arg_no_of_cols = 1 Then
			iColumnTo	= inewcolumn
			iColumnFrom = inewcolumn
		Else
			iColumnTo	= arg_no_of_cols
			iColumnFrom = 1
		End If
		
		guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "Rung " + string(iRungFrom) + " - " + String(iRungTo) + " Column " + String(iColumnFrom)  + " - " + String(iColumnTo))
		
		For j = iColumnFrom to iColumnTo
			For i = iRungFrom to iRungTo
				iPos = Upperbound(strBlocked)  +1
				strBlocked[iPos].iColumn = J 
				strBlocked[iPos].iRung = I
			Next
		Next

		// -----------------------------------------------------------------------
		// 2. Dann pr$$HEX1$$fc00$$ENDHEX$$fen, ob frei ist
		// -----------------------------------------------------------------------
		For i = 1 to Upperbound(strBlocked)
			lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(strBlocked[i].iColumn) + " and nrow=" + string(strBlocked[i].iRung), 1, this.dsLayoutDetail.Rowcount())
			if lFound = 0 Then
				sError = "Error: Row/Column mismatch"
				return -1
			End If
			
			if this.dsLayoutDetail.Getitemnumber(lFound, "ntype") <> EMPTY Then
				sError = "Row " + string(strBlocked[i].iColumn) + " Rung " + String(strBlocked[i].iRung) + " is already in use"
				guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "Row " + string(strBlocked[i].iColumn) + " Rung " + String(strBlocked[i].iRung) + " is in use")
				return -1
			End If
		Next

end Choose

guoLog.uf_debug("["+ this.classname( )+".of_check_position] "  +  this.isStowage +" - " + "EMPTY")

return EMPTY

end function

public function long of_set_marker_insert (long itype, long irow, long icolumn, long lmarkercolor, integer arg_no_of_rungs, integer arg_no_of_cols);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_set_marker_insert (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 08.10.2009
* Argument(e):
* long itype
*  Long irow
*  Long icolumn
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  08.10.2009	1.0           Ulrich Paudler     Erstellung
* 19.11.2009	1.1		    Ulrich Paudler  	Drawerfood und Traynonfood eingebaut
* 17.05.2010				Klaus F$$HEX1$$f600$$ENDHEX$$rster		Drawerfood und Drawer mit 3 Schienen
*************************************************************/
Long		lFound, lX1, lX2, lY1, i
String	sDWObject

//  Farbe setzen
oDW.setitem(1,"nmarkercolor",lmarkerColor)

if (iRow = 0 or iRow=1) and iColumn = 0 Then
	oDW.Modify("t_marker_left.visible=0")
	oDW.Modify("t_marker_right.visible=0")
	oDW.Modify("t_marker_top.visible=0")
	oDW.Modify("t_marker_bottom.visible=0")
End If

lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
End If


odw.SetRedraw(false)

// Alle "Buttons" ausblenden
this.dsObjects.SetFilter("")
this.dsObjects.Filter()

for i = 1 to this.dsObjects.RowCount()
	sDWObject = this.dsObjects.GetItemString(i, "cobject")
	if  of_check_string(sDWObject,"p_button_" ) Then
		oDW.Modify(sDWObject + ".visible=0")
	End If
next

//sDWObject = "p_button_col_" + string(iColumn, "00") + "_row_" + string(iRow, "00")

oDW.Modify("t_marker_left.visible=1")
oDW.Modify("t_marker_right.visible=1")
oDW.Modify("t_marker_top.visible=1")
oDW.Modify("t_marker_bottom.visible=1")


lX1 = lXOffset + ((iColumn -1) * lDefaultWidth) - 10
lX2 = lX1 + lDefaultWidth + 15

Choose Case iType
	Case DRAWER, DRAWERFOOD
	lY1 = lYOffset + (iRow * lDefaultHeight) - lDefaultHeight

	oDW.Modify("t_marker_left.x=" + string(lX1))
	oDW.Modify("t_marker_left.y=" + string(lY1))
	oDW.Modify("t_marker_left.height=" + string(lDefaultHeight * 2))
		
	oDW.Modify("t_marker_right.x=" + string(lX2))
	oDW.Modify("t_marker_right.y=" + string(lY1))
	oDW.Modify("t_marker_right.height=" + string(lDefaultHeight * 2))
	
	oDW.Modify("t_marker_top.x=" + string(lX1) )
	oDW.Modify("t_marker_top.y=" + string(lY1))
	oDW.Modify("t_marker_top.width=" + string(lX2 - lX1))
	
	oDW.Modify("t_marker_bottom.x=" + string(lX1))
	oDW.Modify("t_marker_bottom.y=" + string(lY1 + (lDefaultHeight * 2) - 5))
	oDW.Modify("t_marker_bottom.width=" + string(lX2 - lX1))

Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
	lY1 = lYOffset + (iRow * lDefaultHeight) - (lDefaultHeight * 2)

	oDW.Modify("t_marker_left.x=" + string(lX1))
	oDW.Modify("t_marker_left.y=" + string(lY1))
	oDW.Modify("t_marker_left.height=" + string(lDefaultHeight * 3))
		
	oDW.Modify("t_marker_right.x=" + string(lX2))
	oDW.Modify("t_marker_right.y=" + string(lY1))
	oDW.Modify("t_marker_right.height=" + string(lDefaultHeight * 3))
	
	oDW.Modify("t_marker_top.x=" + string(lX1) )
	oDW.Modify("t_marker_top.y=" + string(lY1))
	oDW.Modify("t_marker_top.width=" + string(lX2 - lX1))
	
	oDW.Modify("t_marker_bottom.x=" + string(lX1))
	oDW.Modify("t_marker_bottom.y=" + string(lY1 + (lDefaultHeight * 3) - 5))
	oDW.Modify("t_marker_bottom.width=" + string(lX2 - lX1))

Case TRAY, TRAYNONFOOD
	lY1 = lYOffset + (iRow * lDefaultHeight) - lDefaultHeight + 10

	oDW.Modify("t_marker_left.x=" + string(lX1))
	oDW.Modify("t_marker_left.y=" + string(lY1))
	oDW.Modify("t_marker_left.height=" + string(lDefaultHeight * 2 - 40) )
		
	oDW.Modify("t_marker_right.x=" + string(lX2))
	oDW.Modify("t_marker_right.y=" + string(lY1))
	oDW.Modify("t_marker_right.height=" + string(lDefaultHeight * 2 - 40))
	
	oDW.Modify("t_marker_top.x=" + string(lX1) )
	oDW.Modify("t_marker_top.y=" + string(lY1))
	oDW.Modify("t_marker_top.width=" + string(lX2 - lX1))
	
	oDW.Modify("t_marker_bottom.x=" + string(lX1))
	oDW.Modify("t_marker_bottom.y=" + string(lY1 + (lDefaultHeight * 2) - 45))
	oDW.Modify("t_marker_bottom.width=" + string(lX2 - lX1))
	
Case DRAWER_MULTI_RUNG
	
	if arg_no_of_rungs = 1 Then
		lY1 = lYOffset + ((iRow - arg_no_of_rungs) * lDefaultHeight)
	Else
		lY1 = lYOffset + ((iRow - arg_no_of_rungs + 1) * lDefaultHeight)
	End If

	oDW.Modify("t_marker_left.x=" + string(lX1))
	oDW.Modify("t_marker_left.y=" + string(lY1))
	oDW.Modify("t_marker_left.height=" + string(lDefaultHeight * arg_no_of_rungs))
	
	oDW.Modify("t_marker_right.x=" + string(lX1 + (lDefaultWidth * arg_no_of_cols) + 15))
	oDW.Modify("t_marker_right.y=" + string(lY1))
	oDW.Modify("t_marker_right.height=" + string(lDefaultHeight * arg_no_of_rungs))
	
	oDW.Modify("t_marker_top.x=" + string(lX1) )
	oDW.Modify("t_marker_top.y=" + string(lY1))
	oDW.Modify("t_marker_top.width=" + string((lX2 - lX1) * arg_no_of_cols   - (15 * (arg_no_of_cols - 1) )))
	
	oDW.Modify("t_marker_bottom.x=" + string(lX1))
	oDW.Modify("t_marker_bottom.y=" + string(lY1 + (lDefaultHeight * arg_no_of_rungs) - 5))
	oDW.Modify("t_marker_bottom.width=" + string((lX2 - lX1) * arg_no_of_cols  - (15 * (arg_no_of_cols - 1) )))

	
	
Case Else
	oDW.Modify("t_marker_left.visible=0")
	oDW.Modify("t_marker_right.visible=0")
	oDW.Modify("t_marker_top.visible=0")
	oDW.Modify("t_marker_bottom.visible=0")
end Choose

of_set_position("t_marker_left",  TRUE)
of_set_position("t_marker_right", TRUE)
of_set_position("t_marker_top",  TRUE)
of_set_position("t_marker_bottom", TRUE)

odw.SetRedraw(True)

return 1
end function

public function long of_draw_header (long al_result_key);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_header (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.07.2010
*
* Argument(e):
* long al_result_key
*
* Beschreibung:		Zeichne neuen Header gem$$HEX3$$e400df002000$$ENDHEX$$CBASE-NAM-CR-0029
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.07.2010		Erstellung
*
*
* Return: long
*
*/

Return of_draw_header(al_result_key, FALSE)


end function

public function long of_create_text (string sobjectname, string stext, string sfont, long ifontsize, long ifontweight, long lx, long ly, long lheight, long lwidth, long iborder, long ialign, long lcolor, long ivisible, string sband);/*
* Objekt : uo_cart_diagram
* Methode: of_create_text (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.07.2010
*
* Argument(e):
*	 string sobjectname
*	 string stext
*	 string sfont
*	 long ifontsize
*	 long ifontweight
*	 long lx
*	 long ly
*	 long lheight
*	 long lwidth
*	 long iborder
*	 long ialign
*	 long lcolor
*	 long ivisible
*	 string sband
*
* Beschreibung:		Erzeuge Text Objekt im NON-Backlog-DW 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.07.2010		Erstellung
*
*
* Return: long
*
*/


Return of_create_text(sobjectname,stext,sfont, ifontsize, ifontweight, lx, ly, lheight, lwidth, iborder, ialign, lcolor, ivisible, sband, FALSE)


end function

public function long of_print_prepare_backlog (string arg_s_printer, string arg_s_airline, long arg_l_flightnumber, string arg_s_suffix, string arg_s_header, string arg_s_from, string arg_s_to, string arg_s_actype, string arg_s_stowage, long arg_l_page, long arg_l_belly, date arg_d_departure, string arg_s_time, string arg_s_class, string arg_s_container, string arg_s_owner, string arg_s_version, string arg_s_area, string arg_s_workstation, string arg_s_loadinglist);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print_prepare_backlog (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.10.2009
* Argument(e):
* string arg_s_printer
*  string arg_s_airline
*  long arg_l_flightnumber
*  string arg_s_suffix
*  string arg_s_header
*  string arg_s_from
*  string arg_s_to
*  string arg_s_actype
*  string arg_s_stowage
*  long arg_l_page
*  long arg_l_belly
*  date arg_d_departure
*  string arg_s_time
*  string arg_s_class
*  string arg_s_container
*  string arg_s_owner
*  string arg_s_version
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  29.10.2009	1.0           Ulrich Paudler     Erstellung
*  13.01.2010	1.1           Ulrich Paudler     Erweiterung area, workstation und loadinglist
*
*************************************************************/
Integer	iUseLetterFormat 


of_modify_dw_backlog("datawindow.printer='" +arg_s_printer+ "'")
of_modify_dw_backlog("datawindow.print.documentname = 'CartdiagramSheet_"  +  arg_s_airline + "_" + String(arg_l_Flightnumber, "000") + "_" + arg_s_suffix + "'")
of_modify_dw_backlog("t_title.text='"  +  arg_s_header + "'")
of_modify_dw_backlog("t_flight.text='" +  arg_s_airline + " " + string(arg_l_Flightnumber,"000") + " " + arg_s_suffix + "'")
of_modify_dw_backlog("t_from.text='" + arg_s_from + "'")
of_modify_dw_backlog("t_to.text ='" + arg_s_to + "'")
of_modify_dw_backlog("t_aircraft_type.text='" +  arg_s_actype + "'")
of_modify_dw_backlog("t_stowage.text='" + arg_s_stowage + "'")

//of_modify_dw_backlog("t_page.text='" + String(arg_l_page)+  "'")
of_modify_dw_backlog("t_page.text=' '")

if arg_l_belly > 0 Then
	of_modify_dw_backlog("t_belly.text='Belly'")
Else
	of_modify_dw_backlog("t_belly.text=''")
End If

of_modify_dw_backlog("t_day.text='" + String(arg_d_departure,"DD") + "'")
of_modify_dw_backlog("t_time.text='" + arg_s_time + "'")
of_modify_dw_backlog("t_class.text='" +  arg_s_class + "'")
of_modify_dw_backlog("t_container.text='" + arg_s_container+  "'")
of_modify_dw_backlog("t_aircraft.text='" + arg_s_owner + " " + arg_s_actype + " [" + arg_s_version + "]" + "'")
// 13.01.2010 Ulrich Paudler [UP]
of_modify_dw_backlog("t_workstation.text ='" +arg_s_area + " - " + arg_s_workstation + "'")
of_modify_dw_backlog("t_loadinglist.text ='" +arg_s_loadinglist + "'")

is_Ac_Type			= arg_s_actype
is_Loadinglist		= arg_s_loadinglist
   
If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"

iUseLetterFormat = integer(f_mandant_profilestring(sqlca, s_app.smandant, "PaperFormat", "UseLetterFormat", "0"))

if iUseLetterFormat = 1 Then
	of_modify_dw_backlog("datawindow.print.paper.size=1")
Else
	of_modify_dw_backlog("datawindow.print.paper.size=9")
End If

return 0

end function

public function long of_draw_footer (long al_result_key);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_footer (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.07.2010
*
* Argument(e):
* long al_result_key
*
* Beschreibung:		Footer zeichnen
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.07.2010		Erstellung
*
*
* Return: long
*
*/

Return of_draw_footer(al_result_key, FALSE)


end function

public function long of_init_tr (long arg_lindexkey, long arg_ldetailkey, long arg_lairlinekey, string arg_sunit, datastore arg_ods, datetime arg_ddeparture, datastore arg_odsbacklog);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_init (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 16.04.2009
*
* Argument(e):	* long arg_llayoutkey
*  long arg_lindexkey
*  long arg_ldetailkey
*  long arg_lairlinekey
*  string arg_sunit
*  datastore arg_ods
*  datetime arg_ddeparture
*  datastore arg_odsbacklog
*
* Return: long
*
*
* wrapper zum weiterleiten des funktionsaufrufes
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*30.09.2009	1.1			Ulrich Paudler	sauberes initialisieren 
*19.01.2010	1.2			Ulrich Paudler	Unterscheidung Header im Footer
*08.02.2010	1.3			Ulrich Paudler	Backlog nach zuweisung $$HEX1$$fc00$$ENDHEX$$bersetzen
*************************************************************/
Long ll_RetVal


this.il_IndexKey		= arg_lIndexKey
this.lDetailKey	= arg_lDetailKey
il_AirlineKey	= arg_lAirlineKey
this.sUnit			= arg_sUnit
this.oDs				= arg_ods
this.idt_Departure	= date(arg_dDeparture)
this.oDsBacklog	= arg_odsbacklog
this.bBacklog     = of_is_backlog_enabled()


// 19.01.2010 Ulrich Paudler [UP] Header im Footer
//Cartdiagram
if	of_is_tr_header_in_footer() Then
	arg_ods.dataobject = "dw_uo_layout_footer_n"
Else
	arg_ods.dataobject = "dw_uo_layout_n"
End If
arg_ods.InsertRow(0)

// Backlog
if of_is_tr_header_in_footer() Then
	arg_odsbacklog.dataobject = "dw_uo_layout_backlog_footer_n"
Else
	arg_odsbacklog.dataobject = "dw_uo_layout_backlog_n"
End If
//arg_odsbacklog.InsertRow(0)

// 08.02.2010 Ulrich Paudler [UP] Backlog auch $$HEX1$$fc00$$ENDHEX$$bersetzen
// uf.translate_datastore(arg_odsbacklog)

SELECT  max(NLAYOUT_KEY) 
	INTO :this.lLayoutKey
	FROM CEN_PACKINGLIST_LAYOUT
	WHERE NPACKINGLIST_INDEX_KEY =:arg_lindexkey AND NPACKINGLIST_DETAIL_KEY=:arg_ldetailkey 
	USING SQLCA;
	if SQLCA.SQLCode <> 0 Then
		return -1
	End If	
	
SELECT  CUNIT
	INTO :this.sUnit
	FROM CEN_PACKINGLISTS
	WHERE NPACKINGLIST_INDEX_KEY =:arg_lindexkey AND NPACKINGLIST_DETAIL_KEY=:arg_ldetailkey 
	USING SQLCA;
	if SQLCA.SQLCode <> 0 Then
		return -1
	End If		

// 30.09.2009 Ulrich Paudler [UP] initialisieren
iCurrentRow = 0
iCurrentColumn = 0
lErrorCount = 0
sError =""

//// 10.12.2009 Ulrich Paudler [UP]
////lXOffSet 	= 50
lYOffSet 	= 30 //5 // war 50
//// 10.12.2009 Ulrich Paudler [UP]
////lDefaultWidth 	= 322
lDefaultHeight = 52 // war 54

// Datastores zur$$HEX1$$fc00$$ENDHEX$$cksetzen
dsLayoutDetail.Reset()
dsLayoutContents.Reset()
dsLayoutDimension.Reset()
dsLayoutAddObjects.Reset()
dsPL.Reset()
dsPLContents.Reset()
dsObjects.Reset()

// 03.09.2009 Ulrich Paudler [UP]
dsBacklog.Reset()

ll_RetVal = 	this.of_init_tr(arg_sunit)


return ll_RetVal

end function

public function long of_create_text (string sobjectname, string stext, string sfont, long ifontsize, long ifontweight, long lx, long ly, long lheight, long lwidth, long iborder, long ialign, long lcolor, long ivisible, string sband, boolean ab_backlog);/* 
* Funktion/Event: of_create_text
* Beschreibung: 	Text anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	sObjectName		= Name des TextObjects
* 	sText					= Anzuzeigender Text
*	sFont					= Schriftart
*	iFontSize				= Schriftgr$$HEX2$$f600df00$$ENDHEX$$e
*	iFontweight			= Fett oder Normal, 700 oder 400
*	lX						= XPos des Textes im Datawindow
*	lY						= YPos
*	lHeight				= H$$HEX1$$f600$$ENDHEX$$he des Textes im Datawindow
*	lWidth				= Breite
*	iBorder				= Rahmen An = 2 / Aus = 0
*	iAlign					= Ausrichtung / Left = 0, Right = 1, Center = 2
*	ivisible				= Sichtbarkeit / sichtbar = 1, unsichtbar = 0
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008	Erstellung
*	1.1 			U.Paudler	20.08.2009	Sichtbar flag eingef$$HEX1$$fc00$$ENDHEX$$gt
*	1.2 			U.Paudler	22.10.2009	Farbe mit $$HEX1$$fc00$$ENDHEX$$bergeben
*	1.3 			U.Paudler	25.01.2010	Editm$$HEX1$$f600$$ENDHEX$$glichkeit der Drawer/Tray Texte 
*	1.4 			O.Hoefer 	16.06.2010	Maskieren von Single Quotes
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet
Long	lFound, llNewRow, llFindrow, iResize, iMove
LongLong lllSequence
Boolean lb_breakpoint
Integer	li_Replace

// Nur bestimmte objekte
if of_check_string(sObjectName,"t_content_") Then
	llFindRow = this.dsLayoutAddObjects.Find("cobject_name='" + sobjectname + "'",1,dsLayoutAddObjects.Rowcount())
	if llFindrow > 0 Then
		lheight = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nheight")
		//lwidth = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nwidth")
		if of_check_string(sObjectName,"t_content_floating_") Then
			lX = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nxpos")
			lY = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nypos")
			lwidth = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nwidth")
		Else
			//lX = of_set_xposition(this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nxpos"))
			//lY = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nypos")
		End If
		iborder = 0 //this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nborderstyle")
		ialign = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "ntextalign")
		sfont = this.dsLayoutAddObjects.GetItemString(llFindrow, "cfontname")
		lcolor = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nfontcolor")
		ifontweight = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nfontweight") 
		ifontsize = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nfontsize")
		stext = "" // this.dsLayoutAddObjects.GetItemString(llFindrow, "cvalue")
		iResize =		this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nresizeable")
		iMove = this.dsLayoutAddObjects.GetItemnumber(llFindrow, "nmoveable")
		
		if of_check_string(sobjectname,"t_content_") Then
			sFont = FONT_MS_SANS_SERIF
		End If
		
	Else
		// --------------------------------------------------------------------------------------------------------------------
		// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
		// --------------------------------------------------------------------------------------------------------------------
		lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)
		if lllSequence = -1 Then
			sError = "Error: Sequence failed"
			return -1
		End If
		llNewRow = this.dsLayoutAddObjects.InsertRow(0)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nadd_object_key", lllSequence)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nlayout_key", this.lLayoutKey)
		if of_check_string(sObjectName,"t_content_floating_") Then
			this.dsLayoutAddObjects.SetItem(llNewRow, "nobject_type", FLOATCONTENTOBJECT) 
			this.dsLayoutAddObjects.SetItem(llNewRow, "nxpos", lX)
			iResize = 1
			iMove = 1
		Else
			this.dsLayoutAddObjects.SetItem(llNewRow, "nobject_type", CONTENTOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle
			this.dsLayoutAddObjects.SetItem(llNewRow, "nxpos", of_get_xposition(lX, sObjectName))
			iResize = 0
			iMove = 0
		End If
		this.dsLayoutAddObjects.SetItem(llNewRow, "cobject_name", sobjectname)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nheight", lheight)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nwidth", lwidth)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nypos", lY)	
		this.dsLayoutAddObjects.SetItem(llNewRow, "nborderstyle", 0) //iborder
		this.dsLayoutAddObjects.SetItem(llNewRow, "ntextalign", ialign)
		this.dsLayoutAddObjects.SetItem(llNewRow, "cfontname", sfont)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nfontcolor", lcolor)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nfontweight", ifontweight) 
		this.dsLayoutAddObjects.SetItem(llNewRow, "nfontsize", ifontsize)
		this.dsLayoutAddObjects.SetItem(llNewRow, "cvalue", "")
		this.dsLayoutAddObjects.SetItem(llNewRow, "nresizeable", iResize)
		this.dsLayoutAddObjects.SetItem(llNewRow, "nmoveable", iMove)
	End If
End If

// nicht nach links abdriften!
if lX < 0 Then lX = 0

//if isnull(sTag) Then sTag = ""
if iFontSize > 0 Then iFontSize = iFontSize * -1

// ------------------------------------------			
// Single Quotes maskieren
// ------------------------------------------			
If pos(sText, "'")  > 0 then
	lb_breakpoint=true
	li_Replace = f_replace_string(sText, "'", "~~~'")
End If

sCreate = "create text(band=" + sBand + " alignment='" + string(ialign) + "' " + &
			"text='" + sText + "' border='" + string(iBorder) + "' color='" + String(lColor) + "' " + &
			"x='" + string(lX) +  "' y='" + string(lY) + "' " + &
			" height='"+ String(lHeight) + "' width='" + string(lWidth) + "' " + &
			" name=" + sObjectName + &
			" visible='" + string(ivisible) + "' resizeable=" + String(iResize) + "  moveable=" + String(iMove) + " font.face='" + sFont + "' " + &
			" font.height='" + String(iFontSize) + "' font.weight='" + String(iFontWeight) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"

// ------------------------------------------			
// Normal oder Backlog?
// ------------------------------------------			

If ab_backlog = FALSE Then
	if isValid(oDw) Then
		if oDw.Describe(sObjectName +".Text")<> "!" Then
			return 0
		Else
			sRet = oDw.modify(sCreate)
			if of_check_string(sObjectName,"t_drag_target_") Then
				oDw.SetPosition(sObjectName, "", FALSE)
			Else
				oDw.SetPosition(sObjectName, "", TRUE)
			End If
		End If
	End If
	
	if isValid(oDS) Then
			if oDS.Describe(sObjectName +".Text")<> "!" Then
			return 0
		Else
			sRet = oDS.modify(sCreate)
			if of_check_string(sObjectName,"t_drag_target_") Then
				oDS.SetPosition(sObjectName, "", FALSE)
			Else
				oDS.SetPosition(sObjectName, "", TRUE)
			End If
		End If
	End If

Else
	if isValid(odwbacklog ) Then
		if odwbacklog.Describe(sObjectName +".Text")<> "!" Then
			return 0
		Else
			sRet = odwbacklog.modify(sCreate)
			if of_check_string(sObjectName,"t_drag_target_") Then
				odwbacklog.SetPosition(sObjectName, "", FALSE)
			Else
				odwbacklog.SetPosition(sObjectName, "", TRUE)
			End If
		End If
	End If
	
	if isValid(odsbacklog ) Then
			if odsbacklog.Describe(sObjectName +".Text")<> "!" Then
			return 0
		Else
			sRet = odsbacklog.modify(sCreate)
			if of_check_string(sObjectName,"t_drag_target_") Then
				odsbacklog.SetPosition(sObjectName, "", FALSE)
			Else
				odsbacklog.SetPosition(sObjectName, "", TRUE)
			End If
		End If
	End If
End If 

return 1

end function

public function long of_draw_footer (long al_result_key, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_footer (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.07.2010
*
* Argument(e):
* long al_result_key
*
* Beschreibung:		Footer zeichnen
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.07.2010		Erstellung
*
*
* Return: long
*
*/


Integer	li_Succ
Long		ll_Flight_Number
String	ls_Airline
String	ls_Text
String	ls_Band
Integer	li_Font_Size
String	ls_Box_From, ls_Box_To
String	ls_departure_time, ls_ramp_time, ls_kitchen_time  
String	ls_Suffix


//f_departure 
//f_ramptime 
//f_flightnumber 
//f_rampbox 
//f_workstation 
//f_stowageposition 
ls_Text = "f_workstation.text='" +   + "'"
li_Succ = of_modify(ls_Text, ab_backlog)	
ls_Text = "f_stowageposition.text='" + " " + "'"
li_Succ = of_modify(ls_Text, ab_Backlog)


//if of_is_header_in_footer() Then
//	ls_Band = "header"	
//Else
//	ls_Band = "footer"
//End If
If NOT ib_Mode_TR_Cart Then
	if of_is_header_in_footer() Then
		ls_Band = "footer"	
	Else
		ls_Band = "header"
	End If
Else
	if of_is_tr_header_in_footer() Then
		ls_Band = "footer"	
	Else
		ls_Band = "header"
	End If
End If

If al_Result_key > 0 Then
  SELECT cairline,   
         nflight_number,   
         cdeparture_time,   
         cramp_time,   
         ckitchen_time ,
			nrouting_id,
			cbox_from,
			cbox_to,
			csuffix
    INTO :ls_airline,   
         :ll_flight_number,   
         :ls_departure_time,   
         :ls_ramp_time,   
         :ls_kitchen_time  ,
			:il_Routing_ID,
			:ls_Box_From,
			:ls_Box_To,
			:ls_Suffix
    FROM cen_out  
   WHERE nresult_key = :al_Result_key   ;
Else
	ls_airline			= ""
	ll_flight_number	= -1
	ls_departure_time	= ""
	ls_ramp_time		= ""
	ls_kitchen_time	= ""
	il_Routing_ID     = -1
	ls_Box_From			= ""
	ls_Box_To			= ""
	ls_Suffix			= ""
End If

ls_Suffix = TRIM(ls_Suffix)

// -----------------------------------------------------
// Departure Time
// -----------------------------------------------------
ls_Text = "f_departure.text='" + ls_departure_time + "'"
li_Succ = of_modify(ls_Text, ab_Backlog)

// -----------------------------------------------------
// Ramp Time
// -----------------------------------------------------
ls_Text = "f_ramptime.text='" + ls_ramp_time + "'"
li_Succ = of_modify(ls_Text, ab_Backlog)

// -----------------------------------------------------
// Customer + Flight Number
// -----------------------------------------------------
If ll_Flight_number > 999 Then
	ls_Text = "f_flightnumber.text='" +  ls_Airline + String(ll_Flight_Number,"0000") + ls_Suffix +"'"
Else
	ls_Text = "f_flightnumber.text='" +  ls_Airline + " " + String(ll_Flight_Number, "000") +  ls_Suffix + "'"
End If

If ll_Flight_Number = -1 Then
	ls_Text = "f_flightnumber.text=' '"
End If
li_Succ = of_modify(ls_Text, ab_Backlog)

// -----------------------------------------------------
// Ramp Box
// -----------------------------------------------------
If isnull(ls_Box_From) Then ls_Box_From = ""
If isnull(ls_Box_To) Then ls_box_to = ""
ls_Text = "f_rampbox.text='" +  ls_Box_From + "'"
If ls_box_to > "" Then
	ls_Text = "f_rampbox.text='" +  ls_Box_From + "-" + ls_box_to + "'"
End If
	
Return 1

end function

public function long of_draw_header (long al_result_key, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_header (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.07.2010
*
* Argument(e):
* long al_result_key
*
* Beschreibung:		Zeichne neuen Header gem$$HEX3$$e400df002000$$ENDHEX$$CBASE-NAM-CR-0029
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.07.2010		Erstellung
* 1.1 			O.Hoefer	02.08.2010		Mehrmals Anpassungen nach diversen Anforderungs$$HEX1$$e400$$ENDHEX$$nderungen
* 1.2 			O.Hoefer	17.10.2011		Hinzu: Suffix zu Flugnummer
* 1.3 			O.Hoefer	08.08.2013		MAX nicht $$HEX1$$fc00$$ENDHEX$$bersetzen
* 1.4 			O.Hoefer	02.05.2017		issue #2502 max 4 legs bei "Best Before"
*
*
* Return: long
*
*/

Integer	li_Succ
Long		ll_Count
Long		ll_Count_2
Long		ll_Rows 
Long		ll_Flight_Number
Long		ll_Leg_Number
Long		ll_Current_Result_Key
Long		ll_Version, ll_PAX
Long		ll_Result_Keys[]
Long		ll_X, ll_Y
Integer	li_Height_Header_Classes = 10
String	ls_Class
String	ls_Airline
String	ls_Output
String	ls_Filter
String	ls_TLC_From, ls_TLC_TO
String	ls_Name
String	ls_Text
String	ls_Band
Long		ll_Color_Grey = rgb(200, 200, 200)
String	ls_File
String	ls_error, ls_modify
Long		ll_Object_Counter
Integer	li_Start_X
Integer	li_Border = BORDER_BOX
Blob		lb_Logo
Integer	li_Width_Other	= 25
Integer	li_Col_Space	= 75
Integer	li_Width_First	= 20
Integer	li_Height	
Integer	li_Start_Pos_LOS
Integer	li_Available_Width
Long		ll_Num_Classes
Long		ll_Temp
String	ls_Suffix
String	ls_Level_of_Service[]



li_Start_X = 250
ll_Y = 1 
// Platz ausnutzen: Beginn Objekt unterhalb - Freiraum oben - feste Zeile (MAX/PAX)
//li_Height = 138 - 10 - 10
//li_Height = 14 // li_Height / 8


// --------------------------------------------------------------------
// Zeichne / f$$HEX1$$fc00$$ENDHEX$$lle neuen Header f$$HEX1$$fc00$$ENDHEX$$r Leg 1...n
// --------------------------------------------------------------------

// Wohin zeichnen - oben oder unten?
If NOT ib_Mode_TR_Cart Then
	if of_is_header_in_footer() Then
		ls_Band = "footer"	
	Else
		ls_Band = "header"
	End If
Else
	if of_is_tr_header_in_footer() Then
		ls_Band = "footer"	
	Else
		ls_Band = "header"
	End If
End If
// --------------------------------------------------------------------
// Ermittle Legs
// --------------------------------------------------------------------

DataStore 	lds_Legs
lds_Legs = CREATE DataStore
//lds_Legs.DataObject = "dw_uo_flight_legs"
lds_Legs.DataObject = "dw_uo_flight_legs_new"
lds_Legs.SetTransObject(SQLCA)

DataStore 	lds_PAX
lds_PAX = CREATE DataStore
lds_PAX.DataObject = "dw_uo_cart_flight_pax"
lds_PAX.SetTransObject(SQLCA)


ll_Rows = lds_Legs.retrieve(al_Result_Key)
li_Succ = lds_Legs.Sort()

If ll_Rows = 0  Then
	lds_Legs.DataObject = "dw_uo_flight_legs_cp"
	lds_Legs.SetTransObject(SQLCA)
	ll_Rows = lds_Legs.retrieve(al_Result_Key)
	li_Succ = lds_Legs.Sort()
End If

If ll_Rows = 0  Then
	lds_Legs.DataObject = "dw_uo_flight_legs_single"
	lds_Legs.SetTransObject(SQLCA)
	ll_Rows = lds_Legs.retrieve(al_Result_Key)
	li_Succ = lds_Legs.Sort()
End If

// --------------------------------------------------------------------------------------
// SB: "...wenn die Funktion Best Before aktiv ist, zeigt er maximal 4 Legs auf dem Header
//      an - wenn es 5 Legs gibt, dann werden diese ausgeblendet im Header"
// --------------------------------------------------------------------------------------
If ib_print_best_before Then
	For ll_Count = lds_Legs.RowCount() To 1 Step -1
		if lds_Legs.GetItemNumber(ll_Count, "nleg_number") > 4 then
			li_Succ = lds_Legs.RowsDiscard(ll_Count, ll_Count, Primary!)
		End If
	Next
End If

// 19.08.2010 nicht skalieren
//// -------------------------------------------
//// Breite berechnen
//// -------------------------------------------
//If lds_Legs.RowCount() = 0 Then
//	// wenn kein Flug
//Else
//	li_Col_Space = (715 - li_Start_X) / lds_Legs.RowCount()
//	// Raum zwischen Spalten
//	//li_Col_Space -= 5
//	li_Width_Other	= (li_Col_Space - 5) * 25 / 70
//	li_Width_First	= (li_Col_Space - 5) * 20 / 70
//End If

// Hole Daten f$$HEX1$$fc00$$ENDHEX$$r Legs
If ll_Rows > 0 Then
	ll_Result_Keys = lds_Legs.Object.nresult_key.Primary
	// Lese 
	ll_Rows = lds_PAX.Retrieve(ll_Result_Keys)
	// dw_uo_cart_flight_pax
	
	
	// Entferne Klasse "*" 
	For ll_Count = lds_PAX.RowCount() To 1 Step -1
		ls_Class = lds_PAX.GetItemString(ll_Count, "cclass")
		If ls_Class = "*" Then
			li_Succ = lds_PAX.RowsDiscard(ll_Count, ll_Count, Primary!)
		End If
	Next
	
	//	18.08.2010 NUR BUCHUNGSKLASSEN
	For ll_Count = lds_PAX.RowCount() To 1 Step -1
		If lds_PAX.GetItemNumber(ll_Count, "cen_out_pax_nbooking_class") = 0 Then
			li_Succ = lds_PAX.RowsDiscard(ll_Count, ll_Count, Primary!)
		End If
	Next
	
	ll_Rows = lds_PAX.RowCount()
	// Anzahl Klassen
	ll_Num_Classes = 0
	ll_Temp = 0 
	If ll_Rows > 0 Then
		//ll_Current_Result_Key = lds_PAX.GetItemNumber(1, "nresult_key")
		// Platz ausnutzen: Beginn Objekt unterhalb - Freiraum oben - feste Zeile (MAX/PAX)
		//li_Height = 138 - 10 - 10
		For ll_Count = 1 To lds_Legs.RowCount()
			ll_Current_Result_Key = lds_Legs.GetItemNumber(ll_Count, "nresult_key")
			ls_Filter = "nresult_key = " + String(ll_Current_Result_Key)
			li_Succ = lds_PAX.SetFilter(ls_Filter)
			li_Succ = lds_PAX.Filter()
			If lds_PAX.RowCount() > ll_Num_Classes Then
				ll_Num_Classes = lds_PAX.RowCount()
			End If
		Next
		// 18.08.2010 nicht skalieren
//		li_Height = 138 - 10 - ll_Y
//		//li_Height = Ceiling( li_Height / (ll_Num_Classes + 2))
//		li_Height = li_Height / (ll_Num_Classes + 2) // Classes + Flight No + From - To
		
		li_Succ = lds_PAX.SetFilter("")
		li_Succ = lds_PAX.Filter()
	Else
		li_Height = 12 // li_Height / 8
	End If
	If li_Height = 0 Then
		li_Height = 12
	End If
	
	ll_X = li_Start_X
	ll_Y = 1
	For ll_Count = 1 To lds_Legs.RowCount()
		// Info Flugnummer f$$HEX1$$fc00$$ENDHEX$$r Leg Nr x
		ll_Flight_Number = lds_Legs.GetItemNumber(ll_Count, "nflight_number")
		ls_Airline = lds_Legs.GetItemString(ll_Count, "cairline")
		ls_Suffix = lds_Legs.GetItemString(ll_Count, "csuffix")	
		If Isnull(ls_Suffix) then ls_Suffix = ""
		ls_Suffix = Trim(ls_Suffix)
		
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
		//li_Succ = of_create_text(ls_name, ls_Airline + " " + String(ll_Flight_number, "000") ,FONT_MICROSOFT_SANS_SERIF, 10, FONT_BOLD, ll_X + 00, ll_Y , li_Height, li_Width_First + li_Width_Other * 2 , BORDER_NONE, 2, 0, 1, ls_Band, ab_Backlog)
		li_Succ = of_create_text(ls_name, ls_Airline + " " + String(ll_Flight_number, "000") + ls_Suffix ,FONT_MICROSOFT_SANS_SERIF, 10, FONT_BOLD, ll_X + 00, ll_Y , li_Height, li_Width_First + li_Width_Other * 2 , BORDER_NONE, 2, 0, 1, ls_Band, ab_Backlog)	
		//ls_Output += ls_Airline + " " + String(ll_Flight_number) + "~t"
		ls_Output += ls_Airline + " " + String(ll_Flight_number) + ls_Suffix + "~t"	
		ll_X += li_Col_Space		
	Next 
	ls_Output += "~r~n"

	ll_X = li_Start_X
	ll_Y += li_Height + 2

	For ll_Count = 1 To lds_Legs.RowCount()
		// Info Leg f$$HEX1$$fc00$$ENDHEX$$r Leg Nr x
		ll_Current_Result_Key = lds_Legs.GetItemNumber(ll_Count, "nresult_key")
		ll_Leg_Number = lds_Legs.GetItemNumber(ll_Count, "nleg_number")
		ls_TLC_From = lds_Legs.GetItemString(ll_Count, "ctlc_from")
		ls_TLC_To = lds_Legs.GetItemString(ll_Count, "ctlc_to")
		ls_Output += String(ll_Leg_Number) + " " + ls_TLC_From + " " + ls_TLC_To + "~t"
		
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
		li_Succ = of_create_text(ls_name, String(ll_Leg_Number)	,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, ll_X +  00, ll_Y , li_Height, li_Width_First , BORDER_NONE, 2, 0, 1, ls_Band, ab_Backlog)
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
		li_Succ = of_create_text(ls_name,  ls_TLC_From				,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, ll_X + li_Width_First, ll_Y , li_Height, li_Width_Other, BORDER_NONE, 2, 0, 1, ls_Band, ab_Backlog)
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
		li_Succ = of_create_text(ls_name,  ls_TLC_To					,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, ll_X + li_Width_First + li_Width_Other, ll_Y , li_Height, li_Width_Other, BORDER_NONE, 2, 0, 1, ls_Band, ab_Backlog)

		ll_X += li_Col_Space
	
	Next 
	ls_Output += "~r~n"

	ll_X = li_Start_X
	ll_Y += li_Height + 2

	For ll_Count = 1 To lds_Legs.RowCount()
		// $$HEX1$$dc00$$ENDHEX$$berschrift
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
		li_Succ = of_create_text(ls_name, " "  ,FONT_MICROSOFT_SANS_SERIF, 6, FONT_BOLD, ll_X , ll_Y , 9, li_Width_First, li_Border, 2, 0, 1, ls_Band, ab_Backlog)
		ls_Modify = ls_Name + ".Background.Color='" + String(ll_Color_Grey ) + "' " + ls_Name +  ".Background.Mode='0'"
		If ab_backlog = FALSE Then
			li_Succ = of_modify_dw(ls_Modify)
		Else
			li_Succ = of_modify_dw_backlog(ls_Modify)
		End If
		
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
		li_Succ = of_create_text(ls_name, "MAX"  ,FONT_MICROSOFT_SANS_SERIF, 6, FONT_BOLD, ll_X + li_Width_First, ll_Y , 9, li_Width_Other, li_Border, 2, 0, 1, ls_Band, ab_Backlog)
		ls_Modify = ls_Name + ".Background.Color='" + String(ll_Color_Grey ) + "' " + ls_Name +  ".Background.Mode='0'"
		If ab_backlog = FALSE Then
			li_Succ = of_modify_dw(ls_Modify)
		Else
			li_Succ = of_modify_dw_backlog(ls_Modify)
		End If
		
		
		ls_Modify = ls_name + ".tag='DO_NOT_TRANSLATE'"
		If ab_backlog = FALSE Then
			li_Succ = of_modify_dw(ls_Modify)
		Else
			li_Succ = of_modify_dw_backlog(ls_Modify)
		End If
		
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
		li_Succ = of_create_text(ls_name, "PAX"  ,FONT_MICROSOFT_SANS_SERIF, 6, FONT_BOLD, ll_X + li_Width_Other + li_Width_First , ll_Y , 9, li_Width_Other, li_Border, 2, 0, 1, ls_Band, ab_Backlog)
		ls_Modify = ls_Name + ".Background.Color='" + String(ll_Color_Grey ) + "' " + ls_Name +  ".Background.Mode='0'"
		If ab_backlog = FALSE Then
			li_Succ = of_modify_dw(ls_Modify)
		Else
			li_Succ = of_modify_dw_backlog(ls_Modify)
		End If
		ls_Output += "  MAX  PAX~t"
		ll_X += li_Col_Space
		Next 
	ls_Output += "~r~n"
	
//	ll_X = li_Start_X
	ll_Y += 9
	
		For ll_Count_2 = 1 To 5 //6
			ll_X = li_Start_X
			If ll_Count_2 > 1 Then
				ll_Y += li_Height
			End If
			For ll_Count = 1 To lds_Legs.RowCount()
				// Version + PAX		
				ll_Current_Result_Key = lds_Legs.GetItemNumber(ll_Count, "nresult_key")
				
				ls_Filter = "nresult_key = " + String(ll_Current_Result_Key) + " and nclass_number = " + String(ll_Count_2)
				li_Succ = lds_PAX.SetFilter(ls_Filter)
				li_Succ = lds_PAX.Filter()
				If lds_PAX.RowCount() > 0 Then
					ll_Version = lds_PAX.GetItemNumber(1, "nversion")
					ll_PAX = lds_PAX.GetItemNumber(1, "npax")
					ls_Class = lds_PAX.GetItemString(1, "cclass")					
					ls_Output += ls_Class + " " + String(ll_Version) + " " + String(ll_PAX) + "~t"					
					ll_Object_Counter++
					ls_Name = "h_" + String(ll_Object_Counter)	
					li_Succ = of_create_text(ls_name, ls_Class				,FONT_MICROSOFT_SANS_SERIF, 7, FONT_NORMAL, ll_X +  00, ll_Y , li_Height_Header_Classes, li_Width_First , li_Border, 2, 0, 1, ls_Band, ab_Backlog)
					ll_Object_Counter++
					ls_Name = "h_" + String(ll_Object_Counter)
					li_Succ = of_create_text(ls_name, String(ll_Version)	,FONT_MICROSOFT_SANS_SERIF, 7, FONT_NORMAL, ll_X + li_Width_First, ll_Y , li_Height_Header_Classes, li_Width_Other , li_Border, 2, 0, 1, ls_Band, ab_Backlog)
					ll_Object_Counter++
					ls_Name = "h_" + String(ll_Object_Counter)
					li_Succ = of_create_text(ls_name, String(ll_PAX)		,FONT_MICROSOFT_SANS_SERIF, 7, FONT_NORMAL, ll_X + li_Width_First + li_Width_Other, ll_Y , li_Height_Header_Classes, li_Width_Other , li_Border, 2, 0, 1, ls_Band, ab_Backlog)
		
					ll_X += li_Col_Space
			
				Else
					ls_Output += "~t"
				
				End If
	
			Next
		ls_Output += "~r~n"
	Next 
	
Else
	// Keine Legs???
	li_Start_Pos_LOS = li_start_X
	//	ls_airline			= ""
	//	ll_flight_number	= -1
	//	ls_departure_time	= ""
	//	ls_ramp_time		= ""
	//	ls_kitchen_time	= ""
	//	il_Routing_ID     = -1
	//	ls_Box_From			= ""
	//	ls_Box_To			= ""	
	//	h_departuredate 
	//	h_packinglist 
	//	h_description 
	//	h_actype 
	//	h_loadinglist 
End If


// ----------------------------------------------------
// Level of Service
// ----------------------------------------------------
li_Succ = of_get_level_of_service(ls_Level_of_Service)
ll_Y = 1
If Upperbound(ls_Level_of_Service) < 6 Then ll_Y += li_Height 
If Upperbound(ls_Level_of_Service) < 5 Then ll_Y += li_Height 
If Upperbound(ls_Level_of_Service) < 4 Then ll_Y += li_Height 
li_Start_Pos_LOS = li_Start_X + 3 * li_Col_Space
If lds_Legs.RowCount() > 3 Then
	li_Start_Pos_LOS = li_Start_X + lds_Legs.RowCount() * li_Col_Space
End If
ll_X = li_Start_Pos_LOS
li_Available_Width = 710 - li_Start_Pos_LOS
For ll_Count = 1 To Upperbound(ls_Level_of_Service) 
	// level of service
	ls_Text = ls_Level_of_Service[ll_Count]
	ll_Object_Counter++
	ls_Name = "h_" + String(ll_Object_Counter)
	li_Succ = of_create_text(ls_name, ls_Text, FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, ll_X, ll_Y , li_Height, li_Available_Width , BORDER_NONE, ALIGN_LEFT , 0, 1, ls_Band, ab_Backlog)	
	ll_Y += li_Height
Next 

// ----------------------------------------------------
// Departure Date
// ----------------------------------------------------
ls_Text = "h_departuredate.text='" + String(idt_Departure, "MMM DD" ) + "'"
If al_result_key < 1 Then
	ls_Text = "h_departuredate.text=' '"
End If
li_Succ = of_modify(ls_Text, ab_Backlog)

// ----------------------------------------------------
// AC Type
// ----------------------------------------------------
If al_result_key > 0 Then 
	SELECT	cactype  
	INTO		:is_ac_type  
	FROM		cen_out  
	WHERE		nresult_key = :al_result_key   ;
Else
	is_ac_type = ""
End If

ls_Text = "h_actype.text='" + is_ac_type + "'"
li_Succ = of_modify(ls_Text, ab_Backlog)

// ----------------------------------------------------
// Logo / Blob
// ----------------------------------------------------
If al_result_key > 0 Then 
	ls_File = f_gettemppath() + "airline_logo_" + String(al_result_key) + ".jpg"
	
	sRegisteredFiles[Upperbound(sRegisteredFiles) + 1] = ls_File
	
	If NOT FileExists(ls_File) Then
		
		SELECTBLOB		cen_airline_logos.blogo  
		INTO				:lb_Logo  
		FROM				cen_airline_logos,   
							cen_out  
		WHERE				cen_airline_logos.nairline_key = cen_out.nairline_key
		AND				cen_out.nresult_key = :al_result_key 
		AND				cen_airline_logos.ntyp = 1 ;
		
		If SQLCA.SQLCode =  0 Then
			If not isnull(lb_logo) Then
				// ins Filesystem
				//ls_File = f_gettemppath() + "airline_logo.jpg"
				li_Succ = of_blob_to_file( ls_file, lb_Logo)
				ll_Object_Counter++
				ls_Name = "h_" + String(ll_Object_Counter)			
		 
				ls_modify = "create bitmap(name=" + ls_Name + " visible='" + String(1)  + "' resizeable=" + String(1) + "  moveable=" + String(1)  + &
					 " band=" + ls_Band + " filename='" + ls_File + "'" + &
					 " x='" + string(10) + "' y='" + string(1) + &
					 "' height='" + String(50) + "' width='" + String(150) + "' border='" + String(border_none ) + "' )"
	
				of_modify(ls_modify, ab_backlog)
				of_set_position(ls_Name, FALSE, ab_backlog )
				
			End If
		end if
	Else
		ll_Object_Counter++
		ls_Name = "h_" + String(ll_Object_Counter)
				
		ls_modify = "create bitmap(name=" + ls_Name + " visible='" + String(1)  + "' resizeable=" + String(1) + "  moveable=" + String(1)  + &
				 " band=" + ls_Band + " filename='" + ls_File + "'" + &
				 " x='" + string(10) + "' y='" + string(1) + &
				 "' height='" + String(50) + "' width='" + String(150) + "' border='" + String(border_none ) + "' )"

		of_modify(ls_modify, ab_backlog)
		of_set_position(ls_Name, FALSE, ab_backlog )
			
	End If
End If

DESTROY	lds_PAX
DESTROY	lds_Legs

Return 1

end function

public function integer of_clean_band (string as_band, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_clean_band (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.07.2010
*
* Argument(e):
*	string		as_band		Header oder Footer
*	boolean		ab_backlog	verwende dw-Backlog
*
* Beschreibung:		L$$HEX1$$f600$$ENDHEX$$sche alles aus Header oder Footer
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.07.2010		Erstellung
*
*
* Return: integer
*
*/


//----------------------------------------------------
// Alle Objecte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
If ab_backlog = FALSE Then
	if isvalid(oDw) Then
		 sDWObjects = oDw.describe("datawindow.objects")
	End If
			
	if isvalid(oDs) Then
		sDWObjects = ods.describe("datawindow.objects")
	End If
Else
	if isvalid(odwbacklog ) Then
		 sDWObjects = odwbacklog .describe("datawindow.objects")
	End If
			
	if isvalid(odsbacklog ) Then
		sDWObjects = odsbacklog .describe("datawindow.objects")
	End If
	
	
End If
	
// sDWObjects = oDw.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If


for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If ab_backlog = FALSE Then
		if isvalid(oDw) Then
			 sBand 	= oDw.Describe(sObjects[i] + ".band")
		End If
		if isvalid(ods) Then
			 sBand 	= ods.Describe(sObjects[i] + ".band")
		End If
	Else
		if isvalid(odwbacklog ) Then
			 sBand 	= odwbacklog  .Describe(sObjects[i] + ".band")
		End If
		if isvalid(odsbacklog ) Then
			 sBand 	= odsbacklog .Describe(sObjects[i] + ".band")
		End If
		
	End If
	If lower(sBand) = lower(as_Band) Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				ls_Error = oDw.modify("destroy " + sObjects[i])
			End If
			
			if isvalid(ods) Then
				ls_Error = ods.modify("destroy " + sObjects[i])
			End If
		Else
			If sBand = "summary" Then
				ll_Debug = 1
			End If
			if isvalid(odwbacklog ) Then
				ls_Error = odwbacklog .modify("destroy " + sObjects[i])
			End If
			
			if isvalid(odsbacklog ) Then
				ls_Error = odsbacklog .modify("destroy " + sObjects[i])
			End If
		End If
		
	End If
	
Next
	
Return 1
end function

public function long of_set_position (string arg_s_mod, boolean arg_b_flag, boolean ab_backlog);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_set_position (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.10.2009
* Argument(e):
* string arg_s_mod
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  29.10.2009	1.0           Ulrich Paudler     Erstellung
*  28.07.2010	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Backlog DW hinzu
*
*************************************************************/

If ab_backlog = FALSE Then
	
	if isValid(oDw) Then
		oDW.SetPosition(arg_s_mod, "", arg_b_flag)
	End If
	
	if isValid(oDS) Then
		oDS.SetPosition(arg_s_mod, "", arg_b_flag)
	End If
			
Else
			
	if isValid(odwbacklog ) Then
		odwbacklog .SetPosition(arg_s_mod, "", arg_b_flag)
	End If
	
	if isValid(odsbacklog ) Then
		 odsbacklog.SetPosition(arg_s_mod, "", arg_b_flag)
	End If
	
End If
			
return 0
end function

public function long of_print_prepare_new_h_f (string arg_s_loadinglist, string arg_s_packinglist, string arg_s_pl_description, string arg_s_rampbox, string arg_s_stowage, string arg_s_class, string arg_s_workstation, string arg_s_currentpage, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_print_prepare_new_h_f (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 27.07.2010
*
* Argument(e):
*	 string arg_s_loadinglist
*	 string arg_s_packinglist
*	 string arg_s_pl_description
*	 string arg_s_rampbox
*	 string arg_s_stowage
*	 string arg_s_class
*	 string arg_s_workstation
*	 string arg_s_currentpage
*
* Beschreibung:		F$$HEX1$$fc00$$ENDHEX$$llen der verbleibenden Felder in Header / Footer
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	27.07.2010		Erstellung
* 1.1 			O.Hoefer	13.12.2010		Diverse Versuche, die maximal m$$HEX1$$f600$$ENDHEX$$gliche Fontgr$$HEX1$$f600$$ENDHEX$$sse auszurechnen
*
*
* Return: long
*
*/

Long		li_W, li_H 
Integer	li_Font_Size
Boolean	lb_Bold = FALSE
String	ls_Font_Name
String	ls_Message
Integer	li_Succ
Integer	li_min_font_size = -5
Integer	li_Ret, iret
Integer	li_Calc_Size
Long		ll_Duration, ll_Start, ll_Stop



If Trim(arg_s_workstation) = "-" then
   arg_s_workstation = " "
End If


of_modify("h_loadinglist.text='"					+ arg_s_loadinglist		+ "'", ab_Backlog)
of_modify("h_packinglist.text='" 				+ arg_s_packinglist		+ "'", ab_Backlog)
of_modify("h_description.text='" 				+ arg_s_pl_description	+ "'", ab_Backlog)
of_modify("t_pagecounter.text='" 				+ arg_s_currentpage		+ "'", ab_Backlog)
of_modify("f_stowageposition.text='" 			+ arg_s_stowage			+ "'", ab_Backlog)
of_modify("f_workstation.text='" 				+ arg_s_workstation		+ "'", ab_Backlog)
If Trim(arg_s_rampbox) = "" OR IsNULL(arg_s_rampbox) Then arg_s_rampbox = " "
of_modify("f_rampbox.text='" 						+ arg_s_rampbox			+ "'", ab_Backlog)
//of_modify("f_class.text='" 						+ arg_s_class + "'", ab_Backlog)

// Stowage
ls_Font_Name = of_describe( "f_stowageposition.font.face",  ab_backlog)
li_H = Integer(of_describe( "f_stowageposition.height",  ab_backlog))
li_W = Integer(of_describe( "f_stowageposition.width",  ab_backlog))

ll_Start = CPU()
li_Calc_Size = of_calc_font_size(arg_s_stowage, li_H, li_W, ls_Font_Name, FALSE, FALSE, FALSE, FALSE)
ll_Stop = CPU()
ll_Duration = ll_Stop - ll_Start
If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_print_prepare_new_h_f of_calc_font_size DURATION: " + string(ll_Duration))	
If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_print_prepare_new_h_f " + arg_s_stowage + " => " + ls_Font_Name +"FONT SIZE " + String(li_Calc_Size) + " height" + String(li_H) + " Width " + String(li_W) )

If li_Calc_Size > 0 Then
	of_modify('f_stowageposition.font.height="-'+String(li_Calc_Size)+'"', ab_Backlog)
End If

// Bei zu gro$$HEX1$$df00$$ENDHEX$$en L$$HEX1$$e400$$ENDHEX$$ngen: Font kleiner
Choose Case Len(arg_s_pl_description)
	Case 25 TO 29 
		of_modify('h_description.font.height="-13"', ab_Backlog)
	Case 30 TO 39 
		of_modify('h_description.font.height="-12"', ab_Backlog)
	Case 40 TO 60 
		of_modify('h_description.font.height="-10"', ab_Backlog)
	Case 61 TO 100
		of_modify('h_description.font.height="-8"',  ab_Backlog)
	Case IS > 100
		of_modify('h_description.font.height="-6"',  ab_Backlog)				
End Choose

// Bei zu gro$$HEX1$$df00$$ENDHEX$$en L$$HEX1$$e400$$ENDHEX$$ngen: Font kleiner
//Choose Case Len(arg_s_rampbox)
//	Case 0 TO 4 
//		of_modify('f_rampbox.font.height="-24"', ab_Backlog)
//	Case 6 TO 8
//		of_modify('f_rampbox.font.height="-20"', ab_Backlog)
//	Case IS > 8
//		of_modify('f_rampbox.font.height="-18"', ab_Backlog)				
//End Choose
ls_Font_Name = of_describe( "f_rampbox.font.face",  ab_backlog)
li_H = Integer(of_describe( "f_rampbox.height",  ab_backlog))
li_W = Integer(of_describe( "f_rampbox.width",  ab_backlog))
//ll_Start = CPU()
li_Calc_Size = of_calc_font_size(arg_s_rampbox , li_H, li_W, ls_Font_Name, FALSE, FALSE,FALSE, TRUE)
//ll_Stop = CPU()
//li_Succ = of_modify('f_rampbox.font.height="-18"', ab_Backlog)				
If li_Calc_Size > 0 Then
	of_modify('f_rampbox.font.height="-'+String(li_Calc_Size)+'"', ab_Backlog)
End If

// ---------------------------------------------------------------------
// Bei zu gro$$HEX1$$df00$$ENDHEX$$en L$$HEX1$$e400$$ENDHEX$$ngen: Font kleiner
// ---------------------------------------------------------------------
ls_Message = ""
ls_Font_Name = of_describe( "f_workstation.font.face",  ab_backlog)
li_Font_Size = Integer(of_describe( "f_workstation.font.height",  ab_backlog))
li_H = Integer(of_describe( "f_workstation.height",  ab_backlog))
li_W = Integer(of_describe( "f_workstation.width",  ab_backlog))

ll_Start = CPU()
li_Calc_Size = of_calc_font_size(arg_s_workstation , li_H, li_W, ls_Font_Name, FALSE,FALSE,FALSE,TRUE)
ll_Stop = CPU()
ll_Duration = ll_Stop - ll_Start
If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_print_prepare_new_h_f of_calc_font_size DURATION: " + string(ll_Duration))	
If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_print_prepare_new_h_f " + arg_s_workstation + " => "+ ls_Font_Name+ " FONT SIZE " + String(li_Calc_Size)+ " height " + String(li_H) + " Width " + String(li_W))

If li_Calc_Size > 0 Then
	li_Calc_Size -= 1
	of_modify('f_workstation.font.height="-'+String(li_Calc_Size)+'"', ab_Backlog)
End If

// Bei zu gro$$HEX1$$df00$$ENDHEX$$en L$$HEX1$$e400$$ENDHEX$$ngen: Font kleiner
Choose Case Len(arg_s_loadinglist)
	Case 0 TO 12 
		of_modify('h_loadinglist.font.height="-14"', ab_Backlog)
	Case 13 TO 16
		of_modify('h_loadinglist.font.height="-13"', ab_Backlog)
	Case IS > 16
		of_modify('h_loadinglist.font.height="-12"', ab_Backlog)				
End Choose


Return 0

end function

public function integer of_check_object_sizes (boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_clean_band (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.07.2010
*
* Argument(e):
*	string		as_band		Header oder Footer
*	boolean		ab_backlog	verwende dw-Backlog
*
* Beschreibung:		L$$HEX1$$f600$$ENDHEX$$sche alles aus Header oder Footer
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.07.2010		Erstellung
*
*
* Return: integer
*
*/


//----------------------------------------------------
// Alle Objecte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name
String	ls_Width
String	ls_Syntax
String	ls_Clip

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
If ab_backlog = FALSE Then
	if isvalid(oDw) Then
		 sDWObjects = oDw.describe("datawindow.objects")
	End If
			
	if isvalid(oDs) Then
		sDWObjects = ods.describe("datawindow.objects")
	End If
Else
	if isvalid(odwbacklog ) Then
		 sDWObjects = odwbacklog .describe("datawindow.objects")
	End If
			
	if isvalid(odsbacklog ) Then
		sDWObjects = odsbacklog .describe("datawindow.objects")
	End If
	
	
End If
	
// sDWObjects = oDw.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If


for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	
	If ab_backlog = FALSE Then
		if isvalid(oDw) Then
			 sBand 	= oDw.Describe(sObjects[i] + ".band")
		End If
		if isvalid(ods) Then
			 sBand 	= ods.Describe(sObjects[i] + ".band")
		End If
	Else
		if isvalid(odwbacklog ) Then
			 sBand 	= odwbacklog  .Describe(sObjects[i] + ".band")
			 sTemp 	= odwbacklog  .Describe(sObjects[i] + ".x")
			 If odwbacklog  .Describe(sObjects[i] + ".type") <> "line" Then
				ls_Width = odwbacklog.Describe(sObjects[i] + ".width")
			Else
				ls_Width = String(Long(odwbacklog.Describe(sObjects[i] + ".width")) - Long(stemp))
			End If
			 ls_Clip +=  ls_Name + "~t" + sTemp + "~t" + ls_Width + "~r~n"
		End If
		if isvalid(odsbacklog ) Then
			 sBand 	= odsbacklog .Describe(sObjects[i] + ".band")
			 sTemp 	= odsbacklog  .Describe(sObjects[i] + ".x")
			 If odsbacklog  .Describe(sObjects[i] + ".type") <> "line" Then
				ls_Width = odsbacklog.Describe(sObjects[i] + ".width")
			Else
				ls_Width = String(Long(odsbacklog.Describe(sObjects[i] + ".width")) - Long(stemp))
			End If
			 ls_Clip +=  ls_Name + "~t" + sTemp + "~t" + ls_Width + "~r~n"
		End If
		
	End If

	
Next

if isvalid(odsbacklog ) Then		
	ls_Syntax = 	odsbacklog.Object.DataWindow.Syntax
End If
Clipboard(ls_Clip)	
	
Return 1
end function

public function integer zzz_debug_box (boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: zzz_debug_box (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 15.12.2010
*
* Argument(e):
* boolean ab_backlog
*
* Beschreibung:		Debug Hilfe
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	15.12.2010		Erstellung
*
*
* Return: integer
*
*/


//----------------------------------------------------
// Alle Objekte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name
String	ls_Width
String	ls_Syntax
String	ls_Clip

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
If ab_backlog = FALSE Then
	if isvalid(oDw) Then
		 sDWObjects = oDw.describe("datawindow.objects")
	End If
			
	if isvalid(oDs) Then
		sDWObjects = ods.describe("datawindow.objects")
	End If
Else
	if isvalid(odwbacklog ) Then
		 sDWObjects = odwbacklog .describe("datawindow.objects")
	End If
			
	if isvalid(odsbacklog ) Then
		sDWObjects = odsbacklog .describe("datawindow.objects")
	End If
	
	
End If
	
// sDWObjects = oDw.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If


for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	
	If ab_backlog = FALSE Then
		if isvalid(oDw) Then
			 sBand 	= oDw.Describe(sObjects[i] + ".band")
		End If
		if isvalid(ods) Then
			 sBand 	= ods.Describe(sObjects[i] + ".band")
		End If
	Else
		if isvalid(odwbacklog ) Then
			 sBand 	= odwbacklog  .Describe(sObjects[i] + ".band")
			 sTemp 	= odwbacklog  .Describe(sObjects[i] + ".x")
			 If odwbacklog  .Describe(sObjects[i] + ".type") <> "line" Then
				ls_Width = odwbacklog.Describe(sObjects[i] + ".width")
			Else
				ls_Width = String(Long(odwbacklog.Describe(sObjects[i] + ".width")) - Long(stemp))
			End If
			 ls_Clip +=  ls_Name + "~t" + sTemp + "~t" + ls_Width + "~r~n"
		End If
		if isvalid(odsbacklog ) Then
			
			odsbacklog.modify(sObjects[i] + ".border='2'")
			
//			 sBand 	= odsbacklog .Describe(sObjects[i] + ".band")
//			 sTemp 	= odsbacklog  .Describe(sObjects[i] + ".x")
//			 If odsbacklog  .Describe(sObjects[i] + ".type") <> "line" Then
//				ls_Width = odsbacklog.Describe(sObjects[i] + ".width")
//			Else
//				ls_Width = String(Long(odsbacklog.Describe(sObjects[i] + ".width")) - Long(stemp))
//			End If
//			 ls_Clip +=  ls_Name + "~t" + sTemp + "~t" + ls_Width + "~r~n"
		End If
		
	End If

	
Next

if isvalid(odsbacklog ) Then		
	ls_Syntax = 	odsbacklog.Object.DataWindow.Syntax
End If
Clipboard(ls_Clip)	
	
Return 1
end function

public function integer of_modify (string as_modify, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_modify (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 04.08.2010
*
* Argument(e):
*	string as_modify
*	boolean ab_backlog
*
* Beschreibung:		Rufe Modify f$$HEX1$$fc00$$ENDHEX$$r Normal oder Backlog auf
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	04.08.2010		Erstellung
*
*
* Return: integer
*
*/

Integer	li_Succ

If ab_backlog = FALSE Then
	li_Succ = of_modify_dw(as_modify)
Else
	li_Succ = of_modify_dw_backlog(as_modify)
End If

Return li_Succ

end function

public function integer of_get_multiply ();
Return il_Multiply
end function

public function integer of_get_rungs ();
return il_Rungs
end function

public function integer of_get_columns ();
Return il_columns
end function

public function string of_get_tr_cart_description ();/*
* Objekt : uo_cart_diagram
* Methode: of_get_tr_cart_description (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 09.08.2010
*
* Argument(e):
* none
*
* Beschreibung:		TR Cart Description
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	09.08.2010		Erstellung
*
*
* Return: string
*
*/


return is_TR_Cart_Description
end function

public function boolean of_is_use_class_enabled ();/*
* Objekt : uo_cart_diagram
* Methode: of_is_use_class_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 09.08.2010
*
* Argument(e):
* none
*
* Beschreibung:		Stammdaten TR Cart - Schalter "Use Class" (bef$$HEX1$$fc00$$ENDHEX$$llen nach Class getrennt)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	09.08.2010		Erstellung
*
*
* Return: boolean
*
*/


Return 	ib_TR_Use_Class 
end function

public function boolean of_is_fill_top_down_enabled ();/*
* Objekt : uo_cart_diagram
* Methode: of_is_fill_top_down_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 09.08.2010
*
* Argument(e):
* none
*
* Beschreibung:		Stammdaten TR Cart - Schalter "Fill Top - Down"
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	qq.08.2010		Erstellung
*
*
* Return: boolean
*
*/


Return 	ib_TR_Fill_Top_Down 
end function

public function long of_draw_tr_stowage_pos (long arg_irow, long arg_icolumn, long arg_itype, string arg_stowage);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_tr_stowage_pos (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 11.08.2010
*
* Argument(e):
*	 long arg_irow
*	 long arg_icolumn
*	 long arg_itype
*	 string arg_stowage
*
* Beschreibung:		Schreibe Stowage in den Einschub des TR Carts
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	11.08.2010		Erstellung
* 1.1 			O.Hoefer	01.02.2011		Change Request (S. Bless: please change the font size. 3 or 4 sizes plus)
*
*
* Return: long
*
*/

Long		ll_X2
Long		ll_Drawer_Height 
String	ls_DWObject
Long		ll_Row_Height
Integer	li_Y_Offset
Integer	li_Y_Pos


ll_Drawer_Height	= il_TR_DefaultHeight - 2
ll_Row_Height		= il_TR_DefaultHeight
li_Y_Offset			= il_TR_YOffset
//li_Y_Pos				= li_Y_Offset  + (arg_iRow * il_TR_DefaultHeight) +  (ll_Drawer_Height / 2) - 15
li_Y_Pos				= li_Y_Offset  + (arg_iRow * il_TR_DefaultHeight) +  (ll_Drawer_Height / 2) - 20

// Aktuelle Position merken
this.iCurrentRow		= arg_iRow
this.iCurrentColumn	= arg_iColumn

ll_X2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth - 12
ls_DWObject = "t_stowage_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

//of_create_text(ls_DWObject, arg_stowage ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD , ll_X2 - 50, li_Y_pos, 11 , 50, 0, ALIGN_RIGHT  , 0, 1)
of_create_text(ls_DWObject, arg_stowage ,FONT_MICROSOFT_SANS_SERIF, 12, FONT_BOLD , ll_X2 - 120, li_Y_pos, 16 , 120, 0, ALIGN_RIGHT  , 0, 1)

//if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(ls_DWObject,  TRUE)

Return 1

end function

public function long of_draw_watermark_downline (long arg_irow, long arg_icolumn, integer arg_ltype);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_watermark_downline (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 12.08.2010
*
* Argument(e):
*	 long arg_irow
*	 long arg_icolumn
*	 integer arg_ltype
*
* Beschreibung:		Wasserzeichen "DOWNLINE"
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	12.08.2010		Erstellung
*
*
* Return: long
*
*/


String	ls_Object
long		ll_Row, lX1, lX2, lY1, lY2, lRowHeight //, lYCounter
long		llTextWidth
Long		ll_Color =    RGB(200,200,200)
String	ls_Downline


ls_Downline = "DOWNLINE"

// ============= Vorlage ==============
//pg.setColor(new Color(200, 200, 200));
//pg.setFont(new Font("SansSerif", 0, 30));
//pg.drawString("DOWNLINE", dl_watermark_x - 12, dl_watermark_y);
//It is color 200,200,200 and SansSerif size 30.

if of_is_tr_componentlist_enabled() and bHasDimensions Then
	llTextWidth = TEXTWIDTH1
Else
	llTextWidth = TEXTWIDTHSMALL1
End If

Choose Case arg_ltype
	Case TRAYNONFOOD
		lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 20
	Case Else
		lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
end Choose

lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth/2
lRowHeight = 14

ls_Object = "t_wtrmrk_dwnln_c_" + string(arg_icolumn, "00") + "_r_" + string(arg_iRow, "00")
lY1 = il_TR_YOffset + ((arg_iRow) *  il_tr_defaultheight)
lY1 -= 35

of_create_text(ls_Object, ls_Downline ,FONT_MICROSOFT_SANS_SERIF, 30, FONT_NORMAL, lX1, lY1 , 45 , llTextWidth , 0, ALIGN_CENTER, ll_Color, 1)


return 0
end function

public function long of_draw_segment_indicator (long arg_irow, long arg_icolumn, long arg_itype, long arg_lnumber);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_segment_indicator (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 12.08.2010
*
* Argument(e):
* long arg_irow
*	 long arg_icolumn
*	 long arg_itype
*	 long arg_lnumber
*
* Beschreibung:		Zeichne "Segment X"
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	12.08.2010		Erstellung
*
*
* Return: long
*
*/


Long			ll_X
String		ls_DWObject
long			ll_y
String		ls_Segment
Long			ll_Color


ll_Color = 0 // Black

ls_Segment = "Segment " + String(arg_lnumber)

// Aktuelle Position merken
this.iCurrentRow = arg_iRow
this.iCurrentColumn = arg_iColumn

ll_X = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 12
ll_y = lyOffset + (arg_iRow * lDefaultHeight)  - 15

// Boden des Drawers sind 5 Pixel hoch, die Breite aufziehen
ls_DWObject = "t_segment_indicator_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

of_create_text(ls_DWObject, ls_Segment,FONT_MICROSOFT_SANS_SERIF, 6, FONT_BOLD, ll_X, ll_y, 10 , ldefaultwidth , 0, 0,  ll_Color, 1)
//if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
//of_set_position(sDWObject, False)

Return 1

end function

public function integer of_move_objects (string as_band, integer ai_offset_v, integer ai_offset_h, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_move_objects (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 19.08.2010
*
* Argument(e):
* string as_band
*	 integer ai_offset_v			Offet Vertikal: < 0 nach oben, > 0 nach unten
*	 integer ai_offset_h			Offet Horizontal: < 0 nach links, > 0 nach rechts
*	 boolean ab_backlog			TRUE = Backlog-DW
*
* Beschreibung:		Alle Objekte im Band um x/y Einheiten verschieben in der X bzw. Y-Achse
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	19.08.2010		Erstellung
* 1.1 			O.Hoefer	30.01.2014		X-Achse hinzu plus Schutz vor x/y < 0
* 1.2 			O.Hoefer	31.03.2014		wenn y < 0 w$$HEX1$$fc00$$ENDHEX$$rde => y = 1
*
*
* Return: integer
*
*/

//----------------------------------------------------
// Alle Objekte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name
String	ls_Y_Pos
String	ls_X_Pos
String	ls_Y1_Pos, ls_Y2_Pos
String	ls_X1_Pos, ls_X2_Pos
String	ls_Mod

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
If ab_backlog = FALSE Then
	if isvalid(oDw) Then
		 sDWObjects = oDw.describe("datawindow.objects")
	End If
			
	if isvalid(oDs) Then
		sDWObjects = ods.describe("datawindow.objects")
	End If
Else
	if isvalid(odwbacklog ) Then
		 sDWObjects = odwbacklog .describe("datawindow.objects")
	End If
			
	if isvalid(odsbacklog ) Then
		sDWObjects = odsbacklog .describe("datawindow.objects")
	End If
		
End If
	
// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If


for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If ab_backlog = FALSE Then
		if isvalid(oDw) Then
			 sBand 	= oDw.Describe(sObjects[i] + ".band")
		End If
		if isvalid(ods) Then
			 sBand 	= ods.Describe(sObjects[i] + ".band")
		End If
	Else
		if isvalid(odwbacklog ) Then
			 sBand 	= odwbacklog  .Describe(sObjects[i] + ".band")
		End If
		if isvalid(odsbacklog ) Then
			 sBand 	= odsbacklog .Describe(sObjects[i] + ".band")
		End If
		
	End If
	If lower(sBand) = lower(as_Band) Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				//ls_Error = oDw.modify("destroy " + sObjects[i])
				sType 	= oDw.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y1_Pos = oDw.Describe(sObjects[i] + ".y1")
					ls_Y2_Pos = oDw.Describe(sObjects[i] + ".y2")
					If (Integer(ls_Y1_Pos) + ai_offset_v) > 0 AND (Integer(ls_Y2_Pos) + ai_offset_v) > 0 Then
						ls_Error = oDw.modify(sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'")
						ls_Error = oDw.modify(sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'")
					End If
					
					ls_X1_Pos = oDw.Describe(sObjects[i] + ".x1")
					ls_X2_Pos = oDw.Describe(sObjects[i] + ".x2")
					If Integer(ls_X1_Pos) + ai_offset_h > 0 AND Integer(ls_X2_Pos) + ai_offset_h > 0 Then
						ls_Error = oDw.modify(sObjects[i] + ".x1='" + String(Integer(ls_X1_Pos) + ai_offset_h ) + "'")
						ls_Error = oDw.modify(sObjects[i] + ".x2='" + String(Integer(ls_X2_Pos) + ai_offset_h ) + "'")
					End If

				Else
					ls_Y_Pos = oDw.Describe(sObjects[i] + ".y")
					If Integer(ls_Y_Pos) + ai_offset_v > 0 Then
						ls_Error = oDw.modify(sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'")
					Else
						ls_Error = oDw.modify(sObjects[i] + ".y='1'")
					End If
					// Horizontal					
					ls_X_Pos = oDw.Describe(sObjects[i] + ".x")
					If Integer(ls_X_Pos) + ai_offset_h > 0 Then
						ls_Error = oDw.modify(sObjects[i] + ".x='" + String(Integer(ls_X_Pos) + ai_offset_h ) + "'")
					End If

				End If
				
				
			End If
			
			if isvalid(ods) Then
				//ls_Error = ods.modify("destroy " + sObjects[i])
				sType 	= oDs.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y1_Pos = oDs.Describe(sObjects[i] + ".y1")
					ls_Y2_Pos = oDs.Describe(sObjects[i] + ".y2")
					If Integer(ls_Y1_Pos) + ai_offset_v > 0 AND Integer(ls_Y2_Pos) + ai_offset_v > 0 Then
						ls_Mod = sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'"
						ls_Error = ods.modify(ls_Mod)
						ls_Mod = sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'"
						ls_Error = ods.modify(ls_Mod)
					End If
					
					ls_X1_Pos = oDs.Describe(sObjects[i] + ".x1")
					ls_X2_Pos = oDs.Describe(sObjects[i] + ".x2")
					If Integer(ls_X1_Pos) + ai_offset_h > 0 AND Integer(ls_X2_Pos) + ai_offset_h > 0 Then
						ls_Mod = sObjects[i] + ".x1='" + String(Integer(ls_X1_Pos) + ai_offset_h ) + "'"
						ls_Error = ods.modify(ls_Mod)
						ls_Mod = sObjects[i] + ".x2='" + String(Integer(ls_X2_Pos) + ai_offset_h ) + "'"
						ls_Error = ods.modify(ls_Mod)
					End If
					
				Else
					ls_Y_Pos = oDs.Describe(sObjects[i] + ".y")
					If Integer(ls_Y_Pos) + ai_offset_v > 0 Then
						ls_Mod = sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'"
						ls_Error = ods.modify(ls_Mod)
					Else
						ls_Mod = sObjects[i] + ".y='1'"
						ls_Error = ods.modify(ls_Mod)						
					End If
					
					ls_X_Pos = oDs.Describe(sObjects[i] + ".x")
					If Integer(ls_X_Pos) + ai_offset_h > 0 Then
						ls_Mod = sObjects[i] + ".x='" + String(Integer(ls_X_Pos) + ai_offset_h ) + "'"
						ls_Error = ods.modify(ls_Mod)
					End If
				End If
				
			End If
		Else

			if isvalid(odwbacklog ) Then
				//ls_Error = odwbacklog .modify("destroy " + sObjects[i])
				sType 	= oDs.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y1_Pos = odwbacklog.Describe(sObjects[i] + ".y1")
					ls_Y2_Pos = odwbacklog.Describe(sObjects[i] + ".y2")
					ls_Error = odwbacklog.modify(sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'")
					ls_Error = odwbacklog.modify(sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'")
				Else
					ls_Y_Pos = odwbacklog.Describe(sObjects[i] + ".y")					
					ls_Error = odwbacklog.modify(sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'")
					// X-POS
					ls_X_Pos = odwbacklog.Describe(sObjects[i] + ".x")					
					ls_Error = odwbacklog.modify(sObjects[i] + ".x='" + String(Integer(ls_X_Pos) + ai_offset_h ) + "'")
				End If
			End If
			
			if isvalid(odsbacklog ) Then

				sType 	= odsbacklog.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y1_Pos = odsbacklog.Describe(sObjects[i] + ".y1")
					ls_Y2_Pos = odsbacklog.Describe(sObjects[i] + ".y2")
					ls_Error = odsbacklog.modify(sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'")
					ls_Error = odsbacklog.modify(sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'")
				Else
					ls_Y_Pos = odsbacklog.Describe(sObjects[i] + ".y")
					ls_Error = odsbacklog.modify(sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'")
					
					ls_X_Pos = odsbacklog.Describe(sObjects[i] + ".x")
					ls_Error = odsbacklog.modify(sObjects[i] + ".x='" + String(Integer(ls_X_Pos) + ai_offset_h ) + "'")

				End If
			End If
		End If
		
	End If
	
Next
	
Return 1

end function

public function integer of_get_min_offset (string as_band, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_move_objects (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 19.08.2010
*
* Argument(e):
* string as_band
*	 integer ai_offset_v			Offet Vertikel: < 0 nach oben, > 0 nach unten
*	 integer ai_offset_h			noch ohne Funktion
*	 boolean ab_backlog			TRUE = Backlog-DW
*
* Beschreibung:		TEST Alle Objekte im Band um x Einheiten verschieben in der Y-Achse
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	19.08.2010		Erstellung
*
*
* Return: integer
*
*/

//----------------------------------------------------
// Alle Objekte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name
String	ls_Y_Pos
Integer	li_Min_Y = 1000


// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
If ab_backlog = FALSE Then
	if isvalid(oDw) Then
		 sDWObjects = oDw.describe("datawindow.objects")
	End If
			
	if isvalid(oDs) Then
		sDWObjects = ods.describe("datawindow.objects")
	End If
Else
	if isvalid(odwbacklog ) Then
		 sDWObjects = odwbacklog .describe("datawindow.objects")
	End If
			
	if isvalid(odsbacklog ) Then
		sDWObjects = odsbacklog .describe("datawindow.objects")
	End If	
	
End If
	
// sDWObjects = oDw.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If


for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	
	If sObjects[i] = "r_frame" OR Left(sObjects[i], 9) = "t_marker_" OR sObjects[i] = "p_props" OR sObjects[i] = "p_props_color" Then Continue
	
	If ab_backlog = FALSE Then
		if isvalid(oDw) Then
			 sBand 	= oDw.Describe(sObjects[i] + ".band")
		End If
		if isvalid(ods) Then
			 sBand 	= ods.Describe(sObjects[i] + ".band")
		End If
	Else
		if isvalid(odwbacklog ) Then
			 sBand 	= odwbacklog  .Describe(sObjects[i] + ".band")
		End If
		if isvalid(odsbacklog ) Then
			 sBand 	= odsbacklog .Describe(sObjects[i] + ".band")
		End If
		
	End If
	If lower(sBand) = lower(as_Band) Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				//ls_Error = oDw.modify("destroy " + sObjects[i])
				sType 	= oDw.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y_Pos = oDw.Describe(sObjects[i] + ".y1")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
//					ls_Y2_Pos = oDw.Describe(sObjects[i] + ".y2")
//					ls_Error = oDw.modify(sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'")
//					ls_Error = oDw.modify(sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'")
				Else
					ls_Y_Pos = oDw.Describe(sObjects[i] + ".y")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
					//					ls_Error = oDw.modify(sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'")
				End If				
				
			End If
			
			if isvalid(ods) Then
				//ls_Error = ods.modify("destroy " + sObjects[i])
				sType 	= oDs.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y_Pos = oDs.Describe(sObjects[i] + ".y1")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
					//					ls_Y2_Pos = oDs.Describe(sObjects[i] + ".y2")
//					ls_Error = ods.modify(sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'")
//					ls_Error = ods.modify(sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'")
//					If Integer(ls_Y_Pos) < 25 Then
//						messagebox( sObjects[i] , "Y Pos: "  + ls_Y_Pos)
//					End If
				Else
					ls_Y_Pos = oDs.Describe(sObjects[i] + ".y")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
					//					ls_Error = ods.modify(sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'")
//					If Integer(ls_Y_Pos) < 25 Then
//						messagebox( sObjects[i] , "Y Pos: "  + ls_Y_Pos)
//					End If
				End If
				
			End If
		Else
//			If sBand = "summary" Then
//				ll_Debug = 1
//			End If
			if isvalid(odwbacklog ) Then
				//ls_Error = odwbacklog .modify("destroy " + sObjects[i])
				sType 	= oDs.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y_Pos = odwbacklog.Describe(sObjects[i] + ".y1")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
					//					ls_Y2_Pos = odwbacklog.Describe(sObjects[i] + ".y2")
//					ls_Error = odwbacklog.modify(sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'")
//					ls_Error = odwbacklog.modify(sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'")
				Else
					ls_Y_Pos = odwbacklog.Describe(sObjects[i] + ".y")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
					//					ls_Error = odwbacklog.modify(sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'")
				End If
			End If
			
			if isvalid(odsbacklog ) Then
				//ls_Error = odsbacklog .modify("destroy " + sObjects[i])
				sType 	= odsbacklog.Describe(sObjects[i] + ".type")
				If stype = "line" Then
					ls_Y_Pos = odsbacklog.Describe(sObjects[i] + ".y1")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
					//					ls_Y2_Pos = odsbacklog.Describe(sObjects[i] + ".y2")
//					ls_Error = odsbacklog.modify(sObjects[i] + ".y1='" + String(Integer(ls_Y1_Pos) + ai_offset_v ) + "'")
//					ls_Error = odsbacklog.modify(sObjects[i] + ".y2='" + String(Integer(ls_Y2_Pos) + ai_offset_v ) + "'")
				Else
					ls_Y_Pos = odsbacklog.Describe(sObjects[i] + ".y")
					If Integer(ls_Y_Pos) < li_Min_Y Then li_Min_Y = Integer(ls_Y_Pos)
					//					ls_Error = odsbacklog.modify(sObjects[i] + ".y='" + String(Integer(ls_Y_Pos) + ai_offset_v ) + "'")
				End If
			End If
		End If
		
	End If
	
Next
	
//messagebox( "Min Y ", "Y Pos: "  + String(li_Min_Y))
	
Return li_Min_Y

end function

public function integer of_remove_contents_billing (ref datastore rads_contents);/*
* Objekt : uo_cart_diagram
* Methode: of_remove_contents_billing (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 14.09.2010
*
* Argument(e):
* none
*
* Beschreibung:		Remove Contents with Status "Billing"
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	14.09.2010		Erstellung
*
*
* Return: integer
*
*/


Long		ll_Count
Long		ll_Key
Integer	li_Succ
Integer	li_Reckoning	

// ib_Discard_Status_Billing
/// Billing = 2

If rads_Contents.RowCount() < 1 Then Return 0

For ll_Count = rads_Contents.RowCount() To 1 STEP -1
	li_Reckoning = rads_Contents.GetItemNumber(ll_Count, "nreckoning")
	If li_Reckoning = 2 Then
		ll_Key = rads_Contents.GetItemNumber(ll_Count, "ndetail_key")	
		guoLog.uf_debug("["+ this.classname( )+".of_remove_contents_billing] "  +  this.isStowage +" - " + "Remove Content w. Billing Status 2: " + String(ll_Key))
		li_Succ = rads_Contents.Rowsdiscard( ll_Count, ll_Count, Primary!)
	
	End If
Next


Return li_Succ
end function

public function boolean of_is_tr_componentlist_enabled ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_tr_componentlist_enabled (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 27.10.2009
* Argument(e):
* none
*
* Return: boolean
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fung ob die Komponentenliste eingeschaltet ist
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  27.10.2009	1.0           Ulrich Paudler     Erstellung
*  02.11.2009	1.1           Ulrich Paudler     Umstellung auf of_profilestring
*  02.02.2012	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter "Parameter statt Profile" (Service)
*                                               Variante "Section aus Instanzvariable" (WEB)
*  24.10.2013	1.3           Oliver H$$HEX1$$f600$$ENDHEX$$fer       NAM CR 12032 Immer TRUE
*
*************************************************************/

return TRUE


end function

public function long of_create_line (string sobjectname, long lx1, long ly1, long lx2, long ly2, long lcolor, long al_width);/* 
* Funktion/Event: of_create_line
* Beschreibung: 	Linie anlegen
*
* Besonderheit: 	keine
*
* Argumente:
* 	sObjectName			= Name der Objects
*	lX1					= X1Pos der Linie im Datawindow
*	lY1					= Y1Pos
*	lX2					= X2Pos der Linie im Datawindow
*	lY2					= Y2Pos
*	lColor				= Farbe der Linie
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	26.08.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*/
String 	sCreate
String	sRet

sCreate = "create line(band=detail x1='" + string(lX1) + "' y1='" + &
			 string(lY1) + "' x2='" + string(lX2) + "' y2='" + string(lY2) + &
			 "' name=" + sObjectName + "  moveable=0" + &
			 " visible='1'" + &
			 " pen.style='0' pen.width='" + String(al_width ) + "'" + &
			 " pen.color='" + String(lColor) + "'" + &
			 " background.mode='2' background.color='1073741824' )"


of_modify_dw(sCreate)


return 1

end function

public function long of_draw_tr_background_col (long arg_irow, long arg_icolumn, long arg_color);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_tr_background_col (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 15.09.2010
*
* Argument(e):
* long arg_irow
*	 long arg_icolumn
*	 long arg_color
*
* Beschreibung:		Background colouring for changes
*							If a packing list has been modified in the last 30 days, 
*							then this packing list should have a greyed background on 
*							the cart diagram to show the recent change
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	15.09.2010		Erstellung
*
*
* Return: long
*
*/


Long				ll_X2
String			ls_DWObject
Long				ll_Row_Height
Long				ll_YOffset
String			ls_Create
Integer			li_Succ
Integer			li_Y_pos, li_X_pos, li_Width, li_height
Integer			li_Brush_Hatch = 6


ll_YOffset = il_TR_YOffset
ll_Row_Height = il_TR_DefaultHeight
li_X_Pos = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 1
li_Y_pos = ll_YOffset + (arg_iRow * ll_Row_Height) - ((ll_Row_Height - 5) / 2) - 1
li_height = ll_Row_Height - 5
ll_X2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth //- 12
li_Width = ll_X2 - li_X_Pos //- 10

ls_DWObject = "r_background_colour_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

ls_Create = "create rectangle(band=detail x='" + string(li_X_pos ) +  &
			   "' y='" + string(li_Y_pos ) + "' height='" + string(li_Height) + &
				"' width='" + string(li_Width) + "' name=" + ls_DWObject + &
				" resizeable=" + string(1)  + "  moveable=" + string(1)  + &
				" visible='1'" + &
				"  brush.hatch='" + string(li_Brush_Hatch) + &
				"' brush.color='" + string(arg_color ) +  &
				"' pen.style='0' pen.width='" + string(1) + &
				"' pen.color='" + string(arg_color) + &
				"' background.mode='2' background.color='0')"	

li_Succ = of_modify_dw( ls_Create)

of_set_position(ls_DWObject, False)

Return 1

end function

public function long of_draw_tr_segment_indicator (long arg_irow, long arg_icolumn, long arg_itype, long arg_lnumber);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_segment_indicator (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 12.08.2010
*
* Argument(e):
*	 long arg_irow
*	 long arg_icolumn
*	 long arg_itype
*	 long arg_lnumber
*
* Beschreibung:		Zeichne "Segment X"
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	12.08.2010		Erstellung
*
*
* Return: long
*
*/


String		ls_Segment
Long			ll_Color
Long			ll_X2
Long			ll_Drawer_Height 
String		ls_DWObject
Long			ll_Row_Height
Integer		li_Y_Offset
Integer		li_Y_Pos


ll_Color				= 0 // Black
ls_Segment			= "Segment " + String(arg_lnumber)
ll_Drawer_Height	= il_TR_DefaultHeight - 2
ll_Row_Height		= il_TR_DefaultHeight
li_Y_Offset			= il_TR_YOffset
li_Y_Pos				= li_Y_Offset  + (arg_iRow * il_TR_DefaultHeight) +  (ll_Drawer_Height / 2) - 15

// Aktuelle Position merken
this.iCurrentRow		= arg_iRow
this.iCurrentColumn	= arg_iColumn

ll_X2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  12
ls_DWObject = "t_segment_ind_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

of_create_text(ls_DWObject, ls_Segment ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD , ll_X2, li_Y_pos, 12 , 80, 0, align_left  , ll_Color, 1)
//if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(ls_DWObject,  TRUE)

Return 1

end function

public function integer of_move_to_background (boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_move_objects (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 19.08.2010
*
* Argument(e):
* string as_band
*	 integer ai_offset_v			Offet Vertikel: < 0 nach oben, > 0 nach unten
*	 integer ai_offset_h			noch ohne Funktion
*	 boolean ab_backlog			TRUE = Backlog-DW
*
* Beschreibung:		TEST Alle Objekte im Band um x Einheiten verschieben in der Y-Achse
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	19.08.2010		Erstellung
* 1.1 			O.Hoefer	09.07.2012		Feintuning f$$HEX1$$fc00$$ENDHEX$$r Tipp-Ex $$HEX1$$fc00$$ENDHEX$$ber Mittellinien bei 2 Columns
*
*
* Return: integer
*
*/

//----------------------------------------------------
// Alle Objekte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name
String	ls_Y_Pos
String	ls_Y1_Pos, ls_Y2_Pos

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
If ab_backlog = FALSE Then
	if isvalid(oDw) Then
		 sDWObjects = oDw.describe("datawindow.objects")
	End If
			
	if isvalid(oDs) Then
		sDWObjects = ods.describe("datawindow.objects")
	End If
Else
	if isvalid(odwbacklog ) Then
		 sDWObjects = odwbacklog .describe("datawindow.objects")
	End If
			
	if isvalid(odsbacklog ) Then
		sDWObjects = odsbacklog .describe("datawindow.objects")
	End If
	
	
End If
	
// sDWObjects = oDw.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If

//sDWObject = "r_background_colour_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
//ls_Object = "t_wtrmrk_dwnln_c_" + string(arg_icolumn, "00") + "_r_" + string(arg_iRow, "00")
// t_watermark_102

// p_pic_content_cover_col_
// l_line_6_1 l_line_5_2

// 1. Watermark gross nach hinten 2. Downline nach hinten  3.Colour Marker nach hinten

// 1. Watermark gross nach hinten 2. Downline nach hinten  3.Colour Marker nach hinten
for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If Left(ls_name, Len("t_watermark_")) = "t_watermark_" Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(ods) Then
				of_set_position(ls_name, FALSE, ab_backlog )							
			End If
		Else
			if isvalid(odwbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(odsbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )					
			End If
		End If			
	End If	
Next
	
for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If Left(ls_name, Len("t_wtrmrk_dwnln_c_")) = "t_wtrmrk_dwnln_c_" Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(ods) Then
				of_set_position(ls_name, FALSE, ab_backlog )							
			End If
		Else
			if isvalid(odwbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(odsbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )					
			End If
		End If			
	End If	
Next	
	
for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If Left(ls_name, Len("r_background_colour_")) = "r_background_colour_" Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(ods) Then
				of_set_position(ls_name, FALSE, ab_backlog )							
			End If
		Else
			if isvalid(odwbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(odsbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )					
			End If
		End If			
	End If	
Next		

	
// p_pic_content_cover_col_
// l_line_6_1 l_line_5_2
// p_lane_left_col_2_row_2

// Tipp-Ex $$HEX1$$fc00$$ENDHEX$$ber Mittellinie (bei Drawer mit 2 Cols)
for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If Left(ls_name, Len("p_pic_content_cover_col_")) = "p_pic_content_cover_col_" Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(ods) Then
				of_set_position(ls_name, FALSE, ab_backlog )							
			End If
		Else
			if isvalid(odwbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(odsbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )					
			End If
		End If			
	End If	
Next		


// Schiene
for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If Left(ls_name, Len("p_lane_right_col_1_row_")) = "p_lane_right_col_1_row_" OR Left(ls_name, Len("p_lane_left_col_2_row_")) = "p_lane_left_col_2_row_" Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(ods) Then
				of_set_position(ls_name, FALSE, ab_backlog )							
			End If
		Else
			if isvalid(odwbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(odsbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )					
			End If
		End If			
	End If	
Next		

// Drawer links / rechts
for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	//		Left(ls_name, Len("p_left_drawer_rung_")) = "p_left_drawer_rung_" OR & 
	//		Left(ls_name, Len("p_right_drawer_rung_")) = "p_right_drawer_rung_" OR &
	//		Left(ls_name, Len("p_left_drawer_col_")) = "p_left_drawer_col_" OR &
	//		Left(ls_name, Len("p_right_drawer_col_")) = "p_right_drawer_col_" OR &
	If Left(ls_name, Len("p_left_drawer_")) = "p_left_drawer_" OR &
		Left(ls_name, Len("p_right_drawer_")) = "p_right_drawer_" OR &
		Left(ls_name, Len("p_bottom_drawer_")) = "p_bottom_drawer_" Then &
		
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(ods) Then
				of_set_position(ls_name, FALSE, ab_backlog )							
			End If
		Else
			if isvalid(odwbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(odsbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )					
			End If
		End If			
	End If	
Next		
// Mittellinien
for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If Left(ls_name, Len("l_line_5_2")) = "l_line_5_2" OR Left(ls_name, Len("l_line_6_1")) = "l_line_6_1" Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(ods) Then
				of_set_position(ls_name, FALSE, ab_backlog )							
			End If
		Else
			if isvalid(odwbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )		
			End If
			if isvalid(odsbacklog ) Then
				of_set_position(ls_name, FALSE, ab_backlog )					
			End If
		End If			
	End If	
Next		
		
Return 1

end function

public function long of_draw_tr_drawer (long arg_irow, long arg_icolumn, long arg_itype, boolean arg_bnew, string as_description);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_tr_drawer (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 14.12.2010
*
* Argument(e):
* long arg_irow
*	 long arg_icolumn
*	 long arg_itype
*	 boolean arg_bnew
*	 string as_description
*
* Beschreibung:		TR Drawer zeichnen
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	14.12.2010		Erstellung
* 1.1 			O.Hoefer	02.02.2011		Hinzu: Drawer f$$HEX1$$fc00$$ENDHEX$$r Carts mit 7 HE
*
*
* Return: long
*
*/


Long		lX1
Long		lX2
Long		lFound, lFoundNext, lRowHeight, i, lYCounter, lNewDetailKey
Long		ll_Drawer_Height = 90 / 2
String	sDWObject, sDWButtonObject
Long		iType, iTypeNext
long		lY, lW
Long		ll_Row_Height
Long		ll_YOffset


// Bilder nicht skalieren, sondern from Stock
String	ls_PIC_Left
String	ls_PIC_Right
//Drawer_right_tc_10.JPG
//Drawer_left_tc_14.JPG
//Drawer_right_tc_6.JPG
//Drawer_right_tc_14.JPG
//Drawer_right_tc_8.JPG
//Drawer_left_tc_6.JPG
//Drawer_left_tc_10.JPG
//Drawer_left_tc_8.JPG

ll_YOffset = il_TR_YOffset
ll_Row_Height = il_TR_DefaultHeight
ll_Drawer_Height = ll_Row_Height - 5
//Drawer_left_tc_10.JPG
ls_PIC_Left = "..\Resource\Drawer_left_1.jpg"
ls_PIC_Right = "..\Resource\Drawer_right_1.jpg"

If ib_Expand_TR_Cart = FALSE Then
	ls_PIC_Left		=  "..\Resource\Drawer_left_tc_14.jpg"
	ls_PIC_Right	=  "..\Resource\Drawer_right_tc_14.jpg"
	ll_Drawer_Height = 47
Else
	Choose Case ll_Drawer_Height
		Case	72
			ls_PIC_Left		=  "..\Resource\Drawer_left_tc_10.jpg"
			ls_PIC_Right	=  "..\Resource\Drawer_right_tc_10.jpg"			

		Case	92
			ls_PIC_Left		=  "..\Resource\Drawer_left_tc_8.jpg"
			ls_PIC_Right	=  "..\Resource\Drawer_right_tc_8.jpg"			
			
		Case	124
			ls_PIC_Left		=  "..\Resource\Drawer_left_tc_6.jpg"
			ls_PIC_Right	=  "..\Resource\Drawer_right_tc_6.jpg"			
				
		Case	115
			ls_PIC_Left		=  "..\Resource\Drawer_left_tc_7.jpg"
			ls_PIC_Right	=  "..\Resource\Drawer_right_tc_7.jpg"			
		
		Case	55
			ls_PIC_Left		=  "..\Resource\Drawer_left_tc_55px.jpg"
			ls_PIC_Right	=  "..\Resource\Drawer_right_tc_55px.jpg"			
			
		Case Else
			
	End Choose
End If


// Aktuelle Position merken
this.iCurrentRow = arg_iRow
this.iCurrentColumn = arg_iColumn


// Seitenteile des Drawers sind im Original 12 x 90 Pixel 
lX1 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 1
sDWObject = "p_left_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, ls_PIC_Left, lX1, ll_YOffset + (arg_iRow * ll_Row_Height) - (ll_Drawer_Height / 2) - 1,  ll_Drawer_Height, 12, 1, 0, 0)

if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

lX2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  lDefaultWidth - 12
sDWObject = "p_right_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
of_create_picture(sDWObject, ls_PIC_Right, lX2, ll_YOffset + (arg_iRow * ll_Row_Height) - (ll_Drawer_Height / 2) - 1, ll_Drawer_Height, 12, 1, 0, 0)
if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject,  False)

// Boden des Drawers sind 5 Pixel hoch, die Breite aufziehen
sDWObject = "p_bottom_drawer_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

of_create_picture(sDWObject, "..\Resource\drawer_bottom.jpg", lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 12, ll_YOffset + (arg_iRow * ll_Row_Height) +  (ll_Drawer_Height / 2) - 6, 5, lX2 - lX1 - 10, 1, 0, 0)

if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(sDWObject, False)

// Bild, dient als Button zum sp$$HEX1$$e400$$ENDHEX$$teren $$HEX1$$f600$$ENDHEX$$ffnen der Contents
// in einem eigenen Dialog
sDWButtonObject = "p_button_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
//of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 15 ,ll_YOffset + (arg_iRow * ll_Row_Height) - 45 - 1, 14, 14, 0, 0, 0)
of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", lX2 - 20 ,ll_YOffset + (arg_iRow * ll_Row_Height)  - 30 , 14, 14, 0, 0, 0)

if of_register(sDWButtonObject, arg_iRow, arg_iColumn) = -1 Then return -1

	sDWObject = "t_master_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")
	
//	lY1 = li_Y_Offset  + (il_TR_DefaultHeight / 2 ) + (lRowHeight * lYCounter) - llAdditionali_Y_Offset
//	lY1 = lY1 + 1
	of_create_text(sDWObject, as_Description ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD, lXOffset + ((arg_iColumn -1) * lDefaultWidth) + 10 ,&
									ll_YOffset + ((arg_iRow - 1) * ll_Row_Height) + (il_TR_DefaultHeight / 2 ) &
									, 15 ,   ldefaultwidth - 10 , 0, align_left ,  RGB(0,0,0), 1)	
									
									
// -----------------------------------
// Den Button nach oben, sonst kann
// er nicht angeklickt werden
// -----------------------------------
of_set_position(sDWButtonObject, True)

Return 1

end function

public function string of_describe_dw_backlog (string arg_s_mod);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_modify_dw_backlog (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 28.10.2009
* Argument(e):
* string arg_s_mod
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  28.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
String	ls_Return

if isValid(oDwBacklog) Then
	ls_Return =  oDwBacklog.describe(arg_s_mod)
End If

if isValid(oDsBacklog) Then
	ls_Return = oDsBacklog.describe(arg_s_mod)
End If
			
return ls_Return
end function

public function string of_describe_dw (string arg_s_mod);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_modify_dw (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 09.09.2009
* Argument(e):
* string arg_s_mod
*
* Return: long
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fen und $$HEX1$$c400$$ENDHEX$$ndern
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  09.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
String sRet
	
if isValid(oDw) Then
	sRet = oDw.describe(arg_s_mod)
End If

if isValid(oDS) Then
	sRet = oDS.describe(arg_s_mod)
End If

		
return sret
end function

public function string of_describe (string as_modify, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_describe (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 04.08.2010
*
* Argument(e):
*	string as_modify
*	boolean ab_backlog
*
* Beschreibung:		Rufe Modify f$$HEX1$$fc00$$ENDHEX$$r Normal oder Backlog auf
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	04.08.2010		Erstellung
*
*
* Return: integer
*
*/

Integer	li_Succ
String	ls_Return

If ab_backlog = FALSE Then
	ls_Return = of_describe_dw(as_modify)
Else
	ls_Return = of_describe_dw_backlog(as_modify)
End If

Return ls_Return

end function

public function boolean of_suppress_class_watermark (long al_airline_key, string as_unit, long al_routing, string as_class);/*
* Objekt : uo_cart_diagram
* Methode: of_suppress_class_watermark (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.09.2010
*
* Argument(e):
* long al_airline_key
*	 string as_unit
*	 long al_routing
*	 string as_class
*
* Beschreibung:		Watermark f$$HEX1$$fc00$$ENDHEX$$r bestimmte Klasse unterdr$$HEX1$$fc00$$ENDHEX$$cken 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.09.2010		Erstellung
*
*
* Return: boolean
*
*/


String	ls_Value
String	ls_Airline

ls_Airline = f_get_airline_name(al_airline_key)

ls_Value = f_unitprofilestring( "w_local_cart_diagram" , "WM_XCL_" + ls_Airline + "_" + String(al_Routing) + "_" +  as_Class , "" , as_unit) 
If ls_Value = "YES" Then
	Return TRUE
End If

Return FALSE
end function

public function boolean of_is_downline_enabled (long al_airline_key, long al_routing_id, string as_unit);
/*
* Objekt : uo_cart_diagram
* Methode: of_is_downline_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.09.2010
*
* Argument(e):
* long al_airline_key
*	 long al_routing_id
*
* Beschreibung:		Schalter Watermark DOWNLINE
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.09.2010		Erstellung
*
*
* Return: boolean
*
*/

String		ls_Value


ls_Value = f_unitprofilestring("w_local_cart_diagram" , "WATERMARK_DOWNLINE_" + f_get_airline_name(al_Airline_key) + "_" + String(al_Routing_id), "EMPTY" , as_unit) 

// Wenn leer: Default lesen
If ls_Value = "EMPTY" Then 

	ls_Value = f_unitprofilestring("w_local_cart_diagram" , "DEF_WATERMARK_DOWNLINE", "" , as_unit) 
	
End If

If Upper(ls_Value) = "ON" Then
	Return TRUE
End If


Return FALSE

end function

public function boolean of_is_backcol_enabled (long al_airline_key, long al_routing_id, string as_unit);/*
* Objekt : uo_cart_diagram
* Methode: is_backcol_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.09.2010
*
* Argument(e):
* long al_airline_key
*	 long al_routing_id
*
* Beschreibung:		Schalter Watermark Bachground Colouring
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.09.2010		Erstellung
*
*
* Return: boolean
*
*/

String		ls_Value
String		ls_Airline


ls_Airline = f_get_airline_name(al_Airline_key)
ls_Value = f_unitprofilestring("w_local_cart_diagram" , "WATERMARK_BACKCOL_" + ls_Airline+ "_" + String(al_Routing_id), "EMPTY" , as_unit) 


// Wenn leer: Default lesen
If ls_Value = "EMPTY" Then 

	ls_Value = f_unitprofilestring("w_local_cart_diagram" , "DEF_WATERMARK_BACKCOL", "" , as_unit) 
	
End If

If Upper(ls_Value) = "ON" Then
	Return TRUE
End If


Return FALSE

end function

public function integer of_get_watermark_type (long al_airline_key, long al_routing_id, string as_unit);/*
* Objekt : uo_cart_diagram
* Methode: of_get_watermark_type (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 11.09.2012
*
* Argument(e):
* long al_airline_key
*	 long al_routing_id
*	 string as_unit
*
* Beschreibung:		Ermittle Wasserzeichen
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	11.09.2012		Erstellung
*
*
* Return: integer
*
*/

Integer		li_Type
String		ls_Value
String		ls_Airline


ls_Airline = f_get_airline_name(al_Airline_key)

ls_Value = f_unitprofilestring("w_local_cart_diagram" , "WATERMARK_" + ls_Airline + "_" + String(al_Routing_id), "EMPTY" , as_unit) 

Choose Case ls_Value
	Case "PRODRANGE"
		li_Type = Watermark_prodrange
	Case "OPS"
		li_Type = Watermark_ops
	Case "CLASS"
		li_Type = watermark_class
	Case "FLIGHTNUMBER"
		li_Type = watermark_flight_number
	Case "RAMPTIME"
		li_Type = watermark_ramp_time
	Case "KITCHENTIME"
		li_Type = watermark_kitchen_time
	Case "NONE"
		li_Type = -1
	Case Else
		li_Type = -1
		
End Choose

// Wenn leer: Default lesen
If ls_Value = "EMPTY" Then 

	ls_Value = f_unitprofilestring("w_local_cart_diagram" , "DEF_WATERMARK_" + ls_Airline, "" , as_unit) 

	Choose Case ls_Value
		Case "PRODRANGE"
			li_Type = Watermark_prodrange
		Case "OPS"
			li_Type = Watermark_ops
		Case "CLASS"
			li_Type = watermark_class
		Case "FLIGHTNUMBER"
			li_Type = watermark_flight_number
		Case "RAMPTIME"
			li_Type = watermark_ramp_time
		Case "KITCHENTIME"
			li_Type = watermark_kitchen_time
		Case "NONE"
			li_Type = -1
		Case Else
			li_Type = -1
	End Choose
	
End If

Return li_Type

end function

public function long of_draw_tr_cart (string as_unit);/* 
* Funktion/Event: of_draw_tr_cart
* Beschreibung: 	Zeichnen des Transporter Carts
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		26.08.2008	Erstellung
*	1.1				U.Paudler	29.04.2009   Eis Einschub entfernen
*	1.2				U.Paudler	19.10.2009   Eis Einschub Umriss entfernen, unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
*	1.3				U.Paudler	21.10.2009  	Druck Zentrieren
*	1.4				U.Paudler	26.10.2009  	Reifen
*	1.5			   U.Paudler	18.01.2010  	Front/Rear Bezeichnung
*	1.6			   O.H$$HEX1$$f600$$ENDHEX$$fer  	15.12.2010  	Kopie of_draw_cart => of_draw_tr_cart
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long		lRows
Long		lColumns
Long		lWidth
Long		i, j
Long		lX
Long		lY
String	sDWObject
Long		lWheelsize = 11
Long		lWheelXOffset = 5
Long		lWheeli_Y_Offset = 1
Long		lWheelHeight = 23
Long		llTextWidth
Long		ll_Cart_Type_Key
Long		ll_Multiply
Long		ll_Detailheight
Integer	li_Succ
Long		ll_Bottom_Offset = 10
Integer	li_Y_Offset
Date		ldt_Departure

// TR CART statt normaler carts
// Beispiel TR 12

li_Y_Offset = il_TR_YOffset

ilContainerType = TR_CART   // this.dsAirlineEq.GetItemNumber(1, "ntype")


If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"


// CBASE-UK-CR-2013-002
If ib_Extended_TR_Handling = TRUE Then
	// ----------------------------------------------
	// TR Type selection using more detailed parms
	// ----------------------------------------------
	ldt_Departure = idt_departure
	
	ll_Cart_Type_Key = of_get_tr_cart_key(as_unit, il_IndexKey, ldt_departure , il_rungs, il_columns, il_multiply, il_AirlineKey)

else
	ll_Cart_Type_Key =  of_get_tr_cart_type_old( s_app.smandant , as_unit , il_AirlineKey , il_Routing_ID )

End If


guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_cart] Type: " + String(ll_Cart_Type_Key))

//isContainerShortName  = "TR12"  // = this.dsAirlineEq.GetItemString(1, "cunit")
lRows 	= il_rungs		//	this.dsAirlineEq.GetItemNumber(1, "nrows")
lColumns = il_columns 		//	this.dsAirlineEq.GetItemNumber(1, "ncolumns")
ll_Multiply = il_multiply

ilColumnCount = lColumns

If ib_Expand_TR_Cart Then
   If of_is_Header_in_footer() Then
      If IsValid(ods) Then
         ll_Detailheight = of_get_detail_height(oDs) - (il_Header_Height_H_in_F  + il_Footer_Height_H_in_F)
         il_TR_DefaultHeight = (ll_Detailheight - lWheelHeight  -  li_Y_Offset - 25) / (il_rungs + 0)
      End If
      If isvalid(odw) Then
         ll_Detailheight = of_get_detail_height(oDw) - (il_Header_Height_H_in_F  + il_Footer_Height_H_in_F)
         il_TR_DefaultHeight = (ll_Detailheight - lWheelHeight  -  li_Y_Offset - 25) / (il_rungs + 0)
      End If
   Else   
      If IsValid(ods) Then
         ll_Detailheight = of_get_detail_height(oDs) - (il_Header_Height_Normal  + il_Footer_Height_Normal)
         il_TR_DefaultHeight = (ll_Detailheight - lWheelHeight  -  li_Y_Offset - 25) / (il_rungs + 0)
      End If
      If isvalid(odw) Then
         ll_Detailheight = of_get_detail_height(oDw) - (il_Header_Height_Normal  + il_Footer_Height_Normal)
         il_TR_DefaultHeight = (ll_Detailheight - lWheelHeight  -  li_Y_Offset - 25) / (il_rungs + 0)
      End If
   End If
Else
   il_TR_DefaultHeight = ldefaultheight

End If


guoLog.uf_debug("["+ this.classname( )+".of_draw_tr_cart] "  +  this.isStowage +" - " + "il_TR_DefaultHeight "  + string(il_TR_DefaultHeight) )


// 21.10.2009 Ulrich Paudler [UP] F$$HEX1$$fc00$$ENDHEX$$r Druck zentrieren bzw. verschieben
if lColumns <= 1 Then
	if of_is_tr_componentlist_enabled() Then
//	if of_is_tr_componentlist_enabled() and bHasDimensions Then
		lXOffSet = INITIALOFFSET1
		lDefaultWidth = INITIALWIDTH
	Else
		lXOffSet = INITIALOFFSETSMALL1
		lDefaultWidth = INITIALWIDTH
	End If
Else
	if of_is_tr_componentlist_enabled() Then
//	if of_is_tr_componentlist_enabled() and bHasDimensions Then
		lXOffSet = INITIALOFFSETSMALL2
		lDefaultWidth = INITIALWIDTHSMALL
	Else
		lXOffSet = INITIALOFFSET2
		lDefaultWidth = INITIALWIDTH
	End If
End If

//If lXOffSet > 199 Then
//	lXOffSet -= 50
//End If

lX = lXOffSet
lY = li_Y_Offset

ii_TR_Cart_Left = lXOffSet
ii_TR_Cart_Width = lColumns * lDefaultWidth

For i = 1 to lColumns
	
	sDWObject = "l_line_4_" + string(i)
	of_create_line(sDWObject, lX , li_Y_Offset + il_TR_DefaultHeight / 2 , lX + lDefaultWidth , li_Y_Offset + il_TR_DefaultHeight / 2, RGB(0, 0, 0))
	of_register(sDWObject, -1, -1)
	
	// ---------------------------------------------------------
	// 22.04.2010, KF
	// Breite und xPosition der Spalten merken um sp$$HEX1$$e400$$ENDHEX$$ter
	// $$HEX1$$fc00$$ENDHEX$$berh$$HEX1$$e400$$ENDHEX$$ngende Test zu k$$HEX1$$fc00$$ENDHEX$$rzen
	// ---------------------------------------------------------
	ilColumnWidth[i]	=	lDefaultWidth
	ilColumnX[i]			=  lX 
	ilColumnY[i]			=  li_Y_Offset + il_TR_DefaultHeight / 2
	
	lX += lDefaultWidth
Next

// -------------------------
// Rahmen f$$HEX1$$fc00$$ENDHEX$$r Cart / Trolleys
// zeichnen
// -------------------------
li_Y_Offset += il_TR_DefaultHeight / 2
lX = lXOffSet 
lY = li_Y_Offset

ii_TR_Cart_Top		= li_Y_Offset

If ib_expand_tr_cart Then
	ii_TR_Cart_Height = lRows  * il_TR_DefaultHeight + ll_Bottom_Offset
Else	
	ii_TR_Cart_Height = lRows  * ldefaultheight + ll_Bottom_Offset //ldefaultheight
End If

For i = 1 to lColumns
	// Vertikale Linien
	sDWObject = "l_line_5_" + string(i)
	// 19.10.2009 Ulrich Paudler [UP] Unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
	of_create_line(sDWObject, lX, li_Y_Offset, lX, li_Y_Offset + lRows  * il_TR_DefaultHeight + ll_Bottom_Offset , RGB(128, 128, 128))
	of_register(sDWObject, -1, -1)
	
	sDWObject = "l_line_6_" + string(i)
	// 19.10.2009 Ulrich Paudler [UP] Unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
	of_create_line(sDWObject, lX + lDefaultWidth , li_Y_Offset, lX + lDefaultWidth , li_Y_Offset + lRows * il_TR_DefaultHeight + ll_Bottom_Offset , RGB(128, 128, 128))
	of_register(sDWObject, -1, -1)
	
	// ---------------------------------
	// Drag Drop Target anlegen
	// Schienen zeichnen
	// ---------------------------------
	For j = 1 to lRows
		// Das DragDrop Target 20 pixel hoch zeichnen
		sDWObject = "t_drag_target_col_" + string(i, "00") + "_row_" + string(j, "00")
		of_create_text(sDWObject, "",FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, lX + 10, lY + (j * il_TR_DefaultHeight) - 40, 50, lDefaultWidth - 20, 0, 0, RGB(0,0,0), 1)
		of_register(sDWObject, -1, -1)
		
		sDWObject = "p_lane_left_col_" + string(i) + "_row_" + string(j)
		of_create_picture(sDWObject, "..\Resource\Lane_left.jpg", lX + 1, lY + (j * il_TR_DefaultHeight) - 5, 8, 5, 1, 0, 0)
		of_register(sDWObject, -1, -1)
		
		sDWObject = "p_lane_right_col_" + string(i) + "_row_" + string(j)
		of_create_picture(sDWObject, "..\Resource\Lane_right.jpg", lX + lDefaultWidth - 5 , lY + (j * il_TR_DefaultHeight) - 5, 8, 5, 1, 0, 0)
		of_register(sDWObject, -1, -1)
		
		// -------------------------------------------------------------
		// Rechte Spalte: Rungs mit Nummer
		// -------------------------------------------------------------		
		If i = lColumns Then
			sDWObject = "t_rungnumber_col_" + string(i) + "_row_" + string(j)
			//of_create_picture(sDWObject, "..\Resource\Lane_right.jpg", lX + lDefaultWidth - 5 , lY + (j * il_TR_DefaultHeight) - 5, 8, 5, 1, 0, 0)
			li_Succ = of_create_text(sDWObject,String(j) ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, lX + lDefaultWidth - 5 + 10 , lY + (j * il_TR_DefaultHeight) - 5 , 10, 10 , 0, 2, RGB(200,200,200), 1, "detail", FALSE)	
			of_register(sDWObject, -1, -1)
		End If
		
	Next
	
	// Horizontale Linie
	sDWObject = "l_line_7_" + string(i)
	// 19.10.2009 Ulrich Paudler [UP] Unterste Linie nicht in voller H$$HEX1$$f600$$ENDHEX$$he zeichnen
	of_create_line(sDWObject, lX , li_Y_Offset + lRows  * il_TR_DefaultHeight + ll_Bottom_Offset, lX + lDefaultWidth , li_Y_Offset + lRows  * il_TR_DefaultHeight + ll_Bottom_Offset , RGB(128, 128, 128))
	of_register(sDWObject, -1, -1)
		
	// 26.10.2009 Ulrich Paudler [UP] R$$HEX1$$e400$$ENDHEX$$der unter dem Trolley zeichnen
	if of_get_container_type() = TR_CART Then
		sDWObject = "r_wheel_left_1_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lWheelXOffset , li_Y_Offset + (lRows * il_TR_DefaultHeight) +  lWheelHeight / 2 + lWheeli_Y_Offset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		sDWObject = "r_wheel_left_2_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lWheelXOffset + lWheelsize  , li_Y_Offset + (lRows * il_TR_DefaultHeight) +  lWheelHeight / 2 + lWheeli_Y_Offset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		
		sDWObject = "r_wheel_right_1_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lDefaultWidth - lWheelsize - lWheelXOffset  , li_Y_Offset + (lRows * il_TR_DefaultHeight) +  lWheelHeight / 2 + lWheeli_Y_Offset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		sDWObject = "r_wheel_right_2_col_" + string(i) 
		of_create_wheel(sDWObject, lX + lDefaultWidth - lWheelsize * 2  - lWheelXOffset, li_Y_Offset + (lRows * il_TR_DefaultHeight) +  lWheelHeight / 2 + lWheeli_Y_Offset, lWheelHeight, lWheelsize, RGB(128, 128, 128))
		of_register(sDWObject, -1, -1)
		
	End If

	lX += lDefaultWidth
Next

// 18.01.2010 Ulrich Paudler [UP] Textobjekte Front und Rear
if lColumns = 2 Then
	
	lX = lXOffSet
	if of_get_container_type() = TR_CART Then
		lY = li_Y_Offset + (lRows * il_TR_DefaultHeight) +  (lWheelHeight / 2)
	Else
		lY = li_Y_Offset + (lRows * il_TR_DefaultHeight)
	End If
	
	sDWObject = "t_front_" + string(i)
	of_create_text(sDWObject, uf.translate("Front"),FONT_MICROSOFT_SANS_SERIF, 12, FONT_BOLD, lX + 1, lY + 1 , 25, lDefaultWidth - 2, 0, 2, 0, 1)
	of_register(sDWObject, -1, -1)
	lX += lDefaultWidth
		
	sDWObject = "t_rear_" + string(i)
	of_create_text(sDWObject, uf.translate("Rear"),FONT_MICROSOFT_SANS_SERIF, 12, FONT_BOLD, lX + 1, lY + 1 , 25, lDefaultWidth - 2, 0, 2, 0, 1)
	of_register(sDWObject, -1, -1)

End If


Return 1

end function

public function long of_init_tr (string as_unit);/* 
* Funktion/Event: of_init_tr
* Beschreibung: 	Layoutparameter lesen und Layout Zeichnen
*
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann				Was und warum
*	1.0 		K.F$$HEX1$$f600$$ENDHEX$$rster		06.08.2008		Erstellung
*	1.1			U.Paudler  	15.04.2009		Fehlerbehandlung, R$$HEX1$$fc00$$ENDHEX$$ckgabewerte
*	1.2			U.Paudler  	03.09.2009		Backlog
*	1.3			U.Paudler  	30.09.2009		Cache Objekte einf$$HEX1$$fc00$$ENDHEX$$hren
*	1.4			U.Paudler  	27.10.2009		F$$HEX1$$fc00$$ENDHEX$$llzeilen f$$HEX1$$fc00$$ENDHEX$$r die Backlogseite
*	1.5			U.Paudler  	19.11.2009		Drawerfood und Traynonfood eingebaut
*	1.6			U.Paudler  	19.01.2010		Anzeigelayout initialiseren
*	1.7			U.Paudler  	03.02.2010		Floating Content 
*
* Return Codes:
*	 1		Alles OK
*	-1		Equipment nicht definiert
*  -2   	Fehler beim Anlegen der Standardwerte
*	-3		Standardwerte konnten nach Neuanlage nicht gelesen werden
*  -4    Einschub Fehler
*	-5		Einschub Content Fehler
*	-6		Tray Fehler
*	-7		Tray Content Fehler
*/
Long	lLayoutDetailKeys[], ll_Row
Long iType, iContent, iRow, iColumn
String sDWButtonObject
guoLog.uf_debug("["+ this.classname( )+".of_init_tr] Start")

// 19.01.2010 Ulrich Paudler [UP]
of_print_deinit()
of_print_backlog_deinit()
if isvalid(oDw) Then uf.translate_datawindow(oDw)
if isvalid(oDs) Then uf.translate_datastore(oDs)

// --------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob es f$$HEX1$$fc00$$ENDHEX$$r den Containertypen Parameter gibt
// --------------------------------------------------------------
// Cache pr$$HEX1$$fc00$$ENDHEX$$fen
if  ilCachedAirlineKey = il_AirlineKey and isCachedUnit = this.sUnit and this.dsAirlineEq.RowCount() = 1 Then
Else
	this.dsAirlineEq.Retrieve(il_AirlineKey, this.sUnit)
	 ilCachedAirlineKey = il_AirlineKey
	 isCachedUnit = this.sUnit
End If

if this.dsAirlineEq.RowCount() <> 1 Then
	//Messagebox("Achtung", "F$$HEX1$$fc00$$ENDHEX$$r diese Airline wurde keine Equipment f$$HEX1$$fc00$$ENDHEX$$r den Container:" +this.sUnit + " gefunden!" )
//	return -1
End If


// --------------------------------------------------------------
// 06.05.2010, KF
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob der SL Dimensionen zugeordnet sind
// --------------------------------------------------------------
Long lCount

select count(*) into :lCount from cen_packinglist_size where npackinglist_index_key = :this.il_IndexKey and npackinglist_detail_key = :this.lDetailKey;

if sqlca.sqlcode < 0 Then
	guoLog.uf_error("["+ this.classname( )+".of_init_tr] "  +  this.isStowage +" - " + "Error counting dimensions: " + sqlca.sqlerrtext )
	return -4
Elseif lCount > 0  Then // St$$HEX1$$fc00$$ENDHEX$$ckliste hat Dimensionen
	bHasDimensions = TRUE
Else // St$$HEX1$$fc00$$ENDHEX$$ckliste hat Dimensionen
	bHasDimensions = FALSE
End If



// --------------------------------------------------------------
// Layoutinformationen lesen, wenn es noch keine gibt, dann
// ein leeres Layout anlegen
// --------------------------------------------------------------
this.dsLayout.Retrieve(il_IndexKey, lDetailKey)

if this.dsLayout.RowCount() = 0 Then
	If this.dsAirlineEq.RowCount() > 0 Then
		if this.of_create_defaults() <> 1 Then
			return -2
		Else
			this.dsLayout.Retrieve(il_IndexKey, lDetailKey)
			if this.dsLayout.RowCount() = 0 Then
				return -3
			End If
		End If
	End If
Else
	// --------------------------------------------------------------
	// Belegung der Trolleys einlesen
	// --------------------------------------------------------------
	this.lLayoutKey 		= this.dsLayout.GetItemNumber(1, "nlayout_key")
	this.dsLayoutDetail.Retrieve(this.lLayoutKey)
	
//	f_print_datastore(this.dsLayoutDetail)
	
//	// 26.01.2010 Ulrich Paudler [UP] Check layout
//	if this.of_check_layout(il_IndexKey, lDetailKey) <> 0 Then
//		return -2
//	End If
	
End If


// Alles Resetten
this.of_unregister_all()

// --------------------------------------------------------------------------------
// 03.09.2009 Ulrich Paudler [UP] Backlog einlesen
// --------------------------------------------------------------------------------
if bBacklog Then
	this.dsBacklog.Retrieve(this.lLayoutKey)
	if isvalid(oDwBacklog) Then 
		this.dsBacklog.ShareData ( oDwBacklog )
	Else
		this.dsBacklog.ShareData ( oDsBacklog )
	End If
Else
	this.dsBacklog.Reset()
	if isvalid(oDwBacklog) Then 
		this.dsBacklog.ShareData ( oDwBacklog )
	Else
		this.dsBacklog.ShareData ( oDsBacklog )
	End If
End If
// --------------------------------------------------------------
// Verweise in die Inhalte einlesen
// --------------------------------------------------------------
for ll_Row = 1 to this.dsLayoutDetail.RowCount()
	lLayoutDetailKeys[Upperbound(lLayoutDetailKeys) + 1] = this.dsLayoutDetail.GetItemNumber(ll_Row, "nlayout_detail_key") 
next

if UpperBound(lLayoutDetailKeys) = 0 Then lLayoutDetailKeys[Upperbound(lLayoutDetailKeys) + 1] = -1

dsLayoutContents.SetFilter("")
dsLayoutContents.Filter()
dsLayoutContents.Retrieve(lLayoutDetailKeys)

// --------------------------------------------------------------
// MZV Parameter einlesen....
// --------------------------------------------------------------
dsLayoutDimension.SetFilter("")
dsLayoutDimension.Filter()
dsLayoutDimension.Retrieve(lLayoutDetailKeys)

// --------------------------------------------------------------
// Textobjekte/Bitmaps/Rectangles einlesen
// --------------------------------------------------------------
dsLayoutAddObjects.Retrieve(lLayoutKey)
// --------------------------------------------------------------
// St$$HEX1$$fc00$$ENDHEX$$cklisteninhalte einlesen
// --------------------------------------------------------------
this.dsPLContents.Retrieve(il_IndexKey, lDetailKey, datetime(idt_Departure))


// --------------------------------------------------------------
// Objekte zeichnen
// --------------------------------------------------------------

//Integer  li_number_of_rungs, li_number_of_columns, li_number_of_pages
//ll_key = of_get_tr_cart_key(as_unit, il_IndexKey, idt_Departure , li_number_of_rungs, li_number_of_columns, li_number_of_pages)


// Trolley Zeichnen
this.of_draw_tr_cart(as_unit)


Return 1

end function

public function integer of_get_explosion_setting (long al_pl_index_key, string as_unit);/*
* Objekt : uo_cart_diagram
* Methode: of_get_explosion_setting (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.09.2010
*
* Argument(e):
* long al_pl_index_key
*
* Beschreibung:		Explosion Setting fpr PL Index Key
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.09.2010		Erstellung
* 1.1 			O.Hoefer	04.04.2011		loc_unit_pl_areas mit G$$HEX1$$fc00$$ENDHEX$$ltigkeit
* 1.2 			O.Hoefer	06.04.2011		Bugfix G$$HEX1$$fc00$$ENDHEX$$ltigkeit
* 1.3 			O.Hoefer	18.10.2012	   NAM-CR-12071 Funktion Master Data Preview
* 1.4 			O.Hoefer	25.05.2016	   CBASE-NAM-CR-16008_V3_28042016 All Item Lists will show exploded by default, except for LAX and ORD 
* 1.5 			O.Hoefer	01.08.2016		NON Sky Explode Settings
*
*
* Return: integer
*              1		Explode
*              0     Do not explode
*             -1     Use Setting from Diagram Painter
*
*/


Integer		li_Explosion_Setting


// CBASE-NAM-CR-16008_V3_28042016 All Item Lists will show exploded by default
If ib_non_sky = TRUE AND ib_non_sky_vip = FALSE Then
	li_Explosion_Setting = 1
End If

If ib_enable_masterdata_view Then
	// NAM-CR-12071 Funktion Master Data Preview ON
	li_Explosion_Setting = -1
	Return li_Explosion_Setting
End If

If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"


SELECT	loc_unit_pl_areas.nexplode  			
Into		:li_Explosion_Setting
FROM		loc_unit_pl_areas,   
			loc_unit_areas,   
			cen_packinglist_index,   
			loc_unit_workstation  
WHERE		loc_unit_pl_areas.narea_key = loc_unit_areas.narea_key  and  
			loc_unit_pl_areas.nworkstation_key = loc_unit_workstation.nworkstation_key  and  
			loc_unit_pl_areas.npackinglist_index_key = cen_packinglist_index.npackinglist_index_key  and  
			loc_unit_pl_areas.npackinglist_index_key = :al_pl_index_key  AND 
			:idt_departure between loc_unit_pl_areas.dvalid_from AND loc_unit_pl_areas.dvalid_to AND
			loc_unit_pl_areas.cclient = :s_app.smandant  AND  
			loc_unit_pl_areas.cunit = :as_unit;   

If SQLCA.SQLCode <> 0 Then
	li_Explosion_Setting = -1
	//guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_setting " + sqlca.sqlerrtext )			
	
	
	// CBASE NAM CR 16008 All Item Lists will show exploded by default. This eliminates the need to maintain the 
	// Explode Contents setting in Area Allocation:		
	If ib_non_sky OR ib_non_sky_vip Then
		li_Explosion_Setting = 1
		guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_setting NON SKY "+ as_unit + " / " + String(idt_departure) + " / " + String(al_pl_index_key) + ": " + String(li_Explosion_Setting))			
	End If
		
End If

If il_Disable_Debug = 0 then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_setting "+ as_unit + " / " + String(idt_departure) + " / " + String(al_pl_index_key) + ": " + String(li_Explosion_Setting))			
End if

If IsNULL(li_Explosion_Setting) Then li_Explosion_Setting = -1

Return li_Explosion_Setting

end function

public function long of_draw_content (long irow, long icolumn, string as_unit);/* 
* Funktion/Event: of_draw_content
* Beschreibung: 	Zeichnet einen Inhalt in den drawer/tray
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 iRow				Zeile
**	 iColumn			"Spalte"

* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		22.09.2008	Erstellung
*	1.1				U.Paudler	15.04.2009	Refactoring
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/

Long 	llType, llContent
long	llFound = 0
long 	llLayoutDetailKey

// Die Position(en) im Trolley muss als geblockt markiert werden
llFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if llFound = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
End If

// ---------------------------------------------------------------------------
// Contenttyp ermitteln
// ---------------------------------------------------------------------------
llType 				= this.dsLayoutDetail.Getitemnumber(llFound, "ntype")
llContent			= this.dsLayoutDetail.Getitemnumber(llFound, "ncontent")
llLayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(llFound, "nlayout_detail_key")


// 15.04.2009 Ulrich Paudler [UP]
Choose Case llType
	Case DRAWER, DRAWER_3RUNG, TRAYNONFOOD
		of_draw_content_drawer(llLayoutDetailKey, llContent, irow, icolumn, llType, as_unit)
		
	Case TRAY, DRAWERFOOD, DRAWERFOOD_3RUNG
		of_draw_content_tray(llLayoutDetailKey, irow, icolumn, llType)
		
	Case DRAWER_MULTI_RUNG
		// MultiRung
		of_draw_content_drawer_multi (llLayoutDetailKey, llContent, irow, icolumn, llType, as_unit)
		
end Choose

this.dsPLContents.SetFilter("")
this.dsPLContents.Filter()
this.dsPLContents.Sort()

// Aktuelle Position merken
this.iCurrentRow = iRow
this.iCurrentColumn = iColumn

return 1
end function

public function boolean of_is_aisle_enabled (long al_index_key, long al_detail_key);/*
* Objekt : uo_cart_diagram
* Methode: of_is_aisle_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.09.2010
*
* Argument(e):
*	 long al_index_key
*	 long al_detail_key
*
* Beschreibung:		Ermittle AISLE_FLAG f$$HEX1$$fc00$$ENDHEX$$r St$$HEX1$$fc00$$ENDHEX$$ckliste
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.09.2010		Erstellung
*
*
* Return: boolean
*
*/

Boolean	lb_Return
Long		ll_AISLE_Flag
String	ls_Value


lb_return = FALSE
// AISLE_FLAG
ll_AISLE_Flag = AISLE_FLAG

SELECT	cflagvalue  
INTO		:ls_Value  
FROM		cen_packinglist_flags  
WHERE		npackinglist_index_key = :al_index_key 
AND		npackinglist_detail_key = :al_detail_key 
AND		nflag_id = :ll_AISLE_Flag    ;

IF SQLCA.SQLCode = 0 Then
	If NOT IsNULL(ls_Value) Then
		If Upper(ls_Value) = "YES" Then
			lb_Return = TRUE
		End If
	End If
End If
			

Return lb_return

end function

public function long of_draw_watermark_aisle (boolean ab_tr_cart);
/*
* Objekt : uo_cart_diagram
* Methode: of_draw_watermark_aisle (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 15.09.2010
*
* Argument(e):
* boolean ab_tr_cart				FALSE => Standard Cart, TRUE => TR Cart
*
*
* Beschreibung:		Wasserzeichen hinzu (Ein Riesen-Backslash $$HEX1$$fc00$$ENDHEX$$ber den gesamten Cart)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	15.09.2010		Erstellung
*
*
* Return: long
*
*/

Long			ll_Color
Integer		li_X_Pos
Integer		li_Width
Integer		li_Y_Pos
Integer		li_Height
Integer		li_Succ
Long			ll_Count
String		ls_Name


ll_Color = RGB(200, 200, 200)

If ab_tr_cart Then
	li_X_Pos		= ii_TR_Cart_Left		// +  5
	li_Width		= ii_TR_Cart_Width	// - 10	
	li_Y_Pos		= ii_TR_Cart_Top		// +  5
	li_Height	= ii_TR_Cart_Height	// - 10
Else
	li_X_Pos		= ii_Std_Cart_Left	//	+  5
	li_Width		= ii_Std_Cart_Width	// - 10	
	li_Y_Pos		= ii_Std_Cart_Top		// +  5
	li_Height	= ii_Std_Cart_Height	// - 10
	li_Height  -= (ldefaultheight * 0.2)
End If

//li_Succ = of_create_line( "t_watermark_aisle", li_X_Pos, li_Y_Pos, li_X_Pos + li_Width, li_Y_Pos + li_Height, ll_Color, 20)
//li_Succ = of_set_position( "t_watermark_aisle", FALSE)

// mehrere d$$HEX1$$fc00$$ENDHEX$$nne Linien statt einer einzelnen dicken 10er oder 12er
For ll_Count = 0 To 20 STEP 2
	ls_Name = "t_watermark_aisle_" + String(ll_Count)
	li_Succ = of_create_line(ls_Name , li_X_Pos, li_Y_Pos + ll_Count, li_X_Pos + li_Width, (li_Y_Pos + li_Height - 20 ) + ll_Count, ll_Color , 2)
	li_Succ = of_set_position( ls_Name, FALSE)
Next

		
Return 0
end function

public function long of_draw_watermark_downline (long arg_irow, long arg_icolumn, integer arg_ltype, boolean ab_transporter);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_watermark_downline (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 12.08.2010
*
* Argument(e):
*	 long arg_irow
*	 long arg_icolumn
*	 integer arg_ltype
*
* Beschreibung:		Wasserzeichen "DOWNLINE"
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	12.08.2010		Erstellung
*
*
* Return: long
*
*/


String	ls_Object
long		ll_Row, lX1, lX2, lY1, lY2, lRowHeight //, lYCounter
long		llTextWidth
Long		ll_Color =    RGB(200,200,200)
String	ls_Downline
Long		ll_rungs, ll_columns
Integer	li_Succ
Long		ll_Width_Factor = 1


ls_Downline = "DOWNLINE"

// ============= Vorlage ==============
//pg.setColor(new Color(200, 200, 200));
//pg.setFont(new Font("SansSerif", 0, 30));
//pg.drawString("DOWNLINE", dl_watermark_x - 12, dl_watermark_y);
//It is color 200,200,200 and SansSerif size 30.

if of_is_tr_componentlist_enabled() and bHasDimensions Then
	llTextWidth = TEXTWIDTH1
Else
	llTextWidth = TEXTWIDTHSMALL1
End If

Choose Case arg_ltype
	Case TRAYNONFOOD
		lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 20
	Case Else
		lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
end Choose

lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth/2
lRowHeight = 14

ls_Object = "t_wtrmrk_dwnln_c_" + string(arg_icolumn, "00") + "_r_" + string(arg_iRow, "00")

If ab_transporter Then
	lY1 = il_TR_YOffset + ((arg_iRow) *  il_tr_defaultheight)
	lY1 -= 35
	of_create_text(ls_Object, ls_Downline ,FONT_MICROSOFT_SANS_SERIF, 30, FONT_NORMAL, lX1, lY1 , 45 , llTextWidth , 0, ALIGN_CENTER, ll_Color, 1)	
	of_set_position(ls_Object, FALSE)
	//of_register(ls_Object, -1, -1)
Else
	lY1 = lyoffset  + ((arg_iRow - 1) *  ldefaultheight )
//	lY1 -= 35

	// Verschiedene Gr$$HEX2$$f600df00$$ENDHEX$$en
	Choose Case arg_ltype
		Case EMPTY 
		Case DRAWER  // Einschub
			lY1 += (ldefaultheight) / 2
		Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
			lY1 += (ldefaultheight) * 0.75
		Case DRAWER_MULTI_RUNG
			//lY1 += (ldefaultheight) * 0.75
			li_Succ = of_get_rungs_and_cols(arg_iRow, arg_icolumn, ll_rungs, ll_columns)
			// Nur bei H$$HEX1$$d600$$ENDHEX$$he > 1
			If ll_rungs > 1 Then
				lY1 += (ldefaultheight) * 0.75
			End If
			// Breite >1 => anpassen
			If ll_columns > 1 Then
				ll_Width_Factor = 2
			End If
			
		Case TRAY  // Tray
		Case DRAWERFOOD  // Einschub	
			lY1 += (ldefaultheight) / 2
		Case TRAYNONFOOD  // Tray	
		Case FLOATING 
	End Choose

	lX1 -= 5

	of_create_text(ls_Object, ls_Downline ,FONT_MICROSOFT_SANS_SERIF, 30, FONT_NORMAL, lX1, lY1 , 45 , llTextWidth * ll_Width_Factor, 0, ALIGN_CENTER, ll_Color, 1)		
	of_set_position(ls_Object, FALSE)
	//of_register(ls_Object, -1, -1)
End If
	
return 0

end function

public function long of_init ();/* 
* Funktion/Event: of_init
* Beschreibung: 	Layoutparameter lesen und Layout Zeichnen
*
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann				Was und warum
*	1.0 		K.F$$HEX1$$f600$$ENDHEX$$rster		06.08.2008		Erstellung
*	1.1			U.Paudler  	15.04.2009		Fehlerbehandlung, R$$HEX1$$fc00$$ENDHEX$$ckgabewerte
*	1.2			U.Paudler  	03.09.2009		Backlog
*	1.3			U.Paudler  	30.09.2009		Cache Objekte einf$$HEX1$$fc00$$ENDHEX$$hren
*	1.4			U.Paudler  	27.10.2009		F$$HEX1$$fc00$$ENDHEX$$llzeilen f$$HEX1$$fc00$$ENDHEX$$r die Backlogseite
*	1.5			U.Paudler  	19.11.2009		Drawerfood und Traynonfood eingebaut
*	1.6			U.Paudler  	19.01.2010		Anzeigelayout initialiseren
*	1.7			U.Paudler  	03.02.2010		Floating Content 
*  1.8         O.H$$HEX1$$f600$$ENDHEX$$fer     01.10.2010     Watermark Downline f$$HEX1$$fc00$$ENDHEX$$r Leg>1 (Ranking & Stammdaten) 
*  1.9         O.H$$HEX1$$f600$$ENDHEX$$fer     16.11.2010     Watermark Downline abschaltbar
*  2.0         O.H$$HEX1$$f600$$ENDHEX$$fer     16.03.2017     Best Before request #1961 CR-RUS-1961
*
* Return Codes:
*	 1		Alles OK
*	-1		Equipment nicht definiert
*  -2   	Fehler beim Anlegen der Standardwerte
*	-3		Standardwerte konnten nach Neuanlage nicht gelesen werden
*  -4    Einschub Fehler
*	-5		Einschub Content Fehler
*	-6		Tray Fehler
*	-7		Tray Content Fehler
*/
Long	lLayoutDetailKeys[], ll_Row
Long iType, iContent, iRow, iColumn
String sDWButtonObject
Integer	li_Succ
Boolean	lb_Watermark_Downline = FALSE
Boolean	lb_downline_switch = FALSE
Boolean	lb_NON_Sky
String	ls_Value	

guoLog.uf_debug("["+ this.classname( )+".of_init] Start")
// 19.01.2010 Ulrich Paudler [UP]

guoLog.uf_debug("["+ this.classname( )+".of_init] of_print_deinit()")
of_print_deinit()

guoLog.uf_debug("["+ this.classname( )+".of_init] of_print_backlog_deinit()")
of_print_backlog_deinit()

guoLog.uf_debug("["+ this.classname( )+".of_init] uf.translate_datastore()")
if isvalid(oDw) Then uf.translate_datawindow(oDw)
if isvalid(oDs) Then uf.translate_datastore(oDs)


lb_NON_Sky  = of_check_non_sky( is_csc )


// ---------------------------------------------
// Best Before
// ---------------------------------------------
ls_Value = f_unitprofilestring( "w_local_cart_diagram" , "PRINT_BEST_BEFORE", "0" , is_CSC ) 
If ls_Value = "1" Then
	ib_Print_Best_Before = TRUE
	of_get_bestbefore_minutes( s_app.smandant , is_csc, il_airlinekey )
Else
	ib_Print_Best_Before = FALSE	
End If


// --------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob es f$$HEX1$$fc00$$ENDHEX$$r den Containertypen Parameter gibt
// --------------------------------------------------------------
// Cache pr$$HEX1$$fc00$$ENDHEX$$fen
if  ilCachedAirlineKey = il_AirlineKey and isCachedUnit = this.sUnit and this.dsAirlineEq.RowCount() = 1 Then
Else
	this.dsAirlineEq.Retrieve(il_AirlineKey, this.sUnit)
	 ilCachedAirlineKey = il_AirlineKey
	 isCachedUnit = this.sUnit
End If

if this.dsAirlineEq.RowCount() <> 1 Then
	//Messagebox("Achtung", "F$$HEX1$$fc00$$ENDHEX$$r diese Airline wurde keine Equipment f$$HEX1$$fc00$$ENDHEX$$r den Container:" +this.sUnit + " gefunden!" )
	guoLog.uf_debug( "["+ this.classname( )+".NO dsAirlineEq for Airline " + String(il_AirlineKey) + " UNIT " + this.sUnit )
	return -1
End If

if this.dsAirlineEq.RowCount() = 1 Then
	il_Equipment_Width = this.dsAirlineEq.GetItemNumber(1, "ncolumns")
End If
// 16.01.2014 CBASE-UK-CR-2013-013
ib_Draw_Add_Text = of_is_add_on_text_enabled()

// --------------------------------------------------------------
// 06.05.2010, KF
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob der SL Dimensionen zugeordnet sind
// --------------------------------------------------------------
Long lCount

guoLog.uf_debug("["+ this.classname( )+".of_init] count(*) from cen_packinglist_size")

select count(*) into :lCount from cen_packinglist_size where npackinglist_index_key = :this.il_IndexKey and npackinglist_detail_key = :this.lDetailKey;

if sqlca.sqlcode < 0 Then
	guoLog.uf_error("["+ this.classname( )+".of_init] "  +  this.isStowage +" - " + "Error counting dimensions: " + sqlca.sqlerrtext )
	guoLog.uf_debug( "["+ this.classname( )+".Error counting dimensions ")
	return -4
Elseif lCount > 0  Then // St$$HEX1$$fc00$$ENDHEX$$ckliste hat Dimensionen
	bHasDimensions = TRUE
Else // St$$HEX1$$fc00$$ENDHEX$$ckliste hat Dimensionen
	bHasDimensions = FALSE
End If


IF ib_BarCode_on_CartDiagram THEN
	bHasDimensions = TRUE
END IF

// --------------------------------------------------------------
// Layoutinformationen lesen, wenn es noch keine gibt, dann
// ein leeres Layout anlegen
// --------------------------------------------------------------
guoLog.uf_debug("["+ this.classname( )+".of_init]  dsLayout.Retrieve")

this.dsLayout.Retrieve(il_IndexKey, lDetailKey)

if this.dsLayout.RowCount() = 0 Then
	guoLog.uf_debug("["+ this.classname( )+".of_init] of_create_defaults")
	if this.of_create_defaults() <> 1 Then
		guoLog.uf_debug( "["+ this.classname( )+".dsLayout.RowCount()=0 of_create_defaults() <> 1")
		return -2
	Else
		this.dsLayout.Retrieve(il_IndexKey, lDetailKey)
		if this.dsLayout.RowCount() = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".dsLayout.RowCount()=0")
			return -3
		End If
	End If
Else
	// --------------------------------------------------------------
	// Belegung der Trolleys einlesen
	// --------------------------------------------------------------
	this.lLayoutKey 		= this.dsLayout.GetItemNumber(1, "nlayout_key")
	
	guoLog.uf_debug("["+ this.classname( )+".of_init] dsLayoutDetail.Retrieve")

	this.dsLayoutDetail.Retrieve(this.lLayoutKey)
	
//	f_print_datastore(this.dsLayoutDetail)
	
	// 26.01.2010 Ulrich Paudler [UP] Check layout
	if this.of_check_layout(il_IndexKey, lDetailKey) <> 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_check_layout<>0")
		return -2
	End If
	
End If

guoLog.uf_debug("["+ this.classname( )+".of_init] of_unregister_all")

// Alles Resetten
this.of_unregister_all()

// --------------------------------------------------------------------------------
// 03.09.2009 Ulrich Paudler [UP] Backlog einlesen
// --------------------------------------------------------------------------------
if bBacklog Then
	this.dsBacklog.Retrieve(this.lLayoutKey)
	if isvalid(oDwBacklog) Then 
		this.dsBacklog.ShareData ( oDwBacklog )
	Else
		this.dsBacklog.ShareData ( oDsBacklog )
	End If
Else
	this.dsBacklog.Reset()
	if isvalid(oDwBacklog) Then 
		this.dsBacklog.ShareData ( oDwBacklog )
	Else
		this.dsBacklog.ShareData ( oDsBacklog )
	End If
End If
// --------------------------------------------------------------
// Verweise in die Inhalte einlesen
// --------------------------------------------------------------
for ll_Row = 1 to this.dsLayoutDetail.RowCount()
	lLayoutDetailKeys[Upperbound(lLayoutDetailKeys) + 1] = this.dsLayoutDetail.GetItemNumber(ll_Row, "nlayout_detail_key") 
next

if UpperBound(lLayoutDetailKeys) = 0 Then lLayoutDetailKeys[Upperbound(lLayoutDetailKeys) + 1] = -1

dsLayoutContents.SetFilter("")
dsLayoutContents.Filter()
dsLayoutContents.Retrieve(lLayoutDetailKeys)

// --------------------------------------------------------------
// MZV Parameter einlesen....
// --------------------------------------------------------------
dsLayoutDimension.SetFilter("")
dsLayoutDimension.Filter()
dsLayoutDimension.Retrieve(lLayoutDetailKeys)

if il_Disable_Debug= 0 then
	guoLog.uf_debug( "["+ this.classname( )+".of_init] dsLayoutDimension.RowCount " + String(dsLayoutDimension.RowCount()))
End If

// --------------------------------------------------------------
// Textobjekte/Bitmaps/Rectangles einlesen
// --------------------------------------------------------------
guoLog.uf_debug("["+ this.classname( )+".of_init] ddsLayoutAddObjects.Retrieve")

dsLayoutAddObjects.Retrieve(lLayoutKey)
// --------------------------------------------------------------
// St$$HEX1$$fc00$$ENDHEX$$cklisteninhalte einlesen
// --------------------------------------------------------------
guoLog.uf_debug("["+ this.classname( )+".of_init] dsPLContents.Retrieve")

this.dsPLContents.Retrieve(il_IndexKey, lDetailKey, datetime(idt_Departure))

// --------------------------------------------------------------
// Display of items on status $$HEX1$$1c20$$ENDHEX$$Billing$$HEX4$$1d20200020002000$$ENDHEX$$added 08/18/2010
// Items that are on status billing in any drawer should 
// not be displayed in the cart diagram.
// --------------------------------------------------------------
If ib_discard_status_billing Then
	guoLog.uf_debug("["+ this.classname( )+".of_init] of_remove_contents_billing")

	li_Succ = of_remove_contents_billing(dsPLContents)
End If

// --------------------------------------------------------------
// Objekte zeichnen
// --------------------------------------------------------------


guoLog.uf_debug("["+ this.classname( )+".of_init] of_draw_cart")
// Trolley Zeichnen
this.of_draw_cart()

// Separater Downline Schalter f$$HEX1$$fc00$$ENDHEX$$r NON-TR Carts
lb_downline_switch = of_is_downline_enabled( is_csc )

For ll_Row = 1 to this.dsLayoutDetail.RowCount()
	
	iType 			= this.dsLayoutDetail.Getitemnumber(ll_Row, "ntype")
	iContent		= this.dsLayoutDetail.Getitemnumber(ll_Row, "ncontent")
	iRow			= this.dsLayoutDetail.Getitemnumber(ll_Row, "nrow")
	iColumn		= this.dsLayoutDetail.Getitemnumber(ll_Row, "ncolumn")
	
	// Watermark DOWNLINE ganzer Cart
	If ii_Catering_Leg > 1 Then
		
		If of_is_downline_enabled(is_csc) Then lb_Watermark_Downline = TRUE
		
		// ---------------------------------------------------------------------
		// Downline nur wenn Catering Leg EINSTELLIG, andernfalls ignorieren
		// ---------------------------------------------------------------------
		IF lb_Watermark_Downline = TRUE Then
			if il_Disable_Debug= 0 then	
				guoLog.uf_debug( "["+ this.classname( )+".of_init] ii_Catering_Leg > 1 ("+String(ii_Catering_Leg)+") lb_Watermark_Downline = TRUE")			
			End If
			If ii_Catering_Leg > 9 then
			//If pos(String(ii_Catering_Leg),"1") > 0 then
				lb_Watermark_Downline = FALSE	
				if il_Disable_Debug= 0 then	
					guoLog.uf_debug( "["+ this.classname( )+".of_init] ii_Catering_Leg > 1 ("+String(ii_Catering_Leg)+") lb_Watermark_Downline = TRUE => FALSE ")			
				End If
			End If
		End If
	End If
	
	Choose Case iType
		Case EMPTY 
			// 09.02.2010 Ulrich Paudler [UP] Button f$$HEX1$$fc00$$ENDHEX$$r Floating Content einf$$HEX1$$fc00$$ENDHEX$$gen
			if iRow = 1 and iColumn = 0 and bFloatingContent Then
				sDWButtonObject = "p_button_col_" + string(iColumn, "00") + "_row_" + string(iRow, "00")
				//of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", 15 , 30 , 14, 14, 0, 0, 0)
				of_create_picture(sDWButtonObject, "..\Resource\drawer_content_expand.jpg", 10 , 30 , 14, 14, 0, 0, 0)
				of_register(sDWButtonObject, iRow, iColumn)
			End If
			continue // Position unbelegt
	
		Case DRAWER  // Einschub
			if this.of_draw_drawer(iRow, iColumn, iType, FALSE) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " +sError)
				return -4
			End If
			
			// Watermark	
			ii_PL_Leg_Number = 0	
				
			if this.of_draw_content(iRow, iColumn, is_CSC) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -5
			End If
			
			IF lb_Watermark_Downline Then
				If lb_downline_switch Then 
					li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
				End If
			Else
				// ------------------------------------------------------------------------------------------------------------
				// 01.10.2010 Downline Watermark
				//  Downline Watermark an einem Drawer, der teil einer Packing List ist: Dies wird im Content der Packing List 
				// in der Spalte "Leg" gepflegt (Leg-Nummer >1)	
				// ------------------------------------------------------------------------------------------------------------
				IF ii_PL_Leg_Number > 1 Then
					If lb_downline_switch Then 
						li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
					End If
				End If
			End If

	
		Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
			// Einschub $$HEX1$$fc00$$ENDHEX$$ber 3 Schienen
			if this.of_draw_drawer_3_rung(iRow, iColumn, iType, FALSE) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -4
			End If
			// Watermark Downline
			ii_PL_Leg_Number = 0	

			if this.of_draw_content(iRow, iColumn, is_CSC) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -5
			End If
			
			IF lb_Watermark_Downline Then
				If lb_downline_switch Then 
					li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
				End If
			Else					
				// ------------------------------------------------------------------------------------------------------------
				// 01.10.2010 Downline Watermark
				//  Downline Watermark an einem Drawer, der teil einer Packing List ist: Dies wird im Content der Packing List 
				// in der Spalte "Leg" gepflegt (Leg-Nummer >1)	
				// ------------------------------------------------------------------------------------------------------------
				IF ii_PL_Leg_Number > 1 Then
					If lb_downline_switch Then 
						li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
					End If
				End If
			End If
	
		Case DRAWER_MULTI_RUNG
			// Einschub $$HEX1$$fc00$$ENDHEX$$ber 3 Schienen
			if this.of_draw_drawer_multi_rung(iRow, iColumn, iType,  this.dsLayoutDetail.Getitemnumber(ll_Row, "nrungs"),  this.dsLayoutDetail.Getitemnumber(ll_Row, "ncolumns"), True) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -4
			End If

			// Watermark Downline
			ii_PL_Leg_Number = 0	
			
			if this.of_draw_content(iRow, iColumn, is_CSC) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)
				return -5
			End If

			IF lb_Watermark_Downline Then
				If lb_downline_switch Then 
					li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
				End If
			Else					
				// ------------------------------------------------------------------------------------------------------------
				// 01.10.2010 Downline Watermark
				//  Downline Watermark an einem Drawer, der teil einer Packing List ist: Dies wird im Content der Packing List 
				// in der Spalte "Leg" gepflegt (Leg-Nummer >1)	
				// ------------------------------------------------------------------------------------------------------------
				IF ii_PL_Leg_Number > 1 Then
					If lb_downline_switch Then 
						li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
					End If
				End If
			End If

		Case TRAY  // Tray
			if this.of_draw_tray(iRow, iColumn, iType,FALSE) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -6
			End If
			if this.of_draw_content(iRow, iColumn, is_CSC) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -7
			End If
			
			IF lb_Watermark_Downline Then
				If lb_downline_switch Then 
					li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
				End If
			End If

		Case DRAWERFOOD  // Einschub	
			if this.of_draw_drawer(iRow, iColumn, iType, FALSE) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -8
			End If
			if this.of_draw_content(iRow, iColumn, is_CSC) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -9
			End If
			
			IF lb_Watermark_Downline Then
				If lb_downline_switch Then 
					li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
				End If
			End If
			
		
		Case TRAYNONFOOD  // Tray	
			if this.of_draw_tray(iRow, iColumn, iType, FALSE) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)
				return -10
			End If
			if this.of_draw_content(iRow, iColumn, is_CSC) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)
				return -11
			End If

			IF lb_Watermark_Downline Then
				If lb_downline_switch Then 
					li_Succ = of_draw_watermark_downline(irow, icolumn, iType, FALSE)
				End If
			End If
			
		
		Case FLOATING 
			if bFloatingContent Then
			if this.of_draw_floating(iRow, iColumn, iType, FALSE) <> 1 Then
				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
				guoLog.uf_error( "["+ this.classname( )+".of_init] " + sError)

				return -12
			End If
//			if this.of_draw_content(iRow, iColumn) <> 1 Then
//				sError += " - Row " + string(iRow) + " Col " + string(iColumn)
//				return -13
//			End If
			End If
		
		Case Else
			// Messagebox("", "Unknown type " + string(iType))
		end Choose 
next

// 28.10.2009 Ulrich Paudler [UP] Seite mit Leerzeilen auff$$HEX1$$fc00$$ENDHEX$$llen
of_fill_backlog_page()

// --------------------------------------------------------------
// Texte etc ...
// --------------------------------------------------------------
for ll_Row = 1 to this.dsLayoutAddObjects.RowCount()
	Choose Case this.dsLayoutAddObjects.GetItemNumber(ll_Row, "nobject_type") 
		Case TEXTOBJECT 
			this.of_create_text(ll_Row)
		Case RECTANGLEOBJECT 
			this.of_create_rect(ll_Row)
		Case BITMAPOBJECT 
			this.of_create_picture(ll_Row)
		Case CONTENT_TEXT_OBJECT
			this.of_create_content_freetext(ll_Row)
	end Choose
	
next

// --------------------------------------------------------------
// 20.04.2010, KF
// Objekte die breiter geworden sind als die Seite
// wieder resizen
// --------------------------------------------------------------
this.of_set_position()

// --------------------------------------------------------------
// 20.04.2010, KF
// Objekte die breiter geworden sind als die Seite
// wieder resizen
// --------------------------------------------------------------
this.of_check_object_width()

guoLog.uf_debug("["+ this.classname( )+".of_init] Ende")

guoLog.uf_debug( "["+ this.classname( )+".of_init] SUB END")

return 1

end function

public function long of_draw_watermark (integer ai_type, long al_flight_number, string as_ramp_time, string as_kitchen_time, string as_ops, string as_class, string as_prodrange, long al_airline_key, string as_unit, long al_routing, boolean ab_tr_cart);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_watermark (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 15.09.2010
*
* Argument(e):
* integer ai_type
*	 long al_flight_number
*	 string as_ramp_time
*	 string as_kitchen_time
*	 string as_ops
*	 string as_class
*
* Beschreibung:		Wasserzeichen hinzu
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	15.09.2010		Erstellung
* 1.1 			O.Hoefer	31.05.2012		Watermark nicht $$HEX1$$fc00$$ENDHEX$$bersetzen
* 1.2 			O.Hoefer	11.09.2012		Font Size f$$HEX1$$fc00$$ENDHEX$$r Ramp/Kitchen Time & OPS wie Flight Number (=125)
*
*
* Return: long
*
*/


String		ls_Watermark_Text
Long			ll_Color
Integer		li_X_Pos
Integer		li_Width
Integer		li_Y_Pos
Integer		li_Height
Long			ll_Font_Size
Long			ll_WM_Height
Integer		li_Succ
String		ls_mod


If ai_type = -1 Then return 0


ll_Color = RGB(200, 200, 200)
ll_Font_Size = 75
ll_WM_Height = 300

// Operations / Complexes (so called OPS) = Operations maintained locally for each CSC in CBASE
// Class (based on class for that stowage position)
// Flight Number of first leg
// Kitchen Time
// Ramp Time
//CONSTANT Integer WATERMARK_CLASS				= 100
//CONSTANT Integer WATERMARK_FLIGHT_NUMBER	= 102
//CONSTANT Integer WATERMARK_KITCHEN_TIME		= 103
//CONSTANT Integer WATERMARK_RAMP_TIME			= 104
//CONSTANT Integer WATERMARK_OPS					= 105
//CONSTANT Integer WATERMARK_PRODRANGE			= 106


Choose Case ai_type
	Case WATERMARK_CLASS
		ls_Watermark_Text = as_class 
		ll_Font_Size = 180
		ll_WM_Height = 200
		
		// Unterdr$$HEX1$$fc00$$ENDHEX$$cke Watermark f$$HEX1$$fc00$$ENDHEX$$r Class 
		if of_suppress_class_watermark(al_airline_key, as_unit, al_routing, as_class ) Then
//			If (il_Disable_Debug) = 0 Then
//				uf.mbox("Suppress Class Watermark", as_unit +  " / " + String(al_routing) + " / " + as_class)				
//			End If
			as_class = ""
			ls_Watermark_Text = ""
		End If
		
	Case WATERMARK_FLIGHT_NUMBER
		ls_Watermark_Text = String(al_flight_number, "000") 
		ll_Font_Size = 125
		ll_WM_Height = 150

	Case WATERMARK_KITCHEN_TIME
		ll_Font_Size = 125
		ls_Watermark_Text =  as_kitchen_time  

	Case WATERMARK_RAMP_TIME
		ll_Font_Size = 125
		ls_Watermark_Text = as_ramp_time 

	Case WATERMARK_OPS
		ll_Font_Size = 125
		ls_Watermark_Text =  as_ops
		
	Case WATERMARK_PRODRANGE
		ls_Watermark_Text =  as_prodrange 
		
End Choose

If Trim(ls_Watermark_Text) > "" Then
	// Draw Watermark centered
	If ab_tr_cart Then
		li_X_Pos = ii_TR_Cart_Left 
		li_Width = ii_TR_Cart_Width
		li_Y_Pos = ii_TR_Cart_Top
		li_Height = ii_TR_Cart_Height
	Else
		li_X_Pos = ii_STD_Cart_Left 
		li_Width = ii_STD_Cart_Width
		li_Y_Pos = ii_STD_Cart_Top
		li_Height = ii_STD_Cart_Height
		
	End If
	
	
	li_Y_Pos += (li_Height / 2) - (ll_WM_Height /2)

	// xpos ############

	li_Succ = of_create_text("t_watermark_"+ String(ai_type), ls_Watermark_Text ,FONT_MICROSOFT_SANS_SERIF, ll_Font_Size, font_normal, 0, li_Y_Pos, ll_WM_Height, 720, 0, align_center, ll_Color, 1)
//	li_Succ = of_create_text("t_watermark_"+ String(ai_type), ls_Watermark_Text ,FONT_MICROSOFT_SANS_SERIF, ll_Font_Size, font_normal, li_X_Pos, li_Y_Pos, ll_WM_Height, li_Width, 0, align_center, ll_Color, 1)
	// Watermark nicht $$HEX1$$fc00$$ENDHEX$$bersetzen
	ls_mod = "t_watermark_"+ String(ai_type) + ".tag='DO_NOT_TRANSLATE'"
	of_modify(ls_mod , false)

	li_Succ = of_set_position( "t_watermark_"+ String(ai_type), FALSE)

End If
		
Return 0

end function

public function integer of_get_print_width (string as_text, string as_font, integer ai_fontsize, boolean ab_bold, boolean ab_italic, boolean ab_underline, ref integer rai_height, ref integer rai_width);/*
* Objekt : uo_cart_diagram
* Methode: of_get_font_size (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 01.10.2010
*
* Argument(e):
*	 string as_text
*	 string as_font
*	 integer ai_fontsize
*	 boolean ab_bold
*	 boolean ab_italic
*	 boolean ab_underline
*	 ref integer rai_height
*	 ref integer rai_width
*
* Beschreibung:		Kopiert aus einem Beispiel 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	01.10.2010		Erstellung
*
*
* Return: integer
*
*/

Boolean	lb_Succ
Integer	li_Succ
long ll_Job
Integer	li_Breakpoint
int li_Width
// Start a new print job.
Integer	li_weight
String ls_File

ls_File = f_gettemppath() + "CBASE-DUMMY-"  + "-" + String(Rand(32767)) + String(now(), "hhmmss") + ".PDF"
If FileExists(ls_File) Then 
	filedelete(ls_File)
	ls_File = f_gettemppath() + "CBASE-DUMMY-"  + "-" + String(Rand(32767)) + String(now(), "hhmmss") + ".PDF"
End If
//If not 

ll_Job = PrintOpen("Dummy for Text Size")

If ll_Job < 1 Then
	ls_File = f_gettemppath() + "CBASE-DUMMY-"  + "-" + String(Rand(32767)) + String(now(), "hhmmss") + ".PDF"
	ll_Job = PrintOpen("Dummy for Text Size")
	
End If

If ab_bold Then
	li_weight = FONT_BOLD //700
Else
	li_weight = FONT_NORMAL //400
End If

// Determine the width of the text.
// Define the font for Job.

//PrintDefineFont ( printjobnumber, fontnumber, facename, height, weight, fontpitch, fontfamily, italic, underline )
//AnyFont!

//PrintDefineFont(ll_Job, 2, "Courier 10Cps",    250, 700, Default!, Modern!, FALSE, FALSE)
li_Succ = PrintDefineFont(ll_Job, 2, as_font ,  ai_fontsize , li_weight, Default!, AnyFont!, FALSE, FALSE)
// Set the font for Job.

li_Succ = PrintSetFont(ll_Job, 2)

li_Width = PrintWidth(ll_Job, as_text )

If li_Width < 1 Then
	
	li_Breakpoint = -99
	
End If

li_Succ = printcancel(ll_Job)
//li_Succ = printclose(ll_Job)

// width in inch/1000
rai_width = li_Width

If FileExists(ls_File) Then 
	lb_Succ = filedelete(ls_File)
Else
	// File Nicht sichtbar
	lb_Succ = FALSE
End If


Return li_Width

end function

protected function boolean of_is_downline_enabled (string as_unit);
/*
* Objekt : uo_cart_diagram
* Methode: of_is_downline_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.09.2010
*
* Argument(e):
*	 long al_airline_key
*	 long al_routing_id
*
* Beschreibung:		Schalter Watermark DOWNLINE pro Betrieb f$$HEX1$$fc00$$ENDHEX$$r NON-TR Carts
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.09.2010		Erstellung
*
*
* Return: boolean
*
*/

String		ls_Value


ilCartDiagramDownlineCounter++

If isCartDiagramDownlineSetting = "" Then

	ls_Value = f_unitprofilestring("w_local_cart_diagram" , "DEF_WATERMARK_DWNLN_S", "" , as_unit) 
	If Upper(ls_Value) = "ON" Then
		isCartDiagramDownlineSetting = ls_Value
		Return TRUE
	Else
		isCartDiagramDownlineSetting = "OFF"
	End If

Else
	If Upper(isCartDiagramDownlineSetting) = "ON" Then
		Return TRUE
	ElseIf Upper(isCartDiagramDownlineSetting) = "OFF" Then
		Return FALSE
	End If
End if

Return FALSE

end function

public function integer of_get_rungs_and_cols (long al_row, long al_column, ref long ral_rungs, ref long ral_columns);/*
* Objekt : uo_cart_diagram
* Methode: of_get_rungs_and_cols (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.11.2010
*
* Argument(e):
* long al_row
*	 long al_column
*	 ref long ral_rungs
*	 ref long ral_columns
*
* Beschreibung:		Ermittle Gr$$HEX2$$f600df00$$ENDHEX$$e eines Multi Rung Drawers
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.11.2010		Erstellung
*
*
* Return: integer
*
*/


Long	lFound
Long	iType, iContent, lLayoutDetailKey


lFound = this.dsLayoutDetail.Find("ncolumn=" + string(al_column ) + " and nrow=" + string(al_row ), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_rungs_and_cols NOT FOUND C" + String(al_column) + " R" + String(al_row))			
	end if
	ral_Rungs	= 1
	ral_Columns	= 1
	return -1
End If

// ---------------------------------------------------------------------------
// Contenttyp ermitteln
// ---------------------------------------------------------------------------
iType 				= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
iContent				= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
lLayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(lFound, "nlayout_detail_key")


// ---------------------------------------------------------------------------
// Bei Multi-Rung: Abmessungen sichern
// ---------------------------------------------------------------------------
If iType = DRAWER_MULTI_RUNG Then
	ral_Rungs		= this.dsLayoutDetail.Getitemnumber(lFound, "nrungs")
	ral_Columns		= this.dsLayoutDetail.Getitemnumber(lFound, "ncolumns")
	If isnull(ral_Rungs)		Then ral_Rungs		= 1
	If isnull(ral_Columns)	Then ral_Columns	= 1
	
Else
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_rungs_and_cols TYPE<>DRAWER_MULTI_RUNG  C" + String(al_column) + " R" + String(al_row))			
	end if
	ral_Rungs	= 1 
	ral_Columns = 1
	Return -1
End If

Return 1

end function

public function integer of_get_relevant_row_column (long al_row, long al_column, ref long ral_master_row, ref long ral_master_column);/*
* Objekt : uo_cart_diagram
* Methode: of_get_relevant_row_column (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.11.2010
*
* Argument(e):
* long al_row
*	 long al_column
*	 ref long ral_rungs
*	 ref long ral_columns
*
* Beschreibung:		Ermittle Gr$$HEX2$$f600df00$$ENDHEX$$e eines Multi Rung Drawers
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.11.2010		Erstellung
*
*
* Return: integer
*
*/


Long	lFound
Long	iType, iContent, lLayoutDetailKey
Long	ll_Ancestor


lFound = this.dsLayoutDetail.Find("ncolumn=" + string(al_column ) + " and nrow=" + string(al_row ), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
	return -1
End If

ll_Ancestor = this.dsLayoutDetail.Getitemnumber(lFound, "nancestor")


lFound = this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor ) + " and ntype=" + string(DRAWER_MULTI_RUNG ), 1, this.dsLayoutDetail.Rowcount())
if lFound = 0 Then
	return -1
End If

// ---------------------------------------------------------------------------
// Contenttyp ermitteln
// ---------------------------------------------------------------------------
iType 				= this.dsLayoutDetail.Getitemnumber(lFound, "ntype")
iContent				= this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
lLayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(lFound, "nlayout_detail_key")


// ---------------------------------------------------------------------------
// Bei Multi-Rung: Abmessungen sichern
// ---------------------------------------------------------------------------
If iType = DRAWER_MULTI_RUNG Then
//	ral_Rungs		= this.dsLayoutDetail.Getitemnumber(lFound, "nrungs")
//	ral_Columns	= this.dsLayoutDetail.Getitemnumber(lFound, "ncolumns")
	ral_master_row = this.dsLayoutDetail.Getitemnumber(lFound, "nrow")
	ral_master_column = this.dsLayoutDetail.Getitemnumber(lFound, "ncolumn")
	
Else
	ral_master_row = this.dsLayoutDetail.Getitemnumber(lFound, "nrow")
	ral_master_row = al_row
	ral_master_column = al_column
	
	Return -1
End If

Return 1

end function

public function integer of_is_position_in_use (integer arg_itype, long arg_inewrow, long arg_inewcolumn, integer arg_irungs, integer arg_icolumns);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_position_in_use (Function)
* Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster [KF]
* Datum  : 27.05.2010
* Argument(e):
* Long inewrow
*  Long inewcolumn
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
* 27.05.2010				Klaus F$$HEX1$$f600$$ENDHEX$$rster	Erstellung
*************************************************************/
Integer 	iType
Long		lFound1, lFound2, lAncestor, lAncestorNew

// --------------------------------------------------------------------------------
//  Pr$$HEX1$$fc00$$ENDHEX$$fen, ob das Ziel unbelegt innerhalb des Objekts liegt
// --------------------------------------------------------------------------------
Choose Case arg_iType
	Case DRAWER, DRAWERFOOD
		
		lFound1 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_inewcolumn) + " and nrow=" + string(arg_inewrow), 1, this.dsLayoutDetail.Rowcount())
		lFound2		= this.dsLayoutDetail.Find("ncolumn=" + string( this.iCurrentColumn) + " and nrow=" + string( this.iCurrentRow), 1, this.dsLayoutDetail.Rowcount())
		
		if lFound1 <= 0 Then return 1
		if lFound2 <= 0 Then return 1
		
		iType	= this.dsLayoutDetail.Getitemnumber(lFound1, "ntype")
		
		lAncestorNew	= this.dsLayoutDetail.GetItemNumber(lFound1, "nancestor")
		lAncestor			= this.dsLayoutDetail.GetItemNumber(lFound2, "nancestor")
				
		if  lAncestor = lAncestorNew Then 
			return EMPTY
		Elseif lAncestorNew = 0 Then
			
			if 	lFound1 + 1 > this.dsLayoutDetail.RowCount() Then return 1
						
			if 	(this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) and & 
				(this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "nancestor") = lAncestor) Then
				return EMPTY
			End If
			
		End If

	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
		
		lFound1 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_inewcolumn) + " and nrow=" + string(arg_inewrow), 1, this.dsLayoutDetail.Rowcount())
		lFound2		= this.dsLayoutDetail.Find("ncolumn=" + string( this.iCurrentColumn) + " and nrow=" + string( this.iCurrentRow), 1, this.dsLayoutDetail.Rowcount())
		
		if lFound1 <= 0 Then return 1
		if lFound2 <= 0 Then return 1
		
		iType	= this.dsLayoutDetail.Getitemnumber(lFound1, "ntype")
		
		lAncestorNew	= this.dsLayoutDetail.GetItemNumber(lFound1, "nancestor")
		lAncestor			= this.dsLayoutDetail.GetItemNumber(lFound2, "nancestor")
				
		if  lAncestor = lAncestorNew Then 
			return EMPTY
		Elseif lAncestorNew = 0 Then
			
			if 	lFound1 + 1 > this.dsLayoutDetail.RowCount() Then return 1
			if 	lFound1 - 1 < 1 Then return 1
						
			if 	(this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) and & 
				(this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "nancestor") = lAncestor) and & 
				(this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "nancestor") = lAncestor) Then
				return EMPTY
			End If
			
		End If
		
		
	Case TRAY, TRAYNONFOOD
		
	Case DRAWER_Multi_rung
		
		lFound1 		= this.dsLayoutDetail.Find("ncolumn=" + string(arg_inewcolumn) + " and nrow=" + string(arg_inewrow), 1, this.dsLayoutDetail.Rowcount())
		lFound2		= this.dsLayoutDetail.Find("ncolumn=" + string( this.iCurrentColumn) + " and nrow=" + string( this.iCurrentRow), 1, this.dsLayoutDetail.Rowcount())
		
		if lFound1 <= 0 Then return 1
		if lFound2 <= 0 Then return 1
		
		iType	= this.dsLayoutDetail.Getitemnumber(lFound1, "ntype")
		
		lAncestorNew	= this.dsLayoutDetail.GetItemNumber(lFound1, "nancestor")
		lAncestor			= this.dsLayoutDetail.GetItemNumber(lFound2, "nancestor")
				
		if lAncestor = lAncestorNew Then 
			return EMPTY
		Elseif lAncestorNew = 0 Then
			
			//if 	lFound1 + 1 > this.dsLayoutDetail.RowCount() Then return 1
			if 	lFound1 - 1 < 1 Then return 1
						
//			if 	(this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) and & 
//				(this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 - 1, "nancestor") = lAncestor) and & 
//				(this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "ntype") = EMPTY or this.dsLayoutDetail.GetItemNumber(lFound1 + 1, "nancestor") = lAncestor) Then
//				return EMPTY
//			End If

			if (this.dsLayoutDetail.GetItemNumber(lFound1, "ntype") = EMPTY) Then
				return EMPTY
			End If

		End If

end Choose

return 1

end function

public function long of_get_content_length (long arg_l_index, long arg_l_detail);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_content_length (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 05.10.2009
* Argument(e):
* long arg_l_index
*  long arg_l_detail
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  05.10.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/

Long liRetVal
long	lllength

dsPLSize.Retrieve(arg_l_index, arg_l_detail)

if dsPLSize.Rowcount() > 0 Then
	lllength = dsPLSize.getitemnumber(1,"nwidth")
	liRetVal = 0
Else
	// Keine Angaben gefunden > keine L$$HEX1$$e400$$ENDHEX$$nge
	liRetVal = 0
End If

return liRetVal

end function

public function boolean of_explode (long al_index_key, string as_unit, integer ai_parent_setting, integer ai_content);/*
* Objekt : uo_cart_diagram
* Methode: of_explode (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 14.12.2010
*
* Argument(e):
*	 long			al_index_key		St$$HEX1$$fc00$$ENDHEX$$ckliste
*	 string		as_unit				Betrieb
*
* Beschreibung:		Area Allocation: Explosion ein oder aus?
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	14.12.2010		Erstellung
*
*
* Return: boolean
*
*/


Boolean	lb_return = FALSE
Integer	li_Explode_Setting
String	ls_PL


ls_PL = f_get_packinglist( al_index_key )

// -------------------------------------------------
// Explode setting: ON / OFF
// -------------------------------------------------
If al_Index_Key > 0 Then
	li_Explode_Setting = of_get_explosion_setting(al_Index_Key, as_unit)
	Choose Case li_Explode_Setting
		Case 1 
			lb_return = TRUE
			guoLog.uf_debug("["+ this.classname( )+".of_explode] "  +  this.isStowage +" - " + "EXPLODE (area allocation) "  + ls_PL) // string(al_Index_Key) )
			if il_Disable_Debug= 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_explode: EXPLODE (area allocation) "  + ls_PL)
			End If

		Case 0
			lb_return = FALSE
			guoLog.uf_debug("["+ this.classname( )+".of_explode] "  +  this.isStowage +" - " + "SUPPRESS (area allocation) " + ls_PL) // string(al_Index_Key) )
			if il_Disable_Debug= 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_explode: SUPPRESS (area allocation) " + ls_PL)
			End If
		Case -1
			If ai_Content = Explosion Then
				lb_return = TRUE
				guoLog.uf_debug("["+ this.classname( )+".of_explode] "  +  this.isStowage +" - " + "EXPLODE (painter) "  + ls_PL) // string(al_Index_Key) )
				if il_Disable_Debug= 0 then
					guoLog.uf_debug( "["+ this.classname( )+".of_explode: EXPLODE (painter) "  + ls_PL)
				End If
			Elseif ai_Content = Content Then
				lb_return = FALSE
				guoLog.uf_debug("["+ this.classname( )+".of_explode] "  +  this.isStowage +" - " + "CONTENT (painter) "  + ls_PL) // string(al_Index_Key) )
				if il_Disable_Debug= 0 then
					guoLog.uf_debug( "["+ this.classname( )+".of_explode: CONTENT (painter) "  + ls_PL)
				End If
			Else			
				If ai_parent_setting = 1 Then
					//lb_return = TRUE
					guoLog.uf_debug("["+ this.classname( )+".of_explode] "  +  this.isStowage +" - " + "EXPLODE (parent) "  + ls_PL) // string(al_Index_Key) )
					if il_Disable_Debug= 0 then
						guoLog.uf_debug( "["+ this.classname( )+".of_explode: EXPLODE (parent) "   + ls_PL)
					End If
				Else
					//lb_return = FALSE
					guoLog.uf_debug("["+ this.classname( )+".of_explode] "  +  this.isStowage +" - " + "SUPPRESS (parent) " + ls_PL) // string(al_Index_Key) )
					if il_Disable_Debug= 0 then
						guoLog.uf_debug( "["+ this.classname( )+".of_explode: SUPPRESS (parent) "   + ls_PL)
					End If
				End If
			End If
	End Choose
End If

Return lb_return

end function

public function long of_draw_content_drawer_multi (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit);
/*
* Objekt : uo_cart_diagram
* Methode: of_draw_content_drawer_multi (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 10.12.2010
*
* Argument(e):
*	 long arg_llayoutdetailkey
*	 long arg_icontent
*	 long arg_irow
*	 long arg_icolumn
*	 long arg_ltype
*	 string arg_cunit
*
* Beschreibung:		Zeichnen eines Multi-Rung-Drawers (Explosion / Content + optional Distribution)
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			10.12.2010	angepasste Kopie von of_draw_content_drawer
* 1.1 			Oliver Hoefer			18.02.2011	Distribution - kein L$$HEX1$$f600$$ENDHEX$$schen nach dem Eintragen
* 1.2 			Oliver Hoefer			11.03.2011	Reparatur Qty-Anzeige
* 1.3 			Oliver Hoefer			14.03.2011	Header nach Oben
* 1.4 			Oliver Hoefer			23.05.2011	dsPLContents: Filter am Ende der Funktion entfernen
* 1.5 			Oliver Hoefer			26.11.2012	Backlog Anzeige
* 1.6 			Oliver Hoefer			28.11.2012	Header nicht blau, wenn nicht EDIT MODE
* 1.7 			Oliver Hoefer			05.06.2013	Explosion + Header CBASE-CR-NAM-13015
* 1.8 			Oliver Hoefer			08.05.2014	Backlog Anzeige angepasst
* 1.9 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
* 1.10 			O.Hoefer       		12.06.2014	IM10782135
* 2.0 			Oliver Hoefer			05.08.2016	Backlog Anpasung - F4-CR-1416
*
*
* Return: long
*
*/

Long			ll_Row, lX1, lX2, lY1, lY2, lRowHeight, lYCounter
Long			lPercentQuantity, lPercentText, lWidthQuantity, lWidthText
Long			lContentIndexKey,  lContentDetailKey, llAdditionalYOffset
Long			llMaxContentEx
Long			llTextWidth
Integer		li_Explode_Setting
Long			ll_no_of_rungs
Long			ll_Sort_OLD, ll_Sort_NEW
LOng			ll_Ancestor, ll_Found
Long			ll_Start_Row, ll_Temp
Integer		li_Succ
String		ls_Backlog
String		ls_Text
Long			ll_Explosion_Counter
Long			ll_Col_Counter
Long			ll_no_of_columns	= 1
Long			ll_Col_Offset		= 0 
Long			ll_Row_Offset		= 0 
String		ls_Object_Qty
Long			ll_Item_Counter
Long			ll_Temp_Key, ll_Test_Count
String		ls_Filter, ls_Object, ls_HeaderText
String		ls_Display
Long			ll_Rows
Long			ll_Content_Row
Long			ll_Count
Integer		li_Content_Setting
String		ls_Qty_Object, ls_Qty_Value
Boolean		lb_breakpoint
Long			ll_layout_content_key_header[]
Boolean		lb_Header
Long			ll_backlog_counter
Double		ld_Items
String		ls_Header_PL
s_component lstr_component
datastore lds_Temp


If arg_ltype <> DRAWER_MULTI_RUNG  Then
	// Falscher Typ
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Type<>DRAWER_MULTI_RUNG")
	End If
	Return -1
End If

// Content Typ
If IsNULL(arg_iContent) Then arg_iContent = DISTRIBUTION
If arg_iContent = 0  Then arg_iContent = DISTRIBUTION
li_Content_Setting = arg_iContent
this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()

this.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(arg_llayoutdetailkey))
this.dsLayoutDimension.Filter()
this.dsLayoutDimension.Sort()
ll_Temp = dsLayoutDimension.RowCount() 

if this.dsLayoutContents.RowCount() = 0 Then
	// Noch nichts zugeordnet: nur erlaubt bei Verteilung
	If arg_iContent <> DISTRIBUTION Then
		if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi dsLayoutContents.RowCount=0 UND arg_iContent <> DISTRIBUTION RETURN")
		if isvalid(lds_Temp) then destroy lds_Temp
		return 1
	End If
End If

if il_Disable_Debug = 0 Then
	choose case arg_iContent
		case DISTRIBUTION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer_multi *** DISTRIBUTION")
		Case CONTENT
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer_multi *** CONTENT")			
		CASE EXPLOSION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer_multi *** EXPLOSION")			
		CASE ELSE
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer_multi *** UNKNOWN")			
	End Choose
End If

ll_Found = dsLayoutDetail.Find("ncolumn=" + string( arg_icolumn ) + " and nrow=" + string(arg_irow), 1, this.dsLayoutDetail.Rowcount())
If ll_Found > 0 Then
	ll_Ancestor = dsLayoutDetail.GetItemNumber(ll_Found, "nancestor")
	ll_Found = dsLayoutDetail.Find("ntype=" + String(DRAWER_MULTI_RUNG) + " and nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())			
	If ll_Found > 0 Then
		ll_no_of_rungs = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrungs")
		ll_no_of_columns = this.dsLayoutDetail.Getitemnumber(ll_Found, "ncolumns")
	End If
End If
		
llMaxContentEx = of_get_maxcontent( arg_irow, arg_icolumn)

If ll_no_of_columns = 2 Then
	llMaxContentEx = llMaxContentEx / 2
End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi llMaxContentEx " + String(llMaxContentEx))
End If

llAdditionalYOffset = 50
If ll_Ancestor > 0 Then
	// Erste Row zu diesem Drawer 
	ll_Found = dsLayoutDetail.Find("nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())	 
	If ll_Found > 0 Then
		ll_Start_Row = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrow")
	End If
End If	
		
ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
	
	If dsLayoutContents.GetItemNumber(ll_Row, "nheader_flag" ) = 1 Then
		// This is a "header" for content sheet
		ll_layout_content_key_header[upperbound(ll_layout_content_key_header) + 1] = dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key")
	End If
	
Next
this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()
If trim(ls_Filter) = "" Then
	this.dsPLContents.SetFilter("npackinglist_index_key= -123")
	this.dsPLContents.Filter()
	//  Leer machen
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi FILTER dsPLContents (kein nlayout_content_key)")
	End If
End If

// ----------------------------------------------------------------------- 
// Header hochsortieren
// -----------------------------------------------------------------------
For ll_Count = 1 to 	dsPLContents.RowCount()
	ll_Temp_Key = dsPLContents.GetItemNumber(ll_Count, "nlayout_content_key")
	ls_Text = dsPLContents.GetItemString(ll_Count, "cen_packinglist_index_cpackinglist")
	For ll_Test_Count = 1 To upperbound(ll_layout_content_key_header)
		If ll_Temp_Key = ll_layout_content_key_header[ll_Test_Count] AND ll_Count > 1 Then
			if il_Disable_Debug=0 Then	guoLog.uf_debug( "["+ this.classname( )+".Header Move up: " + ls_text)
			ll_Sort_OLD =  dsPLContents.GetItemNumber(1, "nsort")
			ll_Sort_NEW =  dsPLContents.GetItemNumber(ll_Count, "nsort")
			li_Succ = dsPLContents.SetItem(1, "nsort", ll_Sort_NEW)
			li_Succ = dsPLContents.SetItem(ll_Count, "nsort", ll_Sort_OLD)			
		End If
	Next
Next
this.dsPLContents.Sort()

// ----------------------------------------------------------------------- 
// Ende Header hochsortieren
// -----------------------------------------------------------------------

this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
If ll_no_of_columns = 2 AND arg_icolumn = 1 Then
	li_Succ = this.dsObjects.SetFilter("ncolumn in (1, 2) and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
End If

this.dsObjects.Filter()
this.dsObjects.Sort()

// -------------------------------------------------
// Alle Textobjekte l$$HEX1$$f600$$ENDHEX$$schen
// -------------------------------------------------
For ll_Row = this.dsObjects.RowCount() to 1 step -1
	ls_Object = this.dsObjects.Getitemstring(ll_Row, "cobject")
	if of_check_string(ls_Object,"t_content_" ) Then
		if not of_check_string(ls_Object,"t_content_order_" ) Then
			this.of_unregister(ls_Object)
		End If
	End If
Next

this.dsObjects.SetFilter("" )
this.dsObjects.Filter()
this.dsObjects.Sort()

// -------------------------------------------------
// Explode setting: override or keep existing
// -------------------------------------------------
If il_IndexKey > 0 Then
	li_Explode_Setting = of_get_explosion_setting(il_IndexKey, arg_cunit)
	Choose Case li_Explode_Setting
		Case 1 
			//arg_iContent = EXPLOSION
			li_Content_Setting = EXPLOSION
			guoLog.uf_debug("["+ this.classname( )+".of_draw_content_drawer_multi] "  +  this.isStowage +" - " + "EXPLODE "  + string(il_IndexKey) )
		Case 0
			///arg_iContent = CONTENT
			li_Content_Setting = CONTENT
			guoLog.uf_debug("["+ this.classname( )+".of_draw_content_drawer_multi] "  +  this.isStowage +" - " + "CONTENT "  + string(il_IndexKey) )
		Case -1
			guoLog.uf_debug("["+ this.classname( )+".of_draw_content_drawer_multi] "  +  this.isStowage +" - " + "use existing "  + string(il_IndexKey) + "  " + String(arg_iContent) )
			// NO CHANGE: keep existing setting
	End Choose
End If

// ----------------------------------
// Content wird zu Explosion
// ----------------------------------
If arg_iContent = CONTENT Then
	li_Content_Setting = EXPLOSION
ElseIf arg_iContent = DISTRIBUTION Then
	//li_Content_Setting = DISTRIBUTION	
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi arg_iContent = DISTRIBUTION => li_Content_Setting = EXPLOSION")
	End If
	li_Content_Setting = EXPLOSION
Else
	li_Content_Setting = EXPLOSION
End If


If li_Content_Setting = EXPLOSION Then
	// ----------------------------------------------------------
	// --- EXPLOSION aufbauen                                 ---
	// ----------------------------------------------------------
	ll_Explosion_Counter = 0
	ll_Row_Offset = 0 
	// ----------------------------------------------------------
	// Textobjekte erzeugen / positionieren
	// ----------------------------------------------------------
	if bHasDimensions Then
		llTextWidth = lDefaultWidthSmall - 10
	Else
		llTextWidth = lDefaultWidth
	End If
	// ----------------------------------------------------------
	// Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
	// ----------------------------------------------------------
	lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
	lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth / 2
	lRowHeight = 14
	lYCounter = 0
	lPercentQuantity	= 10
	lPercentText		= 95
	lWidthQuantity		= llTextWidth * lPercentQuantity / 100
	lWidthText			= llTextWidth * lPercentText / 100

	// -------------------------------------------------
	// Objekt "Order" f$$HEX1$$fc00$$ENDHEX$$llen
	// -------------------------------------------------
	li_Succ = this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_order_')" )		
	If ll_no_of_columns = 2 AND arg_icolumn = 1 Then
		li_Succ = this.dsObjects.SetFilter("ncolumn in (1, 2) and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_order')" )
	End If
	
	li_Succ = this.dsObjects.Filter()
	li_Succ = this.dsObjects.Sort()
	If this.dsObjects.RowCount() > 0 Then
		ls_Object = this.dsObjects.GetItemstring(1, "cobject")
		if of_check_string(ls_Object,"t_content_order_" ) Then
			ls_Display =  of_get_order(arg_iRow, arg_iColumn) 
			If ls_Display = "0" Then ls_Display = " "
			of_modify_text( ls_Object, ls_Display)
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Row " + String(arg_iRow) + " Column " + String(arg_iColumn) +" ORDER=" + ls_Display)
			End If
		End If
	Else
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi t_content_order_ NOT FOUND ll_Row " + String(arg_iRow) + " Column " + String(arg_iColumn))
		End If
	End If
	
	// Filter - content OHNE order
	li_Succ = this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_') and not Match(cobject, 't_content_order_')" )
	this.dsObjects.Filter()
	this.dsObjects.Sort()
	
	ll_Item_Counter = 0
	
	// ----------------------------------------------
	// Header als normalen Text einbauen
	// ----------------------------------------------
	ll_Item_Counter += 1
	If ll_Item_Counter > llMaxContentEx And ll_no_of_columns = 2 AND ll_Item_Counter <= (llMaxContentEx * ll_no_of_columns ) Then 
		ll_Row_Offset = - llMaxContentEx
		ll_Col_Offset = 1
		lYCounter = ll_Item_Counter + ll_Row_Offset - 1 
	End If	
	ls_Object = "t_content_text_" + string(ll_Item_Counter + ll_Row_Offset) + "_col_" + string(arg_iColumn + ll_Col_Offset , "00") + "_row_" + string(arg_iRow, "00")
	
	// bei 3 oder mehr H$$HEX1$$f600$$ENDHEX$$heneinheiten: die passende Rungnumber verwenden
	If ll_Start_Row > 0 Then
		of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1 + (ll_Col_Offset * lDefaultWidth), lYOffset + ((ll_Start_Row ) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , llTextWidth , 0, 0, 0, 1)
	else
		of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1 + (ll_Col_Offset * lDefaultWidth), lYOffset + ((arg_iRow ) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , llTextWidth , 0, 0, 0, 1)
	End If
	
	If arg_icontent = explosion then
		of_modify_dw(ls_Object + '.font.weight="'+String(FONT_BOLD)+'"')
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi arg_icontent=explosion font.weight=700 " + ls_Object)
		End If
	End If	
		
	if of_register(ls_Object, arg_iRow, arg_icolumn + ll_Col_Offset) = -1 Then
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi register failed " + ls_Object)
		End If
		//return -1
	End If
	if il_Disable_Debug=0 Then	guoLog.uf_debug( "["+ this.classname( )+".Explosion 1 - create: " + ls_Object)
	
	lYCounter ++
	lPercentText		= 75
	lWidthText			= llTextWidth * lPercentText / 100
	// --------------------------------------------------------------------------------------
	// 				Explosion Header wurde eingetragen
	// 				Explosion Items 
	// --------------------------------------------------------------------------------------
	For ll_Row = ll_Item_Counter + 1 to (llMaxContentEx * ll_no_of_columns)
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Row " + String(ll_Row))
		End If
		If ll_Row > llMaxContentEx And ll_no_of_columns = 2 AND ll_Item_Counter <= (llMaxContentEx * ll_no_of_columns ) Then 
			ll_Row_Offset = - llMaxContentEx
			ll_Col_Offset = 1				
		End If
		lYCounter = ll_Row + ll_Row_Offset - 1 
		
		lY1 = lYOffset + ((arg_iRow) * lDefaultHeight) + 2 + (lRowHeight * lYCounter) - llAdditionalYOffset
		// bei 3 oder mehr H$$HEX1$$f600$$ENDHEX$$heneinheiten: die passende Rungnumber verwenden
		If ll_Start_Row > 0 Then
			lY1 = lYOffset + ((ll_Start_Row) *  lDefaultHeight) + 2 + (lRowHeight * lYCounter) - llAdditionalYOffset
		Else
			lY1 = lYOffset + ((arg_iRow) * lDefaultHeight) + 2 + (lRowHeight * lYCounter) - llAdditionalYOffset
		End If
		// Textfeld
		lX1 = lXOffset + ((arg_icolumn -1 + ll_Col_Offset) * lDefaultWidth) + 14
		ls_Object = "t_content_text_" + string(ll_Row + ll_Row_Offset) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".Explosion 1 - create: " + ls_Object)
		End If

		of_create_text(ls_Object, "",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1 , lY1, 15 , llTextWidth , 0, 0,  0, 1)
		if of_register(ls_Object, arg_iRow, arg_icolumn + ll_Col_Offset) = -1 Then
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi register failed " + ls_Object)
			End If
			//return -1		
		End If

		lYCounter ++
	Next
	
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Item_Counter " + String(ll_Item_Counter))
	End If
	
	// -------------------------------------------------
	// Textobjekte fuer Distribution f$$HEX1$$fc00$$ENDHEX$$llen
	// -------------------------------------------------
	ll_Row_Offset = 0
	ll_Col_Offset = 0
	
	lX1 = lXOffset + ((arg_icolumn -1 + ll_Col_Offset) * lDefaultWidth) + 14
	
	for ll_Row = 1 to this.dsLayoutDimension.RowCount()
		If ll_Row + ll_Item_Counter = llMaxContentEx + 1 And ll_no_of_columns = 2 Then 
			lYCounter = 0
			ll_Row_Offset = - llMaxContentEx
			ll_Col_Offset = 1
		End If
		
		lX1 = lXOffset + ((arg_icolumn -1 + ll_Col_Offset) * lDefaultWidth) + 14
		
		ls_Text = ""
		if this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit") > 0 Then
			ls_Text +=  f_check_null(string(this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit")) + " x ")
		End If
		ls_Text += f_check_null(this.dsLayoutDimension.GetItemString(ll_Row, "ctext")  )
		ls_Text += f_check_null( "/" + this.dsLayoutDimension.GetItemString(ll_Row, "cmeal_control_code")  )
		ls_Text += f_check_null( "/" + this.dsLayoutDimension.GetItemString(ll_Row, "cclass"))
	
		if this.dsLayoutDimension.GetItemNumber(ll_Row, "nspml") = 1 Then
			ls_Text += "/SPML"
		End If
		if not ibedit then ls_text = ""
		
		// ----------------------------------------------------------------------
		// Name: Z$$HEX1$$e400$$ENDHEX$$hler pro Spalte / tats$$HEX1$$e400$$ENDHEX$$chliche Spalte / Einschubzeile
		// ----------------------------------------------------------------------
		ls_Object = "t_content_text_" + string(ll_Item_Counter + ll_Row + ll_Row_Offset) + "_col_" + string(arg_iColumn + ll_Col_Offset , "00") + "_row_" + string(arg_iRow, "00")
		
		//if ll_Row + ll_Item_Counter > (llMaxContent * ll_no_of_columns) Then
		if ll_Row + ll_Item_Counter > (llMaxContentEx * ll_no_of_columns) Then
				
			if il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Row + ll_Item_Counter " + String(ll_Row) + " + " + String(ll_Item_Counter) + " > llMaxContentEx * ll_no_of_columns " + String(llMaxContentEx * ll_no_of_columns) + " KEIN PLATZ ")
			End If
		Else
		
			If ll_Start_Row > 0 Then
				// bei 3 oder mehr H$$HEX1$$f600$$ENDHEX$$heneinheiten: die passende Rungnumber verwenden
				If ll_Row > llMaxContentEx And ll_no_of_columns = 2 Then 
					lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14			
					of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((ll_Start_Row ) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity, 0, 0, 0, 1)
				Else			
					of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((ll_Start_Row ) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity, 0, 0, 0, 1)				
				End If			
			Else
				If ll_Row > llMaxContentEx And ll_no_of_columns = 2 Then 
					lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14			
					of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((arg_iRow ) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity, 0, 0, 0, 1)
				Else			
					of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((arg_iRow ) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity, 0, 0, 0, 1)				
				End If
			End If
			of_modify_dw(ls_Object + '.font.weight="' + String(FONT_NORMAL) + '"')
			of_modify_dw(ls_Object + '.font.height="-8"')
			if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".Explosion 1 - create: " + ls_Object)
			If ll_Row > llMaxContentEx And ll_no_of_columns = 2 Then 
				if of_register(ls_Object, arg_iRow, 2) = -1 Then
					if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_register FAILED " + ls_Object)
				End If
			Else
				if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi of_register FAILED " + ls_Object)
				Else
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi of_register SUCCESS " + ls_Object)
				end if
			End If		
			of_modify_text(ls_Object, ls_Text)
			of_modify_dw(ls_Object + '.font.weight="' + String(FONT_NORMAL) + '"')
			of_modify_dw(ls_Object + '.font.height="-8"')
			if ibedit then
				of_modify_dw(ls_Object + ".x='" + String(lX1) + "'") 
			end if
			lYCounter++
		End If
	Next
	
Elseif arg_icontent = DISTRIBUTION Then
	// -------------------------------------------------
	//	Distribution pur (OHNE Kombination mit Content)
	// -------------------------------------------------
	if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi arg_icontent = DISTRIBUTION ")
	// ----------------------------------------------------------
	// Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
	// ----------------------------------------------------------
	if bHasDimensions Then
		llTextWidth = TEXTWIDTH1
	Else
		llTextWidth = TEXTWIDTHSMALL1
	End If
	Choose Case arg_ltype
		Case TRAYNONFOOD
			lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 20
		Case Else
			lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
	end Choose
	lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth/2
	lRowHeight = 14
	lYCounter = 0
	
	For ll_Col_Counter = 1 To ll_no_of_columns
		
		If ll_Col_Counter > 1 and arg_icolumn < 2 Then
			lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
			lYCounter = 0
		End If
	
		For ll_Row = 1 to llMaxContentEx * ll_no_of_columns
	
			If arg_ltype = DRAWER_MULTI_RUNG AND ll_Start_Row > 0 Then
				lY1 = lYOffset + ((ll_Start_Row) *  lDefaultHeight) + 2 + (lRowHeight * lYCounter) - llAdditionalYOffset
			Else
				lY1 = lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * lYCounter) - llAdditionalYOffset
			End If
			ls_Object = "t_content_std_text_" + string(ll_Row, "00") + "_col_" + string(arg_icolumn + ll_Col_Counter - 1, "00") + "_row_" + string(arg_iRow, "00")			
			of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1  ,lY1 , 15 , llTextWidth , 0, 0, 0, 1)			
			if of_register(ls_Object, arg_iRow, arg_icolumn + ll_Col_Counter - 1) = -1 Then
				//return -1	
				if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Register Object failed: " + ls_Object)
			Else
				if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Register Object succeds: " + ls_Object) 
			End If
			lYCounter ++
		Next
		
	Next


	// -------------------------------------------------
	// wenn das Objekt die Order Nummer ist: f$$HEX1$$fc00$$ENDHEX$$llen
	// -------------------------------------------------
	li_Succ = this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_order_')" )		
	If ll_no_of_columns = 2 AND arg_icolumn = 1 Then
		li_Succ = this.dsObjects.SetFilter("ncolumn in (1, 2) and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
	End If	
	li_Succ = this.dsObjects.Filter()
	
	li_Succ = this.dsObjects.Sort()
	If dsObjects.Rowcount() > 0 Then
		ls_Object = this.dsObjects.GetItemstring(1, "cobject")
		if of_check_string(ls_Object,"t_content_order_" ) Then
			ls_Display =  of_get_order(arg_iRow, arg_iColumn) 
			If ls_Display = "0" Then ls_Display = " "
			of_modify_text( ls_Object, ls_Display)
			if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Row " + String(arg_iRow) + " Column " + String(arg_iColumn) +" ORDER=" + ls_Display)
		End If
	Else
		if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi t_content_order_ NOT FOUND ll_Row " + String(arg_iRow) + " Column " + String(arg_iColumn))
	End If

	// -------------------------------------------------
	// Distribution f$$HEX1$$fc00$$ENDHEX$$llen
	// -------------------------------------------------
	ll_Row_Offset = 0 
	ll_Col_Counter = 1
	for ll_Row = 1 to this.dsLayoutDimension.RowCount()
		If ll_Row = llMaxContentEx + 1 AND ll_no_of_columns > 1 Then
			ll_Col_Counter = 2
			ll_Row_Offset = - llMaxContentEx
		End If
//		If ll_Row = llMaxContent + 1 AND ll_no_of_columns > 1 Then
//			ll_Col_Counter = 2
//			ll_Row_Offset = - llMaxContent
//		End If
			
		ls_Text = ""
		if this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit") > 0 Then
			ls_Text +=  f_check_null(string(this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit")) + " x ")
		End If
		ls_Text += f_check_null(this.dsLayoutDimension.GetItemString(ll_Row, "ctext")  )
		ls_Text += f_check_null( "/" + this.dsLayoutDimension.GetItemString(ll_Row, "cmeal_control_code")  )
		ls_Text += f_check_null( "/" + this.dsLayoutDimension.GetItemString(ll_Row, "cclass"))
	
		if this.dsLayoutDimension.GetItemNumber(ll_Row, "nspml") = 1 Then
			ls_Text += "/SPML"
		End If
		if not ibedit then ls_text = ""
		ls_Object = "t_content_std_text_" + string(ll_Row, "00") + "_col_" + string(arg_icolumn + ll_Col_Counter - 1, "00") + "_row_" + string(arg_iRow, "00")
		of_modify_text(ls_Object, ls_Text)
	next
Else
	if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi undefined content")
//	return -1
End If

// -------------------------------------------------
// Erstmal alle Texte wieder resetten
// -------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
If arg_icolumn = 1 and ll_no_of_columns = 2 Then
	li_Succ = this.dsObjects.SetFilter("(ncolumn=" + string(arg_icolumn) + " OR ncolumn=2) and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
End If

this.dsObjects.Filter()
this.dsObjects.Sort()

For ll_Row = 1 to this.dsObjects.RowCount()
	ls_Object = this.dsObjects.GetItemstring(ll_Row, "cobject")
	if of_check_string(ls_Object,"t_content_" ) Then
		// 12.01.2010 Ulrich Paudler [UP]
		of_modify_text( ls_Object , "")
	End If
Next

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

li_Content_Setting = EXPLOSION
// ------------------------------------------------------------------------
// Texte neu eintragen
// Unterscheidung Content vs. Exploded Content vs. Verteilung ohne Content
// ------------------------------------------------------------------------
if li_Content_Setting = EXPLOSION Then
	ll_Col_Offset = 0 
	// -------------------------------------------------
	// --- EXPLOSION                                 ---
	// -------------------------------------------------
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi li_Content_Setting = EXPLOSION nach Reset All ")
	End If
	// -------------------------------------------------
	// wenn das Objekt die Order Nummer ist: f$$HEX1$$fc00$$ENDHEX$$llen
	// -------------------------------------------------
	li_Succ = this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_order_')" )
	If ll_no_of_columns = 2 AND arg_icolumn = 1 Then
		li_Succ = this.dsObjects.SetFilter("ncolumn in (1, 2) and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_order')" )
	End If		
	li_Succ = this.dsObjects.Filter()
	li_Succ = this.dsObjects.Sort()
	If this.dsObjects.RowCount() > 0 Then
		ls_Object = this.dsObjects.GetItemstring(1, "cobject")
		if of_check_string(ls_Object,"t_content_order_" ) Then
			ls_Display =  of_get_order(arg_iRow, arg_iColumn) 
			If ls_Display = "0" Then ls_Display = " "
			of_modify_text( ls_Object, ls_Display)
			if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Row " + String(arg_iRow) + " Column " + String(arg_iColumn) +" ORDER=" + ls_Display)
		End If
	Else
		if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi t_content_order_ NOT FOUND ll_Row " + String(arg_iRow) + " Column " + String(arg_iColumn))
	End If

	// ------------------------------------------------------------------------------------------------------------
	// 	Header + Inhalt
	// ------------------------------------------------------------------------------------------------------------
	ll_Explosion_Counter = 0
	ll_Row_Offset = 0 
	lds_Temp = create datastore
	lds_Temp.dataobject = "dw_packinglist_edit_content"
	lds_Temp.SetTransObject(sqlca)
	
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".dsPLContents dsPLContents.RowCount() " + String(dsPLContents.RowCount()))
	End If
	
	ll_Content_Row = 1
	For ll_Content_Row = 1 To dsPLContents.RowCount()
		If il_indexkey = 595824 Then
			li_Succ = li_Succ
		End If
		lContentIndexKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
		lContentDetailKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")
		if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".dsPLContents Row " + String(ll_Content_Row) + " ContentIndex " + String(lContentIndexKey))
		ll_Rows = lds_Temp.Retrieve(lContentIndexKey, lContentDetailKey, datetime(idt_Departure), 0)
		lds_Temp.SetSort("nsort a")
		lds_Temp.Sort()
		ll_Explosion_Counter++
		
		//If ll_Explosion_Counter = llMaxContent + 1 AND ll_no_of_columns > 1 Then
		If ll_Explosion_Counter = llMaxContentEx + 1 AND ll_no_of_columns > 1 Then
			ll_Col_Counter = 2
			//ll_Row_Offset = - llMaxContent
			ll_Row_Offset = - llMaxContentEx
			ll_Col_Offset = 1
		End If
		
		// BACKLOG???
		//If ll_Explosion_Counter + ll_Row_Offset < llMaxContent Then	
		//If ll_Explosion_Counter + ll_Row_Offset < llMaxContentEx Then	
		
		If ll_Explosion_Counter + ll_Row_Offset < llMaxContentEx OR &
			(ll_Explosion_Counter + ll_Row_Offset = llMaxContentEx AND ll_Content_Row = dsPLContents.RowCount())	Then		
			
			ls_Object = "t_content_text_" + string(ll_Explosion_Counter + ll_Row_Offset) + "_col_" + string(arg_iColumn + ll_Col_Offset , "00") + "_row_" + string(arg_iRow, "00")
			// Header eintragen
			lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
			lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
			lstr_component.squantity = String(dsPLContents.GetItemNumber(ll_Content_Row, "nquantity"))
			
			if il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi XX " + ls_Object  + " / " + lstr_component.ssnr +  " Quantity: " + String(dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")))
			// ---------------------------------------------------------------
			// Header? 
			// ---------------------------------------------------------------
			lb_Header = FALSE
			ll_Temp_Key = dsPLContents.GetItemNumber(ll_Content_Row, "nlayout_content_key")
			For ll_Test_Count = 1 To upperbound(ll_layout_content_key_header)
				If ll_Temp_Key = ll_layout_content_key_header[ll_Test_Count] Then
					lb_Header = TRUE	
				End If
			Next
			If lb_header Then
				of_modify_dw(ls_Object + '.font.weight="700"')
				If il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer HEADER FLAG " + dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext"))
				End If
				ls_Header_PL = dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
				
				If ibEdit Then
					of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,0)) + "'" )
				Else
					of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,0)) + "'" )
				End If
			Else
				of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,0)) + "'" )
			End If
						
			// ------------------------------------------------------------------------------------------------------------
			// 01.10.2010 Downline Watermark
			//  Downline Watermark an einem Drawer, der teil einer Packing List ist: Dies wird im Content der Packing List 
			// in der Spalte "Leg" gepflegt (Leg-Nummer >1)	
			// ------------------------------------------------------------------------------------------------------------
			ii_PL_Leg_Number			= this.dsPLContents.GetItemNumber(ll_Content_Row, "nleg_number")
			If IsNULL(ii_PL_Leg_Number) Then ii_PL_Leg_Number = 0
		
			ls_HeaderText =  of_get_item_description(lstr_component, TRUE)
			of_modify_text(ls_Object, ls_HeaderText)
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi modify: " + ls_Object + "=" + ls_HeaderText)
			End If
			
			if ibedit AND arg_icontent = Explosion then
				of_modify_dw(ls_Object + '.font.weight="700"')
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi BOLD ibedit=TRUE AND arg_icontent = Explosion " + ls_Object )
				End If
			End If
	
			If ll_Content_Row > 1 Then
				li_Succ = li_Succ
			End If	
			
			if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Explosion 2 - modify: " + ls_Object + " ll_Explosion_Counter=" + String(ll_Explosion_Counter) + " ls_HeaderText " + ls_HeaderText )
			// Ab hier:		Details eintragen
			// wenn f$$HEX1$$fc00$$ENDHEX$$r die St$$HEX1$$fc00$$ENDHEX$$ckliste in Area Allocation "suppress" eingestellt ist: keine Inhalte zeigen
			If of_explode( lContentIndexKey, arg_cunit, li_Explode_Setting, arg_icontent ) = FALSE Then
				If il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi SUPPRESS " + lstr_component.ssnr)
				If arg_icontent = content AND lb_Header = FALSE Then
					of_modify_dw(ls_Object + '.font.weight="400"')
				End If
				CONTINUE
			Else
				If arg_icontent = content Then
					If il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Parent = CONTENT => EXPLODE " + lstr_component.ssnr)
				End If
			End If
			// 05.06.2013 Explosion + Header CBASE-CR-NAM-13015

//			// ------------------------------------------------------------------------------------------------------------
//			// wenn die St$$HEX1$$fc00$$ENDHEX$$ckliste ein Header ist. dann nicht Explode???
//			// ------------------------------------------------------------------------------------------------------------
//			If lb_Header AND ibedit Then
//				If il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi DO NOT EXPLODE HEADER " + lstr_component.ssnr)
//				CONTINUE
//			End If
			for ll_Row = 1 to lds_Temp.RowCount()
				ll_Explosion_Counter++
				If ll_Explosion_Counter = llMaxContentEx + 1 AND ll_no_of_columns > 1 Then
					// Ab jetzt Spalte 2 
					ll_Col_Offset = 1
					ll_Row_Offset =  - llMaxContentEx
				End If
				
				if il_Disable_Debug= 0 then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Explosion_Counter " + String(ll_Explosion_Counter) +" ll_Row " + String(ll_Row) + " / " + lds_Temp.GetItemString(ll_Row, "cpackinglist_detail") )
				End If
				// Mehr als angezeigt werden kann
				if ll_Explosion_Counter >= (llMaxContentEx * ll_no_of_columns) AND (ll_Row <= lds_Temp.RowCount()) Then	
					if ll_Explosion_Counter = llMaxContentEx * ll_no_of_columns AND (ll_Row < lds_Temp.RowCount()) Then	
						if of_is_backlog_enabled() Then
							if il_Disable_Debug= 0 then
								guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi BACKLOG ll_Explosion_Counter " + String(ll_Explosion_Counter) +" ll_Row " + String(ll_Row) + " >= (llMaxContentEx * ll_no_of_columns)" + String((llMaxContentEx * ll_no_of_columns)) + " / " + lds_Temp.GetItemString(ll_Row, "cpackinglist_detail"))
							End If
							// Text eintragen ...
							ls_Object = "t_content_text_" + string(ll_Explosion_Counter) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
							
							of_modify_text(ls_Object, is_Overflow_MSG_2)
							
							// ----------------------------------------------------------------------------------------------------
							// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
							// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
							//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
							//							 should appear automatically and a Content spec should be generated
							// ----------------------------------------------------------------------------------------------------
							If ib_non_sky then
								of_modify_text(ls_Object, is_Overflow_MSG_1)
								
								guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi non sky BACKLOG => CONTENT SPEC " + ls_HeaderText + &
														" / " + lds_Temp.GetItemString(ll_Row, "cpackinglist_detail"))
								
							End If
							
							if il_Disable_Debug= 0 then
								guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi BACKLOG ls_Object " + ls_Object)
							End If
							ls_Object_Qty = "t_content_quantity_" + string(ll_Explosion_Counter) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
							of_modify_text( ls_Object_Qty, "")
						Else
							if il_Disable_Debug= 0 then
								guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi of_is_backlog_enabled() FALSE ll_Explosion_Counter " + String(ll_Explosion_Counter) +" ll_Row " + String(ll_Row) + " >= (llMaxContentEx * ll_no_of_columns)" + String((llMaxContentEx * ll_no_of_columns)) + " / " + ls_Headertext)
							End If
							// Menge eintragen ..
							ls_Object = "t_content_quantity_" + string(ll_Row + ll_Row_Offset + ll_Explosion_Counter) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
							of_modify_text(ls_Object, "")
							// Text eintragen ..
							If arg_ltype = drawer_multi_rung and ll_Explosion_Counter > 0 Then
								ls_Object = "t_content_text_" + string(ll_Row + ll_Explosion_Counter + ll_Row_Offset) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
							Else					
								ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
							End If
							lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
							lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
							lstr_component.squantity = String(lds_Temp.GetItemNumber(ll_Row, "nquantity"))
							ls_Display =  of_get_item_description(lstr_component)
							of_modify_text(ls_Object, ls_Display)
						End If
						
					ElseIf ll_Explosion_Counter = llMaxContentEx * ll_no_of_columns AND (ll_Row = lds_Temp.RowCount()) Then
						// 12.06.14 IM10782135 
						// Counter = MAX und aktuelle Zeile = letzte Zeile
						// Menge eintragen ..
						ls_Object = "t_content_quantity_" + string(ll_Row_Offset + ll_Explosion_Counter ) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")		
						if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Explosion 2 - modify: " + ls_Object + " ll_Explosion_Counter=" + String(ll_Explosion_Counter) )
						of_modify_dw(ls_Object + '.font.weight="400"')
						of_modify_dw(ls_Object + '.font.height="-8"')
			
						// Text eintragen ..
						ls_Object = "t_content_text_" + string(ll_Explosion_Counter + ll_Row_Offset) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")	
						lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
						lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
						lstr_component.squantity = String(lds_Temp.GetItemNumber(ll_Row, "nquantity"))
								
						ls_Display = of_get_item_description(lstr_component)
						if il_Disable_Debug=0 Then	guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Explosion 2 - modify: " + ls_Object + " ll_Explosion_Counter=" + String(ll_Explosion_Counter) )
						of_modify_text(ls_Object, ls_Display)
						of_modify_dw(ls_Object + '.font.weight="400"')
						of_modify_dw(ls_Object + '.font.height="-8"')
						
						
					End If
		
					If (ll_Explosion_Counter = llMaxContentEx * ll_no_of_columns AND (ll_Row = lds_Temp.RowCount())) Then
						// Letzte Zeile passt noch hinein => Kein Backlog
					Else
						If ib_Enable_Meal_Distribution = FALSE Then	
							lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
							lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
							lstr_component.squantity	= String(lds_Temp.GetItemNumber(ll_Row, "nquantity")) 
							ls_Backlog = of_get_item_description(lstr_component)
							ll_backlog_counter++
							//of_draw_content_backlog_tray(ll_backlog_counter, arg_iRow, arg_icolumn, ls_Backlog , PACKINGLIST)
							ld_items = lds_Temp.GetItemNumber(ll_Row, "nquantity")
							li_Succ = of_add_backlog( arg_irow, arg_icolumn,  "t_dummy_" + String(ll_backlog_counter) , 0, "", ls_Backlog, ll_backlog_counter, arg_ltype, ls_HeaderText) 
							if il_Disable_Debug= 0 then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi BACKLOG NO DISTR " + ls_Backlog)
						End If
					End If
					
				Else
		
					// Menge eintragen ..
					ls_Object = "t_content_quantity_" + string(ll_Row_Offset + ll_Explosion_Counter ) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")		
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Explosion 2 - modify: " + ls_Object + " ll_Explosion_Counter=" + String(ll_Explosion_Counter) )
					of_modify_dw(ls_Object + '.font.weight="400"')
					of_modify_dw(ls_Object + '.font.height="-8"')
		
					// Text eintragen ..
					ls_Object = "t_content_text_" + string(ll_Explosion_Counter + ll_Row_Offset) + "_col_" + string(arg_icolumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")	
					lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
					lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
					lstr_component.squantity = String(lds_Temp.GetItemNumber(ll_Row, "nquantity"))
							
					ls_Display = of_get_item_description(lstr_component)
					if il_Disable_Debug=0 Then	guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi Explosion 2 - modify: " + ls_Object + " ll_Explosion_Counter=" + String(ll_Explosion_Counter) )
					of_modify_text(ls_Object, ls_Display)
					of_modify_dw(ls_Object + '.font.weight="400"')
					of_modify_dw(ls_Object + '.font.height="-8"')
				End If
			Next			
		Else
			
				
			If ll_Explosion_Counter + ll_Row_Offset = ll_no_of_columns * llMaxContentEx AND of_is_backlog_enabled() &
			     AND dsPLContents.RowCount() > (ll_no_of_columns * llMaxContentEx) Then
				
				ls_Object = "t_content_text_" + string(ll_Explosion_Counter + ll_Row_Offset) + "_col_" + string(arg_iColumn + ll_Col_Offset , "00") + "_row_" + string(arg_iRow, "00")
				of_modify_text(ls_Object, is_Overflow_MSG_2 )
				if il_Disable_Debug=0 Then
					//guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi SEE BACKLOG " + ls_Object + " ll_Explosion_Counter=" + String(ll_Explosion_Counter) + " ll_Row_Offset=" + String(ll_Row_Offset)  + " llMaxContent=" + String(llMaxContent))
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi SEE BACKLOG " + ls_Object + " ll_Explosion_Counter=" + String(ll_Explosion_Counter) + " ll_Row_Offset=" + String(ll_Row_Offset)  + " llMaxContentEx=" + String(llMaxContentEx))
				End If
				of_modify_dw(ls_Object + '.font.weight="400"')
				of_modify_dw(ls_Object + '.font.height="-8"')
				lstr_component.stext = dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
				lstr_component.ssnr = dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
				lstr_component.squantity	= String(dsPLContents.GetItemNumber(ll_Content_Row, "nquantity"))
				ls_Backlog = of_get_item_description(lstr_component)
				if il_Disable_Debug=0 Then				
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi BACKLOG XXX "+ ls_Backlog) 
				End If
				If ib_Enable_Meal_Distribution = FALSE Then
					ll_backlog_counter++
					//of_draw_content_backlog_tray(ll_backlog_counter,  arg_iRow, arg_icolumn, ls_Backlog, PACKINGLIST)
					ld_items = dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")
					li_Succ = of_add_backlog( arg_irow, arg_icolumn,  "t_dummy_" + String(ll_backlog_counter) , 0, "", ls_Backlog, ll_backlog_counter, arg_ltype, ls_HeaderText) 
				End If
				
				// ----------------------------------------------------------------------------------------------------
				// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
				// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
				//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
				//							 should appear automatically and a Content spec should be generated
				// ----------------------------------------------------------------------------------------------------
				If ib_non_sky then
					of_modify_text(ls_Object, is_Overflow_MSG_1)
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi non sky BACKLOG => CONTENT SPEC " + ls_HeaderText + " /" + ls_Backlog) 
					//lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
					// add content spec ###########					
				End If
				
			Else
				lstr_component.stext = dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
				lstr_component.ssnr = dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
				lstr_component.squantity	= String(dsPLContents.GetItemNumber(ll_Content_Row, "nquantity"))
				ls_Backlog = of_get_item_description(lstr_component)
				if il_Disable_Debug=0 Then				
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi BACKLOG XXX "+ ls_Backlog) 
				End If
				if ib_Enable_Meal_Distribution = FALSE Then	
					ll_backlog_counter++
					//of_draw_content_backlog_tray(ll_backlog_counter,  arg_iRow, arg_icolumn, ls_Backlog, PACKINGLIST)
					ld_items = dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")
					li_Succ = of_add_backlog( arg_irow, arg_icolumn, "t_dummy_" + String(ll_backlog_counter) , 0, "", ls_Backlog, ll_backlog_counter, arg_ltype, ls_HeaderText) 

				End If
			end if			
		end if
	Next
	// Distribution f$$HEX1$$fc00$$ENDHEX$$llen
	// aus ...draw_tray
	ll_Row_Offset = 0
	ll_Col_Offset = 0
	If arg_icontent = content Then
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi (content) ll_Explosion_Counter vor Distributon " + String(ll_Explosion_Counter))
		End If
	End If
	
	If arg_icontent = distribution Then
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi (distribution) ll_Explosion_Counter vor Distributon " + String(ll_Explosion_Counter))
		End If
	End If
	// Nur im Painter werden Distr. Params gezeigt
	If not ibedit Then
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi HIDE DISTRIBUTION PARAMETERS")
		End If
		dsLayoutDimension.SetFilter("1=2")
		dsLayoutDimension.Filter()
	End If
	for ll_Row = 1 to this.dsLayoutDimension.RowCount()
		If ll_Row + ll_Explosion_Counter > llMaxContentEx * ll_no_of_columns OR &
			(ll_Row + ll_Explosion_Counter = llMaxContentEx * ll_no_of_columns AND dsLayoutDimension.RowCount() > llMaxContentEx * ll_no_of_columns) Then
//		If ll_Row + ll_Explosion_Counter > llMaxContent * ll_no_of_columns OR &
//			(ll_Row + ll_Explosion_Counter = llMaxContent * ll_no_of_columns AND dsLayoutDimension.RowCount() > llMaxContent * ll_no_of_columns) Then
//			
			If ll_Row + ll_Explosion_Counter = llMaxContentEx * ll_no_of_columns AND of_is_backlog_enabled() Then
				// "see back..."
				ls_Object = "t_content_text_" + string(ll_Explosion_Counter + ll_Row + ll_Row_Offset) + "_col_" + string(arg_iColumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
				//of_modify_text(ls_Object, uf.translate("see backlog for more details..."))
				of_modify_text(ls_Object, is_Overflow_MSG_2 )
				
				// ----------------------------------------------------------------------------------------------------
				// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
				// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
				//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
				//							 should appear automatically and a Content spec should be generated
				// ----------------------------------------------------------------------------------------------------
				If ib_non_sky then
					of_modify_text(ls_Object, is_Overflow_MSG_1)
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi non sky BACKLOG => CONTENT SPEC " + "##############")
					//lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
					// add content spec ###########					
				End If
				
			End if
			
			if il_Disable_Debug=0 Then	guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Row + ll_Explosion_Counter > llMaxContent kein Platz Counter=" + String(ll_Row + ll_Explosion_Counter) + " Max=" + String(llMaxContentEx))
			If ib_Enable_Meal_Distribution = FALSE Then	
				ls_Text = ""
				if this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit") > 0 Then
					ls_Text +=  f_check_null(string(this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit")) + " x ")
				End If
				ls_Text += f_check_null(this.dsLayoutDimension.GetItemString(ll_Row, "ctext")  )
				ls_Text += f_check_null( "/"  + this.dsLayoutDimension.GetItemString(ll_Row, "cmeal_control_code")  )
				ls_Text += f_check_null(  "/"  + this.dsLayoutDimension.GetItemString(ll_Row, "cclass"))
			
				if this.dsLayoutDimension.GetItemNumber(ll_Row, "nspml") = 1 Then
					ls_Text += "/SPML"
				End If
				if not ibedit then ls_text = ""
			end if
			CONTINUE
		End If
		
//		If ll_Row + ll_Explosion_Counter = llMaxContent + 1 AND ll_no_of_columns > 1 Then
		If ll_Row + ll_Explosion_Counter = llMaxContentEx + 1 AND ll_no_of_columns > 1 Then
			ll_Col_Counter = 2
			//ll_Row_Offset = - llMaxContent
			ll_Row_Offset = - llMaxContentEx
			ll_Col_Offset = 1
		End If
		ls_Text = ""
		if this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit") > 0 Then
			ls_Text +=  f_check_null(string(this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit")) + " x ")
		End If
		ls_Text += f_check_null(this.dsLayoutDimension.GetItemString(ll_Row, "ctext")  )
		ls_Text += f_check_null("/"  + this.dsLayoutDimension.GetItemString(ll_Row, "cmeal_control_code")  )
		ls_Text += f_check_null("/"  + this.dsLayoutDimension.GetItemString(ll_Row, "cclass"))
	
		if this.dsLayoutDimension.GetItemNumber(ll_Row, "nspml") = 1 Then
			ls_Text += "/SPML"
		End If
		if not ibedit then ls_text = ""
		ls_Object = "t_content_text_" + string(ll_Explosion_Counter + ll_Row + ll_Row_Offset) + "_col_" + string(arg_iColumn + ll_Col_Offset, "00") + "_row_" + string(arg_iRow, "00")
		if il_Disable_Debug=0 Then	guoLog.uf_debug( "["+ this.classname( )+".Explosion 2 DISTRIBUTED - modify: " + ls_Object)
		of_modify_text(ls_Object, ls_Text)
		of_modify_dw(ls_Object + '.font.weight="400"')
		of_modify_dw(ls_Object + '.font.height="-8"')
	next
	
ElseIf arg_icontent = DISTRIBUTION Then	
	// Nur Distribution OHNE Contents
	If il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi arg_icontent = DISTRIBUTION ")
	End If
	// Order Nummer: f$$HEX1$$fc00$$ENDHEX$$llen
	li_Succ = this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_order_')" )
	If ll_no_of_columns = 2 Then
		li_Succ = this.dsObjects.SetFilter("(ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + ") OR (ncolumn=" + &
															string(2) + " and nrow= " + string(arg_iRow) + ") and Match(cobject, 't_content_order_')" )
	End If
	li_Succ = this.dsObjects.Filter()
	li_Succ = this.dsObjects.Sort()
	If this.dsObjects.RowCount() > 0 Then
		If this.dsPLContents.RowCount() > 0 Then
			ls_Object = this.dsObjects.GetItemstring(1, "cobject")
			if of_check_string(ls_Object,"t_content_order_" ) Then
				ls_Display =  of_get_order(arg_iRow, arg_iColumn) 
				If ls_Display = "0" Then ls_Display = " "
				of_modify_text( ls_Object, ls_Display)
			End If
		End If
	Else
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi t_content_order_ NOT FOUND ll_Row " + String(arg_iRow) + " Column " + String(arg_iColumn))
		End If
	End If
	
	li_Succ = this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_') and not Match(cobject, 't_content_order_')" )
	If ll_no_of_columns = 2 Then
		li_Succ = this.dsObjects.SetFilter("(ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + ") OR (ncolumn=" + &
												string(2) + " and nrow= " + string(arg_iRow) + ") and Match(cobject, 't_content_') and not Match(cobject, 't_content_order_')" )
	End If
	this.dsObjects.Filter()
	this.dsObjects.Sort()
	// Distribution f$$HEX1$$fc00$$ENDHEX$$llen
	// aus ...draw_tray
	For ll_Row = 1 to this.dsLayoutDimension.RowCount()
		ls_Text = ""
		If this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit") > 0 Then
			ls_Text +=  f_check_null(string(this.dsLayoutDimension.GetItemNumber(ll_Row, "nlimit")) + " x ")
		End If
		ls_Text += f_check_null(      this.dsLayoutDimension.GetItemString(ll_Row, "ctext")  )
		ls_Text += f_check_null("/" + this.dsLayoutDimension.GetItemString(ll_Row, "cmeal_control_code")  )
		ls_Text += f_check_null("/" + this.dsLayoutDimension.GetItemString(ll_Row, "cclass"))
		if this.dsLayoutDimension.GetItemNumber(ll_Row, "nspml") = 1 Then
			ls_Text += "/SPML"
		End If
		if not ibedit then ls_text = ""
		If ll_Row <= dsObjects.RowCount() Then
			ls_Object = this.dsObjects.GetItemstring(ll_Row, "cobject")
			of_modify_text(ls_Object, ls_Text)
			of_modify_dw(ls_Object + '.font.weight="400"')
			of_modify_dw(ls_Object + '.font.height="-8"')			
			if ibedit then
				of_modify_dw(ls_Object + ".x='" + String(lX1) + "'") 
			end if			
		Else
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer_multi ll_Row > dsObjects.RowCount " + String(ll_Row) + " / " + String(dsObjects.RowCount()))
			End If
		End If		
	Next	
End If

this.dsPLContents.SetFilter("")
this.dsPLContents.Filter()
this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()
This.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(arg_llayoutdetailkey))
This.dsLayoutDimension.Filter()

if IsValid(lds_Temp) Then DESTROY lds_Temp

Return 0

end function

public function boolean of_valid_airline_equipment (long al_airline_key, long al_packinglist_index_key, long al_packinglist_detail_key);

// kein airline equipment f$$HEX1$$fc00$$ENDHEX$$r den typ vorhanden?

//select ae.nequipment_key from cen_airline_eq ae where ae.nairline_key = 17847 and ae.cunit = 
//(
//select pl.cunit from cen_packinglists pl   where pl.npackinglist_index_key = 619835 and ...detail....
//
//)




Return TRUE
end function

public function boolean of_check_eq (long al_airline_key, string as_unit_of_measure);/*
* Objekt : uo_cart_diagram
* Methode: of_check_eq (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.02.2011
*
* Argument(e):
* long al_airline_key
*	 string as_unit_of_measure
*
* Beschreibung:		Check Valid Equipment
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.02.2011		Erstellung
*
*
* Return: boolean
*
*/

this.dsAirlineEq.Retrieve(al_airline_key , as_unit_of_measure )

if this.dsAirlineEq.RowCount() < 1 Then
	If il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".NO dsAirlineEq for Airline " + String(al_airline_key) + " UNIT " + as_unit_of_measure)
	End If
	return FALSE
Else
	
	//If il_Disable_Debug=0 Then
	//	guoLog.uf_debug( "["+ this.classname( )+".dsAirlineEq > 0 for Airline " + String(al_airline_key) + " UNIT " + as_unit_of_measure )
	//End If

	if this.dsAirlineEq.RowCount() = 1 Then
		il_Equipment_Width = this.dsAirlineEq.GetItemNumber(1, "ncolumns")
	End If

	RETURN TRUE
End If

RETURN TRUE

end function

public function boolean of_has_contents (long arg_irow, long arg_icolumn);/*
* Objekt : uo_cart_diagram
* Methode: of_has_contents (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 01.03.2011
*
* Argument(e):
* long arg_irow
*	 long arg_icolumn
*
* Beschreibung:		Inhalte vorhanden (aus Diagram Painter)?
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			01.03.2011	Erstellung
* 1.1 			Oliver Hoefer			23.03.2011	Header ignorieren
* 1.2 			Oliver Hoefer			13.04.2011	Alles ganz anders: Inhalt gilt nur dann als nicht leer, wenn Contents im Inhalt
* 1.3 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*
*
* Return: boolean
*
*/

String		ls_Filter
long			ll_Row
Long		 	llType, llContent
long			llFound = 0
long		 	llLayoutDetailKey
Long			ll_layout_content_key
Long			ll_Cont, ll_index, ll_Detail
DateTime		ldt_Valid
Long			ll_Key
String		ls_temp
Boolean 		lb_Diagramm_Empty
Long			ll_Count
Long			ll_Rows
Long			ll_Type
String		ls_PL
DataStore	lds_Contents


lds_Contents = create datastore
lds_Contents.dataobject = "dw_packinglist_edit_content"
lds_Contents.SetTransObject(sqlca)


llFound = this.dsLayoutDetail.Find("ncolumn=" + string(arg_icolumn) + " and nrow=" + string(arg_irow), 1, this.dsLayoutDetail.Rowcount())

if llFound = 0 Then
	sError = "Error: Row/Column mismatch"
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_has_contents Error: Row/Column mismatch ")
	End if
	if IsValid(lds_Contents) then destroy lds_Contents
	return false
End If

// ---------------------------------------------------------------------------
// Contenttyp ermitteln
// ---------------------------------------------------------------------------
llType 				= this.dsLayoutDetail.Getitemnumber(llFound, "ntype")
llContent			= this.dsLayoutDetail.Getitemnumber(llFound, "ncontent")
llLayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(llFound, "nlayout_detail_key")

If llType = DRAWERFOOD OR llType = TRAY Then
	// Nur Distribution - kein Content
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_has_contents llType = DRAWERFOOD OR llType = TRAY ")
	End if
	if IsValid(lds_Contents) then destroy lds_Contents
	Return FALSE
End If

//this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey))
//this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey) + " and (isnull( nheader_flag ) OR  nheader_flag =0)")
this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()

lb_Diagramm_Empty = TRUE

If dsLayoutContents.RowCount() > 0 Then
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_has_contents DIAGRAM dsLayoutContents.rowcount>0 " + String(dsLayoutContents.RowCount()))
	end if
	//Return TRUE
	//lb_Diagramm_Empty = FALSE
Else
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_has_contents DIAGRAM dsLayoutContents.rowcount<1 " + String(dsLayoutContents.RowCount()))
	end if
	lb_Diagramm_Empty = TRUE
	if IsValid(lds_Contents) then destroy lds_Contents
	Return false
End If


If lb_Diagramm_Empty then
	//this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey) + " and nheader_flag = 1")
	this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey) + " and nheader_flag = 1")
	this.dsLayoutContents.Filter() 
	this.dsLayoutContents.Sort()
	
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_has_contents DIAGRAM HEADER ENTRIES dsLayoutContents.rowcount " + String(dsLayoutContents.RowCount()))
	end if
	
	this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(llLayoutDetailKey))
	this.dsLayoutContents.Filter() 
	this.dsLayoutContents.Sort()
	
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_has_contents DIAGRAM NON-HEADER & HEADER ENTRIES dsLayoutContents.rowcount " + String(dsLayoutContents.RowCount()))
	end if
	
	ls_Filter = ""
	For ll_Row = 1 to this.dsLayoutContents.RowCount()
		ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
		if ll_Row <> this.dsLayoutContents.RowCount() Then
			ls_Filter += " or "
		End If
	Next
	
	If Trim(ls_Filter) = "" Then 
		if IsValid(lds_Contents) then destroy lds_Contents
		Return FALSE
	End If 
	
	this.dsPLContents.SetFilter(ls_Filter)
	this.dsPLContents.Filter()
	this.dsPLContents.Sort()
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_has_contents dsPLContents.rowcount(): " + String(dsPLContents.rowcount())) // + " Filter " + ls_Filter)
	End If
	
	if dsPLContents.RowCount() < 1 Then
		// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden UND keine Verteilung
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_has_contents dsPLContents.RowCount() < 1 ")
		End If		
	Else
		
		For ll_Count = 1 To dsPLContents.RowCount()			
			ll_index		= this.dsPLContents.GetItemNumber(ll_Count, "ndetail_key")
			ll_Detail	= this.dsPLContents.GetItemNumber(ll_Count, "npackinglist_detail_detail_key")
			ls_temp     = f_get_packinglist(ll_index)
			// Artikel?
			// 2 = Esl
			// 3 = Artikel
			ll_Type = f_get_packinglist_type(ll_index, idt_departure )
			If ll_Type = 3 Then
				lb_Diagramm_Empty = FALSE
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_has_contents ARTICLE " + ls_temp)
				End If
			Else
				ll_Rows = lds_Contents.Retrieve(ll_index, ll_Detail,  datetime(idt_departure), 0)
				If ll_Rows > 0 Then
					lb_Diagramm_Empty = FALSE
					If il_Disable_Debug = 0 Then
						ls_PL  = this.dsPLContents.GetItemString(ll_Count, "cen_packinglist_index_cpackinglist")
						//guoLog.uf_debug( "["+ this.classname( )+".of_has_contents HEADER CONTENT " + ls_PL)
						guoLog.uf_debug( "["+ this.classname( )+".of_has_contents CONTENT " + ls_PL)
					End If
				End if
			End If
		Next
	End If	
End If


if IsValid(lds_Contents) then destroy lds_Contents

Return NOT lb_Diagramm_Empty

end function

public function long of_add_content (long irow, long icolumn, long ldetail, long lsort, long lheader_flag);/* 
* Funktion/Event: of_add_content
* Beschreibung: 	Ordnet einen Inhalt zu
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 iRow				Zeile
**	 iColumn			"Spalte"
*	 lDetail    	Zeiger auf den Inhalt
*	 nsort			Zeiger auf das Sortierfeld
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		22.09.2008	Erstellung
*	1.1				U.Paudler	16.04.2009	Pr$$HEX1$$fc00$$ENDHEX$$fungen verbessert
*	1.3				U.Paudler	05.10.2009	Groessenpruefung hinzu
*	1.4				U.Paudler  	19.11.2009	Drawerfood und Traynonfood eingebaut
*	1.5				U.Paudler  	10.12.2009	F$$HEX1$$fc00$$ENDHEX$$llstandspr$$HEX1$$fc00$$ENDHEX$$fung repariert
*  1.6            O.Hoefer    08.03.2011  Header Flag hinzu
*  1.7            O.Hoefer    23.11.2012  Max Content aus Funktion
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	lX1
Long	lX2
Long	lFound, lFoundContent, lSequence, i, j, a, lLayoutDetailKey, lLayoutContentKey
Long iType, iCount
// 05.10.2009 Ulrich Paudler [UP]
Long llContentLength = 0
Long llMaxContent
Long	ll_Ancestor, ll_Found, ll_no_of_rungs


// Den Datensatz der Position suchen
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
Else
	
	// Ins leere gedropped
	// 16.04.2009 Ulrich Paudler [UP]
	// Anzahl der Inhalte je nach Einschubtyp begrenzen
	 iType = this.dsLayoutDetail.GetItemNumber(lFound, "ntype") 

	ll_Ancestor = dsLayoutDetail.GetItemNumber(lFound, "nancestor")
	
	// Bei Multi Rung nach dem Mastersatz suchen
	
	if iType = BLOCKED AND ll_Ancestor > 0 Then
		lFound 	= this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor) + " and ntype=" + string( DRAWER_MULTI_RUNG ), 1, this.dsLayoutDetail.Rowcount())
		If lFound > 0 Then
			irow = this.dsLayoutDetail.GetItemNumber(lFound, "nrow") 
			iType = this.dsLayoutDetail.GetItemNumber(lFound, "ntype") 
		End If
	Else	
		
		// 10.12.2009 Ulrich Paudler [UP] Wenn BLOCKED dann den Typ der Zeile dar$$HEX1$$fc00$$ENDHEX$$ber ermittleln
		if iType = BLOCKED Then
			lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow -1), 1, this.dsLayoutDetail.Rowcount())
			if lFound = 0 Then
				sError = "Error: Row/Column mismatch"
				return -1
			Else
				irow = irow -1	
				iType = this.dsLayoutDetail.GetItemNumber(lFound, "ntype") 
			End If	
		End If
	End If
	
	
	Choose Case iType 
		Case DRAWER, DRAWERFOOD
			llMaxContent = iMaxRowsContent
		Case DRAWER_3RUNG, DRAWERFOOD_3RUNG	
			llMaxContent = iMaxRowsContent3Rung
		Case TRAY
			llMaxContent = iMaxRowsContentTray
		// 18.01.2010 Ulrich Paudler [UP]
		Case TRAYNONFOOD
			llMaxContent = iMaxRowsContentTrayNF
			
		Case DRAWER_MULTI_RUNG	
			llMaxContent = iMaxRowsContent3Rung	
			ll_Ancestor = dsLayoutDetail.GetItemNumber(lFound, "nancestor")
			ll_Found = dsLayoutDetail.Find("ntype=" + String(DRAWER_MULTI_RUNG) + " and nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())			
			If ll_Found > 0 Then
				ll_no_of_rungs = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrungs")
				//llMaxContent = 2 + (ll_no_of_rungs - 1) * 3
				llMaxContent = of_get_maxcontent( irow, icolumn)
			End If	
			
		Case Else
			return 0
	end Choose
	
	lLayoutDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
	for i = 1 to this.dsLayoutContents.RowCount()
		if this.dsLayoutContents.GetItemNumber(i, "nlayout_detail_key") = lLayoutDetailKey Then
			lLayoutContentKey = this.dsLayoutContents.GetItemNumber(i, "nlayout_content_key")
			for j = 1 to this.dsPLContents.RowCount()
				if lLayoutContentKey = this.dsPLContents.GetItemNumber(j, "nlayout_content_key") Then
					iCount ++
					// 05.10.2009 Ulrich Paudler [UP]  L$$HEX1$$e400$$ENDHEX$$nge addieren
					llContentLength = llContentLength + of_get_content_length(this.dsPLContents.GetItemNumber(j, "npackinglist_index_key"), this.dsPLContents.GetItemNumber(j, "npackinglist_detail_key"))
				End If
			next
		End If
	next
	
	// 05.10.2009 Ulrich Paudler [UP] 
	// Test ob der eingef$$HEX1$$fc00$$ENDHEX$$gte Content $$HEX1$$fc00$$ENDHEX$$berhaupt noch reinpasst
	if llContentLength > llMaxContentLength Then 
		sError = "Error: Max content length reached"
		return -1
	End If

// 01.02.2010 Ulrich Paudler [UP]
//	if iCount >= llMaxContent Then
//		sError = "Error: Max content watermark reached"
//		return -1
//	End If

	this.dsLayoutDetail.SetItem(lFound, "ncontent", CONTENT)
End If

lSequence = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)

if lSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

// Aktuelle Position merken
this.iCurrentRow = iRow
this.iCurrentColumn = iColumn

// Inhalt suchen	
lFoundContent = this.dsPLContents.Find("ndetail_key = " + string(lDetail) + " and nsort = " + string(lSort), 1, this.dsPLContents.RowCount())

if lFoundContent > 0 Then 
	If lheader_flag = 1 Then
		a = this.dsLayoutContents.InsertRow(1)
	Else
		a = this.dsLayoutContents.InsertRow(0)
	End If
	dsLayoutContents.SetItem(a, "nlayout_content_key", lSequence)
	dsLayoutContents.SetItem(a, "nlayout_detail_key", lLayoutDetailKey)
	
	// -------------------------------------
	// 2011-03-08 Header Flag
	// -------------------------------------
	dsLayoutContents.SetItem(a, "nheader_flag", lheader_flag )
	if il_Disable_Debug= 0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_add_content nlayout_content_key=" + String(lSequence) + " nlayout_detail_key="  + String(lLayoutDetailKey) + " Header Flag=" + String(lheader_flag) )
	End If
	
	this.dsPLContents.SetItem(lFoundContent, "nlayout_content_key", lSequence)
	of_draw_content(iRow, iColumn, is_CSC) //this.sunit)
Else
	sError = "Error: Content not found"
	return -1
End If


return 1
end function

public function boolean of_is_content_sheet_header (long al_layout_detail_key, string as_cpackinglist);/*
* Objekt : uo_cart_diagram
* Methode: of_is_content_sheet_header (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 08.03.2011
*
* Argument(e):
* string as_pl
*	 long al_layout_detail_key
*
* Beschreibung:		hat dieser Content das "Header" flag?
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	08.03.2011		Erstellung
*
*
* Return: boolean
*
*/


Long		ll_Header
Boolean	lb_Return = FALSE
String	ls_PL
Long		ll_layout_content_key
String	ls_Filter
Long		ll_Row


this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(al_layout_detail_key))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()


ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
Next

If Trim(ls_Filter) = "" Then 
	Return FALSE
End If 

this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()
//if il_Disable_Debug=0 Then
//	guoLog.uf_debug( "["+ this.classname( )+".of_is_content_sheet_header dsPLContents.rowcount(): " + String(dsPLContents.rowcount()) + " Filter " + ls_Filter)
//End If

For ll_Row = 1 To dsPLContents.RowCount()
	ls_PL = this.dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
	If ls_PL = as_cpackinglist then
		ll_layout_content_key  = this.dsPLContents.GetItemNumber(ll_Row, "nlayout_content_key")

		select	pc.nheader_flag 
		into		:ll_header
		from		cen_pl_layout_contents pc 
		where		pc.nlayout_detail_key = :al_layout_detail_key
		AND		pc.nlayout_content_key = :ll_layout_content_key;
		
		If SQLCA.SQLCode = 0 Then
			If ll_Header = 1 Then
				lb_Return = TRUE
			End If
		Else
			If il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_is_content_sheet_header Layout Detail Key=" + String(al_layout_detail_key) + " / " + String(SQLCA.sqldbcode) + " / " + SQLCA.sqlerrtext)
			End If
			
		End If
	End If
Next

		
Return lb_Return

end function

public function long of_get_content_sheet_contents (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_header_flag);/*
* Objekt : uo_cart_diagram
* Methode: of_get_content_sheet_contents (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 03.03.2011
*
* Argument(e):
* long arg_llayoutdetailkey
*	 long arg_icontent
*	 long arg_irow
*	 long arg_icolumn
*	 long arg_ltype
*	 string arg_cunit
*	 long arg_start_pos
*	 ref s_distrib_items astr_items[]
*   boolean ab_header_flag 
*
* Beschreibung:		Diagramm-Inhalte sammeln (benutzt von Create Distribution)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	03.03.2011		Erstellung
* 1.1 			O.Hoefer	15.01.2013		Header PL nur in CS wenn CS Switch eingeschaltet
*
*
* Return: long
*
*/


Long			ll_Row 
Long			lContentIndexKey,  lContentDetailKey
Long			ll_Temp
Integer		li_Succ
String		ls_Text
Long			ll_Index_Key
Long			ll_Col_Counter
Long			ll_Item_Counter
String		ls_Filter,  lsText , ls_HeaderText
Long			ll_Rows
Long			ll_Content_Row
Long			ll_Current_Index
Boolean		lb_is_header
Boolean		lb_content_spec_enabled	
Long			ll_Number_of_Contents = 0 
s_component			lstr_component
s_distrib_items	lstr_Empty[]


astr_items = lstr_Empty

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents BEGIN FUNCTION")
End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents layoutdetailkey=" + String(arg_lLayoutDetailKey)  + " column=" + &
					String(arg_icolumn) + " row=" + String(arg_irow) + " unit=" + arg_cunit + " Startpos=" + String(arG_start_pos)  )
End If

this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()

if this.dsLayoutContents.RowCount() = 0 Then
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents KEIN INHALT?")
	End If
	Return 0
End If
		
ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
Next

If Trim(ls_Filter) = "" Then 
	Return 0
End If 

this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()
if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents dsPLContents.rowcount(): " + String(dsPLContents.rowcount()) + " Filter " + ls_Filter)
End If

If il_IndexKey = 0 Then
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents il_IndexKey=0" )
	End If
End If

if dsPLContents.RowCount() < 1 Then
	// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden UND keine Verteilung
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents dsPLContents.RowCount() < 1 ")
	End If
	li_succ = -9999
Else
	// ------------------------------------------------------------------------------------------------------------
	// Ab hier:		Inhalt $$HEX1$$fc00$$ENDHEX$$bertragen
	// ------------------------------------------------------------------------------------------------------------
	For ll_Content_Row = 1 To dsPLContents.RowCount()
		
		lContentIndexKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
		lContentDetailKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")

		lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
		lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
		lstr_component.squantity	= ""
		ls_HeaderText =  of_get_item_description(lstr_component)
		
		ll_Index_Key = f_get_packinglist_key(lstr_component.ssnr)
		lb_content_spec_enabled =	of_is_content_spec_enabled( ll_Index_Key, is_csc , idt_departure  )
		
		// Check Header		
		lb_is_header = of_is_content_sheet_header( arg_llayoutdetailkey , lstr_component.ssnr)
		If ab_header_flag = lb_is_header Then
			
			// 15.01.2013 wenn Header Flag UND Header Parameter, ABER KEIN CS Schalter: NO ACTION
			If ab_header_flag AND lb_is_header AND lb_content_spec_enabled = FALSE Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents HEADER FLAG TRUE, CS NOT ACTIVATED " + ls_HeaderText)
				CONTINUE
			End If
			
			ll_Number_of_Contents += 1
			ll_Current_Index = upperbound(astr_items) + 1
			astr_items[ll_Current_Index].sitem = ls_HeaderText
			astr_items[ll_Current_Index].cpackinglist	= lstr_component.ssnr
			astr_items[ll_Current_Index].ctext			= lstr_component.stext
			astr_items[ll_Current_Index].lcount = this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")
			if il_Disable_Debug = 0 Then
				If ab_header_flag Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents HEADER FLAG TRUE ls_HeaderText " + ls_HeaderText)
				Else
					guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents HEADER FLAG FALSE ls_HeaderText " + ls_HeaderText)
				End If
			End If
		End If
	Next
End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_content_sheet_contents END FUNCTION" )
End If

Return ll_Number_of_Contents

end function

public function integer of_align_objects (string as_match, long al_align_mode, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_clean_band (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.07.2010
*
* Argument(e):
*	string		as_band		Header oder Footer
*	boolean		ab_backlog	verwende dw-Backlog
*
* Beschreibung:		L$$HEX1$$f600$$ENDHEX$$sche alles aus Header oder Footer
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.07.2010		Erstellung
*
*
* Return: integer
*
*/


//----------------------------------------------------
// Alle Objecte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
If ab_backlog = FALSE Then
	if isvalid(oDw) Then
		 sDWObjects = oDw.describe("datawindow.objects")
	End If
			
	if isvalid(oDs) Then
		sDWObjects = ods.describe("datawindow.objects")
	End If
Else
	if isvalid(odwbacklog ) Then
		 sDWObjects = odwbacklog .describe("datawindow.objects")
	End If
			
	if isvalid(odsbacklog ) Then
		sDWObjects = odsbacklog .describe("datawindow.objects")
	End If
	
	
End If
	
// sDWObjects = oDw.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If


for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	If pos(lower(sObjects[i]), as_match) > 0 Then
		If ab_backlog = FALSE Then
			if isvalid(oDw) Then
				//ls_Error = oDw.modify("destroy " + sObjects[i])
				ls_Error = oDw.modify(sObjects[i] + ".alignment='" + String(al_align_mode) + "'")
			End If
			
			if isvalid(ods) Then
//				ls_Error = ods.modify("destroy " + sObjects[i])
				ls_Error = oDs.modify(sObjects[i] + ".alignment='" + String(al_align_mode) + "'")
			End If
		Else
		
			if isvalid(odwbacklog ) Then
				ls_Error = oDwBacklog.modify(sObjects[i] + ".alignment='" + String(al_align_mode) + "'")
			End If
			
			if isvalid(odsbacklog ) Then
				ls_Error = oDsBacklog.modify(sObjects[i] + ".alignment='" + String(al_align_mode) + "'")
			End If
		End If
		
	End If
	
Next
	
Return 1
end function

public function long of_get_explosion_content (long arg_llayoutdetailkey, long arg_irow, long arg_icolumn, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[]);/*
* Objekt : uo_cart_diagram
* Methode: of_get_explosion_content (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 03.03.2011
*
* Argument(e):
*	 long arg_llayoutdetailkey
*	 long arg_icontent
*	 long arg_irow
*	 long arg_icolumn
*	 long arg_ltype
*	 string arg_cunit
*	 long arg_start_pos
*	 ref s_distrib_items astr_items[]
*
* Beschreibung:		Diagramm-Inhalte sammeln (benutzt von Create Distribution)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	03.03.2011		Erstellung
*
*
* Return: long
*
*/


Long			ll_Row 
Long			lContentIndexKey,  lContentDetailKey
Long			ll_Temp
Integer		li_Succ
String		ls_Text
Long			ll_Col_Counter
Long			ll_Item_Counter
String		ls_Filter,  lsText , ls_HeaderText
Long			ll_Rows
Long			ll_Found
Long			ll_Content_Row
Long			ll_Current_Index
s_component			lstr_component
s_distrib_items	lstr_Empty[]
Long			ll_Number_of_Contents = 0 
Long			ll_Type


astr_items = lstr_Empty

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content BEGIN FUNCTION")
End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content layoutdetailkey=" + String(arg_lLayoutDetailKey)  + " column=" + &
					String(arg_icolumn) + " row=" + String(arg_irow) + " unit=" + arg_cunit + " Startpos=" + String(arG_start_pos)  )
End If

this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()

if this.dsLayoutContents.RowCount() < 1 Then
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content KEIN INHALT?")
	End If
	Return 0
End If
	
ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(arg_icolumn) + " and nrow=" + string(arg_irow), 1, this.dsLayoutDetail.Rowcount())							
if ll_Found > 0 Then
	ll_Type	= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
	If ll_Type <> EXPLOSION Then
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content KEINE EXPLOSION")
		End If
		Return 0		
	End If	
End If
		
ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
Next

If Trim(ls_Filter) = "" Then 
	Return 0
End If 

this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()
if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content dsPLContents.rowcount(): " + String(dsPLContents.rowcount()) + " Filter " + ls_Filter)
End If

If il_IndexKey = 0 Then
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content il_IndexKey=0" )
	End If
End If

if dsPLContents.RowCount() < 1 Then
	// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden UND keine Verteilung
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content dsPLContents.RowCount() < 1 ")
	End If
	li_succ = -9999
Else
	// ------------------------------------------------------------------------------------------------------------
	// Ab hier:		Inhalt $$HEX1$$fc00$$ENDHEX$$bertragen
	// ------------------------------------------------------------------------------------------------------------
	For ll_Content_Row = 1 To dsPLContents.RowCount()
		ll_Number_of_Contents += 1
		
		lContentIndexKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
		lContentDetailKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")

		lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
		lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
		lstr_component.squantity	= ""
		ls_HeaderText =  of_get_item_description(lstr_component)
		ll_Current_Index = upperbound(astr_items) + 1
		astr_items[ll_Current_Index].sitem = ls_HeaderText
		astr_items[ll_Current_Index].cpackinglist	= lstr_component.ssnr
		astr_items[ll_Current_Index].ctext			= lstr_component.stext
		astr_items[ll_Current_Index].lcount = this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")
	Next
End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_explosion_content END FUNCTION" )
End If

Return ll_Number_of_Contents

end function

public function boolean of_is_explosion_enabled (long al_index_key, string as_unit, date ad_departure);/*
* Objekt : uo_cart_diagram
* Methode: of_is_explosion_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 05.08.2010
*
* Argument(e):
* long al_index_key
*	 string as_unit
*	 date ad_departure
*
* Beschreibung:		Ermittle ob PL im Diagramm aufgel$$HEX1$$f600$$ENDHEX$$st werden soll
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	05.08.2010		Erstellung
* 1.1 			O.Hoefer	01.08.2016		NON Sky Explode Settings
*
*
* Return: boolean
*
*/


Long		ll_Rows
Long		ll_Explode
Integer	li_Succ
String	ls_Filter
Boolean	lb_Return = FALSE
Integer	li_Return = 0
DataStore	lds_PL_Unit_Assignment

// ------------------------------------------------------
// Master data View: keine local setting ber$$HEX1$$fc00$$ENDHEX$$cksichtigen
// ------------------------------------------------------
If ib_Enable_masterdata_view Then
	return FALSE
End If

If ib_non_sky = TRUE AND ib_non_sky_vip = FALSE Then
	RETURN TRUE
END IF

lds_PL_Unit_Assignment = CREATE DataStore
lds_PL_Unit_Assignment.DataObject = "dw_local_area_pl_assign"
lds_PL_Unit_Assignment.SetTransObject(SQLCA)
If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"

ll_Rows = lds_PL_Unit_Assignment.Retrieve(s_app.smandant, as_unit, al_index_key ) 

If ll_Rows < 1 Then 
	DESTROY lds_PL_Unit_Assignment

	If ib_non_sky OR ib_non_sky_vip Then
		Return TRUE
	Else
		Return FALSE
	End If
	
End If

//ls_Filter = " dvalid_from <= " +  String(ad_departure , "yyyy-dd-mm") + " and  dvalid_to >= " + String(ad_departure , "yyyy-dd-mm")
ls_Filter = " dvalid_from <= " +  String(ad_departure , "yyyy-mm-dd") + " and  dvalid_to >= " + String(ad_departure , "yyyy-mm-dd")
li_Succ = lds_PL_Unit_Assignment.SetFilter(ls_Filter)
li_Succ = lds_PL_Unit_Assignment.Filter()

If lds_PL_Unit_Assignment.RowCount() > 0 Then
	ll_Explode	 = lds_PL_Unit_Assignment.GetItemNumber(1, "nexplode")
	If ll_Explode = 1 Then
		li_Return = 1
		lb_Return = TRUE
	End If
End If

DESTROY lds_PL_Unit_Assignment

Return lb_Return
end function

public function boolean of_exists_content_sheet_header (long al_column, long al_row);/*
* Objekt : uo_cart_diagram
* Methode: of_exists_content_sheet_header (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 08.03.2011
*
* Argument(e):
*	 long Column, Row
*
* Beschreibung:		hat dieser Einschub das "Header" flag?
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	08.03.2011		Erstellung
*
*
* Return: boolean
*
*/


Boolean	lb_Return = FALSE
String	ls_Filter
Long		ll_header
Long		ll_Found
Long		ll_Layout_Detail_Key, ll_Content


ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
if ll_Found > 0 Then
	ll_Content				= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
	ll_Layout_Detail_Key	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
	if il_Disable_Debug= 0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_exists_content_sheet_header ll_LayoutDetailKey " + String(ll_Layout_Detail_Key) + " C" + String(al_column ) + " R" + String(String(al_row )))
	End If
			
	this.dsLayoutContents.SetFilter("nheader_flag=1 AND nlayout_detail_key=" + string(ll_layout_detail_key))
	this.dsLayoutContents.Filter() 
	
	If dsLayoutContents.RowCount() > 0 Then

		lb_Return = TRUE
		if il_Disable_Debug= 0 then
			guoLog.uf_debug( "["+ this.classname( )+".of_exists_content_sheet_header TRUE C" + String(al_column ) + " R" + String(String(al_row )))
		End If
	Else
		lb_Return = FALSE
		if il_Disable_Debug= 0 then
			guoLog.uf_debug( "["+ this.classname( )+".of_exists_content_sheet_header FALSE C" + String(al_column ) + " R" + String(String(al_row )))
		End If
	End If

Else
	if il_Disable_Debug= 0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_exists_content_sheet_header lNOT FOUND C" + String(al_column ) + " R" + String(String(al_row )))
	End If
End If
	

this.dsLayoutContents.SetFilter("")
this.dsLayoutContents.Filter() 

		
Return lb_Return

end function

public function long of_get_fixed_content (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_do_not_explode);
/*
* Objekt : uo_cart_diagram
* Methode: of_get_fixed_content (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 03.03.2011
*
* Argument(e):
*	 long arg_llayoutdetailkey
*	 long arg_icontent
*	 long arg_irow
*	 long arg_icolumn
*	 long arg_ltype
*	 string arg_cunit
*	 long arg_start_pos
*	 ref s_distrib_items astr_items[]
*
* Beschreibung:		Diagramm-Inhalte sammeln (benutzt von Create Distribution)
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			03.03.2011	Erstellung
* 1.1 			Oliver Hoefer			08.03.2013	Anpassungen
* 1.2 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
* 1.3 			Oliver Hoefer			10.08.2016	Header PL
*
*
* Return: long
*
*/


Long			ll_Row 
Long			lContentIndexKey,  lContentDetailKey, llAdditionalYOffset
Long			llMaxContent //, llMaxContentEx
Integer		li_Explode_Setting
Long			ll_no_of_rungs
LOng			ll_Ancestor, ll_Found
Long			ll_Start_Row, ll_Temp
Integer		li_Succ
String		ls_Text
Long			ll_Explosion_Counter
Long			ll_Col_Counter
Long			ll_Item_Counter
String		ls_Qty_Object
String		ls_Qty
String		ls_Filter,  lsText , ls_HeaderText, ls_HeaderPL, ls_HeaderPLandText
Long			ll_Rows
Long			ll_Original_Content
Long			ll_Content_Row
Integer		li_Content_Setting
Long			ll_Current_Index
Boolean		lb_Current_PL_Is_Header
String		ls_Pl_to_Check_For_Header
s_component lstr_component
datastore lds_Temp
Long			ll_Tmp_Setting
s_distrib_items	lstr_Empty[]
Long			ll_Number_of_Contents = 0 


ll_Original_Content = arg_icontent
astr_items = lstr_Empty

If s_app.itrace >0 then
	il_Disable_Debug = 0
end if

if il_Disable_Debug=0 Then
	If ab_do_not_explode Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content BEGIN FUNCTION ab_do_not_explode=TRUE")
	Else
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content BEGIN FUNCTION ab_do_not_explode=FALSE")
	End If
End If

If arg_ltype <> DRAWER_MULTI_RUNG  Then
	// Falscher Typ
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content arg_ltype <> DRAWER_MULTI_RUNG")
	End If
	Return -1
End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content layoutdetailkey=" + String(arg_lLayoutDetailKey)  + " arg_iContent=" + String(arg_iContent) + " column=" + &
					String(arg_icolumn) + " row=" + String(arg_irow) + " type=" + String(arg_ltype) + " unit=" + arg_cunit + " Startpos=" + String(arG_start_pos)  )
End If

// Content Typ
If IsNULL(arg_iContent) Then arg_iContent = DISTRIBUTION
If arg_iContent = 0  Then arg_iContent = DISTRIBUTION
li_Content_Setting = arg_iContent
this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()


if il_Disable_Debug=0 Then
	choose case arg_iContent
		case DISTRIBUTION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** DISTRIBUTION")
		Case CONTENT
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** CONTENT")			
		CASE EXPLOSION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** EXPLOSION")			
		CASE ELSE
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** UNKNOWN")			
	End Choose
End If

if this.dsLayoutContents.RowCount() = 0 Then
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content KEIN INHALT?")
	End If
	Return 0
End If

ll_Found = dsLayoutDetail.Find("ncolumn=" + string( arg_icolumn ) + " and nrow=" + string(arg_irow), 1, this.dsLayoutDetail.Rowcount())
If ll_Found > 0 Then
	ll_Ancestor = dsLayoutDetail.GetItemNumber(ll_Found, "nancestor")
	ll_Found = dsLayoutDetail.Find("ntype=" + String(DRAWER_MULTI_RUNG) + " and nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())			
	If ll_Found > 0 Then
		ll_no_of_rungs = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrungs")
//		ll_no_of_columns = this.dsLayoutDetail.Getitemnumber(ll_Found, "ncolumns")
	End If
End If
		
llMaxContent = of_get_maxcontent( arg_irow, arg_icolumn)  //2 + (ll_no_of_rungs - 1) * 3
//llMaxContentEx = 2 + (ll_no_of_rungs - 1) * 3 // iMaxRowsContentExplosion3Rung
llAdditionalYOffset = 50
If ll_Ancestor > 0 Then
	// Erste Row zu diesem Drawer 
	ll_Found = dsLayoutDetail.Find("nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())	 
	If ll_Found > 0 Then
		ll_Start_Row = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrow")
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content StartRow: " + String(ll_Start_Row))
		End If
	End If
Else
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content ll_Ancestor=0")
	End If
End If	
		
ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
Next

If Trim(ls_Filter) = "" Then 
	Return 0
End If 

this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()


// ----------------------------------------------------------------------- 
// Header hochsortieren
// -----------------------------------------------------------------------
Long	ll_Count, ll_Temp_Key,ll_Sort_NEW,ll_Sort_OLD, ll_Test_Count
For ll_Count = 1 to 	dsPLContents.RowCount()
	ll_Temp_Key = dsPLContents.GetItemNumber(ll_Count, "nlayout_content_key")
	ls_Text = dsPLContents.GetItemString(ll_Count, "cen_packinglist_index_cpackinglist")
	lb_Current_PL_Is_Header = FALSE
	lContentIndexKey = this.dsPLContents.GetItemNumber(ll_Count, "ndetail_key")
	ls_Pl_to_Check_For_Header = f_get_packinglist( lContentIndexKey)
	lb_Current_PL_Is_Header = of_is_content_sheet_header( arg_llayoutdetailkey , ls_Pl_to_Check_For_Header )
	
	If lb_Current_PL_Is_Header AND ll_Count > 1 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content Header Move up: " + ls_text)
		ll_Sort_OLD =  dsPLContents.GetItemNumber(1, "nsort")
		ll_Sort_NEW =  dsPLContents.GetItemNumber(ll_Count, "nsort")
		li_Succ = dsPLContents.SetItem(1, "nsort", ll_Sort_NEW)
		li_Succ = dsPLContents.SetItem(ll_Count, "nsort", ll_Sort_OLD)			
	End If
Next
this.dsPLContents.Sort()

// ----------------------------------------------------------------------- 
// Ende Header hochsortieren
// -----------------------------------------------------------------------



if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content dsPLContents.rowcount(): " + String(dsPLContents.rowcount()) + " Filter " + ls_Filter)
End If

// -------------------------------------------------
// Explode setting: override or keep existing
// -------------------------------------------------
If il_IndexKey > 0 Then
	li_Explode_Setting = of_get_explosion_setting(il_IndexKey, arg_cunit)
	Choose Case li_Explode_Setting
		Case 1 
			arg_iContent = EXPLOSION
			guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content] "  +  this.isStowage +" - " + "EXPLODE "  + string(il_IndexKey) )
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLODE "  + string(il_IndexKey))
			End If
		Case 0
			arg_iContent = CONTENT
			guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content] "  +  this.isStowage +" - " + "CONTENT "  + string(il_IndexKey) )
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content CONTENT "  + string(il_IndexKey))
			End If
		Case -1
			guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content] "  +  this.isStowage +" - " + "use existing "  + string(il_IndexKey) + "  " + String(arg_iContent) )
			// NO CHANGE: keep existing setting
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING "  + string(il_IndexKey)+ "  " + String(arg_iContent))
			End If

	End Choose
Else
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content il_IndexKey=0" )
	End If
End If

// ----------------------------------
// Content wird zu Explosion
// ----------------------------------
If arg_iContent = CONTENT Then
	li_Content_Setting = EXPLOSION
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content arg_iContent = CONTENT => EXPLOSION " )
	End If

ElseIf arg_iContent = DISTRIBUTION Then
	li_Content_Setting = DISTRIBUTION	
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content arg_iContent = DISTRIBUTION " )
	End If
End If

If li_Content_Setting = EXPLOSION Then
	// ----------------------------------------------------------
	// --- EXPLOSION aufbauen                                 ---
	// ----------------------------------------------------------
	ll_Item_Counter = 0
	
Else
//	sError = "Error: undefined content"
//	if il_Disable_Debug=0 Then
//		guoLog.uf_debug( "["+ this.classname( )+".Error: undefined content")
//	End If
//	return -1
End If

// ------------------------------------------------------------------------
// Texte neu eintragen
// Unterscheidung Content vs. Exploded Content vs. Verteilung ohne Content
// ------------------------------------------------------------------------

If il_Disable_Debug = 0 Then
	//guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLOSION/DISTRIBUTION")
	If dsPLContents.RowCount() > 0 Then
		//dsPLContents.saveas("c:\temp\cbase\of_get_fixed_content_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_dsPLContents.PSR", PSReport! , true)
	End If
End If

if dsPLContents.RowCount() < 1 AND arg_iContent <> DISTRIBUTION Then
	// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden UND keine Verteilung
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content dsPLContents.RowCount() < 1 AND arg_iContent <> DISTRIBUTION")
	End If
	li_succ = -9999
//	End If	
	

//Elseif arg_iContent = EXPLOSION Then // Explosion Layout
Elseif li_Content_Setting = EXPLOSION OR li_Content_Setting = CONTENT OR li_Content_Setting = DISTRIBUTION Then // Explosion Layout	
	// -------------------------------------------------
	// --- EXPLOSION                                 ---
	// -------------------------------------------------
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLOSION/DISTRIBUTIONCONTENT")
	End If
	// -------------------------------------------------
	// wenn das Objekt die Order Nummer ist: f$$HEX1$$fc00$$ENDHEX$$llen
	// -------------------------------------------------
	// ------------------------------------------------------------------------------------------------------------
	// Ab hier:		Header + Inhalt
	// ------------------------------------------------------------------------------------------------------------
	lds_Temp = create datastore
	lds_Temp.dataobject = "dw_packinglist_edit_content"
	lds_Temp.SetTransObject(sqlca)

	ll_Explosion_Counter = arg_start_pos - 1 


//	ll_Content_Row = 1
	For ll_Content_Row = 1 To dsPLContents.RowCount()
		ll_Number_of_Contents += 1
		
		lContentIndexKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
		lContentDetailKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")
	
		ll_Rows = lds_Temp.Retrieve(lContentIndexKey, lContentDetailKey, datetime(idt_Departure), 0)
		lds_Temp.SetSort("nsort a")
		lds_Temp.Sort()
				 
//		// ------------------------------------------------------------------------------------------------------------
//		// Wenn Header St$$HEX1$$fc00$$ENDHEX$$ckliste im Einschub vorhanden => nicht EXPLODE
//		// ------------------------------------------------------------------------------------------------------------
//		If ab_do_not_explode Then
//			lds_Temp.Reset()
//		End If
	
		// ------------------------------------------------------------------------------------------------------------
		// Wenn Header vorhanden und aktuelle St$$HEX1$$fc00$$ENDHEX$$ckliste <> Header => nicht EXPLODE
		// ------------------------------------------------------------------------------------------------------------
		//If ab_do_not_explode Then
			lb_Current_PL_Is_Header = FALSE
			ls_Pl_to_Check_For_Header = f_get_packinglist( lContentIndexKey)
			lb_Current_PL_Is_Header = of_is_content_sheet_header( arg_llayoutdetailkey , ls_Pl_to_Check_For_Header )
			If NOT lb_Current_PL_Is_Header  Then
				//lds_Temp.Reset()
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content DO NOT SUPPRESS (Not a Header): " + ls_Pl_to_Check_For_Header)
			Else
				// 18.03.2013 SUPPRESS???
				//lds_Temp.Reset()
				
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content DO NOT SUPPRESS (PL IS Header): " + ls_Pl_to_Check_For_Header)
				
			End If
		//End If
	
		ll_Explosion_Counter++

		lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
		lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
		lstr_component.squantity	= ""
		ls_HeaderText =  of_get_item_description(lstr_component)
		ls_HeaderPL = lstr_component.ssnr
		ls_HeaderPLandText = lstr_component.ssnr + " - " + lstr_component.stext
		// ######################################################################
		ll_Current_Index = upperbound(astr_items) + 1
		astr_items[ll_Current_Index].sitem = ls_HeaderText
		
		astr_items[ll_Current_Index].cpackinglist	= lstr_component.ssnr
		astr_items[ll_Current_Index].ctext			= lstr_component.stext
				
		If ll_Original_Content = CONTENT Then		
			astr_items[ll_Current_Index].bcontent = TRUE
		End If
		
		If ll_Original_Content = EXPLOSION Then		
			astr_items[ll_Current_Index].bcontent = TRUE
		End If
		
		If lb_Current_PL_Is_Header Then
			If ll_Content_Row =  1 then
				astr_items[ll_Current_Index].bbold = TRUE
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content lb_Current_PL_Is_Header BOLD " + ls_HeaderText)
			End If
		End If

		// ------------------------------------------------------------------------------------------------------------
		// wenn keine Header PL vorhanden: Explosion Top BOLD 
		// ------------------------------------------------------------------------------------------------------------
		If ll_Original_Content = EXPLOSION AND ab_do_not_explode = FALSE Then	
			astr_items[ll_Current_Index].bbold = TRUE
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content ll_Original_Content=EXPLOSION AND NO HEADER bbold=TRUE " + ls_HeaderText)
			End If
		End If
					
		astr_items[ll_Current_Index].lcount = this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content ls_HeaderText " + ls_HeaderText)
		End If
		// ######################################################################
		
		// ------------------------------------------------------------------------------------------------------------
		// wenn f$$HEX1$$fc00$$ENDHEX$$r die St$$HEX1$$fc00$$ENDHEX$$ckliste in Area Allocation "suppress" eingestellt ist: keine Inhalte zeigen
		// ------------------------------------------------------------------------------------------------------------
//		If of_explode( lContentIndexKey, arg_cunit, li_Explode_Setting, arg_icontent ) = FALSE Then
//			If il_Disable_Debug=0 Then
//				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content SUPPRESS " + lstr_component.ssnr)
//			End If
//			CONTINUE
//		Else
//			If arg_icontent = content Then
//				If il_Disable_Debug=0 Then
//					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content Parent = CONTENT => EXPLODE " + lstr_component.ssnr)
//				End If
//			End If
//		End If
		ll_Tmp_Setting = of_get_explosion_setting(lContentIndexKey, arg_cunit)
		Choose Case ll_Tmp_Setting
			Case 1 
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLODE "  + string(lContentIndexKey) + " / " + lstr_component.ssnr)
				End If
			Case 0
				lds_Temp.Reset()
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content SUPPRESS "  + string(lContentIndexKey) + " / " + lstr_component.ssnr)
				End If
			Case -1
				// NO CHANGE: keep existing setting
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING "  + string(lContentIndexKey)+  + " / " + lstr_component.ssnr +"  " + String(arg_iContent))
				End If
				If ll_Original_Content = CONTENT Then
					lds_Temp.Reset()
					if il_Disable_Debug=0 Then
						guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING=CONTENT "  + lstr_component.ssnr +" lds_Temp.RowCount() " + String(lds_Temp.RowCOunt()))
					End If
				Else
					if il_Disable_Debug=0 Then
						guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING<>CONTENT "  + lstr_component.ssnr +" lds_Temp.RowCount() " + String(lds_Temp.RowCOunt()))
					End If
				End If
				
		End Choose

		
		for ll_Row = 1 to lds_Temp.RowCount()
			//ll_Explosion_Counter++
			lstr_component.stext =lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
			lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
			lstr_component.squantity = String(lds_Temp.GetItemNumber(ll_Row, "nquantity")) 
			lsText = of_get_item_description(lstr_component)

			ll_Current_Index = upperbound(astr_items) + 1
			//astr_items[ll_Current_Index].sitem = ls_Qty + lsText
			astr_items[ll_Current_Index].sitem = lsText
			
			astr_items[ll_Current_Index].cpackinglist	= lstr_component.ssnr
			astr_items[ll_Current_Index].ctext			= lstr_component.stext
			
			astr_items[ll_Current_Index].lcount = lds_Temp.GetItemNumber(ll_Row, "nquantity")
			
			// Parent merken
			astr_items[ll_Current_Index].sparent = ls_HeaderPLandText //ls_HeaderText
			
			astr_items[ll_Current_Index].sparentpl = ls_HeaderPL
			
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content CONTENT " + lstr_component.squantity + " / " + lstr_component.ssnr + " / " + lstr_component.stext)
			End If
		Next
	Next

End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content END FUNCTION" )
End If

//if il_Disable_Debug=0 Then
//	If isvalid(ods) then
//		ods.saveas("c:\temp\cbase\of_get_fixed_content_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_CART_.PSR", PSReport! , true)
//	end if
//End If

if IsValid(lds_Temp) then DESTROY lds_Temp

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

Return ll_Number_of_Contents

end function

protected function long of_draw_content_drawer (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_sunit);
/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_content_drawer (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 15.04.2009
*
* Argument(e):	long arg_llayoutdetailkey
*	 Long arg_icontent
*	 Long arg_irow
*	 Long arg_icolumn
* Return: Long
*
*
*
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
* ???			  1.0		??				Erstellung
* 15.04.2009 1.1	Ulrich Paudler	Spalte cen_packinglists_cunit nach details_cunit ge$$HEX1$$e400$$ENDHEX$$ndert
* 06.10.2009 1.2	Ulrich Paudler	Text l$$HEX1$$e400$$ENDHEX$$uft $$HEX1$$fc00$$ENDHEX$$ber den Rand hinaus
* 19.11.2009 1.3	Ulrich Paudler	Drawerfood und Traynonfood eingebaut
* 11.01.2010 1.4	Ulrich Paudler	Textweite begrenzen, Bedingte Anzeige der Artikelnummer/Text
* 18.01.2010 1.5	Ulrich Paudler	Menge 1 nicht anzeigen
* 02.02.2010 1.6	Ulrich Paudler	normalen Content fett 
* 08.02.2010 1.7	Ulrich Paudler	Textbreite und Y-Position angepasst
* 20.10.2010 1.8  Klaus F$$HEX1$$f600$$ENDHEX$$rster	Drawer $$HEX1$$fc00$$ENDHEX$$ber 3 Schienen eingebaut
* 01.10.2010 1.9  Oliver H$$HEX1$$f600$$ENDHEX$$fer   Schalter Leg Number auslesen
* 13.12.2010 2.0  Oliver H$$HEX1$$f600$$ENDHEX$$fer   Sonderfall: im Diagramm sind Contents zugeordnet, aber die Einstellung in Area Allocation lautet "Explosion"
* 23.03.2011 2.1  Oliver H$$HEX1$$f600$$ENDHEX$$fer   Content Bold
* 23.03.2011 2.2  Oliver H$$HEX1$$f600$$ENDHEX$$fer   Explode / Suppress je Inhalts-Item
* 05.12.2012 2.3  Oliver H$$HEX1$$f600$$ENDHEX$$fer   Bold / non-Bold $$HEX1$$c400$$ENDHEX$$nderungen
* 26.03.2013 2.4  Oliver H$$HEX1$$f600$$ENDHEX$$fer   Content Spec Indicator + Overflow
* 08.05.2014 2.5	Margret N$$HEX1$$fc00$$ENDHEX$$ndel	 dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*************************************************************/

String		ls_Filter, ls_Object, ls_Mod, lsText, lsHeaderText
long			ll_Row, lX1, lX2, lY1, lY2, lRowHeight, lYCounter, lPercentQuantity, lPercentUnit, lPercentText,  lWidthQuantity,  lWidthText
long			lContentIndexKey,  lContentDetailKey, llAdditionalYOffset
long			llMaxContent, llMaxContentEx
long			llTextWidth
Integer		li_Explode_Setting
Long			ll_no_of_rungs
LOng			ll_Ancestor, ll_Found
Long			ll_Temp
Integer		li_Succ
String		ls_Text, ls_DWObject
Long			ll_Row_Offset
Long			ll_Explosion_Counter
Long			ll_no_of_columns = 1
Long			ll_Content_Row 
Long			ll_Item_Counter
Long			ll_Rows
Long			ll_Expl_Header_Width
Long			ll_layout_content_key_header[]
Long			ll_index_key
Integer		li_Content_Setting
Integer		li_Suppress_Setting
Boolean		lb_Header
Long			ll_Test_Count, ll_Temp_Key
Boolean		lb_NON_FOOD = FALSE
Boolean		lb_Header_Exists = FALSE
Boolean		lb_Content_Spec_Drawer
String		ls_PL
datastore lds_Temp
s_component lstr_component

If arg_llayoutdetailkey =  90295  Then
	li_Succ = 1 
End If

this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()

this.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(arg_llayoutdetailkey))
this.dsLayoutDimension.Filter()
this.dsLayoutDimension.Sort()
ll_Temp = dsLayoutDimension.RowCount() 

if this.dsLayoutContents.RowCount() = 0 Then
	// Noch nichts zugeordnet
	return 1
End If

// Anzahl der maximalen Zeilen je nach Einschubtyp festlegen
Choose Case arg_ltype
	Case TRAYNONFOOD
		llMaxContent = iMaxRowsContentTray
		llMaxContentEx = iMaxRowsContentExplosionTray
		If ibedit Then
			llMaxContentEx += 1
		End If
		llAdditionalYOffset = 0
		lb_NON_FOOD = TRUE
		
	Case DRAWER_3RUNG
		llMaxContent = iMaxRowsContent3Rung
		llMaxContentEx = iMaxRowsContentExplosion3Rung
		llAdditionalYOffset = 50
		
	Case DRAWER
		llMaxContent = iMaxRowsContent
		llMaxContentEx = iMaxRowsContentExplosion
//		llMaxContent = of_get_maxcontent( arg_irow, arg_icolumn)
//		llMaxContentEx = of_get_maxcontent( arg_irow, arg_icolumn)
		
		llAdditionalYOffset = 0
		lb_NON_FOOD = TRUE
		
	Case Else
		llMaxContent = iMaxRowsContent
		llMaxContentEx = iMaxRowsContentExplosion
		llAdditionalYOffset = 0
		
end Choose

ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
	
	//dsLayoutContents.SetItem(a, "nheader_flag", lheader_flag )
	If dsLayoutContents.GetItemNumber(ll_Row, "nheader_flag" ) = 1 Then
		// This is a "header" for content sheet
		ll_layout_content_key_header[upperbound(ll_layout_content_key_header) + 1] = dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key")
	End If
	
Next
this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()

this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()
// -------------------------------------------------
// Alle Textobjekte l$$HEX1$$f600$$ENDHEX$$schen
// -------------------------------------------------
For ll_Row = this.dsObjects.RowCount() to 1 step -1
	ls_Object = this.dsObjects.Getitemstring(ll_Row, "cobject")
	if of_check_string(ls_Object,"t_content_" ) Then
		//19.11.2009 Ulrich Paudler [UP] Pr$$HEX1$$fc00$$ENDHEX$$fung erweitert, nicht alle Order l$$HEX1$$f600$$ENDHEX$$schen
		if  not of_check_string(ls_Object,"t_content_order_" ) Then
			this.of_unregister(ls_Object)
		End If
	End If
Next

this.dsObjects.SetFilter("" )
this.dsObjects.Filter()
this.dsObjects.Sort()

If arg_llayoutdetailkey  = 90318 Or arg_llayoutdetailkey  = 90926 Then
	li_Succ = 1
End If

// ----------------------------------------------------------
// Gibt es hier eine Header-PL?
// ----------------------------------------------------------
lb_Header_Exists = of_exists_content_sheet_header(arg_icolumn ,arg_irow )


//If arg_iContent = CONTENT Then
//	If il_Disable_Debug=0 Then
//		guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer CONTENT => EXPLOSION ")
//	End If
//End If

if il_Disable_Debug=0 Then
	choose case arg_iContent
		case DISTRIBUTION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer *** DISTRIBUTION")
		Case CONTENT
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer *** CONTENT")			
		CASE EXPLOSION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer *** EXPLOSION")			
		CASE ELSE
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer *** UNKNOWN")			
	End Choose
End If

//// ------------------------------------
//// Explode: override or keep existing
//// ------------------------------------
////li_Content_Setting = -1
li_Content_Setting = arg_iContent

If not ibedit then
	li_Content_Setting = EXPLOSION
end if

// ----------------------------------------------------------
// Alle Textobjekte neu zeichnen
// Unterscheidung Content vs. Exploded Content
// ----------------------------------------------------------
//if arg_iContent = CONTENT Then
if li_Content_Setting = CONTENT Then	
	// ----------------------------------------------------------
	// Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
	// ----------------------------------------------------------
	// 11.01.2010 Ulrich Paudler [UP]
//	if bHasDimensions Then
//		llTextWidth = TEXTWIDTH1
//	Else
//		llTextWidth = TEXTWIDTHSMALL1
//	End If

// 322 255   

	if bHasDimensions Then
		llTextWidth = lDefaultWidthSmall - 10
	Else
		llTextWidth = lDefaultWidth
	End If
	
	Choose Case arg_ltype
		Case TRAYNONFOOD
			lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 20
		Case Else
			lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
	end Choose
	lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth/2
	lRowHeight = 14
	lYCounter = 0
	
	If arg_llayoutdetailkey =  90295 OR arg_llayoutdetailkey =  90318  Then
		li_Succ = 1 
	End If
	
	For ll_Row = 1 to llMaxContent
		// 09.02.2010 Ulrich Paudler [UP]
		lY1 = lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * lYCounter) - llAdditionalYOffset
		
		ls_Object = "t_content_std_text_" + string(ll_Row, "00") + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
		// 02.02.2010 Ulrich Paudler [UP] Normalen Content gr$$HEX2$$f600df00$$ENDHEX$$er darstellen
		// ### lb_Header_Exists
		If lb_Header_Exists = FALSE AND (arg_ltype = TRAYNONFOOD OR arg_ltype = DRAWER) Then
			// ------------------------------------------------------------------
			// Typ NON FOOD und kein Header vorhanden => nothing should be bold
			// ---------------------------------------------------------- -------
			If arg_icontent = EXPLOSION AND arg_ltype = TRAYNONFOOD Then
				of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_BOLD, lX1  ,lY1 , 15 , llTextWidth , 0, 0, 0, 1)
			Else
				of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1  ,lY1 , 15 , llTextWidth , 0, 0, 0, 1)
			End If
		Else
			of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1  ,lY1 , 15 , llTextWidth , 0, 0, 0, 1)
		End If
		if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then return -1
		lYCounter ++
	Next

//Elseif arg_iContent = EXPLOSION Then
Elseif li_Content_Setting = EXPLOSION Then
	// ----------------------------------------------------------
	// Textobjekte erzeugen / positionieren
	// ----------------------------------------------------------
	
	// 11.01.2010 Ulrich Paudler [UP]
	if bHasDimensions Then
		llTextWidth = lDefaultWidthSmall - 10
	Else
		llTextWidth = lDefaultWidth
	End If

	// 322 255   

	llTextWidth = lDefaultWidth
	
	
	// ----------------------------------------------------------
	// Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
	// ----------------------------------------------------------
	lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
	lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + lDefaultWidth / 2
	lRowHeight = 14
	lYCounter = 0

	lPercentQuantity  	= 10
	lPercentText		= 95

	lWidthQuantity 		= llTextWidth * lPercentQuantity / 100
	lWidthText			= llTextWidth * lPercentText / 100

	
	ls_Object = "t_content_header_" + string(0) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
	if ibedit then
		ls_Object = "t_content_text_" + string(1) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
	end if
	
	//t_content_text_2_col_01_row_02
	//t_content_text_1_col_01_row_09
	
	of_unregister(ls_Object) //, arg_iRow, arg_icolumn)
	
	
	// 01.02.2010 Ulrich Paudler [UP]
	//If lb_Header_Exists = FALSE AND arg_icontent = EXPLOSION AND (arg_ltype = TRAYNONFOOD OR arg_ltype = DRAWER) Then
	If lb_Header_Exists = TRUE Then
		of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_BOLD, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity , 0, 0, 0, 1)
		//of_create_text(ls_Object, " ",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1 + (ll_Col_Offset * lDefaultWidth), lYOffset + ((ll_Start_Row ) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , llTextWidth , 0, 0, 0, 1)
		If il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BOLD lb_Header_Exists = FALSE AND arg_icontent = EXPLOSION AND (arg_ltype = TRAYNONFOOD OR arg_ltype = DRAWER)")
		End If
	//ElseIf lb_Header_Exists = FALSE AND arg_icontent = CONTENT AND (arg_ltype = TRAYNONFOOD OR arg_ltype = DRAWER) Then
	ElseIf lb_Header_Exists = FALSE AND (arg_ltype = TRAYNONFOOD OR arg_ltype = DRAWER) Then
		// ------------------------------------------------------------------
		// Typ NON FOOD und kein Header vorhanden => nothing should be bold
		// ------------------------------------------------------------------
		If il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer NOT BOLD lb_Header_Exists = FALSE AND arg_icontent = CONTENT AND (arg_ltype = TRAYNONFOOD OR arg_ltype = DRAWER)")
		End If
		if arg_iContent = EXPLOSION then
			//of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_BOLD, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity , 0, 0, 255, 1)
			//lWidthText + lWidthQuantity
			of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_BOLD, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity , 0, 0, 0, 1)
		Else
			//of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity , 0, 0, 255, 1)
			of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity , 0, 0, 0, 1)
		End If
	Else
		If il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer NOT BOLD ")
		End If
		of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity , 0, 0, 0, 1)
		//of_create_text(ls_Object, "...",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lYOffset + ((arg_iRow - 1) *  lDefaultHeight) + 2 + (lRowHeight * (lYCounter)) - llAdditionalYOffset, 15 , lWidthText + lWidthQuantity , 0, 0, 255, 1)
	End if
	
	if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then return -1

	// ------------------------------------------------------------------
	// Alle Objekte Font Size 8  - auch Header
	// ------------------------------------------------------------------
	of_modify_dw( ls_Object + '.font.height="-8"')

	lYCounter ++
	// 06.10.2009 Ulrich Paudler [UP] Text l$$HEX1$$e400$$ENDHEX$$uft $$HEX1$$fc00$$ENDHEX$$ber den Rand hinaus (da 5% f$$HEX1$$fc00$$ENDHEX$$r das einger$$HEX1$$fc00$$ENDHEX$$ckte draufgehen!)
	lPercentText		= 85
	lWidthText			= llTextWidth * lPercentText / 100
	
	For ll_Row = 1 to llMaxContentEx
		
		lY1 = lYOffset + ((arg_iRow - 1) *  lDefaultHeight)+ 2 + (lRowHeight * lYCounter) - llAdditionalYOffset
		
		// Mengenfeld
		ls_Object = "t_content_quantity_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")

		// ##################### JASPER
		If ibedit Then
			ls_Object = "t_content_quantity_" + string(ll_Row + 1) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
		End If		
		
		of_create_text(ls_Object, "",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1, lY1, 15 ,lWidthQuantity, 0, ALIGN_LEFT , 0, 1)
		if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then return -1		
		// Textfeld
		ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
		// ##################### JASPER
		If ibedit Then
			ls_Object = "t_content_text_" + string(ll_Row + 1) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
		End If	
		
		of_create_text(ls_Object, "",FONT_MS_SANS_SERIF, 8, FONT_NORMAL, lX1 + lWidthQuantity + 1 , lY1, 15, lWidthText , 0, 0,  0, 1)
		if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then return -1
		lYCounter ++
	Next

	
Else
	sError = "Error: undefined content"
	return -1
End If

// -------------------------------------------------
// Erstmal alle Texte wieder resetten
// -------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()

For ll_Row = 1 to this.dsObjects.RowCount()
	ls_Object = this.dsObjects.GetItemstring(ll_Row, "cobject")
	if of_check_string(ls_Object,"t_content_" ) Then
		// 12.01.2010 Ulrich Paudler [UP]
		of_modify_text( ls_Object , "")
	End If
Next

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

// ----------------------------------------------------------
// Texte neu eintragen
// Unterscheidung Content vs. Exploded Content
// ----------------------------------------------------------
if dsPLContents.RowCount() < 1 Then
	// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden
//Elseif arg_iContent = CONTENT Then // Content Layout
Elseif li_Content_Setting = CONTENT Then // Content Layout	
	// -------------------------------------------------
	// Dann die Texte alle nochmal eintragen
	// -------------------------------------------------
		
	//this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
	li_Succ = this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_') and not Match(cobject, 't_content_order_')" )
	this.dsObjects.Filter()
	this.dsObjects.Sort()

	//For i = 1 to this.dsObjects.RowCount()
	For ll_Row = 1 to this.dsPLContents.RowCount()
				
//		for ll_Index = 1 to upperbound(lstr_item) 
//			If trim(lstr_item[ll_Index].cpackinglist) > "" Then
//				
//				If ll_Index > 1 then
//					continue
//				end if
		If ll_Row = 1 Then
			ls_PL = dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
			ll_index_key = f_get_packinglist_key(ls_PL)
			lb_Content_Spec_Drawer = of_is_content_spec_enabled(ll_index_key , is_CSC, idt_departure )
			//guoLog.uf_debug( "["+ this.classname( )+".")
		End if		
				
		If ll_Row_Offset + ll_Row > this.dsObjects.RowCount() Then
			// Voll
			Continue
		End If
				
		// 01.02.2010 Ulrich Paudler [UP]
		if ll_Row > this.dsObjects.RowCount() Then
			// sError = "Error: too many contents"
			// return -1
			continue
		Else
			//ls_Object = this.dsObjects.GetItemstring(ll_Row, "cobject")
			ls_Object = this.dsObjects.GetItemstring(ll_Row_Offset + ll_Row, "cobject")
		End If

		// -------------------------------------
		// Header?
		// -------------------------------------
		lb_Header = FALSE
		ll_Temp_Key = dsPLContents.GetItemNumber(ll_Row, "nlayout_content_key")
		For ll_Test_Count = 1 To upperbound(ll_layout_content_key_header)
			If ll_Temp_Key = ll_layout_content_key_header[ll_Test_Count] Then
				lb_Header = TRUE		
			End If
		Next
		If lb_header Then
			of_modify_dw(ls_Object + '.font.weight="'+String(FONT_BOLD)+'"')
	
			If il_Disable_Debug=0 Then
				//guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer HEADER FLAG " + dsPLContents.GetItemString(ll_Row, "cen_packinglists_ctext"))
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer HEADER FLAG " + dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist"))
				//of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,255)) + "'" )
			Else
				of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,0)) + "'" )
			End If
//			If ibEdit Then
//				of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,255)) + "'" )
//			Else
				of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,0)) + "'" )
//			End If
		End If

		lstr_component.stext 		= this.dsPLContents.GetItemString(ll_Row, "cen_packinglists_ctext")
		lstr_component.ssnr 			= this.dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
		//                                                                    cen_packinglist_index_cpackinglist
		// ------------------------------------------------------------------------------------------------------------
		// 01.10.2010 Downline Watermark
		//  Downline Watermark an einem Drawer, der Teil einer Packing List ist: Dies wird im Content der Packing List 
		// in der Spalte "Leg" gepflegt (Leg-Nummer >1)	
		// ------------------------------------------------------------------------------------------------------------
		ii_PL_Leg_Number			= this.dsPLContents.GetItemNumber(ll_Row, "nleg_number")
		If IsnULL(ii_PL_Leg_Number) Then ii_PL_Leg_Number = 0
		// 10.02.2010 Ulrich Paudler [UP]
		//if this.dsPLContents.GetItemNumber(ll_Row, "nquantity") > 0.0  and   this.dsPLContents.GetItemNumber(ll_Row, "nquantity") <> 1.0 Then
		if this.dsPLContents.GetItemNumber(ll_Row, "nquantity") > 0.0 Then
			if this.dsPLContents.GetItemNumber(ll_Row, "nquantity") <> 1 OR ib_suppress_qty_1 = FALSE Then
				lstr_component.squantity	= string( this.dsPLContents.GetItemNumber(ll_Row, "nquantity"))
			Else
				lstr_component.squantity	= ""
			End If
		Else
			lstr_component.squantity	= ""
		End If

		if ll_Row >= llMaxContent and dsPLContents.RowCount() > llMaxContent Then
			if ll_Row = llMaxContent Then
				if of_is_backlog_enabled() Then
					If lb_Content_Spec_Drawer Then
						of_modify_text( ls_Object, is_Overflow_MSG_3) // see cs and overflow
						guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr + " " + is_Overflow_MSG_3)
					Else
						of_modify_text( ls_Object, is_Overflow_MSG_2)
						guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr + " " + is_Overflow_MSG_2)
					End if
					
					lsText =  of_get_item_description(lstr_component)

					If ib_Enable_Meal_Distribution = FALSE Then
						of_draw_content_backlog_tray(ll_Row,  arg_iRow, arg_icolumn, lsText, of_get_type(arg_iRow, arg_icolumn) )
					End If
						
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer => BACKLOG " + lsText)					
				End If
				// ----------------------------------------------------------------------------------------------------
				// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
				// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
				//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
				//							 should appear automatically and a Content spec should be generated
				// ----------------------------------------------------------------------------------------------------
				If ib_non_sky then
					of_modify_text(ls_Object, is_Overflow_MSG_1)
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer non sky BACKLOG => CONTENT SPEC " + lstr_component.ssnr + " /" + lsText) 
					// add content spec ###########					
				End If
				
			Else
				lsText =  of_get_item_description(lstr_component)
				
				If ib_Enable_Meal_Distribution = FALSE Then
					of_draw_content_backlog_tray(ll_Row, arg_iRow, arg_icolumn, lsText, of_get_type(arg_iRow, arg_icolumn))
				End If
					
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer => BACKLOG " + lsText)
			End If
			
			// ########### BACKLOG bei MZV OFF
			if ib_Enable_Meal_Distribution = FALSE Then
				//li_Succ = of_sd_add_backlog( arg_iRow, arg_icolumn, ls_Object, Integer(lstr_component.squantity), arg_sunit  , lsText,1, arg_ltype ,  lstr_component.ssnr, il_master_row  )
			End If
			
		Else
			//If ll_Row = 1 AND this.dsPLContents.GetItemNumber(ll_Row, "nquantity") = 1  Then
			If this.dsPLContents.GetItemNumber(ll_Row, "nquantity") = 1  Then
				lsText =  of_get_item_description(lstr_component, TRUE)
			Else
				lsText =  of_get_item_description(lstr_component)
			End If	
			
			of_modify_text( ls_Object, lsText)
		End If
	Next
	
	this.dsObjects.SetFilter("")
	this.dsObjects.Filter()
	this.dsObjects.Sort()
	
	
//Elseif arg_iContent = EXPLOSION Then // Explosion Layout
Elseif li_Content_Setting = EXPLOSION Then // Explosion Layout
	//	if dsPLContents.RowCount() > 0 Then
	
	// -------------------------------------------------
	// EXPLOSION
	// -------------------------------------------------
	
	lds_Temp = create datastore
	lds_Temp.dataobject = "dw_packinglist_edit_content"
	lds_Temp.SetTransObject(sqlca)
	
	ll_Item_Counter = 0
	For ll_Content_Row = 1 To dsPLContents.RowCount()

		lContentIndexKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
		lContentDetailKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")
	
	
		If ll_Content_Row = 1 Then
			//ls_PL = dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
			ll_index_key = lContentIndexKey //f_get_packinglist_key(ls_PL)
			lb_Content_Spec_Drawer = of_is_content_spec_enabled(ll_index_key , is_CSC, idt_departure )
			//guoLog.uf_debug( "["+ this.classname( )+".")
		End if		
	
	
		ll_Rows = lds_Temp.Retrieve(lContentIndexKey, lContentDetailKey, datetime(idt_Departure), 0)
		
		If NOT ibEdit Then
			li_Suppress_Setting = of_get_explosion_setting(lContentIndexKey, arg_sunit)
			Choose Case li_Suppress_Setting
			Case 1
				if il_Disable_Debug= 0 then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer EXPLODE " + string(lContentIndexKey) )			
				End If
			Case 0
				// Nicht Explosion
				lds_Temp.Reset()
				if il_Disable_Debug= 0 then
					guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer NICHT EXPLOSION " + string(lContentIndexKey) )			
				End If
			Case -1
				If arg_icontent <> EXPLOSION Then
					lds_Temp.Reset()
				End If
			End Choose			
		End If
		
		lds_Temp.SetSort("nsort a")
		lds_Temp.Sort()
	
		ls_Object = "t_content_header_" + string(0) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")				
		// ##################### JASPER
		If ibedit Then
			ls_Object = "t_content_text_" + string(1) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
			ll_Item_Counter++
		End If	
	
		if NOT lb_Header_Exists Then
			If arg_icontent = EXPLOSION Then
				of_modify_dw(ls_Object + '.font.weight="'+String(FONT_BOLD)+'"')
			Else
				of_modify_dw(ls_Object + '.font.weight="'+String(FONT_NORMAL)+'"')
			End If
			
		End If
	
		// ------------------------------------------------------------------------------------------------------------
		// wenn mehrere PL exploded werden, dann wird header 2, 3, ... als Content eingetragen und umformatiert
		// ------------------------------------------------------------------------------------------------------------
		If ll_Content_Row > 1 Then
			ll_Item_Counter++
			ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
		End If
		
		// Header eintragen
		// 11.01.2010 Ulrich Paudler [UP]
		lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
		lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
		
		// -------------------------------------
		// Header?
		// -------------------------------------
		lb_Header = FALSE
		ll_Temp_Key = dsPLContents.GetItemNumber(ll_Content_Row, "nlayout_content_key")
		For ll_Test_Count = 1 To upperbound(ll_layout_content_key_header)
			If ll_Temp_Key = ll_layout_content_key_header[ll_Test_Count] Then
				lb_Header = TRUE		
			End If
		Next
		If lb_header Then
			of_modify_dw(ls_Object + '.font.weight="' + String(FONT_BOLD) + '"')
			If il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer HEADER FLAG " + dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext"))
			End If
//			If ibEdit Then
//				of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,255)) + "'" )
//			Else
				of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,0)) + "'" )
//			End If
		End If
		
//		//If lb_header = FALSE AND arg_icontent = EXPLOSION  Then
//		If lb_header = FALSE  Then
//			If arg_icontent = EXPLOSION Then
//				of_modify_dw(ls_Object + '.font.weight="' + String(FONT_BOLD) + '"')
//				If il_Disable_Debug=0 Then
//					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer NO HEADER FLAG AND arg_icontent = EXPLOSION BOLD " + dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext"))
//				End If			
//			End If
//		End If
		
		// ------------------------------------------------------------------------------------------------------------
		// 01.10.2010 Downline Watermark
		//  Downline Watermark an einem Drawer, der teil einer Packing List ist: Dies wird im Content der Packing List 
		// in der Spalte "Leg" gepflegt (Leg-Nummer >1)	
		// ------------------------------------------------------------------------------------------------------------
		ii_PL_Leg_Number			= this.dsPLContents.GetItemNumber(ll_Content_Row, "nleg_number")
		If IsnULL(ii_PL_Leg_Number) Then ii_PL_Leg_Number = 0
	
		// ------------------------------------------------------------------------------------------------------------	
		// 30.03.2011, KF: Menge war immer blank!?!?!?
		// ------------------------------------------------------------------------------------------------------------
		// lstr_component.squantity	= ""
		// ------------------------------------------------------------------------------------------------------------
		//if this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity") > 0.0  and   this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity") <> 1.0 Then
		if this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity") > 0.0 Then
			lstr_component.squantity	= string( this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity"))
			If il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer QUANTITY HINZU " + lstr_component.ssnr )
			End If
		Else
			lstr_component.squantity	= ""
		End If
		
		lsHeaderText =  of_get_item_description(lstr_component, TRUE)

		// 12.01.2010 Ulrich Paudler [UP]
		of_modify_text(ls_Object, lsHeaderText)
		of_modify_dw(ls_Object + '.font.height="-8"')
		
		// ------------------------------------------------------------------------------------------------------------
		// wenn mehrere PL exploded werden, dann wird Header Nummer 2, 3,... als Content eingetragen und umformatiert
		// ------------------------------------------------------------------------------------------------------------
		If ll_Content_Row > 1 Then
			If lb_header = FALSE Then // Never BOLD
				//of_modify_dw(ls_Object + '.font.weight="700"')
				of_modify_dw(ls_Object + '.font.weight="400"')
			End If
			
			If il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer EXPLODE & BOLD " + lsHeaderText)
			End If
			of_modify_dw(ls_Object + '.x="' + String(lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14) +  '"')
			ll_Expl_Header_Width = Integer(llTextWidth * .95 ) + lWidthQuantity 
			of_modify_dw(ls_Object + '.width="' + String(ll_Expl_Header_Width) + '"')
			
		End If
		
		// ------------------------------------------------------------------------------------------------------------
		// wenn f$$HEX1$$fc00$$ENDHEX$$r die St$$HEX1$$fc00$$ENDHEX$$ckliste in Area Allocation "suppress" eingestellt ist: keine Inhalte zeigen
		// ------------------------------------------------------------------------------------------------------------
		If of_explode( lContentIndexKey, arg_sunit, li_Explode_Setting, arg_icontent ) = FALSE Then
				If il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer SUPPRESS " + lstr_component.ssnr)
				End If
			CONTINUE
		Else
			If arg_icontent = content Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer Parent = CONTENT => EXPLODE " + lstr_component.ssnr)
			End If
		End If
		
		// ------------------------------------
		// Details eintragen
		// ------------------------------------
		for ll_Row = 1 to lds_Temp.RowCount()
			ll_Item_Counter++
			// Mehr als angezeigt werden kann
			if ll_Item_Counter >= llMaxContentEx and lds_Temp.RowCount() > llMaxContentEx Then
				if ll_Item_Counter = llMaxContentEx Then	
					
					if of_is_backlog_enabled() Then
						// Text eintragen ..						
						ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
						If ll_Content_Row > 1 Then
							ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
						End If	
						
						If ibedit Then
							ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
						End If
						
						// 12.01.2010 Ulrich Paudler [UP]
						If lb_Content_Spec_Drawer Then
							of_modify_text( ls_Object, is_Overflow_MSG_3) // see cs and overflow
							guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr + " " + is_Overflow_MSG_3)
						Else
							of_modify_text( ls_Object, is_Overflow_MSG_2)
							guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr + " " + is_Overflow_MSG_2)
						End if
						
						If il_Disable_Debug=0 Then
							guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr)
						End If
					Else
						// Menge eintragen ..
						ls_Object = "t_content_quantity_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
						if ibedit Then
							ls_Object = "t_content_quantity_" + string(ll_Item_Counter ) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
						end if					
						
						// 18.01.2010 Ulrich Paudler [UP] nur mengen <> 1 anzeigen
						//if lds_Temp.GetItemNumber(ll_Row, "nquantity") <> 1.0 Then
						if lds_Temp.GetItemNumber(ll_Row, "nquantity") > 0 Then	
							If lds_Temp.GetItemNumber(ll_Row, "nquantity") <> 1 OR ib_suppress_qty_1 = FALSE Then
								of_modify_text(ls_Object, string(lds_Temp.GetItemNumber(ll_Row, "nquantity")) + " x ")
							Else
								of_modify_text(ls_Object, "")
							End If
						Else
							of_modify_text(ls_Object, "")
						End If
	
						// Text eintragen ..
						// 13.01.2010 Ulrich Paudler [UP]						
						ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
						
						if ibedit Then
							ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
						end if
						//ls_Mod = ls_Object + ".text='" + lds_Temp.GetItemString(ll_Row, "cpackinglist_text") + "'"
						lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
						lstr_component.ssnr  = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
						lstr_component.squantity	= ""
//						// nquantity ????######
//						if not ibedit then
//							if lds_Temp.GetItemNumber(ll_Row, "nquantity") <> 1.0 Then
//								lstr_component.squantity = String(lds_Temp.GetItemNumber(ll_Row, "nquantity"))
//							End if
//						end if
						lsText =  of_get_item_description(lstr_component)
						// 12.01.2010 Ulrich Paudler [UP]
						of_modify_text(ls_Object, lsText)
					End If
					
					// ----------------------------------------------------------------------------------------------------
					// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
					// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
					//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
					//							 should appear automatically and a Content spec should be generated
					// ----------------------------------------------------------------------------------------------------
					If ib_non_sky then
						of_modify_text(ls_Object, is_Overflow_MSG_1)
						guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer non sky BACKLOG => CONTENT SPEC " + lstr_component.ssnr + " /" + lsText) 
						// add content spec ###########					
					End If
					
					
				End If
	
				// 02.09.2009 Ulrich Paudler [UP] Backlog eintragen
				
				// ########### 19.12.2012 TEST ###################
				If ib_Enable_Meal_Distribution = FALSE Then
					of_draw_content_backlog_drawer(ll_Row, arg_iRow, arg_icolumn, lds_Temp, arg_ltype, lsHeaderText)
				End If
				
				// ########### BACKLOG bei MZV OFF
				if ib_Enable_Meal_Distribution = FALSE Then
					//li_Succ = of_sd_add_backlog( arg_iRow, arg_icolumn, ls_Object, lds_Temp.GetItemNumber(ll_Row, "nquantity"), arg_sunit  , lsText,1, arg_ltype ,  lstr_component.ssnr, il_master_row  )
					//li_Succ = of_sd_add_content_backlog_drawer(ll_Row , al_Row, arg_icolumn, lds_Temp,  DRAWER , lsHeaderText, al_content_master_row_id )		
					//guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components BACKLOG " + lsHeaderText + " / " + lsText )

				End If				
				
			Else
				// --------------------------------------------------
				// Normalfall: Menge / Text  eintragen
				// --------------------------------------------------
	
				// Menge eintragen ..
				ls_Object = "t_content_quantity_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
				If ll_Content_Row > 1 Then
					ls_Object = "t_content_quantity_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
				End If		
				If ibedit Then
					ls_Object = "t_content_quantity_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
				End If	
				
				// 18.01.2010 Ulrich Paudler [UP]
				//if lds_Temp.GetItemNumber(ll_Row, "nquantity") <> 1.0 Then
				if lds_Temp.GetItemNumber(ll_Row, "nquantity") > 0 Then
					If lds_Temp.GetItemNumber(ll_Row, "nquantity") <> 1 OR ib_suppress_qty_1 = FALSE Then
						of_modify_text(ls_Object, string(lds_Temp.GetItemNumber(ll_Row, "nquantity")) + " x ")
					Else
						of_modify_text(ls_Object, "")
					End If
				Else
					of_modify_text(ls_Object, "")
				End If			
				ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
				If ll_Content_Row > 1 Then
					ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
				End If
				If ibedit Then
					ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")				
				end if
				lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
				lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
				lstr_component.squantity = ""
				lsText =  of_get_item_description(lstr_component)
				// 12.01.2010 Ulrich Paudler [UP]
				of_modify_text(ls_Object, lsText)
			End If
		Next
	
	Next
	
End If

if IsValid(lds_Temp) Then DESTROY lds_Temp

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

return 0
end function

public function long of_draw_content_backlog_tray (long arg_l_counter, long arg_i_row, long arg_i_column, string arg_s_text, long arg_l_type, decimal arg_dec_qty);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_content_backlog_tray (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 02.09.2009
* Argument(e):
* long arg_l_counter
*  Long arg_i_row
*  Long arg_i_column
*  string arg_s_text
*  Long	arg_l_type
*
* Return: Long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  02.09.2009	1.0           Ulrich Paudler     Erstellung
*
*************************************************************/
String ls_DWObject

ls_DWObject = "t_content_backlog_tray_text_" + string(arg_l_counter) + "_col_" + string(arg_i_column, "00") + "_row_" + string(arg_i_Row, "00")
if of_register(ls_DWObject, arg_i_row, arg_i_column) = -1 Then
	//return -1
End if

of_add_backlog( arg_i_row, arg_i_column, ls_DWObject, arg_dec_qty ,"", arg_s_text, arg_l_counter, arg_l_type,"")

// ----------------------------------------------------------------------------------------------------
// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
//							 should appear automatically and a Content spec should be generated
// ----------------------------------------------------------------------------------------------------
If ib_non_sky then
	of_modify_text(ls_DWObject, is_Overflow_MSG_1)
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_backlog_tray non sky BACKLOG => CONTENT SPEC " + arg_s_text) 
	//lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
	// add content spec ###########					
End If


return 1
end function

public function long of_print_prepare (string arg_s_printer, string arg_s_airline, long arg_l_flightnumber, string arg_s_suffix, string arg_s_header, string arg_s_from, string arg_s_to, string arg_s_actype, string arg_s_stowage, long arg_l_page, long arg_l_belly, date arg_d_departure, string arg_s_time, string arg_s_class, string arg_s_container, string arg_s_owner, string arg_s_version, string arg_s_area, string arg_s_workstation, string arg_s_loadinglist, long arg_l_leg);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_print_prepare (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 29.10.2009
* Argument(e):
* string arg_s_printer
*  string arg_s_airline
*  long arg_l_flightnumber
*  string arg_s_suffix
*  string arg_s_header
*  string arg_s_from
*  string arg_s_to
*  string arg_s_actype
*  string arg_s_stowage
*  long arg_l_page
*  long arg_l_belly
*  date arg_d_departure
*  string arg_s_time
*  string arg_s_class
*  string arg_s_container
*  string arg_s_owner
*  string arg_s_version
*
* Return: long
*
*
* Headerdaten in das DW einsetzen
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  29.10.2009	1.0           Ulrich Paudler     Erstellung
*  13.01.2010	1.1           Ulrich Paudler     Erweiterung area, workstation und loadinglist
*  19.01.2012	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Result Key Ermittlung: Suffix fehlte
*
*************************************************************/

of_modify_dw("datawindow.printer='" +arg_s_printer+ "'")
of_modify_dw("datawindow.print.documentname = 'CartdiagramSheet_"  +  arg_s_airline + "_" + String(arg_l_Flightnumber, "000") + "_" + arg_s_suffix + "'")
of_modify_dw("t_title.text='"  +  arg_s_header + "'")
of_modify_dw("t_flight.text='" +  arg_s_airline + " " + string(arg_l_Flightnumber,"000") + arg_s_suffix + "'")
of_modify_dw("t_from.text='" + arg_s_from + "'")
of_modify_dw("t_to.text ='" + arg_s_to + "'")
of_modify_dw("t_aircraft_type.text='" +  arg_s_actype + "'")
of_modify_dw("t_stowage.text='" + arg_s_stowage + "'")
of_modify_dw("t_page.text='" + String(arg_l_page)+  "'")
if arg_l_belly > 0 Then
	of_modify_dw("t_belly.text='Belly'")
Else
	of_modify_dw("t_belly.text=''")
End If
of_modify_dw("t_day.text='" + String(arg_d_departure,"DD") + "'")
of_modify_dw("t_time.text='" + arg_s_time + "'")
of_modify_dw("t_class.text='" +  arg_s_class + "'")
of_modify_dw("t_container.text='" + arg_s_container+  "'")
of_modify_dw("t_aircraft.text='" + arg_s_owner + " " + arg_s_actype + " [" + arg_s_version + "]" + "'")
//of_modify_dw("t_signature.text='" + s_app.sOrga +"'")
//of_modify_dw("t_printed.text ='" +string(today(),s_app.sDateformat) + "  " + string(now(),"HH:MM") + "'")

// 13.01.2010 Ulrich Paudler [UP]
of_modify_dw("t_workstation.text ='" +arg_s_area + " - " + arg_s_workstation + "'")
of_modify_dw("t_loadinglist.text ='" +arg_s_loadinglist + "'")


// Result_key ermitteln
SELECT	nresult_key  
INTO		:il_Result_Key  
FROM		cen_out  
WHERE		cairline = :arg_s_airline
AND		nflight_number = :arg_l_flightnumber 
AND		nleg_number	= :arg_l_leg
AND		csuffix = :arg_s_suffix
AND		trunc(ddeparture) = :arg_d_departure
AND		ctlc_from	= :arg_s_from
AND       cunit = :is_CSC;
// 13.07.2023 HR: issue #8370 Multi Unit Flight - Wrong Flight Data on Cart Diagram (Add Cunit in the SQL to get the right flight)
guoLog.uf_debug( "["+ this.classname( )+".of_print_prepare] SQL Result: sqlnrows=" + string(sqlca.sqlnrows) +" slqcode=" + string(sqlca.sqlcode))

return 0

end function

public function integer of_fill_component_list (ref uo_distribution rauodistribution, ref s_component rastr_component[], string arg_s_stowage, string arg_s_pl, long arg_l_lbelly);/*
* Objekt : uo_cart_diagram
* Methode: of_fill_component_list (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 29.04.2011
*
* Argument(e):
* ref uo_distribution rauodistribution
*	 ref s_component rastr_component[]
*	 string arg_s_stowage
*	 string arg_s_pl
*	 long arg_l_lbelly
*
* Beschreibung:		aus Distribution ausgelagert 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	29.04.2011		Erstellung
* 1.1 			O.Hoefer	08.02.2012		CBASE-NAM-CR-12011 Combine Entries with the Same Text 
* 1.2 			O.Hoefer	09.02.2012		CBASE-NAM-CR-12011 Sort by item list number, class and leg
* 1.3 			O.Hoefer	24.03.2020		#4984 Adjust sorting of item lists on cart diagram
*
*
* Return: integer
*
*/

Long		llIndexComponent, llRowContent, llIndex
String	ls_temp
Boolean	lb_breakpoint
Boolean	lb_Sort_by_PL_Class_Leg = FALSE
Boolean	lb_Sort_by_Class_Desc_Leg = FALSE
Boolean	lb_Consolidate_Entries  = FALSE
Integer	li_Succ
String	ls_Temp_PL
String	ls_Temp_Text
Long		ll_Temp_Qty
Long		ll_Temp_Counter
Boolean	lb_Found_Double_Entry
String	ls_Original_Sort
Long		ll_Disable_2nd_Distr
Long		ll_pltype_key, ll_pl_distribution_key
String	ls_pl_type, ls_meal_control_code
String	ls_Find
Long		ll_Found
string	sValue, ssection, sDefault
integer	iconfig
String	ls_Sort_by_Class_Desc_Leg


// ### Profile

If NOT Isvalid(rauoDistribution) Then
	guoLog.uf_debug( "["+ this.classname( )+".of_fill_component_list] Stowage " + arg_s_Stowage + " PL: " + rastr_component[llIndexComponent].ssnr + " rauoDistribution not valid ")
	Return -1
End If

// ----------------------------------------------------------------------
// bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 1 then
		lb_Sort_by_PL_Class_Leg = TRUE
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_PL_Class_Leg = FALSE
	end if
	
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 2 then
		lb_Sort_by_Class_Desc_Leg = TRUE
		lb_Sort_by_PL_Class_Leg = FALSE 
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_Class_Desc_Leg = FALSE
	end if
	
Else
	
	If is_section > "" Then
		sSection = is_section
	Else
		sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(sSection) = "" Then sSection = "docbrowser"
	End if
	
	if sSection <> "docbrowser" Then
		iConfig = integer(Mid(sSection,11))
		sDefault ="Default" +string(iConfig)
	Else
		sDefault ="Default"
	End If
	
	sValue = of_profilestring(s_app.suser,sDefault,"CartDiagramCompSort","0") 
	If sValue = "1" Then
		lb_Sort_by_PL_Class_Leg = TRUE
		sValue = of_profilestring(s_app.suser,sDefault,"CartDiagramCompDistinct","0") 
		If sValue = "1" Then
			lb_Consolidate_Entries = TRUE
		End if
	End if
	// #4984 Adjust sorting of item lists on cart diagram
	If sValue = "2" Then
		lb_Sort_by_PL_Class_Leg = FALSE
		lb_Sort_by_Class_Desc_Leg = TRUE
		sValue = of_profilestring(s_app.suser,sDefault,"CartDiagramCompDistinct","0") 
		If sValue = "1" Then
			lb_Consolidate_Entries = TRUE
		End if
	End if
	
	
End if

// Liste der Komponenten f$$HEX1$$fc00$$ENDHEX$$llen
llIndexComponent = 0
For llIndex = 1 to upperbound(rauoDistribution.uoStowages)

	If NOT Isvalid(rauoDistribution) then
      guoLog.uf_error( "["+ this.classname( )+".of_fill_component_list] INVALID rauoDistribution " + arg_s_pl)
      EXIT
   End If
   If  upperbound(rauoDistribution.uoStowages) < 1 Then
      guoLog.uf_error( "["+ this.classname( )+".of_fill_component_list] INVALID upperbound(rauoDistribution.uoStowages)  " + arg_s_pl )
      EXIT
   End If
   If not isvalid(rauoDistribution.uoStowages[llIndex]) Then
      guoLog.uf_error( "["+ this.classname( )+".of_fill_component_list] INVALID rauoDistribution.uoStowages["+String(llIndex)+"] " + arg_s_pl)
      EXIT
   End If
   
	If trim(rauoDistribution.uoStowages[llIndex].sStowage) = arg_s_Stowage & 
			and rauoDistribution.uoStowages[llIndex].sPackinglist = arg_s_PL  & 
			and rauoDistribution.uoStowages[llIndex].lBelly = arg_l_lBelly Then
			
		If lb_Sort_by_PL_Class_Leg Then	
			ls_Original_Sort = rauoDistribution.uoStowages[llIndex].dsContent.Describe("DataWindow.Table.Sort")
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.SetSort("cpackinglist A, nclass_number A, cmeal_control_code A")
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.Sort()
		end if
		
		If lb_Sort_by_Class_Desc_Leg Then
			ls_Sort_by_Class_Desc_Leg = "nclass_number A, ctext A, cmeal_control_code A"
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.SetSort(ls_Sort_by_Class_Desc_Leg)
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.Sort()
		end if
		
		
//		if il_Disable_Debug = 0 Then	
//			rauoDistribution.uoStowages[llIndex].dsContent.saveas("c:\temp\cbase\dscontent_"+string(cpu())+".xls",excel5!,true)	
//		End if
		
		For llRowContent= 1 to rauoDistribution.uoStowages[llIndex].dsContent.Rowcount()
						
			llIndexComponent++
			
			rastr_component[llIndexComponent].stext = rauoDistribution.uoStowages[llIndex].dsContent.getitemstring(llRowContent,"ctext")
			rastr_component[llIndexComponent].ssnr = rauoDistribution.uoStowages[llIndex].dsContent.getitemstring(llRowContent,"cpackinglist")
			
			If rastr_component[llIndexComponent].ssnr = "CVXFB2373" then //"FVS11C009" Then
				lb_Breakpoint=TRUE		
			End If
			rastr_component[llIndexComponent].lquantity = rauoDistribution.uoStowages[llIndex].dsContent.getitemnumber(llRowContent,"nquantity")
			rastr_component[llIndexComponent].squantity = ""
			rastr_component[llIndexComponent].llength = rauoDistribution.uoStowages[llIndex].dsContent.getitemnumber(llRowContent,"nwidth")
			rastr_component[llIndexComponent].str_item_props.stext = rauoDistribution.uoStowages[llIndex].dsContent.getitemstring(llRowContent,"cpl_type")
			rastr_component[llIndexComponent].str_item_props.smeal_control_code = rauoDistribution.uoStowages[llIndex].dsContent.getitemstring(llRowContent,"cmeal_control_code")
			rastr_component[llIndexComponent].str_item_props.sclass = rauoDistribution.uoStowages[llIndex].dsContent.getitemstring(llRowContent,"cclass")
			rastr_component[llIndexComponent].str_item_props.lspml = rauoDistribution.uoStowages[llIndex].dsContent.getitemnumber(llRowContent,"nspml")
			rastr_component[llIndexComponent].str_item_props.llimit = 0

			// ---------------------------------------------------------------------
			// Switch Off Secondary Distr. CBASE-CR-NAM-12050
			// ---------------------------------------------------------------------
			ll_pltype_key				= rauoDistribution.uoStowages[llIndex].dsContent.getitemnumber(llRowContent,"npltype_key")
			ll_pl_distribution_key	= rauoDistribution.uoStowages[llIndex].dsContent.getitemnumber(llRowContent,"npl_distribution_key")
			ls_pl_type					= rauoDistribution.uoStowages[llIndex].dsContent.getitemstring(llRowContent,"cpl_type")
			ls_meal_control_code		= rauoDistribution.uoStowages[llIndex].dsContent.getitemstring(llRowContent,"cmeal_control_code")
			ls_Find  = "npltype_key=" + String(ll_pltype_key) +  " AND "
			ls_Find += "npl_distribution_key=" + String(ll_pl_distribution_key)+  " AND "
			ls_Find += "ctext='" + ls_pl_type+  "' AND "
			ls_Find += "cmeal_control_code='" + ls_meal_control_code+  "'"
			ll_Found = rauoDistribution.uoStowages[llIndex].dsPackinglistSize.Find(ls_Find, 1, rauoDistribution.uoStowages[llIndex].dsPackinglistSize.RowCOunt())
			If ll_Found > 0 then
				ll_Disable_2nd_Distr =  rauoDistribution.uoStowages[llIndex].dsPackinglistSize.getitemnumber(ll_Found,"ndisable_2nd_distribution")
				If isnull(ll_Disable_2nd_Distr) then ll_Disable_2nd_Distr = 0 
			End If
//			rauoDistribution.uoStowages[llIndex].dsContent.saveas("c:\temp\cbase\distr_content_"+string(cpu())+".xls", excel5!,true)
//			rauoDistribution.uoStowages[llIndex].dsPackinglistSize.saveas("c:\temp\cbase\distr_sizes_"+string(cpu())+".xls", excel5!,true)			
			rastr_component[llIndexComponent].str_item_props.ldontdistribute = ll_Disable_2nd_Distr 
			
			If ll_Disable_2nd_Distr = 1 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_fill_component_list] Stowage " + arg_s_Stowage + " PL: " + rastr_component[llIndexComponent].ssnr + " ndisable_2nd_distribution = 1 " )
			End If						
		Next
		
		If lb_Sort_by_PL_Class_Leg Then	
			//ls_Original_Sort = rauoDistribution.uoStowages[llIndex].dsContent.Describe("DataWindow.Table.Sort")
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.SetSort(ls_Original_Sort)
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.Sort()
		end if
		If lb_Sort_by_Class_Desc_Leg Then
			//ls_Sort_by_Class_Desc_Leg = "nclass_number A, ctext A, cmeal_control_code A"
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.SetSort(ls_Original_Sort)
			li_Succ = rauoDistribution.uoStowages[llIndex].dsContent.Sort()
		end if
		
		
	End If
Next

Return 1

end function

public function integer of_init_slot (ref uo_cart_distribution rauocartdistribution, long al_row, long al_column, long al_maxlength);/*
* Objekt : uo_cart_diagram
* Methode: of_init_slot (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 29.04.2011
*
* Argument(e):
* ref uo_cart_distribution rauocartdistribution
*	 long al_row
*	 long al_column
*	 long al_maxlength
*
* Beschreibung:		aus Distribution ausgelagert
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	29.04.2011		Erstellung
*
*
* Return: integer
*
*/

Long		ll_Order
String	ls_temp
s_distrib_items lstr_item[] , lstr_item_empty[]
	
	
lstr_item = lstr_item_empty
Choose Case of_get_type(al_Row, al_Column)
	Case TRAY
		rauoCartDistribution.of_set_type(al_Column, al_Row, TRAY)
		rauoCartDistribution.of_set_length(al_Column, al_Row, al_Maxlength )
		rauoCartDistribution.of_set_order(al_Column, al_Row, long(of_get_order(al_Row, al_Column)) )
		of_get_item_properties(al_Row, al_Column, lstr_item)
		if il_Disable_Debug = 0 Then	
			guoLog.uf_debug( "["+ this.classname( )+".of_init_slot] TRAY Max Len " + String(al_Maxlength))
		End If
		rauoCartDistribution.of_set_item(al_Column, al_Row, lstr_item)
		
		ll_Order = long(of_get_order(al_Row, al_Column))
		rauoCartDistribution.of_set_alloc_props(al_Column, al_Row, ll_Order, lstr_item)
		
	Case DRAWERFOOD
		rauoCartDistribution.of_set_type(al_Column, al_Row, DRAWERFOOD)
		rauoCartDistribution.of_set_length(al_Column, al_Row, al_Maxlength )
		rauoCartDistribution.of_set_order(al_Column, al_Row, long(of_get_order(al_Row, al_Column)) )
		of_get_item_properties(al_Row, al_Column, lstr_item)
		rauoCartDistribution.of_set_item(al_Column, al_Row, lstr_item)
		if il_Disable_Debug = 0 Then	
			guoLog.uf_debug( "["+ this.classname( )+".of_init_slot] DRAWERFOOD Max Len " + String(al_Maxlength))
		End If
		
		ll_Order = long(of_get_order(al_Row, al_Column))
		rauoCartDistribution.of_set_alloc_props(al_Column, al_Row, ll_Order, lstr_item)
		
	Case DRAWER_MULTI_RUNG
		rauoCartDistribution.of_set_type(al_Column, al_Row, DRAWER_MULTI_RUNG)
		rauoCartDistribution.of_set_length(al_Column, al_Row, al_Maxlength )
		rauoCartDistribution.of_set_order(al_Column, al_Row, long(of_get_order(al_Row, al_Column)) )
		of_get_item_properties(al_Row, al_Column, lstr_item)
		rauoCartDistribution.of_set_item(al_Column, al_Row, lstr_item)
		if il_Disable_Debug = 0 Then
			ls_temp = "uo_cart_diagram.of_init_slot DRAWER_MULTI_RUNG Max Len " + String(al_Maxlength)
			guoLog.uf_debug( "["+ this.classname( )+".of_init_slot upperbound(lstr_item) " + String(upperbound(lstr_item)))						
		End If
		
		ll_Order = long(of_get_order(al_Row, al_Column))
		rauoCartDistribution.of_set_alloc_props(al_Column, al_Row, ll_Order, lstr_item)
		

	Case ELSE
		// No Valid Type
		if il_Disable_Debug = 0 Then	
			guoLog.uf_debug( "["+ this.classname( )+".of_init_slot] IRRELEVANT TYPE " + String(of_get_type(al_Row, al_Column)))
		End If

End Choose


Return 1
end function

public function integer of_distr_content_4_contentsheet (ref datastore rads_distribution_contents, ref uo_cart_distribution rauocartdistribution, long al_row, long al_column, long al_content_master_row_id);	/*
	* Objekt : uo_cart_diagram
	* Methode: of_distr_content_4_contentsheet (Function)
	* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
	* Datum  : 29.04.2011
	*
	* Argument(e):
	* ref datastore rads_distribution_contents
	*	 ref uo_cart_distribution rauocartdistribution
	*	 long al_row
	*	 long al_column
	*	 long al_content_master_row_id
	*
	* Beschreibung:		aus Distribution ausgelagert
	*
	* Aenderungshistorie:
	* Version 		Wer			Wann			Was und warum
	* 1.0 			O.Hoefer	29.04.2011		Erstellung
	*
	*
	* Return: integer
	*
	*/
	
	
	// --------------------------------------------------------------------------
	// Verteilter Content nach Content Sheet dsLoadingContents 
	// --------------------------------------------------------------------------
	Long	ll_Count
	Integer	li_Succ 
	Long		ll_Content_Header_Detail_Key
	String	ls_temp_content_pl
	String	ls_temp_content
	Long		ll_temp_qty
	Long		ll_Sort_Counter
	Long	ll_new_Row
	s_distrib_items	lstr_item[]


	rauoCartDistribution.of_get_row_without_sub(al_Column, al_row, lstr_item)
	
	//lstr_item 
	
	For ll_Count = 1 To Upperbound(lstr_item)
		If trim(lstr_item[ll_Count].sitem) > "" Then
			if il_Disable_Debug= 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_distr_content_4_contentsheet content sheet dsLoadingContents llRowId=" + String(al_content_master_row_id) + " / " + lstr_item[ll_Count].sitem)
			End If
			
			ll_temp_qty = lstr_item[ll_Count].lcount 
			If ll_temp_qty = 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_distr_content_4_contentsheet qty=0 SKIP " + + lstr_item[ll_Count].sitem)
				CONTINUE
			end if
			
			ll_New_Row = rads_distribution_contents.InsertRow(0)
			ll_Content_Header_Detail_Key = (al_Column * 1000) + al_row								
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key	)						
			li_Succ =rads_distribution_contents.SetItem(ll_New_Row, "nrowid", al_content_master_row_id)
			ls_temp_content_pl = lstr_item[ll_Count].cpackinglist  
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "cpackinglist", ls_temp_content_pl)
			ls_temp_content = lstr_item[ll_Count].ctext 
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", ls_temp_content)
			If Trim(ls_temp_content) = "" Then
				li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", lstr_item[ll_Count].sitem)
			End If
			if il_Disable_Debug= 0 then
				If isnull(ls_temp_content) then ls_temp_content = "NULL"
				If isnull(ls_temp_content_pl) then ls_temp_content_pl = "NULL"			
				//guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution content sheet TRAY DISTRIBUTED ITEM llrowid="+ String(al_content_master_row_id) + " / " + ls_temp_content + " / " + ls_temp_content_pl + " / " + lstr_item[ll_Count].sitem)
				guoLog.uf_debug( "["+ this.classname( )+".of_distr_content_4_contentsheet content sheet DRAWER_MULTI_RUNG DISTRIBUTED ITEM llrowid="+ String(al_content_master_row_id) + " / " +  ls_temp_content_pl + " / " + ls_temp_content + " / " + lstr_item[ll_Count].sitem)
			End If
			ll_temp_qty = lstr_item[ll_Count].lcount // ids_distribution_results.GetItemNumber(ll_Distr_Counter , "nqty")
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nquantity", ll_temp_qty)
			ll_Sort_Counter++
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
		End If
	Next
	// --------------------------------------------------------------------------
	// Ende Verteilter Content nach Content Sheet dsLoadingContents 
	// --------------------------------------------------------------------------
Return 1

end function

public function long of_draw_watermark_downline (long arg_irow, long arg_icolumn, integer arg_ltype, long arg_lcolour);
/*
* Objekt : uo_cart_diagram
* Methode: of_draw_watermark_downline (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 12.08.2010
*
* Argument(e):
*	 long arg_irow
*	 long arg_icolumn
*	 integer arg_ltype
*
* Beschreibung:		Wasserzeichen "DOWNLINE"
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	12.08.2010		Erstellung
*
*
* Return: long
*
*/


String	ls_Object
long		ll_Row, lX1, lX2, lY1, lY2, lRowHeight //, lYCounter
long		llTextWidth
Long		ll_Color =    RGB(200,200,200)
String	ls_Downline
Long		ll_rungs, ll_columns
Integer	li_Succ
Long		ll_Width_Factor = 1


ll_Color =   arg_lcolour

ls_Downline = "DOWNLINE"

// ============= Vorlage ==============
//pg.setColor(new Color(200, 200, 200));
//pg.setFont(new Font("SansSerif", 0, 30));
//pg.drawString("DOWNLINE", dl_watermark_x - 12, dl_watermark_y);
//It is color 200,200,200 and SansSerif size 30.

if of_is_tr_componentlist_enabled() and bHasDimensions Then
	llTextWidth = TEXTWIDTH1
Else
	llTextWidth = TEXTWIDTHSMALL1
End If

Choose Case arg_ltype
	Case TRAYNONFOOD
		lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 20
	Case Else
		lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
end Choose

lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth/2
lRowHeight = 14

ls_Object = "t_wtrmrk_dwnln_c_" + string(arg_icolumn, "00") + "_r_" + string(arg_iRow, "00")

lY1 = lyoffset  + ((arg_iRow - 1) *  ldefaultheight )
//	lY1 -= 35

// Verschiedene Gr$$HEX2$$f600df00$$ENDHEX$$en
Choose Case arg_ltype
	Case EMPTY 
	Case DRAWER  // Einschub
		lY1 += (ldefaultheight) / 2
	Case DRAWER_3RUNG, DRAWERFOOD_3RUNG
		lY1 += (ldefaultheight) * 0.75
	Case DRAWER_MULTI_RUNG
		
		li_Succ = of_get_rungs_and_cols(arg_iRow, arg_icolumn, ll_rungs, ll_columns)
		// Nur bei H$$HEX1$$d600$$ENDHEX$$he > 1
		If ll_rungs > 1 Then
			lY1 += (ldefaultheight) * 0.75
		End If
		// Breite >1 => anpassen
		If ll_columns > 1 Then
			ll_Width_Factor = 2
		End If
		
	Case TRAY  // Tray
	Case DRAWERFOOD  // Einschub	
		lY1 += (ldefaultheight) / 2
	Case TRAYNONFOOD  // Tray	
	Case FLOATING 
End Choose

lX1 -= 5

of_create_text(ls_Object, ls_Downline ,FONT_MICROSOFT_SANS_SERIF, 30, FONT_NORMAL, lX1, lY1 , 45 , llTextWidth * ll_Width_Factor, 0, ALIGN_CENTER, ll_Color, 1)		
of_set_position(ls_Object, FALSE)
//of_register(ls_Object, -1, -1)

return 0

end function

public function long of_remove_distribution (long irow, long icolumn);

// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_remove_distribution (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
// long llayoutdetailkey
// --------------------------------------------------------------------------------
// Return: Long
// --------------------------------------------------------------------------------
//  Beschreibung:
//  L$$HEX1$$f600$$ENDHEX$$schen der zugeordneten Inhalte eines Einschubs/Tabletts
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  04.12.2008	           Klaus F$$HEX1$$f600$$ENDHEX$$rster     Erstellung
//  17.04.2009		      U.Paudler		Filter zur$$HEX1$$fc00$$ENDHEX$$cksetzen, Postion als $$HEX1$$dc00$$ENDHEX$$bergabeparameter
//  03.09.2009			Ulrich Paudler	Backlog hinzugef$$HEX1$$fc00$$ENDHEX$$gt
//  08.02.2010			Ulrich Paudler	Formatierungen zur$$HEX1$$fc00$$ENDHEX$$cksetzen
//  06.05.2011			Oliver H$$HEX1$$f600$$ENDHEX$$fer KOPIE von of_remove_content nach of_remove_distribution
// --------------------------------------------------------------------------------
Long 		i, j
Long		lContentKey, lNull, lFound, lLayoutDetailkey
String	sObject
Long		ll_Found, ll_Ancestor
Long		ll_Content
Integer	li_Type, li_Succ
Long		ll_rungs
Long		ll_columns = 1

SetNull(lNull)

dsLayoutContents.SetFilter("")
dsLayoutContents.Filter()

// Rausfinden, was sich in der Position befindet (Drawer/Tray)
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iColumn) + " and nrow=" + string(iRow), 1, this.dsLayoutDetail.Rowcount())
if lFound = 0 Then 
	this.sError = "Error DetailKey not found"
	return -1
Else
	lLayoutDetailkey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key") 
	ll_Content = this.dsLayoutDetail.Getitemnumber(lFound, "ncontent")
	//this.dsLayoutDetail.Setitem(lFound, "ncontent", lNull)
	
	ll_Ancestor = dsLayoutDetail.GetItemNumber(lFound, "nancestor") 
	
	li_Type = dsLayoutDetail.Getitemnumber(lFound, "ntype")
	If li_Type = DRAWER_MULTI_RUNG Then
		// Zwei Spalten?
		li_Succ = of_get_rungs_and_cols(irow, icolumn, ll_rungs, ll_columns)
		
	End If
		
	
	// Order?
	this.dsLayoutDetail.Setitem(lFound, "norder", lNull)
	
	ll_found = this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor), 1, this.dsLayoutDetail.Rowcount())
	Do while ll_Found > 0
		this.dsLayoutDetail.Setitem(ll_Found, "norder", lNull)
		ll_found = this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor),ll_found + 1, this.dsLayoutDetail.Rowcount() + 1)
	Loop

End If

//// --------------------------------------------------------------------------------
//// 05.12.2008, KF: Zuordnung zu St$$HEX1$$fc00$$ENDHEX$$cklisten entfernen
//// --------------------------------------------------------------------------------
//for i = this.dsLayoutContents.RowCount() to 1 Step -1
//	if this.dsLayoutContents.GetItemNumber(i, "nlayout_detail_key") = llayoutdetailkey Then
//		lContentKey = this.dsLayoutContents.GetItemNumber(i, "nlayout_content_key")
//		for j = 1 to this.dsPLContents.Rowcount()
//			if this.dsPLContents.GetItemNumber(j, "nlayout_content_key") = lContentKey Then
//				this.dsPLContents.SetItem(j, "nlayout_content_key", lNull)
//			End If	
//		next
//		this.dsLayoutContents.DeleteRow(i)
//	End If
//next


// --------------------------------------------------------------------------------
// 05.12.2008, KF: Zuornung der MZV Parameter entfernen
// --------------------------------------------------------------------------------
this.dsLayoutDimension.SetFilter("nlayout_detail_key = " + string(llayoutdetailkey))
this.dsLayoutDimension.Filter()
for i = this.dsLayoutDimension.RowCount() to 1 Step -1
	if this.dsLayoutDimension.GetItemNumber(i, "nlayout_detail_key") = llayoutdetailkey Then
		this.dsLayoutDimension.DeleteRow(i)
	End If
next

// --------------------------------------------------------------------------------
// 05.12.2008, KF: Texte entfernen
// --------------------------------------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(iColumn) + " and nrow=" + string(iRow)) 
If li_Type = DRAWER_MULTI_RUNG AND iColumn = 1 AND ll_Columns > 1 Then
	li_Succ = dsObjects.SetFilter("ncolumn in (1 , 2) and nrow=" + string(iRow)) 
End If
this.dsObjects.Filter()

for i = 1 to this.dsObjects.RowCount() 
	sObject = this.dsObjects.GetItemString(i, "cobject")
	if not of_check_string(sObject,"t_content_" )  Then 
		continue
	End If
	// 03.09.2009 Ulrich Paudler [UP]
	if of_check_string(sObject, "t_content_backlog_" ) Then
		of_modify_dw("Destroy " + sObject)
	Else
		// 08.02.2010 Ulrich Paudler [UP] Formatierungen zur$$HEX1$$fc00$$ENDHEX$$cksetzen
		lFound = this.dsLayoutAddObjects.Find("cobject_name='" + sObject + "'", 1, dsLayoutAddObjects.Rowcount())
		if lFound > 0 Then
			this.dsLayoutAddObjects.deleterow(lFound)
		End If
		of_modify_dw(sObject + ".text=' '")
	End If
next

li_Succ = of_draw_content_drawer_multi(llayoutdetailkey, ll_Content, irow, icolumn, DRAWER_MULTI_RUNG, is_csc )


// 17.04.2009 Ulrich Paudler [UP]
// Filter wieder zur$$HEX1$$fc00$$ENDHEX$$cksetzen
//this.dsObjects.SetFilter("ncolumn=" + string(iColumn) + " and nrow=" + string(iRow)) 
this.dsObjects.SetFilter("") 
this.dsObjects.Filter()
this.dsObjects.Sort()


return 0
end function

public function long of_remove_distribution ();/*
* Objekt : uo_cart_diagram
* Methode: of_remove_distribution (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 06.05.2011
*
* Argument(e):
* none
*
* Beschreibung:		Entfernen der Distribution Parameter an der aktuellen Stelle
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	06.05.2011		Erstellung
*
*
* Return: long
*
*/


return of_remove_distribution(iCurrentRow, iCurrentColumn)
end function

public function long of_remove_content (long irow, long icolumn, boolean ab_remove_distr_parms_4_multi);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_remove_content (Function)
// Autor  : Klaus F$$HEX1$$f600$$ENDHEX$$rster
// --------------------------------------------------------------------------------
// Argument(e):
//  long irow
//	 long icolumn
//	 boolean ab_remove_distr_parms_4_multi TRUE => L$$HEX1$$f600$$ENDHEX$$sche Distr parms auch bei Multi Rung
//
// --------------------------------------------------------------------------------
// Return: Long
// --------------------------------------------------------------------------------
//  Beschreibung:
//  L$$HEX1$$f600$$ENDHEX$$schen der zugeordneten Inhalte eines Einschubs/Tabletts
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  04.12.2008	           Klaus F$$HEX1$$f600$$ENDHEX$$rster     Erstellung
//  17.04.2009		      U.Paudler		Filter zur$$HEX1$$fc00$$ENDHEX$$cksetzen, Postion als $$HEX1$$dc00$$ENDHEX$$bergabeparameter
//  03.09.2009			Ulrich Paudler	Backlog hinzugef$$HEX1$$fc00$$ENDHEX$$gt
//  08.02.2010			Ulrich Paudler	Formatierungen zur$$HEX1$$fc00$$ENDHEX$$cksetzen
//  23.05.2011			     Oliver H$$HEX1$$f600$$ENDHEX$$fer      Parameter hinzu (ab_remove_distr_parms_4_multi)
// --------------------------------------------------------------------------------
Long 		i, j
Long		lContentKey, lNull, lFound, lLayoutDetailkey
String	sObject
Long		ll_Found, ll_Ancestor
Integer	li_Type, li_Succ
Long		ll_rungs
Long		ll_columns = 1
Long		ll_Content
Boolean	lb_Distribution = FALSE
SetNull(lNull)


dsLayoutContents.SetFilter("")
dsLayoutContents.Filter()

// Rausfinden, was sich in der Position befindet (Drawer/Tray)
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(iColumn) + " and nrow=" + string(iRow), 1, this.dsLayoutDetail.Rowcount())
if lFound = 0 Then 
	this.sError = "Error DetailKey not found"
	return -1
Else
	lLayoutDetailkey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key") 
	ll_Content = this.dsLayoutDetail.GetItemNumber(lFound, "ncontent") 
	this.dsLayoutDetail.Setitem(lFound, "ncontent", lNull)
	
	ll_Ancestor = dsLayoutDetail.GetItemNumber(lFound, "nancestor") 
	
	li_Type = dsLayoutDetail.Getitemnumber(lFound, "ntype")
	If li_Type = DRAWER_MULTI_RUNG Then
		// Zwei Spalten?
		li_Succ = of_get_rungs_and_cols(irow, icolumn, ll_rungs, ll_columns)
		
	End If
		
	
	// Order?
	this.dsLayoutDetail.Setitem(lFound, "norder", lNull)
	
	ll_found = this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor), 1, this.dsLayoutDetail.Rowcount())
	Do while ll_Found > 0
		this.dsLayoutDetail.Setitem(ll_Found, "norder", lNull)
		ll_found = this.dsLayoutDetail.Find("nancestor=" + string(ll_Ancestor),ll_found + 1, this.dsLayoutDetail.Rowcount() + 1)
	Loop

End If

// --------------------------------------------------------------------------------
// 05.12.2008, KF: Zuordnung zu St$$HEX1$$fc00$$ENDHEX$$cklisten entfernen
// --------------------------------------------------------------------------------
for i = this.dsLayoutContents.RowCount() to 1 Step -1
	if this.dsLayoutContents.GetItemNumber(i, "nlayout_detail_key") = llayoutdetailkey Then
		lContentKey = this.dsLayoutContents.GetItemNumber(i, "nlayout_content_key")
		for j = 1 to this.dsPLContents.Rowcount()
			if this.dsPLContents.GetItemNumber(j, "nlayout_content_key") = lContentKey Then
				this.dsPLContents.SetItem(j, "nlayout_content_key", lNull)
			End If	
		next
		this.dsLayoutContents.DeleteRow(i)
	End If
next


// --------------------------------------------------------------------------------
// 06.05.2011 OH wenn typ = multirung dann NICHT DISTRIBUTION PARMS entfernen
// Cart Issue List #48
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// 05.12.2008, KF: Zuornung der MZV Parameter entfernen
// --------------------------------------------------------------------------------
this.dsLayoutDimension.SetFilter("nlayout_detail_key = " + string(llayoutdetailkey))
this.dsLayoutDimension.Filter()
If li_Type <> DRAWER_MULTI_RUNG OR ab_remove_distr_parms_4_multi = TRUE Then	
	for i = this.dsLayoutDimension.RowCount() to 1 Step -1
		if this.dsLayoutDimension.GetItemNumber(i, "nlayout_detail_key") = llayoutdetailkey Then
			this.dsLayoutDimension.DeleteRow(i)
		End If
	next
Else
	If this.dsLayoutDimension.RowCount() > 0 Then
		lb_Distribution = TRUE 
	End If
End If

// --------------------------------------------------------------------------------
// 05.12.2008, KF: Texte entfernen
// --------------------------------------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(iColumn) + " and nrow=" + string(iRow)) 
If li_Type = DRAWER_MULTI_RUNG AND iColumn = 1 AND ll_Columns > 1 Then
	li_Succ = dsObjects.SetFilter("ncolumn in (1 , 2) and nrow=" + string(iRow)) 
End If
this.dsObjects.Filter()

for i = 1 to this.dsObjects.RowCount() 
	sObject = this.dsObjects.GetItemString(i, "cobject")
	if not of_check_string(sObject,"t_content_" )  Then 
		continue
	End If
	// 03.09.2009 Ulrich Paudler [UP]
	if of_check_string(sObject, "t_content_backlog_" ) Then
		of_modify_dw("Destroy " + sObject)
	Else
		// 08.02.2010 Ulrich Paudler [UP] Formatierungen zur$$HEX1$$fc00$$ENDHEX$$cksetzen
		lFound = this.dsLayoutAddObjects.Find("cobject_name='" + sObject + "'", 1, dsLayoutAddObjects.Rowcount())
		if lFound > 0 Then
			this.dsLayoutAddObjects.deleterow(lFound)
		End If
		//of_modify_dw(sObject + ".text='...'")
		of_modify_dw(sObject + ".text=' '")
	End If
next

If li_Type = DRAWER_MULTI_RUNG Then
	// Neu zeichnen
	If lb_Distribution Then
		ll_Content = DISTRIBUTION
		li_Succ = of_draw_content_drawer_multi(llayoutdetailkey, ll_Content, irow, icolumn, DRAWER_MULTI_RUNG, is_csc )
	End If
End If

// 17.04.2009 Ulrich Paudler [UP]
// Filter wieder zur$$HEX1$$fc00$$ENDHEX$$cksetzen
//this.dsObjects.SetFilter("ncolumn=" + string(iColumn) + " and nrow=" + string(iRow)) 
this.dsObjects.SetFilter("") 
this.dsObjects.Filter()
this.dsObjects.Sort()



return 0
end function

public function integer of_handle_empty_contents (long al_row, long al_column, ref boolean rab_empty, ref boolean rab_entire_container_empty);/*
* Objekt : uo_cart_diagram
* Methode: of_handle_empty_contents (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.05.2011
*
* Argument(e):
*	 long al_row
*	 long al_column
*	 ref boolean rab_empty
*	 ref boolean rab_entire_container_empty
*
* Beschreibung:		zu of_create_distribution
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.05.2011		Erstellung
*
*
* Return: integer
*
*/

Integer	li_Succ

If rab_Empty Then
	if of_get_type(al_Row, al_Column) = TRAY Then
		If of_has_contents(al_Row, al_Column) THEN
			rab_Entire_Container_Empty = FALSE
			rab_Empty = FALSE
		Else
			If ib_Remove_Empty_Drawer Then
				of_remove_tray(al_row, al_column)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_handle_empty_contents DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00") + String(al_Column) + " / " + String(al_Row))	
				End If

			End If
		End If
		
	ElseIF of_get_type(al_Row, al_Column) = DRAWERFOOD OR of_get_type(al_Row, al_Column) = drawer_3rung then
		If of_has_contents(al_Row, al_Column) THEN
			rab_Entire_Container_Empty = FALSE
			rab_Empty = FALSE
		Else
			If ib_Remove_Empty_Drawer Then
				of_remove_drawer(al_Row, al_Column)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_handle_empty_contents DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00") + String(al_Column) + " / " + String(al_Row))	
				End If
			End If
		End If
		
	ElseIF of_get_type(al_Row, al_Column) = drawer_multi_rung then
		If of_has_contents(al_Row, al_Column) THEN
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution DRAWER_MULTI_RUNG not empty " + String(al_Column) + " / " + String(al_Row))	
			End If
			rab_Entire_Container_Empty = FALSE
			rab_Empty = FALSE

		Else
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution DRAWER_MULTI_RUNG empty " + String(al_Column) + " / " + String(al_Row))	
			End If
			
			If ib_Remove_Empty_Drawer Then
				of_remove_drawer(al_Row, al_Column)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_handle_empty_contents DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00") + String(al_Column) + " / " + String(al_Row))	
				End If

			End If
		End If
		
	ElseIF of_get_type(al_Row, al_Column) = traynonfood then
		rab_Entire_Container_Empty = FALSE
		rab_Empty = FALSE
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution traynonfood => not empty " + String(al_Column) + " / " + String(al_Row))	
		End If
	Else
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution AFTER DIST CONTAINER NO TYPE " + String(al_Column) + " / " + String(al_Row))	
		End If
	End If
	
	if il_Disable_Debug = 0 OR s_app.itrace > 0 Then
		if rab_Empty then
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution AFTER DIST CONTAINER EMPTY " + String(al_Column) + " / " + String(al_Row))	
			of_create_text("empty_flag_" + String(al_Column)+ "_" + String(al_Row), "E M P T Y",FONT_MICROSOFT_SANS_SERIF, 20, FONT_BOLD, lXOffset + ((al_Column -1) * lDefaultWidth) + 14, (al_Row *  lDefaultHeight) , 25 , TEXTWIDTHSMALL1 , 0, 0, rgb(255,0,0), 1)
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution AFTER DIST CONTAINER NICHT MEHR EMPTY " + String(al_Column) + " / " + String(al_Row))								
		end if
	End If
end if	


Return 1

end function

public function boolean of_set_user (string as_user);
is_user = as_user

Return true
end function

protected function long of_adjust_xposition (long arg_l_pos, string arg_s_object);/*
* Objekt : uo_cart_diagram
* Methode: of_adjust_xposition (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 14.06.2011
*
* Argument(e):
*	long arg_l_pos				gespeicherte X-Position
*	string arg_s_object
*
* Beschreibung:		Passt ggf. die X-Position an (Diagramm wurde mit Component List Schalter=EIN gezeichnet und wird nun OHNE aufgebaut 
*							(oder umgekehrt)=> verschieben von "Free"-Objekten: Rectangle, Text, Free Content)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	14.06.2011		Erstellung
*
*
* Return: long
*
*/


Long		llPosition = 0
Integer	li_Complist_Switch
Boolean	lb_Comp_List_at_Designtime
Boolean	lb_Current_Comp_List_Setting
Double	ld_Factor
Double	ld_Offset_in_Column
Integer	li_Offset


//INITIALWIDTH 			= 322
//INITIALWIDTHSMALL 	= 255
//INITIALOFFSET1= 186
//INITIALOFFSET2= 40
//INITIALOFFSETSMALL1 = 186
//INITIALOFFSETSMALL2 = 200
//TEXTWIDTH1 = 280
//TEXTWIDTH2 = 322
//TEXTWIDTHSMALL1 = 255
//TEXTWIDTHSMALL2 = 255
//ii_Std_Cart_Left
//ii_Std_Cart_Width
//ii_Std_Cart_Top
//ii_Std_Cart_Height

If dsLayout.RowCount() > 0 Then
	li_Complist_Switch = dsLayout.GetItemNumber(1, "ncomponentlist")
End If

If IsNULL(li_Complist_Switch) Then
	// ----------------------------------------------------
	// Kein Wert gespeichert => keine Aktion m$$HEX1$$f600$$ENDHEX$$glich
	// ----------------------------------------------------
	llPosition = arg_l_pos
	Return llPosition
End If

If li_Complist_Switch = 1 Then
	lb_Comp_List_at_Designtime = TRUE 
Else
	lb_Comp_List_at_Designtime = FALSE 
End If

lb_Current_Comp_List_Setting = bHasDimensions

If lb_Comp_List_at_Designtime = lb_Current_Comp_List_Setting Then
	llPosition = arg_l_pos
	Return llPosition
End If

// ----------------------------------------------------
// Die Einstellungen sind unterschiedlich
// ----------------------------------------------------
if lb_Current_Comp_List_Setting Then
	// ----------------------------------------------------
	// nur bei 2 Spalten relevant
	// ----------------------------------------------------
	if ilColumnCount > 1 Then
		If lb_Comp_List_at_Designtime = FALSE Then
			// Zwei Spalten & Comp List EIN
			// wenn Comp List beim Zeichnen NICHT EIN gewesen => anpassen
			li_Offset = arg_l_pos - INITIALOFFSET2
			// Spalte 1?
			If li_Offset <=  initialwidth Then 
				llPosition = arg_l_pos - INITIALOFFSET2 + INITIALOFFSETSMALL2   
			Else
				If li_Offset >= INITIALWIDTH AND li_Offset <= INITIALWIDTH * 2 Then
					// Spalte 2
					ld_Factor =  INITIALWIDTHSmall / INITIALWIDTH
					li_Offset -= INITIALWIDTH
					// Offset von Spalte 2 linker Rand
					If li_Offset < 1 then li_Offset = 1
					// Neue Position = Offset Links (mit Komp) + Spaltenbreite (mit Komp) + (alter Offset in Spalte * Streckungsfaktor)
					llPosition = INITIALOFFSETSMALL2 + initialwidthsmall + (li_Offset * ld_Factor) 

				End If
			End If
		End If
	Else
		// Eine Spalte: keine $$HEX1$$c400$$ENDHEX$$nderung
		llPosition = arg_l_pos 
	End If
Else
	// ----------------------------------------------------
	// nur bei 2 Spalten relevant
	// ----------------------------------------------------
	if ilColumnCount > 1 Then
		// Zwei Spalten & Comp List AUS
		// Comp List ist beim Zeichnen EINGESCHALTET gewesen => anpassen
		If lb_Comp_List_at_Designtime Then
			// Abstand vom linken Cart-Rand 
			li_Offset = arg_l_pos - INITIALOFFSETSMALL2 
			// Spalte 1
			If li_Offset <=  initialwidthsmall Then 
				llPosition = arg_l_pos - INITIALOFFSETSMALL2 + INITIALOFFSET2  
			Else
				If li_Offset >= INITIALWIDTHSmall AND li_Offset <= INITIALWIDTHSmall * 2 Then
					// Spalte 2
					ld_Factor = INITIALWIDTH / INITIALWIDTHSmall
					li_Offset -= INITIALWIDTHSmall
					// Offset von Spalte 2 linker Rand
					If li_Offset < 1 then li_Offset = 1
					
					// Neue Position = Offset Links (ohne Komp-List) + Spaltenbreite (ohne Komp-List) + (alter Offset in erkannter Spalte * Streckungsfaktor)
					llPosition = INITIALOFFSET2 + INITIALWIDTH + (li_Offset * ld_Factor) 					
				End If
			End If
		End If
	Else
		// Eine Spalte: keine $$HEX1$$c400$$ENDHEX$$nderung
		llPosition = arg_l_pos 
	End If
	
End If

// Nicht negativ werden
if llPosition < 0 Then llPosition = 0

return llPosition


end function

public function integer of_clean_tr_diagram (ref datastore rads_diagramm);/*
* Objekt : uo_cart_diagram
* Methode: of_clean_tr_diagram (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 26.07.2011
*
* Argument(e):
* ref datastore rads_diagramm
*
* Beschreibung:		F$$HEX1$$fc00$$ENDHEX$$r TR Carts - Leerseiten bauen
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	26.07.2011		Erstellung
*
*
* Return: integer
*
*/

//----------------------------------------------------
// Alle Objekte im DW analysieren
//----------------------------------------------------
Long 		i, iCount,iPos
string 	sDWObjects, sTemp, sObjects[], sValidObjects[], &
			sBand, sSyntax, sObject, sType, sColType, lTaborder, sTag
long		lFound
String	ls_Error
Long		ll_Debug
String	ls_Name

// ---------------------------------------
// Alle Objekte auslesen
// ---------------------------------------
			
if isvalid(rads_Diagramm) Then
	sDWObjects = rads_Diagramm.describe("datawindow.objects")
End If
	
// sDWObjects = #####.describe("datawindow.objects")

// ---------------------------------------
// Den String zerhacken und alle Objekte
// ein Array schreiben
// ---------------------------------------
for i = 1 to len(sDWObjects)
		if Mid(sDWObjects, i, 1) <> char(9) Then
		sTemp += Mid(sDWObjects, i, 1)
	Else
		iCount ++
		sObjects[iCount] = sTemp
		sTemp = ""
	End If
next

if len(sTemp) > 0 Then		
	iCount ++
	sObjects[iCount] = sTemp
End If


for i = 1 to UpperBound(sObjects)
	ls_Name = sObjects[i]
	
	If Pos(ls_Name, "l_line_4_") = 0 AND &
		Pos(ls_Name, "l_line_5_") = 0 AND &
		Pos(ls_Name, "l_line_6_") = 0 AND &
		Pos(ls_Name, "l_line_7_") = 0 AND &
		Pos(ls_Name, "p_lane_") = 0 AND &
		Pos(ls_Name, "r_wheel_") = 0 AND &
		Pos(ls_Name, "t_watermark") = 0 AND &
		Pos(ls_Name, "t_rear_") = 0 AND &
		Pos(ls_Name, "t_front_") = 0 Then 
	
		if isvalid(rads_Diagramm) Then
			 sBand 	= rads_Diagramm.Describe(sObjects[i] + ".band")
		End If
		If lower(sBand) = lower("detail") Then
			
			if isvalid(rads_Diagramm) Then
				ls_Error = rads_Diagramm.modify("destroy " + sObjects[i])
			End If
		End If
	End If
	
Next
	

Return 1
end function

public function long of_draw_watermark (integer ai_type, long al_flight_number, string as_ramp_time, string as_kitchen_time, string as_ops, string as_class, string as_prodrange, long al_airline_key, string as_unit, long al_routing, boolean ab_tr_cart, string as_suffix);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_watermark (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 15.09.2010
*
* Argument(e):
* integer ai_type
*	 long al_flight_number
*	 string as_ramp_time
*	 string as_kitchen_time
*	 string as_ops
*	 string as_class
*
* Beschreibung:		Wasserzeichen hinzu
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	15.09.2010		Erstellung
* 1.1 			O.Hoefer	31.05.2012		Watermark nicht $$HEX1$$fc00$$ENDHEX$$bersetzen
* 1.2 			O.Hoefer	11.09.2012		Font Size Ramp/Kitchen Time & OPS wie Flight No (=125)
*
*
* Return: long
*
*/


String		ls_Watermark_Text
Long			ll_Color
Integer		li_X_Pos
Integer		li_Width
Integer		li_Y_Pos
Integer		li_Height
Long			ll_Font_Size
Long			ll_WM_Height
Integer		li_Succ
String		ls_mod

ll_Color = RGB(200, 200, 200)
ll_Font_Size = 75
ll_WM_Height = 250


If ai_type = -1 Then return 0

// Operations / Complexes (so called OPS) = Operations maintained locally for each CSC in CBASE
// Class (based on class for that stowage position)
// Flight Number of first leg
// Kitchen Time
// Ramp Time
//CONSTANT Integer WATERMARK_CLASS				= 100
//CONSTANT Integer WATERMARK_FLIGHT_NUMBER	= 102
//CONSTANT Integer WATERMARK_KITCHEN_TIME		= 103
//CONSTANT Integer WATERMARK_RAMP_TIME			= 104
//CONSTANT Integer WATERMARK_OPS					= 105
//CONSTANT Integer WATERMARK_PRODRANGE			= 106


Choose Case ai_type
	Case WATERMARK_CLASS
		ls_Watermark_Text = as_class 
		ll_Font_Size = 180
		If len(as_class) > 4 then ll_Font_Size = 150
		ll_WM_Height = 200
		
		// Unterdr$$HEX1$$fc00$$ENDHEX$$cke Watermark f$$HEX1$$fc00$$ENDHEX$$r Class 
		if of_suppress_class_watermark(al_airline_key, as_unit, al_routing, as_class ) Then
//			If (il_Disable_Debug) = 0 Then
//				uf.mbox("Suppress Class Watermark", as_unit +  " / " + String(al_routing) + " / " + as_class)				
//			End If
			as_class = ""
			ls_Watermark_Text = ""
		End If
		
	Case WATERMARK_FLIGHT_NUMBER
		ls_Watermark_Text = String(al_flight_number, "000") + Trim(as_Suffix)
		ll_Font_Size = 125
		ll_WM_Height = 150

	Case WATERMARK_KITCHEN_TIME
		ll_Font_Size = 125
		ls_Watermark_Text =  as_kitchen_time  

	Case WATERMARK_RAMP_TIME
		ll_Font_Size = 125
		ls_Watermark_Text = as_ramp_time 

	Case WATERMARK_OPS
		ll_Font_Size = 125
		ls_Watermark_Text =  as_ops
		
	Case WATERMARK_PRODRANGE
		ls_Watermark_Text =  as_prodrange 
		
End Choose

If Trim(ls_Watermark_Text) > "" Then
	// Draw Watermark centered
	If ab_tr_cart Then
		li_X_Pos = ii_TR_Cart_Left 
		li_Width = ii_TR_Cart_Width
		li_Y_Pos = ii_TR_Cart_Top
		li_Height = ii_TR_Cart_Height
	Else
		li_X_Pos = ii_STD_Cart_Left 
		li_Width = ii_STD_Cart_Width
		li_Y_Pos = ii_STD_Cart_Top
		li_Height = ii_STD_Cart_Height
	End If
		
	li_Y_Pos += (li_Height / 2) - (ll_WM_Height /2)

  // TD li_X_Pos => max width ####

	li_Succ = of_create_text("t_watermark_"+ String(ai_type), ls_Watermark_Text ,FONT_MICROSOFT_SANS_SERIF, ll_Font_Size, font_normal, 1, li_Y_Pos, ll_WM_Height, 720, 0, align_center, ll_Color, 1)
//	li_Succ = of_create_text("t_watermark_"+ String(ai_type), ls_Watermark_Text ,FONT_MICROSOFT_SANS_SERIF, ll_Font_Size, font_normal, li_X_Pos, li_Y_Pos, ll_WM_Height, li_Width, 0, align_center, ll_Color, 1)
	// Watermark nicht $$HEX1$$fc00$$ENDHEX$$bersetzen
	ls_mod = "t_watermark_"+ String(ai_type) + ".tag='DO_NOT_TRANSLATE'"
	of_modify(ls_mod , false)

	li_Succ = of_set_position( "t_watermark_"+ String(ai_type), FALSE)

End If
		
Return 0

end function

public function integer of_use_doc_gen_settings (n_doc_gen_settings anv_doc_gen_settings);/*
* Objekt : uo_cart_diagram
* Methode: of_use_doc_gen_settings (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 24.01.2012
*
* Argument(e):
* n_doc_gen_settings anv_doc_gen_settings
*
* Beschreibung:		Cart Settings aus User Object statt Profile
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	24.01.2012		Erstellung
*
*
* Return: integer
*
*/


ib_use_doc_gen_settings = TRUE
inv_doc_gen_settings = anv_doc_gen_settings

Return 1
end function

public function boolean of_set_section (string as_section);
is_section = as_section

Return true
end function

public function integer of_sd_fill_component_list (ref uo_distribution rauodistribution, long al_row_id, string arg_s_stowage, string arg_s_pl, long arg_l_lbelly);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_fill_component_list (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 29.04.2011
*
* Argument(e):
*	 ref uo_distribution rauodistribution
*	 ref s_component rastr_component[]
*	 string arg_s_stowage
*	 string arg_s_pl
*	 long arg_l_lbelly
*
* Beschreibung:		aus Distribution ausgelagert 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	29.04.2011		Erstellung
* 1.1 			O.Hoefer	08.02.2012		CBASE-NAM-CR-12011 Combine Entries with the Same Text 
* 1.2 			O.Hoefer	09.02.2012		CBASE-NAM-CR-12011 Sort by item list number, class and leg
* 1.3 			O.Hoefer	18.10.2012		Bugfix bei ausgeschalteter Distribution
* 1.4 			O.Hoefer	22.05.2013		Worksaround f$$HEX1$$fc00$$ENDHEX$$r leeren npl_distribution_key
* 1.5 			O.Hoefer	24.03.2020		#4984 Adjust sorting of item lists on cart diagram
*
*
*
* Return: integer
*
*/

Long		ll_IndexComponent 
Long		ll_Content_Counter
String	ls_temp
Boolean	lb_breakpoint
Boolean	lb_Sort_by_PL_Class_Leg = FALSE
Boolean	lb_Sort_by_Class_Desc_Leg = FALSE
Boolean	lb_Consolidate_Entries  = FALSE
Integer	li_Succ
String	ls_Temp_PL
String	ls_Temp_Text
Long		ll_Temp_Qty
Long		ll_Temp_Counter
Boolean	lb_Found_Double_Entry
String	ls_Original_Sort
Long		ll_Disable_2nd_Distr
Long		ll_pltype_key, ll_pl_distribution_key
String	ls_pl_type, ls_meal_control_code
String	ls_Find
Long		ll_Found, ll_Rows
string	ls_Value, ls_Section, ls_Default
integer	li_config
// --------------------------------------------------------
// Secondary Distribution - Component List
// --------------------------------------------------------
Long			ll_New_Row
Long			ll_Stowage_Counter
LongLong	lll_Sequence
Long			ll_Temp


// ----------------------------------------------------------------------
// bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 1 then
		lb_Sort_by_PL_Class_Leg = TRUE
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_PL_Class_Leg = FALSE
	end if
	
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 2 then
		lb_Sort_by_Class_Desc_Leg = TRUE
		lb_Sort_by_PL_Class_Leg = FALSE 
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_Class_Desc_Leg = FALSE
	end if
	
	// #6466 NAM Barcode	
	If inv_doc_gen_settings.il_NENABLE_NAM_BARCODE = 1  Then
		ib_nam_barcode_on_cartdiagram = TRUE
	ELSE
		ib_nam_barcode_on_cartdiagram = FALSE
	End if
	
Else
	
	If is_section > "" Then
		ls_Section = is_section
	Else
		ls_Section = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(ls_Section) = "" Then ls_Section = "docbrowser"
	End if
	
	if ls_Section <> "docbrowser" Then
		li_config = integer(Mid(ls_Section,11))
		ls_Default ="Default" +string(li_config)
	Else
		ls_Default ="Default"
	End If
	
	
	// #6466 NAM Barcode
	//ls_Value = of_profilestring(s_app.suser,ls_Default,"CartDiagramNAMBarcode","0") 
	ls_Value = f_unitprofilestring("Default","CartDiagramNAMBarcode","0", is_CSC) 
	If ls_Value = "1" Then
		ib_nam_barcode_on_cartdiagram = TRUE
	ELSE
		ib_nam_barcode_on_cartdiagram = FALSE
	End if
		
	
	
	ls_Value = of_profilestring(s_app.suser,ls_Default,"CartDiagramCompSort","0") 
	If ls_Value = "1" Then
		lb_Sort_by_PL_Class_Leg = TRUE
		ls_Value = of_profilestring(s_app.suser,ls_Default,"CartDiagramCompDistinct","0") 
		If ls_Value = "1" Then
			lb_Consolidate_Entries = TRUE
		End if
	End if
	// #4984
	If ls_Value = "2" Then
		lb_Sort_by_PL_Class_Leg = FALSE
		lb_Sort_by_Class_Desc_Leg = TRUE
		ls_Value = of_profilestring(s_app.suser,ls_Default,"CartDiagramCompDistinct","0") 
		If ls_Value = "1" Then
			lb_Consolidate_Entries = TRUE
		End if
	End if
	
	
End if

li_Succ = ids_SD_Components.SetFilter("nrowid=" + String(al_Row_id))
li_Succ = ids_SD_Components.Filter()
ll_Rows = ids_SD_Components.RowCount()

If ids_SD_Components.RowCount() > 0 then
	For ll_Temp = ids_SD_Components.RowCount() to 1 step -1
		ids_SD_Components.deleterow( ll_Temp)
	Next
End If

If IsValid(rauoDistribution) then
	// Liste der Komponenten f$$HEX1$$fc00$$ENDHEX$$llen
	ll_IndexComponent = 0
	For ll_Stowage_Counter = 1 to upperbound(rauoDistribution.uoStowages)
		If trim(rauoDistribution.uoStowages[ll_Stowage_Counter].sStowage) = arg_s_Stowage & 
				and rauoDistribution.uoStowages[ll_Stowage_Counter].sPackinglist = arg_s_PL  & 
				and rauoDistribution.uoStowages[ll_Stowage_Counter].lBelly = arg_l_lBelly Then
				
			If lb_Sort_by_PL_Class_Leg Then	
				ls_Original_Sort = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Describe("DataWindow.Table.Sort")
				li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.SetSort("cpackinglist A, nclass_number A, cmeal_control_code A")
				li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Sort()
			end if
			
			If lb_Sort_by_Class_Desc_Leg Then	
				ls_Original_Sort = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Describe("DataWindow.Table.Sort")
				li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.SetSort("nclass_number A, ctext A, cmeal_control_code A")
				li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Sort()
			end if
			
			//		if il_Disable_Debug = 0 Then	
			//			rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.saveas("c:\temp\cbase\dscontent_"+string(cpu())+".xls",excel5!,true)	
			//		End if
			For ll_Content_Counter= 1 to rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Rowcount()
            		ll_Disable_2nd_Distr = 0
						
				// --------------------------------------------------------------------------------------------------------------------
				// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
				// --------------------------------------------------------------------------------------------------------------------
				lll_Sequence = f_Sequence_ll ("SEQ_CEN_OUT_SD_COMP", sqlca)
				If lll_Sequence <> -1 Then
					ll_New_Row	= ids_sd_components.InsertRow(0)

					li_Succ = ids_sd_components.SetItem(ll_New_Row, "NSD_CL_KEY", lll_Sequence)
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nresult_key", il_result_key )						
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "ntransaction", il_transaction )
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nrowid", al_Row_id)	
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "ctext", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemstring(ll_Content_Counter,"ctext"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "cpackinglist", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemstring(ll_Content_Counter,"cpackinglist"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nquantity", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemnumber(ll_Content_Counter,"nquantity"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "cquantity", "")
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nlength", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemnumber(ll_Content_Counter,"nwidth"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "cdistr_text", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemstring(ll_Content_Counter,"cpl_type"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "cmeal_control_code", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemstring(ll_Content_Counter,"cmeal_control_code"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "cclass", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemstring(ll_Content_Counter,"cclass"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nclass_number", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemnumber(ll_Content_Counter,"nclass_number"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nspml", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemnumber(ll_Content_Counter,"nspml"))
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nlimit", 0)
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nremaining", 0)
				
	
					// ---------------------------------------------------------------------
					// Switch Off Secondary Distr. CBASE-CR-NAM-12050
					// ---------------------------------------------------------------------
						ll_pltype_key            		= rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemnumber(ll_Content_Counter,"npltype_key")
					ll_pl_distribution_key   	= rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemnumber(ll_Content_Counter,"npl_distribution_key")
					ls_pl_type               		= rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemstring(ll_Content_Counter,"cpl_type")
					ls_meal_control_code     = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemstring(ll_Content_Counter,"cmeal_control_code")
	//            ls_Find  = "npltype_key=" + String(ll_pltype_key) +  " AND "
	//            ls_Find += "npl_distribution_key=" + String(ll_pl_distribution_key)+  " AND "
	//            ls_Find += "ctext='" + ls_pl_type+  "' AND "
	//            ls_Find += "cmeal_control_code='" + ls_meal_control_code+  "'"
							ls_Find  = "npltype_key=" + String(ll_pltype_key) +  " AND "
				 //  ls_Find += "npl_distribution_key=" + String(ll_pl_distribution_key)+  " AND "
					if not isnull(ll_pl_distribution_key)	 then
						ls_Find += "npl_distribution_key=" + String(ll_pl_distribution_key)+  " AND "
					else
						guoLog.uf_debug( "["+ this.classname( )+".uo_client_label.of_create_cartdiagram npl_distribution_key is NULL  " + arg_s_PL)
					end if
					
					ls_Find += "ctext='" + ls_pl_type+  "' AND "
					ls_Find += "mid(cmeal_control_code,2)='" + mid(ls_meal_control_code,2) +  "'"
					ll_Found = rauoDistribution.uoStowages[ll_Stowage_Counter].dsPackinglistSize.Find(ls_Find, 1, rauoDistribution.uoStowages[ll_Stowage_Counter].dsPackinglistSize.RowCOunt())
					If ll_Found > 0 then
						ll_Disable_2nd_Distr =  rauoDistribution.uoStowages[ll_Stowage_Counter].dsPackinglistSize.getitemnumber(ll_Found,"ndisable_2nd_distribution")
						If isnull(ll_Disable_2nd_Distr) then ll_Disable_2nd_Distr = 0 
						guoLog.uf_debug( "["+ this.classname( )+".of_sd_fill_component_list ll_Disable_2nd_Distr=" + String(ll_Disable_2nd_Distr) + " FILTER=" + ls_Find)
					End If
					if ll_Disable_2nd_Distr = 1 then
						guoLog.uf_debug( "["+ this.classname( )+".uo_client_label.of_sd_fill_component_list ndisable_2nd_distribution " + arg_s_PL)
					End If
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "ndontdistribute", ll_Disable_2nd_Distr)
					li_Succ = ids_sd_components.SetItem(ll_New_Row, "nunallocated", rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.getitemnumber(ll_Content_Counter,"nquantity"))
				else
					uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
													 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
				end if
			Next
			
			If lb_Sort_by_PL_Class_Leg OR lb_Sort_by_Class_Desc_Leg Then	
				li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.SetSort(ls_Original_Sort)
				li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Sort()
			end if
		End If
	Next
End If

li_Succ = ids_SD_Components.SetFilter("")
li_Succ = ids_SD_Components.Filter()
ll_Rows = ids_SD_Components.RowCount()

return 1

end function

public function long of_sd_create_component_list (long al_row_id);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_create_component_list (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
* long al_row_id
*
* Beschreibung:		Secondary Distribution - List of Components
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
* 1.1 			O.Hoefer	16.10.2012		Bugfix: Qty aufsummieren (falscher Z$$HEX1$$e400$$ENDHEX$$hler)
* 1.2 			O.Hoefer	10.04.2013		Sort angepasst
* 1.3 			O.Hoefer	15.01.2014		CBASE-NAM-CR-14001
* 1.4 			O.Hoefer	24.03.2020		#4984 Adjust sorting of item lists on cart diagram
* 2.0 			O.Hoefer	25.07.2022		#6466 Adjust max availble Space (reserve space for barcode)
*
*
* Return: long
*
*/

Integer	li_Succ
String	lsRet
String	ls_ObjectName, ls_Text, sValue
Long		ll_Index, ll_Num_Components
Long		llX, llY, llHeight, llWidth, llYMax, llWidthAmount, ll_Space
Boolean	lb_Breakpoint
String	ls_Original_Sort
Boolean	lb_Sort_by_PL_Class_Leg, lb_Sort_by_Class_Desc_Leg
Boolean	lb_Consolidate_Entries
Boolean	lb_Found_Double_Entry
String	ls_Section, ls_Default
Integer	iConfig
Long		ll_Comp_Counter, ll_Temp_Counter
String	ls_Temp_text, ls_temp_PL
Long		ll_Temp_Qty
Long		ll_Target_Index
Boolean	lb_Overflow = FALSE
s_component	lstr_Component[]


llX				=  20
llY				=  56
llYMax			=  780   //880 
llHeight			=  10
llWidth			= 142
llWidthAmount	=  30
ll_Space			=   5


// ----------------------------------------------------------------------
// bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 1 then
		lb_Sort_by_PL_Class_Leg = TRUE
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_PL_Class_Leg = FALSE
	end if
	
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 2 then
		lb_Sort_by_Class_Desc_Leg = TRUE
		lb_Sort_by_PL_Class_Leg = FALSE 
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_Class_Desc_Leg = FALSE
	end if

	// #6466 NAM Barcode in Doc Engine
	If inv_doc_gen_settings.il_nenable_nam_barcode = 1 then
		ib_nam_barcode_on_cartdiagram = TRUE	
	ELSE
		ib_nam_barcode_on_cartdiagram = FALSE
	End if
	
Else
	
	If is_section > "" Then
		ls_Section = is_section
	Else
		ls_Section = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(ls_Section) = "" Then ls_Section = "docbrowser"
	End if
	
	if ls_Section <> "docbrowser" Then
		iConfig = integer(Mid(ls_Section,11))
		ls_Default ="Default" +string(iConfig)
	Else
		ls_Default ="Default"
	End If
	
	sValue = of_profilestring(s_app.suser,ls_Default,"CartDiagramCompSort","0") 
	If sValue = "1" Then
		lb_Sort_by_PL_Class_Leg = TRUE
		lb_Sort_by_Class_Desc_Leg = FALSE
	End If
	
	If sValue = "2" Then
		lb_Sort_by_Class_Desc_Leg = TRUE
		lb_Sort_by_PL_Class_Leg = FALSE
	End If
	
	sValue = of_profilestring(s_app.suser,ls_Default,"CartDiagramCompDistinct","0") 
	If sValue = "1" Then
		lb_Consolidate_Entries = TRUE
	End if
End if

li_Succ = ids_SD_Components.SetFilter("nrowid=" + String(al_Row_id))
li_Succ = ids_SD_Components.Filter()
ll_Num_Components = ids_SD_Components.RowCount()

// Keine Daten dann raus
if ll_Num_Components < 1 Then 
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_create_component_list upperbound(arg_component) < 1 RETURN")
	end if
	return 0
End If


ls_Original_Sort = ids_sd_components.Describe("DataWindow.Table.Sort")
guoLog.uf_debug( "["+ this.classname( )+".of_sd_create_component_list original sort " + ls_Original_Sort)

If lb_Sort_by_PL_Class_Leg Then	
	ls_Original_Sort = ids_sd_components.Describe("DataWindow.Table.Sort")
	li_Succ = ids_SD_Components.SetSort("cpackinglist A, nclass_number A, cmeal_control_code A")
	li_Succ = ids_SD_Components.Sort()
	guoLog.uf_debug( "["+ this.classname( )+".of_sd_create_component_list ids_SD_Components.SetSort cpackinglist A, nclass_number A, cmeal_control_code A")

Elseif lb_Sort_by_Class_Desc_Leg Then
	ls_Original_Sort = ids_sd_components.Describe("DataWindow.Table.Sort")
	li_Succ = ids_SD_Components.SetSort("nclass_number A, ctext A , cmeal_control_code A")
	li_Succ = ids_SD_Components.Sort()
	guoLog.uf_debug( "["+ this.classname( )+".of_sd_create_component_list ids_SD_Components.SetSort nclass_number A, ctext A, cmeal_control_code A")

else
	li_Succ = ids_SD_Components.SetSort("nclass_number A, cpackinglist A, cmeal_control_code A")
	li_Succ = ids_SD_Components.Sort()
	guoLog.uf_debug( "["+ this.classname( )+".of_sd_create_component_list ids_SD_Components.SetSort nclass_number A, cpackinglist A, cmeal_control_code A")
end if




// Umsortieren?
If lb_Consolidate_Entries Then
	ls_Temp_text = ids_sd_components.GetItemString(1, "ctext")
	ls_Temp_PL   = ids_sd_components.GetItemString(1, "cpackinglist") 
	lstr_Component[1].stext											= ids_sd_components.GetItemString(1, "ctext")  
	lstr_Component[1].ssnr											= ids_sd_components.GetItemString(1, "cpackinglist")
	lstr_Component[1].lquantity									= ids_sd_components.GetItemNumber(1, "nquantity") 
	lstr_Component[1].squantity									= ""
	lstr_Component[1].llength										= ids_sd_components.GetItemNumber(1, "nlength")
	lstr_Component[1].str_item_props.stext						= ids_sd_components.GetItemString(1, "CDISTR_TEXT") 
	lstr_Component[1].str_item_props.smeal_control_code	= ids_sd_components.GetItemString(1, "CMEAL_CONTROL_CODE") 
	lstr_Component[1].str_item_props.sclass					= ids_sd_components.GetItemString(1, "cclass")
	lstr_Component[1].str_item_props.lspml						= ids_sd_components.GetItemNumber(1, "nspml") 
	lstr_Component[1].str_item_props.llimit = 0
	
	guoLog.uf_debug( "["+ this.classname( )+".List of Components COMPONENT " + lstr_Component[1].ssnr + " CLASS:" + &
															lstr_Component[1].str_item_props.sclass + " " + &
															lstr_Component[1].str_item_props.smeal_control_code )
	

	If ids_sd_components.RowCount() > 1 Then
		For ll_Comp_Counter = 2 To ids_sd_components.RowCount()
			lb_Found_Double_Entry = FALSE
			ls_Temp_text = ids_sd_components.GetItemString(ll_Comp_Counter, "ctext") 
			ls_Temp_PL   = ids_sd_components.GetItemString(ll_Comp_Counter, "cpackinglist")
			
			If Upperbound(lstr_Component) > 0 then
				For ll_Temp_Counter = 1 To Upperbound(lstr_Component)
					IF lstr_Component[ll_Temp_Counter].stext = ls_Temp_text AND &
						lstr_Component[ll_Temp_Counter].ssnr  = ls_temp_PL Then
						lb_Found_Double_Entry = TRUE
						ll_Temp_Qty = ids_sd_components.GetItemNumber(ll_Comp_Counter, "nquantity")
						lstr_Component[ll_Temp_Counter].lquantity = lstr_Component[ll_Temp_Counter].lquantity + ll_Temp_Qty						
					End If
				Next
			End If
			
			If lb_Found_Double_Entry = FALSE then
				ll_Target_Index = upperbound(lstr_Component) + 1
				lstr_Component[ll_Target_Index].stext		= ids_sd_components.GetItemString(ll_Comp_Counter, "ctext") 
				lstr_Component[ll_Target_Index].ssnr  		= ids_sd_components.GetItemString(ll_Comp_Counter, "cpackinglist") 
				lstr_Component[ll_Target_Index].lquantity = ids_sd_components.GetItemNumber(ll_Comp_Counter, "nquantity")
				lstr_Component[ll_Target_Index].squantity = ""
				lstr_Component[ll_Target_Index].llength 	=  ids_sd_components.GetItemNumber(ll_Comp_Counter, "nlength") 
				lstr_Component[ll_Target_Index].str_item_props.stext					= ids_sd_components.GetItemString(ll_Comp_Counter, "CDISTR_TEXT")
				lstr_Component[ll_Target_Index].str_item_props.smeal_control_code = ids_sd_components.GetItemString(ll_Comp_Counter, "CMEAL_CONTROL_CODE")
				lstr_Component[ll_Target_Index].str_item_props.sclass					= ids_sd_components.GetItemString(ll_Comp_Counter, "cclass")
				lstr_Component[ll_Target_Index].str_item_props.lspml					= ids_sd_components.GetItemNumber(ll_Comp_Counter, "nspml")
				lstr_Component[ll_Target_Index].str_item_props.llimit = 0
							
				guoLog.uf_debug( "["+ this.classname( )+".List of Components COMPONENT " + lstr_Component[ll_Target_Index].ssnr + " CLASS:" + &
																		lstr_Component[ll_Target_Index].str_item_props.sclass + " " + &
																		lstr_Component[ll_Target_Index].str_item_props.smeal_control_code )

				
			end if
		Next
	End if	
Else
	For ll_Comp_Counter = 1 To ids_sd_components.RowCount()
		ll_Target_Index = upperbound(lstr_Component) + 1
		lstr_Component[ll_Target_Index].stext		= ids_sd_components.GetItemString(ll_Comp_Counter, "ctext") 
		lstr_Component[ll_Target_Index].ssnr  		= ids_sd_components.GetItemString(ll_Comp_Counter, "cpackinglist") 
		lstr_Component[ll_Target_Index].lquantity = ids_sd_components.GetItemNumber(ll_Comp_Counter, "nquantity") 
		lstr_Component[ll_Target_Index].squantity = ""
		lstr_Component[ll_Target_Index].llength 	=  ids_sd_components.GetItemNumber(ll_Comp_Counter, "nlength") 
		lstr_Component[ll_Target_Index].str_item_props.stext					= ids_sd_components.GetItemString(ll_Comp_Counter, "CDISTR_TEXT")  
		lstr_Component[ll_Target_Index].str_item_props.smeal_control_code = ids_sd_components.GetItemString(ll_Comp_Counter, "CMEAL_CONTROL_CODE")
		lstr_Component[ll_Target_Index].str_item_props.sclass					= ids_sd_components.GetItemString(ll_Comp_Counter, "cclass") 
		lstr_Component[ll_Target_Index].str_item_props.lspml					= ids_sd_components.GetItemNumber(ll_Comp_Counter, "nspml") 
		lstr_Component[ll_Target_Index].str_item_props.llimit = 0
	Next
End if

ll_Num_Components = upperbound(lstr_Component)

ls_ObjectName= "t_components_header"
ls_Text			= uf.translate("Mahlzeitenkomponenten")
of_create_text(ls_ObjectName, ls_Text,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD, llX, llY, llHeight + 4, llWidth, 0, 0,  RGB(0,0,0), 1)
llY = llY+ 2 * llHeight 

For ll_Index = 1 to ll_Num_Components
	ls_ObjectName= "t_components_data_amount_" + string(ll_Index)
	ls_Text = string(lstr_Component[ll_Index].lquantity)
	// #6466 if NAM Barcode is switched ON then exclude space for it  at detail bottom
	if (ib_nam_barcode_on_cartdiagram = FALSE AND llY <= llYMax ) OR (ib_nam_barcode_on_cartdiagram AND llY < llYMax - NAM_BARCODE_OFFSET) Then
		of_create_text(ls_ObjectName, ls_Text,FONT_MICROSOFT_SANS_SERIF, 14, FONT_NORMAL, llX   , llY +  0.2 * llHeight , 2 *  llHeight , llWidthAmount, 0, 0,  RGB(0,0,0), 1)
		
		ls_ObjectName= "t_components_data_text_" + string(ll_Index)
		ls_Text = lstr_Component[ll_Index].stext
	
		of_create_text(ls_ObjectName, ls_Text,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, llX + llWidthAmount +ll_Space, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)
		
		llY = llY+ llHeight
		
		ls_ObjectName= "t_components_data_snr_" + string(ll_Index)
		ls_Text =lstr_Component[ll_Index].ssnr
		of_create_text(ls_ObjectName,ls_Text,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, llX +llWidthAmount +ll_Space, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)
		
		llY = llY+2 * llHeight

	Else
		
		// 14.01.2014 Backlog
		//ls_Text = of_get_item_description( lstr_Component[ll_Index] )
		
		ls_Text= lstr_Component[ll_Index].ssnr + " - " + lstr_Component[ll_Index].stext
		If isNull(lstr_Component[ll_Index].squantity) Then lstr_Component[ll_Index].squantity = ""
		If ib_suppress_qty_1 = FALSE OR lstr_Component[ll_Index].squantity <> "1" Then
			If lstr_Component[ll_Index].squantity <> "0" AND Trim(lstr_Component[ll_Index].squantity) > "" then
				ls_Text = lstr_Component[ll_Index].squantity + " x " + ls_Text
			End if
		End if
				
		li_Succ = of_sd_add_backlog( 0, 0, "", lstr_Component[ll_Index].lquantity , "", ls_Text, ll_Index, LISTOFCOMPONENTS, ls_Text, al_row_id ) 
			
		lb_Overflow = TRUE	

	End If
Next

if llY > llYMax OR (ib_nam_barcode_on_cartdiagram ) Then
	
	If lb_Overflow Then
		ls_ObjectName= "t_components_end"
		//of_create_line(ls_ObjectName,llX - 10 , llY, llX + llWidth , llY, RGB(128, 128, 128))
		llY = llY+ llHeight
		ls_Text			= uf.translate("Weitere Elemente existieren...")
		of_create_text(ls_ObjectName, ls_Text,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD, llX, llY, llHeight , llWidth, 0, 0,  RGB(255,0,0), 1)
	End If
Else
//	ls_Text			= "End"
End If

li_Succ = ids_SD_Components.SetFilter("")
li_Succ = ids_SD_Components.Filter()
ll_Num_Components = ids_SD_Components.RowCount()

If lb_Sort_by_PL_Class_Leg Then	
	//li_Succ = ids_SD_Components.SetSort(ls_Original_Sort)
	li_Succ = ids_SD_Components.Sort()
end if


Return ll_Num_Components

end function

public function integer of_sd_save_distr_contents (s_distrib_items astr_distrib_items[], long al_rowid, long al_sd_cart_key, long al_page, long al_sd_drawer_key);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_save_distr_contents (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 s_distrib_items astr_distrib_items[]
*	 long al_rowid
*	 long al_sd_cart_key
*	 long al_page
*	 long al_sd_drawer_key
*
* Beschreibung:		Secondary Distribution - Save the Contents of Drawers / Trays to DataBase
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
* 1.1 			O.Hoefer	14.09.2018		LongLong f$$HEX1$$fc00$$ENDHEX$$r Sequence SEQ_CEN_OUT_SD_CONTENT - Issue 4103
*
*
* Return: integer
*
*/

Integer	li_Succ
Long		ll_Count, ll_Count_Sub
Long		ll_Num_Entries
Long		ll_Num_Sub_Entries
Long		ll_Key
Long		ll_New_Row, ll_New_Sub_Row
LongLong	lll_Sequence_CONTENT
Long		ll_Sequence_sub
String	ls_Temp, ls_Computed_Item
Boolean	lb_Breakpoint
s_component	lstr_comp


ll_Num_Entries = Upperbound(astr_distrib_items)

if al_rowid =  1000007 then
	lb_Breakpoint = TRUE
end if

For ll_Count = 1 To ll_Num_Entries
	
	If isnull(astr_distrib_items[ll_Count].sitem) Then 
		CONTINUE
	End If
	
	If trim(astr_distrib_items[ll_Count].sitem) = "" Then 
		CONTINUE
	End If
		
	If astr_distrib_items[ll_Count].lcount	= 0 Then
		CONTINUE
	End If
		
	ll_New_Row	= ids_SD_Drawer_Content.InsertRow(0)
	lll_Sequence_CONTENT = f_Sequence ("SEQ_CEN_OUT_SD_CONTENT", sqlca)
	If lll_Sequence_CONTENT <> -1 Then
		li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nsd_content_key", lll_Sequence_CONTENT)
	else
		uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
										 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
	end if
	
	If astr_distrib_items[ll_Count].cpackinglist = "CAAF46829" Then
		guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Drawer_Content " + astr_distrib_items[ll_Count].cpackinglist + " CLASS " + astr_distrib_items[ll_Count].str_prop.sclass )
	End if
	
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nresult_key", il_result_key )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "ntransaction", il_transaction )
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nrowid", al_rowid )
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nsd_cart_key", al_sd_cart_key )
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "npage", al_page )
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nsd_drawer_key", al_sd_drawer_key )
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "ncount", astr_distrib_items[ll_Count].lCount )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nlength", astr_distrib_items[ll_Count].llength )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "citem", astr_distrib_items[ll_Count].sitem )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nshortage", astr_distrib_items[ll_Count].lshortage )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "cpackinglist", astr_distrib_items[ll_Count].cpackinglist )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "ctext", astr_distrib_items[ll_Count].ctext )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "cparent", astr_distrib_items[ll_Count].sparent )	
	If astr_distrib_items[ll_Count].bcontent Then
		li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "ncontent", 1)						
	End If
	If astr_distrib_items[ll_Count].bbold Then
		li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nbold", 1)						
	End If
	If astr_distrib_items[ll_Count].bdistributed Then
		li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "ndistributed", 1)						
	End If
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nleg", astr_distrib_items[ll_Count].lleg )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "cdistr_text", astr_distrib_items[ll_Count].str_prop.stext )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "cmeal_control_code", astr_distrib_items[ll_Count].str_prop.smeal_control_code )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "cclass", astr_distrib_items[ll_Count].str_prop.sclass )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nspml", astr_distrib_items[ll_Count].str_prop.lspml )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nlimit", astr_distrib_items[ll_Count].str_prop.llimit )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "nremaining", astr_distrib_items[ll_Count].str_prop.lremaining )						
	li_Succ = ids_SD_Drawer_Content.SetItem(ll_New_Row, "ndontdistribute", astr_distrib_items[ll_Count].str_prop.ldontdistribute )						

Next

li_Succ = ids_SD_Drawer_Content.Update()

Return li_Succ

end function

public function long of_sd_draw_distributed_components (uo_distribution arg_uo_distribution, string arg_s_stowage, string arg_s_pl, long arg_l_lbelly, string arg_s_carttype, string arg_unit, date arg_departure, boolean arg_bexplode_parent, ref uo_content_sheet rauo_content_sheet, boolean ab_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents);
/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_distributed_components (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 09.11.2009
* Argument(e):
*  uo_distribution arg_uo_distribution
*  string arg_s_stowage
*  string arg_s_pl
*  long arg_l_lbelly
*  string arg_s_carttype
*
* Return: long
*
* Mahlzeitenverteilung durchf$$HEX1$$fc00$$ENDHEX$$hren.
* Zuerst alle zu verteilenden Komponenten in ein Array laden,
* anschlie$$HEX1$$df00$$ENDHEX$$end die Gr$$HEX2$$f600df00$$ENDHEX$$enverh$$HEX1$$e400$$ENDHEX$$ltnisse des Cart ermitteln und setzen.
* Nun die Attribute der Einsch$$HEX1$$fc00$$ENDHEX$$be (Tiefe, Order und Verteilungsparameter) holen und setzen
* Nach dem Setzen der Verteilungsstategie werden die Mahlzeiten verteilt.
* Mit der Nachbearbeitung werden die Bezeichnungen im Diagramm komprimiert.
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  09.11.2009	1.0           Ulrich Paudler     Erstellung
*  19.01.2010	1.1           Ulrich Paudler     nur Mengen > 1 mit Menge anzeigen, nlimit hinzu
*  26.01.2010	1.2           Ulrich Paudler     RuntimeError 16 Reparatur
*  27.01.2010	1.3           Ulrich Paudler     Jede Menge Yield( ) wg. Runtime error
*  13.12.2010	1.4           Oliver H$$HEX1$$f600$$ENDHEX$$fer			DRAWER_MULTI_RUNG hinzu
*  17.02.2011  1.5           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Suche & entferne EMPTY Drawers & Co
*  03.03.2011  1.6           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Normaler Content hinzu
*  03.03.2011  1.7           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Umsortieren: normaler Content vor verteilten Content
*  08.03.2011  1.8           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Distributed Content aufheben f$$HEX1$$fc00$$ENDHEX$$r Content Sheet
*  14.03.2011  1.9           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Fixed Content aufheben f$$HEX1$$fc00$$ENDHEX$$r Content Sheet
*  16.03.2011  1.10          Oliver H$$HEX1$$f600$$ENDHEX$$fer       Content Sheet: Sonderfall Explosion ohne Header Flag => Header
*	16.06.2011	1.11          Oliver H$$HEX1$$f600$$ENDHEX$$fer       Maskieren von Single Quotes
*	06.07.2011	1.12          Oliver H$$HEX1$$f600$$ENDHEX$$fer       Watermark-Aufruf korrigiert
*	20.08.2012	2.0           Oliver H$$HEX1$$f600$$ENDHEX$$fer       aus of_create_distribution herausgel$$HEX1$$f600$$ENDHEX$$st
*	26.11.2012	2.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Auch TRAYs ohne verteilte Komponenten m$$HEX1$$fc00$$ENDHEX$$ssen bearbeitet werden (Backlog)
*	23.01.2014	2.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       CBASE-UK-CR-2013-006 - Overflow on main page

*
*************************************************************/

Long			ll_Index, ll_RetVal
Long			ll_MaxColumns, ll_MaxRows, ll_Column, ll_Row, ll_Maxlength, ll_MaxContent
string		ls_DWObject, lsText
String		ls_temp
Long			ll_Rungs, ll_Cols
Integer		li_Succ 
Integer		li_Test, li_Mod
Long			ll_Target_pos
Long			ll_Count
Boolean		lb_Breakpoint
Long			ll_Count_2,ll_pl_Detail_key
String		ls_Computed_Item
String		ls_Alternative_Object
String		ls_Mod_String
Long			ll_IndexKey,ll_Content_Header_Detail_Key
String		ls_PL
Long			ll_XPos
Long			ll_Rows
Long			ll_New_Row
Boolean		lb_No_Components = FALSE
Boolean		lb_Bold = FALSE
Boolean		lb_Entire_Container_Empty = TRUE
DataStore	lds_Contents_2
String		ls_Temp_Content
String		ls_Temp_content_pl
Long			ll_temp_qty
Long			ll_Master_Setting
Long			ll_Sort_Counter
Boolean		lb_Header_Exists = FALSE
Long			ll_leg_from_ccode 
Boolean		lb_Watermark_Downline
Boolean		lb_Suppress_Watermark_Downline
Long						ll_sd_cart_key
Long						ll_Drawer_Explode_Setting
s_component				lstr_component_x
s_distrib_items		lstr_item[], lstr_item_empty[], lstr_temp[]


// Filter DataStores fur Current Entry
li_Succ = of_sd_set_filter_rowid(al_content_master_row_id)
il_Master_Row = al_content_master_row_id
if not isvalid(arg_uo_distribution) Then
	
	
	if of_is_backlog_enabled() Then
		li_Succ = of_sd_fill_backlog_data(al_content_master_row_id )
	End If
	// Nachbearbeitung Backlog, wird nur aktiv wenn auch etwas eingetragen ist
	ll_RetVal = of_fill_backlog_page()
	
	// -------------------------------------------------------------------
	// CBASE-UK-CR-2013-006
	// -------------------------------------------------------------------
	If ib_Overflow_on_Main AND il_Equipment_Width = 1 Then
		ll_RetVal = of_draw_backlog_on_main()
	End If
			
	return 0
End If

//uoDistribution = arg_uo_distribution
// 28.01.2010 Ulrich Paudler [UP] Sicher ist sicher!
if isvalid(iuo_CartDistribution) Then destroy iuo_CartDistribution
iuo_CartDistribution = create uo_cart_distribution
If is_section > "" Then
	iuo_CartDistribution.is_section = is_section
End if
iuo_CartDistribution.il_Disable_Debug = il_Disable_Debug

if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components ***** " + arg_s_pl + " *****")

If arg_s_pl = "PAMHC00008" OR arg_s_pl = "SQEH122I" Then
	lb_Breakpoint = TRUE
End If

If ib_use_doc_gen_settings Then
	iuo_CartDistribution.ib_use_doc_gen_settings = TRUE
	iuo_CartDistribution.inv_doc_gen_settings = inv_doc_gen_settings
End If

if bHasDimensions Then
	//ll_RetVal = ids_SD_Components.RowCount()   
	ll_RetVal = of_sd_create_component_list( al_content_master_row_id )
	If ll_RetVal = 0 Then
		lb_No_Components = TRUE
		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components COMPONENT LIST EMPTY " + arg_s_stowage + " / " + arg_s_pl )
	End If	
End If

// VerteilungsCart erzeugen
ll_RetVal = iuo_CartDistribution.of_get_cart_dimension( arg_s_carttype, il_AirlineKey, il_IndexKey, lDetailKey, ll_MaxColumns, ll_MaxRows, ll_Maxlength)
il_Equipment_Width = ll_MaxColumns
ll_RetVal = iuo_CartDistribution.of_create_cart(ll_MaxColumns, ll_MaxRows)
// Typ, Tiefe, Order & Properties setzen, jeder Einschub extra
for ll_Column = 1 to ll_MaxColumns
	for ll_Row = 1 to ll_MaxRows
		// Einschub-Properties setzen
		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components of_init_slot " +  String(ll_Row) + " " + String(ll_Column) )	
		li_Succ = of_init_slot( iuo_CartDistribution, ll_Row, ll_Column, ll_Maxlength)			
	Next
Next

// Verteilungsstrategie setzen
ll_RetVal = iuo_CartDistribution.of_set_allocation_mode(iuo_CartDistribution.BYORDER)
ll_RetVal = of_reset_backlog_page(TRAY)
ll_RetVal = of_reset_backlog_page(DRAWERFOOD)
ll_RetVal = of_reset_backlog_page(DRAWER_MULTI_RUNG)

// --------------------------------------------------------------------------------------------
// alle Komponenten in das Cartdiagram verteilen - ist bereits vorher passiert siehe DataStores
// --------------------------------------------------------------------------------------------
// Nachbearbeitung
// Am Ende dann den Text aller Trays $$HEX1$$e400$$ENDHEX$$ndern -> z.B. 2 x HM5271700
for ll_Column = 1 to ll_MaxColumns
	for ll_Row = 1 to ll_MaxRows
		
			
		lb_Suppress_Watermark_Downline = FALSE
		lb_Watermark_Downline = FALSE
		if of_get_type(ll_Row, ll_Column) = TRAY or of_get_type(ll_Row, ll_Column) = DRAWERFOOD Then
			// --------------------------------------------------------------------------------------------
			// Zeichne verteilte Inhalte TRAY / DRAWERFOOD
			// --------------------------------------------------------------------------------------------
			li_Succ = of_sd_draw_comp_tray(ll_column, ll_row, rads_distribution_contents, al_content_master_row_id, arg_unit)
			
		End If
		
		if of_get_type(ll_Row, ll_Column) = TRAYNONFOOD  Then
			// --------------------------------------------------------------------------------------------
			// TRAYNONFOOD 
			// --------------------------------------------------------------------------------------------
			li_Succ = of_sd_draw_comp_tray(ll_column, ll_row, rads_distribution_contents, al_content_master_row_id, arg_unit)				
		End If
		
		
		// DRAWER
		if of_get_type(ll_Row, ll_Column) = DRAWER Then
			If arg_s_pl = "PAMHC00008" OR arg_s_pl = "PLHBC50133" Then
				lb_Breakpoint = TRUE
			End If
			// --------------------------------------------------------------------------------------------
			// Zeichne XXX Inhalte DRAWER
			// --------------------------------------------------------------------------------------------
			ll_Master_Setting = of_get_explosion_setting(il_indexkey, arg_unit)
			// --------------------------------------------------------------------------------------------
			li_Succ = of_sd_draw_comp_drawer(ll_column, ll_row, rads_distribution_contents, al_content_master_row_id, arg_unit, ll_Master_Setting)
			//li_Succ = of_sd_draw_comp_drawer(ll_column, ll_row, rads_distribution_contents, al_content_master_row_id, arg_unit)				li_Succ = of_sd_draw_comp_drawer(ll_column, ll_row, rads_distribution_contents, al_content_master_row_id, arg_unit)
			
		End If
		
		if of_get_type(ll_Row, ll_Column) = DRAWER_MULTI_RUNG Then
			
			li_Succ =  of_distr_content_4_cs( rads_distribution_contents, ll_row, ll_column, al_content_master_row_id )
	
			// ----------------------------------------------------------------------------
			// Zeichne verteilte Inhalte DRAWER_MULTI_RUNG
			// ----------------------------------------------------------------------------
			
			If arg_s_pl = "PAASC30154" OR arg_s_pl = "7PTG00384" Then
				lb_Breakpoint = TRUE
			End If

			li_Succ = of_sd_draw_comp_multi(ll_row, ll_column, arg_unit, al_content_master_row_id)

		End If			
	Next
Next

If ids_sd_cart.RowCount() > 0 Then
	ll_sd_cart_key = ids_SD_Cart.GetItemNumber(1, "nsd_cart_key")
End if
// -------------------------------------------------------------------
// Suche & entferne EMPTY Drawers & Co
// -------------------------------------------------------------------
li_Succ = of_sd_remove_empty_drawers(al_content_master_row_id)	
if of_is_backlog_enabled() Then
	li_Succ = of_sd_fill_backlog_data(al_content_master_row_id )
End If
// Nachbearbeitung Backlog, wird nur aktiv wenn auch etwas eingetragen ist
ll_RetVal = of_fill_backlog_page()

// -------------------------------------------------------------------
// CBASE-UK-CR-2013-006
// -------------------------------------------------------------------
If ib_Overflow_on_Main AND il_Equipment_Width = 1 Then
	ll_RetVal = of_draw_backlog_on_main()
End If
			

If ab_content_sheet Then
//If ab_content_sheet = TRUE AND ib_non_sky = FALSE Then
	// -------------------------------------------------------------------------------------
	// Content Sheet Header: "alle Contents" - auch wenn Distribution nicht enabled
	// -------------------------------------------------------------------------------------
	li_Succ = of_sd_add_content_sheet_header(arg_s_carttype, arg_unit, rauo_content_sheet, al_content_master_row_id,rads_distribution_contents)
End If

If ib_non_sky Then
	// -------------------------------------------------------------------------------------
	// Content Sheet: aus Backlog bef$$HEX1$$fc00$$ENDHEX$$llen f$$HEX1$$fc00$$ENDHEX$$r non sky cities
	// -------------------------------------------------------------------------------------
	li_Succ = of_fill_non_sky_content_spec(arg_s_carttype, arg_unit, rauo_content_sheet, al_content_master_row_id,rads_distribution_contents)
End If


DESTROY lds_contents_2
DESTROY iuo_CartDistribution


if il_Disable_Debug= 0 then
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components ids_TR_Exclusions.RowCount: " + String(ids_TR_Exclusions.rowcount()))
End If

// Remove Filter "rowid" (Secondary Disttribution DataStores)
li_Succ = of_sd_set_filter_rowid(0)

Return 1

end function

public function integer of_sd_init (string as_unit, long al_index_key, long al_detail_key, long al_airline_key, date adt_departure);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_init (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 string as_unit
*	 long al_index_key
*	 long al_detail_key
*	 long al_airline_key
*	 date adt_departure
*
* Beschreibung:		Init DataStores
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: integer
*
*/


Long lRetval
Boolean	lb_NON_Sky


is_CSC = as_unit

lb_NON_Sky  = of_check_non_sky( as_unit )


This.il_IndexKey		= al_index_key
This.lDetailKey		= al_Detail_Key
This.il_AirlineKey	= al_Airline_key
This.idt_departure	= adt_Departure
This.bBacklog			= of_is_backlog_enabled()


SELECT  max(NLAYOUT_KEY) 
	INTO :This.lLayoutKey
	FROM CEN_PACKINGLIST_LAYOUT
	WHERE NPACKINGLIST_INDEX_KEY =:al_index_key AND NPACKINGLIST_DETAIL_KEY=:al_detail_key 
	USING SQLCA;
	if SQLCA.SQLCode <> 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".NO CEN_PACKINGLIST_LAYOUT for " + String(al_index_key) + " / " + String(al_detail_key))
		return -1
	End If	
	
// Dies ist jetzt die andere Unit (Einheit statt CSC)
SELECT  CUNIT
	INTO :This.sUnit
	FROM CEN_PACKINGLISTS
	WHERE NPACKINGLIST_INDEX_KEY =:al_index_key AND NPACKINGLIST_DETAIL_KEY=:al_detail_key 
	USING SQLCA;
	if SQLCA.SQLCode <> 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".NO CEN_PACKINGLISTS for " + String(al_index_key) + " / " + String(al_detail_key))
		return -1
	End If		

iCurrentRow			=	0
iCurrentColumn		=	0
lErrorCount			=	0
sError				=	""
lYOffSet				= 30 //1 //5 // war 50
lDefaultHeight		= 52 //48 // war 54

// Datastores zur$$HEX1$$fc00$$ENDHEX$$cksetzen
dsLayoutDetail.Reset()
dsLayoutContents.Reset()
dsLayoutDimension.Reset()
dsLayoutAddObjects.Reset()
dsPL.Reset()
dsPLContents.Reset()
dsObjects.Reset()

// 03.09.2009 Ulrich Paudler [UP]
dsBacklog.Reset()

lRetval = 	This.of_sd_init()

Return lRetval


end function

public function long of_sd_init ();/* 
* Funktion/Event: of_init
* Beschreibung: 	Layoutparameter lesen und Layout Zeichnen
*
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 
**
* Aenderungshistorie:
* 	Version 		Wer			Wann				Was und warum
*	1.0 		K.F$$HEX1$$f600$$ENDHEX$$rster		06.08.2008		Erstellung
*	1.1			U.Paudler  	15.04.2009		Fehlerbehandlung, R$$HEX1$$fc00$$ENDHEX$$ckgabewerte
*	1.2			U.Paudler  	03.09.2009		Backlog
*	1.3			U.Paudler  	30.09.2009		Cache Objekte einf$$HEX1$$fc00$$ENDHEX$$hren
*	1.4			U.Paudler  	27.10.2009		F$$HEX1$$fc00$$ENDHEX$$llzeilen f$$HEX1$$fc00$$ENDHEX$$r die Backlogseite
*	1.5			U.Paudler  	19.11.2009		Drawerfood und Traynonfood eingebaut
*	1.6			U.Paudler  	19.01.2010		Anzeigelayout initialiseren
*	1.7			U.Paudler  	03.02.2010		Floating Content 
*  1.8         O.H$$HEX1$$f600$$ENDHEX$$fer     01.10.2010     Watermark Downline f$$HEX1$$fc00$$ENDHEX$$r Leg>1 (Ranking & Stammdaten) 
*  1.9         O.H$$HEX1$$f600$$ENDHEX$$fer     16.11.2010     Watermark Downline abschaltbar
*
* Return Codes:
*		 1		Alles OK
*		-1		Equipment nicht definiert
*  	-2   	Fehler beim Anlegen der Standardwerte
*		-3		Standardwerte konnten nach Neuanlage nicht gelesen werden
*	   -4    Einschub Fehler
*		-5		Einschub Content Fehler
*		-6		Tray Fehler
*		-7		Tray Content Fehler
*/
Long	lLayoutDetailKeys[], ll_Row
Long iType, iContent, iRow, iColumn
String sDWButtonObject
Integer	li_Succ
Boolean	lb_Watermark_Downline = FALSE
Boolean	lb_downline_switch = FALSE

guoLog.uf_debug("["+ this.classname( )+".of_sd_init] Start")

//// 19.01.2010 Ulrich Paudler [UP]
//of_print_deinit()
//of_print_backlog_deinit()
//if isvalid(oDw) Then uf.translate_datawindow(oDw)
//if isvalid(oDs) Then uf.translate_datastore(oDs)
//
// --------------------------------------------------------------
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob es f$$HEX1$$fc00$$ENDHEX$$r den Containertypen Parameter gibt
// --------------------------------------------------------------
// Cache pr$$HEX1$$fc00$$ENDHEX$$fen
if  ilCachedAirlineKey = il_AirlineKey and isCachedUnit = this.sUnit and this.dsAirlineEq.RowCount() = 1 Then
Else
	this.dsAirlineEq.Retrieve(il_AirlineKey, this.sUnit)
	 ilCachedAirlineKey = il_AirlineKey
	 isCachedUnit = this.sUnit
End If

if this.dsAirlineEq.RowCount() <> 1 Then
	//Messagebox("Achtung", "F$$HEX1$$fc00$$ENDHEX$$r diese Airline wurde keine Equipment f$$HEX1$$fc00$$ENDHEX$$r den Container:" +this.sUnit + " gefunden!" )
	guoLog.uf_debug( "["+ this.classname( )+".NO dsAirlineEq for Airline " + String(il_AirlineKey) + " UNIT " + this.sUnit )
	il_Equipment_Width = 0 
	return -1
End If

If dsAirlineEq.RowCount() = 1 Then
	isContainerShortName = this.dsAirlineEq.GetItemString(1, "cunit")
	ilContainerType= this.dsAirlineEq.GetItemNumber(1, "ntype")
	il_Equipment_Width = this.dsAirlineEq.GetItemNumber(1, "ncolumns")
End If

// 16.01.2014 CBASE-UK-CR-2013-013
ib_Draw_Add_Text = of_is_add_on_text_enabled()

// --------------------------------------------------------------
// 06.05.2010, KF
// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob der SL Dimensionen zugeordnet sind
// --------------------------------------------------------------
Long lCount

select count(*) into :lCount from cen_packinglist_size where npackinglist_index_key = :this.il_IndexKey and npackinglist_detail_key = :this.lDetailKey;

if sqlca.sqlcode < 0 Then
	guoLog.uf_error("["+ this.classname( )+".of_sd_init] "  +  this.isStowage +" - " + "Error counting dimensions: " + sqlca.sqlerrtext )
	return -4
Elseif lCount > 0  Then // St$$HEX1$$fc00$$ENDHEX$$ckliste hat Dimensionen
	bHasDimensions = TRUE
Else // St$$HEX1$$fc00$$ENDHEX$$ckliste hat Dimensionen
	bHasDimensions = FALSE
End If

// --------------------------------------------------------------
// Layoutinformationen lesen, wenn es noch keine gibt, dann
// ein leeres Layout anlegen
// --------------------------------------------------------------
this.dsLayout.Retrieve(il_IndexKey, lDetailKey)

if this.dsLayout.RowCount() = 0 Then
	if this.of_create_defaults() <> 1 Then
		guoLog.uf_debug( "["+ this.classname( )+".dsLayout.RowCount()=0 of_create_defaults() <> 1")
		return -2
	Else
		this.dsLayout.Retrieve(il_IndexKey, lDetailKey)
		if this.dsLayout.RowCount() = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".dsLayout.RowCount()=0")
			return -3
		End If
	End If
Else
	// --------------------------------------------------------------
	// Belegung der Trolleys einlesen
	// --------------------------------------------------------------
	this.lLayoutKey 		= this.dsLayout.GetItemNumber(1, "nlayout_key")
	this.dsLayoutDetail.Retrieve(this.lLayoutKey)
	
//	f_print_datastore(this.dsLayoutDetail)
	
	// 26.01.2010 Ulrich Paudler [UP] Check layout
	if this.of_check_layout(il_IndexKey, lDetailKey) <> 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_check_layout<>0")
		return -2
	End If
	
End If

//// Alles Resetten
this.of_unregister_all()

// --------------------------------------------------------------
// Verweise in die Inhalte einlesen
// --------------------------------------------------------------
for ll_Row = 1 to this.dsLayoutDetail.RowCount()
	lLayoutDetailKeys[Upperbound(lLayoutDetailKeys) + 1] = this.dsLayoutDetail.GetItemNumber(ll_Row, "nlayout_detail_key") 
next

if UpperBound(lLayoutDetailKeys) = 0 Then lLayoutDetailKeys[Upperbound(lLayoutDetailKeys) + 1] = -1

dsLayoutContents.SetFilter("")
dsLayoutContents.Filter()
dsLayoutContents.Retrieve(lLayoutDetailKeys)

// --------------------------------------------------------------
// MZV Parameter einlesen....
// --------------------------------------------------------------
dsLayoutDimension.SetFilter("")
dsLayoutDimension.Filter()
dsLayoutDimension.Retrieve(lLayoutDetailKeys)

if il_Disable_Debug= 0 then
	guoLog.uf_debug( "["+ this.classname( )+".of_init dsLayoutDimension.RowCount " + String(dsLayoutDimension.RowCount()))
End If

// --------------------------------------------------------------
// Textobjekte/Bitmaps/Rectangles einlesen
// --------------------------------------------------------------
dsLayoutAddObjects.Retrieve(lLayoutKey)
// --------------------------------------------------------------
// St$$HEX1$$fc00$$ENDHEX$$cklisteninhalte einlesen
// --------------------------------------------------------------
this.dsPLContents.Retrieve(il_IndexKey, lDetailKey, datetime(idt_Departure))

// --------------------------------------------------------------
// Display of items on status "Billing" added 08/18/2010
// Items that are on status billing in any drawer should 
// not be displayed in the cart diagram.
// --------------------------------------------------------------
If ib_discard_status_billing Then
	li_Succ = of_remove_contents_billing(dsPLContents)
End If

// --------------------------------------------------------------
// 20.04.2010, KF
// Objekte die breiter geworden sind als die Seite
// wieder resizen
// --------------------------------------------------------------
this.of_check_object_width()


guoLog.uf_debug("["+ this.classname( )+".of_sd_init] Ende")

return 1
end function

public function integer of_sd_get_distr_content (long al_column, long al_row, ref s_distrib_items astr_item[]);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_get_distr_content (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long al_column
*	 long al_row
*	 ref s_distrib_items astr_item[]
*
* Beschreibung:		Secondary Distribution - get distributed (and maybe fixed) content
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: integer
*
*/

Long		ll_Count
Long		ll_Found
String	ls_Find
Long		ll_sd_drawer_key
Long		ll_Temp
Long		ll_Array_Size


ls_Find = "ncolumn=" + String(al_Column) + " AND nrung=" + String(al_Row)
ll_Found = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
If ll_Found > 0 then 
	ll_sd_drawer_key = ids_sd_cart_drawer.GetItemNumber(ll_Found, "nsd_drawer_key")
End If
	
For ll_Count = 1 To ids_sd_drawer_content.RowCount()
	ll_Temp = ids_sd_drawer_content.GetItemNumber(ll_Count, "nsd_drawer_key")
	If ll_Temp = ll_sd_drawer_key Then
		// 
		ll_Array_Size++
		astr_item[ll_Array_Size].lcount = ids_sd_drawer_content.GetItemNumber(ll_Count, "nCount")
		astr_item[ll_Array_Size].llength = ids_sd_drawer_content.GetItemNumber(ll_Count, "nlength")
		astr_item[ll_Array_Size].sitem = ids_sd_drawer_content.GetItemString(ll_Count, "citem")
		astr_item[ll_Array_Size].lshortage = ids_sd_drawer_content.GetItemNumber(ll_Count, "nshortage")
		astr_item[ll_Array_Size].cpackinglist = ids_sd_drawer_content.GetItemString(ll_Count, "cpackinglist")
		astr_item[ll_Array_Size].ctext = ids_sd_drawer_content.GetItemString(ll_Count, "ctext")
		astr_item[ll_Array_Size].sparent = ids_sd_drawer_content.GetItemString(ll_Count, "cparent")
		If ids_sd_drawer_content.GetItemNumber(ll_Count, "ncontent") = 1 Then
			astr_item[ll_Array_Size].bcontent = TRUE
		Else
			astr_item[ll_Array_Size].bcontent = FALSE			
		End If
		If ids_sd_drawer_content.GetItemNumber(ll_Count, "nbold") = 1 Then
			astr_item[ll_Array_Size].bbold = TRUE
		Else
			astr_item[ll_Array_Size].bbold = FALSE
		End If
		If ids_sd_drawer_content.GetItemNumber(ll_Count, "ndistributed") = 1 Then
			astr_item[ll_Array_Size].bdistributed = TRUE
		Else
			astr_item[ll_Array_Size].bdistributed = FALSE
		End If
		astr_item[ll_Array_Size].lleg = ids_sd_drawer_content.GetItemNumber(ll_Count, "nleg")
		astr_item[ll_Array_Size].str_prop.ldontdistribute = ids_sd_drawer_content.GetItemNumber(ll_Count, "ndontdistribute")
	      
      If ids_sd_drawer_content.GetItemNumber(ll_Count, "ndontdistribute") = 1 Then
         guoLog.uf_debug( "["+ this.classname( )+".of_sd_get_distr_content ndontdistribute=1 " + astr_item[ll_Array_Size].sitem)
      End If
      

	End If
Next

Return 1

end function

protected function integer of_sd_handle_empty_contents (long al_row, long al_column, ref boolean rab_empty, ref boolean rab_entire_container_empty, long al_sd_rowid, long al_sd_cart_key);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_handle_empty_contents (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.05.2011
*
* Argument(e):
* long al_row
*	 long al_column
*	 ref boolean rab_empty
*	 ref boolean rab_entire_container_empty
*
* Beschreibung:		Empty Contents - remove drawer / tray...
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.05.2011		Erstellung
*
*
* Return: integer
*
*/

Integer	li_Succ
String	ls_Find
Long		ll_SD_Drawer_Key
Long		ll_SD_Drawer_Row
Long		ll_Rungs
Long		ll_Cols


If rab_Empty Then
	if of_get_type(al_Row, al_Column) = TRAY Then
		If of_has_contents(al_Row, al_Column) THEN
			rab_Entire_Container_Empty = FALSE
			rab_Empty = FALSE
		Else
			ls_Find ="ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) + " and nrowid="+String( al_sd_rowid )
			ll_SD_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
			If ll_SD_Drawer_Row > 0 then
				li_Succ = ids_sd_cart_drawer.SetItem(ll_SD_Drawer_Row, "nempty", 1)
			Else
				ll_SD_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
				If ll_SD_Drawer_Row < 1 then
					ll_sd_drawer_key = f_Sequence ("SEQ_CEN_OUT_SD_DRAWER", sqlca)
					If ll_sd_drawer_key = -1 Then
						uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
														 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
					end if
					ll_SD_Drawer_Row = ids_SD_Cart_Drawer.Insertrow(0)					
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nresult_key", il_result_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntransaction", il_transaction )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrowid", al_sd_rowid )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_cart_key", al_sd_cart_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_drawer_key", ll_sd_drawer_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntype", TRAY )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ncolumn", al_Column )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrung", al_Row )
					li_Succ = ids_sd_cart_drawer.SetItem(ll_SD_Drawer_Row, "nempty", 1)
				End if
			End if	
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_handle_empty_contents TRAY C" + String(al_Column) + " / R" + String(al_Row))	
						
			If ib_Remove_Empty_Drawer Then
				of_remove_tray(al_row, al_column)
//				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				//t_wtrmrk_dwnln_c_02_r_13
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_handle_empty_contents DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00") + String(al_Column) + " / " + String(al_Row))	
				End If

			End If
		End If
		
	ElseIF of_get_type(al_Row, al_Column) = DRAWERFOOD OR of_get_type(al_Row, al_Column) = drawer_3rung then
		If of_has_contents(al_Row, al_Column) THEN
			rab_Entire_Container_Empty = FALSE
			rab_Empty = FALSE
		Else
			ls_Find ="ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) + " and nrowid="+String( al_sd_rowid )
			ll_SD_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
			If ll_SD_Drawer_Row > 0 then
				li_Succ = ids_sd_cart_drawer.SetItem(ll_SD_Drawer_Row, "nempty", 1)
			Else
				ll_SD_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
				If ll_SD_Drawer_Row < 1 then
					ll_sd_drawer_key = f_Sequence ("SEQ_CEN_OUT_SD_DRAWER", sqlca)
					If ll_sd_drawer_key = -1 Then
						uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
														 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
					end if
					ll_SD_Drawer_Row = ids_SD_Cart_Drawer.Insertrow(0)
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nresult_key", il_result_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntransaction", il_transaction )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrowid", al_sd_rowid )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_cart_key", al_sd_cart_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_drawer_key", ll_sd_drawer_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntype", of_get_type(al_Row, al_Column))
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ncolumn", al_Column )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrung", al_Row )	
					li_Succ = ids_sd_cart_drawer.SetItem(ll_SD_Drawer_Row, "nempty", 1)
				End if
			End if	
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_handle_empty_contents TRAY C" + String(al_Column) + " / R" + String(al_Row))	
			
			If ib_Remove_Empty_Drawer Then
				of_remove_drawer(al_Row, al_Column)
//				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_handle_empty_contents DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00") + String(al_Column) + " / " + String(al_Row))	
				End If
			End If
		End If
		
	ElseIF of_get_type(al_Row, al_Column) = drawer_multi_rung then
		If of_has_contents(al_Row, al_Column) THEN
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution DRAWER_MULTI_RUNG not empty " + String(al_Column) + " / " + String(al_Row))	
			End If
			rab_Entire_Container_Empty = FALSE
			rab_Empty = FALSE

		Else
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution DRAWER_MULTI_RUNG empty " + String(al_Column) + " / " + String(al_Row))	
			End If
				
			ls_Find ="ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) + " and nrowid="+String( al_sd_rowid )
			ll_SD_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
			If ll_SD_Drawer_Row > 0 then
				li_Succ = ids_sd_cart_drawer.SetItem(ll_SD_Drawer_Row, "nempty", 1)
			Else
				ll_SD_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
				If ll_SD_Drawer_Row < 1 then
					ll_sd_drawer_key = f_Sequence ("SEQ_CEN_OUT_SD_DRAWER", sqlca)
					If ll_sd_drawer_key = -1 Then
						uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
														 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
					end if
					ll_SD_Drawer_Row = ids_SD_Cart_Drawer.Insertrow(0)
					ll_Rungs = 0
					ll_Cols = 0
					li_Succ = of_get_rungs_and_cols( al_Row, al_Column, ll_rungs, ll_Cols )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nwidth", ll_Cols )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nheight", ll_rungs )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nresult_key", il_result_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntransaction", il_transaction )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrowid", al_sd_rowid )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_cart_key", al_sd_cart_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_drawer_key", ll_sd_drawer_key )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntype", drawer_multi_rung )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ncolumn", al_Column )
					li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrung", al_Row )		
					li_Succ = ids_sd_cart_drawer.SetItem(ll_SD_Drawer_Row, "nempty", 1)
				End if
			End if	
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_handle_empty_contents TRAY C" + String(al_Column) + " / R" + String(al_Row))	
							
			If ib_Remove_Empty_Drawer Then
				of_remove_drawer(al_Row, al_Column)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_handle_empty_contents DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00") + String(al_Column) + " / " + String(al_Row))	
				End If

			End If
		End If
		
	ElseIF of_get_type(al_Row, al_Column) = traynonfood then
		rab_Entire_Container_Empty = FALSE
		rab_Empty = FALSE
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution traynonfood => not empty " + String(al_Column) + " / " + String(al_Row))	
		End If
	Else
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution AFTER DIST CONTAINER WITHOUT TYPE " + String(al_Column) + " / " + String(al_Row))	
		End If
		li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(al_Column, "00") + "_r_" + string(al_Row, "00"), FALSE)
	End If
	
	if il_Disable_Debug = 0 or s_app.itrace > 0 Then
		if rab_Empty then
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution AFTER DIST CONTAINER EMPTY " + String(al_Column) + " / " + String(al_Row))	
			of_create_text("empty_flag_" + String(al_Column)+ "_" + String(al_Row), "E M P T Y",FONT_MICROSOFT_SANS_SERIF, 20, FONT_BOLD, lXOffset + ((al_Column -1) * lDefaultWidth) + 14, (al_Row *  lDefaultHeight) , 25 , TEXTWIDTHSMALL1 , 0, 0, rgb(255,0,0), 1)
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution AFTER DIST CONTAINER NOT EMPTY " + String(al_Column) + " / " + String(al_Row))								
		end if
	End If
end if	



Return 1
end function

public function long of_sd_add_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist, long arg_l_row_id);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_add_backlog (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long arg_l_row
*	 long arg_l_column
*	 string arg_s_object
*	 decimal arg_dec_items
*	 string arg_s_unit
*	 string arg_s_text
*	 long arg_l_counter
*	 long arg_l_type
*	 string arg_s_packinglist
*	 long arg_l_row_id
*
* Beschreibung:		Add Backlog Entry - Secondary Distribution
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
* 1.1 			O.Hoefer	15.01.2014		CBASE-NAM-CR-14001
*
*
* Return: long
*
*/


Integer	li_Succ
Long		ll_New_Row
String	ls_Text, ls_Backlog
Long		ll_MSG_Key

if il_Disable_Debug= 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_add_backlog Text " + arg_s_text + " / "  + " Qty " + String(arg_dec_items))


If Pos(arg_s_text, "JLEH102") > 0  then
	ll_New_Row = ll_New_Row 
End If

Choose Case arg_l_type
	Case EMPTY, BLOCKED
//		ls_Text =uf.translate( "Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		
	Case DRAWER 
//		ls_Text =uf.translate( "Drawer Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0

	Case TRAYNONFOOD
		ls_Text =uf.translate("Tray")
//		ls_Text =uf.translate("Tray Non Food")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0

	Case DRAWERFOOD
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if
		
	Case TRAY 
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if

	Case PACKINGLIST
		ls_Text =  arg_s_packinglist
		// Keine Menge > raus
//		if arg_dec_items = 0.0 Then	
			ls_Backlog = arg_s_text
			//return 0
			arg_dec_items = 1
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
//		Else
//			If arg_dec_items = 1 Then
//				ls_Backlog = arg_s_text
//			Else				
//				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
//				If arg_dec_items = long(arg_dec_items) Then
//					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
//				Else
//					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
//				End if
//			End If
//		End If
		
	Case DRAWER_Multi_rung
		ls_Text =  arg_s_packinglist
		ls_Backlog = arg_s_text
		// Keine Menge > raus
		if arg_dec_items = 0.0 Then	
			//return 0
			ls_Backlog = arg_s_text
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
		Else
//			If arg_dec_items <> 1 Then
//				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
//				If arg_dec_items = long(arg_dec_items) Then
//					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
//				Else
//					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
//				End if
//			Else
				ls_Backlog = arg_s_text
//			End If
		End if

		If Trim(arg_s_packinglist) = "" Then
			ls_Text =  uf.translate("Drawer")
			arg_l_type = PACKINGLIST
		End If
		
		
	Case LISTOFCOMPONENTS
		ls_Text =uf.translate( "Component List")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		
		guoLog.uf_debug( "["+ this.classname( )+".Component List BACKLOG  ("+String(arg_l_Row_id)+") " + arg_s_text )
	
end Choose

ll_MSG_Key = f_Sequence ("SEQ_CEN_OUT_SD_message", sqlca)
If ll_MSG_Key = -1 Then
	uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
									 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
	 Return -1
end if

If Pos(ls_Backlog, "JLEH102") > 0  then
	ll_New_Row = ll_New_Row 
End If

ll_New_Row = ids_SD_Message.insertrow(0)
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nresult_key", il_Result_Key )						
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "ntransaction", il_transaction )
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nrowid", arg_l_Row_id)
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "npage", ii_Current_Page)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nsd_msg_key", ll_MSG_Key)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nmsgtype", MSG_BACKLOG)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nrow",arg_l_row)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncolumn",arg_l_column)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cobject",arg_s_object)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nitems", arg_dec_items)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cunit", arg_s_unit)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncounter",arg_l_counter)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "ntype", arg_l_type)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cbacklog", ls_Backlog)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cpackinglist", ls_Text)

ids_SD_Message.sort()

Return ll_New_Row


end function

public function integer of_sd_fill_backlog_data (long arg_l_row_id);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_fill_backlog_data (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 09.08.2012
*
* Argument(e):
* long arg_l_row_id
*
* Beschreibung:		Fill Backlog DataStore from saved data (ids_SD_Message)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	09.08.2012		Erstellung
* 1.1 			O.Hoefer	15.01.2014		CBASE-NAM-CR-14001
* 1.2 			O.Hoefer	06.06.2014		CBASE-NAM-CR-14005
* 1.3 			O.Hoefer	12.09.2014		do not consolidate when stowage > empty
*
*
* Return: integer
*
*/

Integer	li_Succ
Long		ll_Count, ll_New_Row
Long		ll_Row_ID
Long		ll_Msg_Type
Long		ll_Row, ll_Column
Decimal	ldec_Items
Decimal	ldec_Old_Items
Long		ll_type
Long		ll_Counter
String	ls_Text
String	ls_Object
String	ls_Packinglist
String	ls_Backlog
String	ls_Unit
Long		ll_Found
String	ls_Find
String	ls_stowage	
Boolean	lb_Breakpoint



if ib_Enable_Meal_Distribution = TRUE Then
	dsBacklog.reset()
End If

ids_SD_Message.setfilter("")
ids_SD_Message.filter()

//if s_app.itrace > 0 Then
//	ids_SD_Message.saveas("c:\temp\cbase\ids_SD_Message_" +  String(arg_l_Row_id) + ".xls",excel5!,true )
//end if

ids_SD_Message.setfilter("nrowid=" + String(arg_l_Row_id))
ids_SD_Message.filter()


For ll_Count = 1 To ids_SD_Message.RowCount()

	ll_Row_ID = ids_SD_Message.GetItemNumber(ll_Count, "nrowid")
	
	If ll_Row_ID <> arg_l_Row_id Then 
		CONTINUE
	END IF
			
	ll_Msg_Type = ids_SD_Message.GetItemNumber(ll_Count, "nmsgtype")
	If ll_Msg_Type <> MSG_BACKLOG Then 
		CONTINUE
	END IF
	
	
	ll_Row			= ids_SD_Message.getitemnumber(ll_Count, "nrow")
	ll_Column		= ids_SD_Message.getitemnumber(ll_Count, "ncolumn")
	ldec_Items		= ids_SD_Message.getitemnumber(ll_Count, "nitems")
	ls_Unit			= ids_SD_Message.getitemstring(ll_Count, "cunit")
	ll_Counter		= ids_SD_Message.getitemnumber(ll_Count, "ncounter")
	ll_type			= ids_SD_Message.getitemnumber(ll_Count, "ntype")
	ls_Backlog		= ids_SD_Message.getitemstring(ll_Count, "cbacklog")
	ls_Packinglist	= ids_SD_Message.getitemstring(ll_Count, "cpackinglist")
	ls_Object		= ids_SD_Message.getitemstring(ll_Count, "cobject")
	
	ls_stowage		= ids_SD_Message.getitemstring(ll_Count, "cstowage")
	If isnull (ls_stowage) then
		ls_stowage = ""
	End If
	ls_stowage = trim(ls_stowage)

	If isnull(ldec_Items) OR ldec_Items = 0 Then
		ldec_Items = 1
	End If
	
	If ll_type = 0 OR isnull(ll_type) Then
		ll_type = 1
	End If
	
	If ll_type = 13 Then
		ll_type = 1
	End If
	
	If Pos(ls_Backlog, "'") > 0 AND Pos(ls_Backlog, "~'") < 1 then
		//ls_Backlog = f_replace(ls_Backlog, "'", "~~~'")
		ls_Find = "cbacklog='" +  f_replace(ls_Backlog, "'", "~~~'") + "'"
	Else
		ls_Find = "cbacklog='" + ls_Backlog + "'"
	End If
	
	//ls_Find = "cbacklog='" + ls_Backlog + "'"
	If ll_Column > 0 then
		ls_Find += " AND ncolumn=" + String(ll_Column) 
	End If
	If ll_Row > 0 then
		ls_Find += " AND nrow=" + String(ll_Row) 
	End If
	
	If ls_Packinglist = "Component List" Then
		lb_Breakpoint=TRUE
	End If
	
	If trim(ls_Packinglist) > "" then
		
		If Pos(ls_Packinglist, "'") > 0 AND Pos(ls_Packinglist, "~'") < 1 then
			//ls_Packinglist = f_replace(ls_Packinglist, "'", "~~~'")
			ls_Find += " AND cpackinglist='" +  f_replace(ls_Packinglist, "'", "~~~'") + "'"
		Else
			ls_Find += " AND cpackinglist='" + ls_Packinglist + "'"
		End If
		
		
	End If
		
	//  and ntype=" + String(ll_type) 
	ll_Found = dsBacklog.Find(ls_Find , 1, dsBacklog.RowCount()) 
	
	
	If Pos(ls_Packinglist, "JLEH102") > 0 then
		ll_Found = ll_Found 
	End If
	
	If Pos(ls_Packinglist, "Column") > 0 AND Pos(ls_Packinglist, "Rung") > 0 then
		ll_Found = 0 
	End If
	
	// Stowage => always new line
	If ls_stowage > "" Then
		ll_Found = 0 
	End If
	
	If ll_Found < 1 Then
		ll_New_Row		= dsBacklog.insertrow(0)
		li_Succ = dsBacklog.setitem(ll_New_Row, "nrow", ll_Row)
		li_Succ = dsBacklog.setitem(ll_New_Row, "ncolumn",ll_Column)
		li_Succ = dsBacklog.setitem(ll_New_Row, "cobject",ls_Object)
		li_Succ = dsBacklog.setitem(ll_New_Row, "nitems", ldec_Items)
		li_Succ = dsBacklog.setitem(ll_New_Row, "cunit", ls_Unit)
		li_Succ = dsBacklog.setitem(ll_New_Row, "ncounter",ll_Counter)
		//li_Succ = dsBacklog.setitem(ll_New_Row, "ntype", ll_type)
		li_Succ = dsBacklog.setitem(ll_New_Row, "ntype", 1)
		li_Succ = dsBacklog.setitem(ll_New_Row, "cbacklog", ls_Backlog)
		li_Succ = dsBacklog.setitem(ll_New_Row, "cpackinglist", ls_Packinglist)
		// Sort
		li_Succ = dsBacklog.setitem(ll_New_Row, "nsort",ll_New_Row)
		If ls_stowage > "" Then
			li_Succ = dsBacklog.setitem(ll_New_Row, "cstowage", left(ls_stowage, 1000))			
		End If
	ElseIf ll_Found > 0 Then
		ldec_Old_Items = dsBacklog.getitemnumber(ll_Found, "nitems")
		//If ldec_Old_Items Then
		ldec_Items = ldec_Old_Items + ldec_Items
		li_Succ = dsBacklog.setitem(ll_Found, "nitems", ldec_Items)

		li_Succ = dsBacklog.setitem(ll_Found, "ntype", 1)

	End If
Next

ids_SD_Message.setfilter("")
ids_SD_Message.filter()


dsBacklog.sort()

Return ll_New_Row


end function

public function long of_sd_add_content_backlog_tray (long arg_l_counter, long arg_i_row, long arg_i_column, string arg_s_text, long arg_l_type, decimal arg_dec_qty, long arg_l_row_id);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_add_content_backlog_tray (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long arg_l_counter
*	 long arg_i_row
*	 long arg_i_column
*	 string arg_s_text
*	 long arg_l_type
*	 decimal arg_dec_qty
*	 long arg_l_row_id
*
* Beschreibung:		Secondary Distribution - Backlog Entry (Tray)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: long
*
*/

Integer	li_Succ 


li_Succ = of_sd_add_backlog( arg_i_row, arg_i_column, "NONE", arg_dec_qty , "", arg_s_text, arg_l_counter, arg_l_type, "", arg_l_row_id)

Return 1

end function

public function long of_sd_add_content_backlog_drawer (long arg_l_counter, long arg_i_row, long arg_i_column, datastore arg_ds_data, long arg_l_type, string arg_s_header, long arg_l_rowid);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_add_content_backlog_drawer (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
* long arg_l_counter
*	 long arg_i_row
*	 long arg_i_column
*	 datastore arg_ds_data
*	 long arg_l_type
*	 string arg_s_header
*	 long arg_l_rowid
*
* Beschreibung:		Secondary Distribution - Backlog Entry (Drawet)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: long
*
*/


Integer		li_Succ
String		ls_DWObject, ls_text, ls_unit
Decimal		ld_items
s_component lstr_component 

// Textfeld
ls_DWObject = "t_content_backlog_drawer_text_" + string(arg_l_counter) + "_col_" + string(arg_i_column, "00") + "_row_" + string(arg_i_row, "00")
if of_register(ls_DWObject, arg_i_row, arg_i_column) = -1 Then
	//return -1
End If

ld_items 	= arg_ds_data.GetItemdecimal(arg_l_counter, "nquantity")
ls_unit		= arg_ds_data.GetItemString(arg_l_counter, "details_cunit")
lstr_component.stext = arg_ds_data.GetItemString(arg_l_counter, "cpackinglist_text")
lstr_component.ssnr = arg_ds_data.GetItemString(arg_l_counter, "cpackinglist_detail")	
If isnull(ld_items) then ld_items = 0 
//lstr_component.squantity =  String(ld_items, "#0") //""

ls_text = of_get_item_description( lstr_component )

if arg_s_header = "" Then
	li_Succ = of_sd_add_backlog( arg_i_row, arg_i_column, ls_DWObject, ld_items, ls_unit, ls_text, arg_l_counter, arg_l_type, "", arg_l_rowid) 
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_backlog_drawer of_add_backlog TYPE=" + String(arg_l_type) +  " DS-Row " + String(arg_l_counter) + " / " + ls_text)
Else
	li_Succ = of_sd_add_backlog( arg_i_row, arg_i_column, ls_DWObject,ld_items,ls_unit, ls_text, arg_l_counter, arg_l_type, arg_s_header, arg_l_rowid) 
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_backlog_drawer of_add_backlog PACKINGLIST DS-Row " + String(arg_l_counter) + " / arg_s_header=" + arg_s_header + ": " + ls_text)
End If


return 1

end function

public function long of_sd_distribute_components (uo_distribution arg_uo_distribution, string arg_s_galley, string arg_s_stowage_only, string arg_s_stowage, string arg_s_pl, long arg_l_lbelly, string arg_s_carttype, string arg_unit, date arg_departure, boolean arg_bexplode_parent, ref uo_content_sheet rauo_content_sheet, boolean ab_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents, long al_sd_rowid, long al_sd_cart_key, long al_page, string as_loadinglist);
/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_sd_distribute_components (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 09.11.2009
* Argument(e):
*  uo_distribution arg_uo_distribution
*  string arg_s_stowage
*  string arg_s_pl
*  long arg_l_lbelly
*  string arg_s_carttype
*
* Return: long
*
* Mahlzeitenverteilung durchf$$HEX1$$fc00$$ENDHEX$$hren.
* Zuerst alle zu verteilenden Komponenten in ein Array laden,
* anschlie$$HEX1$$df00$$ENDHEX$$end die Gr$$HEX2$$f600df00$$ENDHEX$$enverh$$HEX1$$e400$$ENDHEX$$ltnisse des Cart ermitteln und setzen.
* Nun die Attribute der Einsch$$HEX1$$fc00$$ENDHEX$$be (Tiefe, Order und Verteilungsparameter) holen und setzen
* Nach dem Setzen der Verteilungsstategie werden die Mahlzeiten verteilt.
* Mit der Nachbearbeitung werden die Bezeichnungen im Diagramm komprimiert.
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  09.11.2009	1.0           Ulrich Paudler     Erstellung
*  19.01.2010	1.1           Ulrich Paudler     nur Mengen > 1 mit Menge anzeigen, nlimit hinzu
*  26.01.2010	1.2           Ulrich Paudler     RuntimeError 16 Reparatur
*  27.01.2010	1.3           Ulrich Paudler     Jede Menge Yield( ) wg. Runtime error
*  13.12.2010	1.4           Oliver H$$HEX1$$f600$$ENDHEX$$fer			DRAWER_MULTI_RUNG hinzu
*  17.02.2011  1.5           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Suche & entferne EMPTY Drawers & Co
*  03.03.2011  1.6           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Normaler Content hinzu
*  03.03.2011  1.7           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Umsortieren: normaler Content vor verteilten Content
*  08.03.2011  1.8           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Distributed Content aufheben f$$HEX1$$fc00$$ENDHEX$$r Content Sheet
*  14.03.2011  1.9           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Fixed Content aufheben f$$HEX1$$fc00$$ENDHEX$$r Content Sheet
*  16.03.2011  1.10          Oliver H$$HEX1$$f600$$ENDHEX$$fer       Content Sheet: Sonderfall Explosion ohne Header Flag => Header
*	16.06.2011	1.11          Oliver H$$HEX1$$f600$$ENDHEX$$fer       Maskieren von Single Quotes
*	06.07.2011	1.12          Oliver H$$HEX1$$f600$$ENDHEX$$fer       Watermark-Aufruf korrigiert
*	20.08.2012	2.0           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Modularisierung
*	12.06.2013	2.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       IM10379289 Exact Match ja, aber ohne Ber$$HEX1$$fc00$$ENDHEX$$cksichtigung SPML
*
*************************************************************/

Boolean		lb_No_Components					= FALSE
Boolean		lb_Entire_Container_Empty		= TRUE
Boolean		lb_Watermark_Downline
Boolean		lb_Suppress_Watermark_Downline
Boolean		lb_Dont_Distribute
Integer		li_Succ 
Long			ll_MaxColumns, ll_MaxRows
Long			ll_Row, ll_Column
Long			ll_Maxlength, ll_MaxContent
Long			ll_RetVal
Long			ll_Rungs, ll_Cols
Long			ll_Count
Long			ll_Unallocated_Qty
Long			ll_Unallocated_Counter
Long			ll_Rows
Long			ll_Min_Fit_Factor_Setting 

il_Master_Row = al_sd_rowid

//if il_Disable_Debug = 0 Then 
guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ***** " + arg_s_pl + " *****")

li_Succ = ids_sd_components.setfilter("nrowid="+String( al_sd_rowid ))
li_Succ = ids_sd_components.filter()
ll_Rows = ids_sd_components.Rowcount()
For ll_Count = 1 To ll_Rows
	ll_Unallocated_Qty = ids_sd_components.getItemNumber(ll_Count,"nquantity")
	li_Succ = ids_sd_components.SetItem(ll_Count, "nunallocated", ll_Unallocated_Qty)
Next

// Bei Schalter "Exact Match": nur eine Verteilungsrunde mit Min Fit = 4
If ib_require_exact_match then
	ll_Min_Fit_Factor_Setting = 4
	// -------------------------------------------------------------
	// IM10379289 Exact Match ja, aber ohne Ber$$HEX1$$fc00$$ENDHEX$$cksichtigung SPML
	// -------------------------------------------------------------
	If ib_exact_match_ignore_SPML Then
		ll_Min_Fit_Factor_Setting = 3
		//if il_Disable_Debug = 0 Then 
		guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components require exact match=ON BUT IGNORE SPML setting ll_Min_Fit_Factor_Setting="+ String(ll_Min_Fit_Factor_Setting))
	End If
End If

ii_current_page = al_page

if not isvalid(arg_uo_distribution) Then
	return 0
End If

//uoDistribution = arg_uo_distribution
// 28.01.2010 Ulrich Paudler [UP] Sicher ist sicher!
if isvalid(iuo_CartDistribution) Then destroy iuo_CartDistribution
iuo_CartDistribution = create uo_cart_distribution
If is_section > "" Then
	iuo_CartDistribution.is_section = is_section
End if
iuo_CartDistribution.ib_suppress_qty_1 = ib_suppress_qty_1

If ib_use_doc_gen_settings Then
	iuo_CartDistribution.ib_use_doc_gen_settings = TRUE
	iuo_CartDistribution.inv_doc_gen_settings = inv_doc_gen_settings
End If

if not isvalid(iuo_CartDistribution) Then 
	if isvalid(iuo_CartDistribution) Then destroy iuo_CartDistribution
	return 0
End If

if bHasDimensions Then
	ll_RetVal = of_sd_fill_component_list(arg_uo_distribution, al_content_master_row_id , arg_s_stowage, arg_s_pl, arg_l_lbelly)
	If ll_RetVal = 0 Then
		lb_No_Components = TRUE
		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components COMPONENT LIST EMPTY " + arg_s_stowage + " / " + arg_s_pl )
	End If	
End If

// VerteilungsCart erzeugen
ll_RetVal = iuo_CartDistribution.of_get_cart_dimension( arg_s_carttype, il_AirlineKey, il_IndexKey, lDetailKey, ll_MaxColumns, ll_MaxRows, ll_Maxlength)
ll_RetVal = iuo_CartDistribution.of_create_cart(ll_MaxColumns, ll_MaxRows)
// Typ, Tiefe, Order & Properties setzen, jeder Einschub extra
for ll_Column = 1 to ll_MaxColumns
	for ll_Row = 1 to ll_MaxRows
		// Einschub-Properties setzen
		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components of_init_slot " +  String(ll_Row) + " " + String(ll_Column) )	
		li_Succ = of_init_slot( iuo_CartDistribution, ll_Row, ll_Column, ll_Maxlength)			
	Next
Next

//If il_Disable_Debug = 0 Then iuo_CartDistribution.of_save_idsAllocateProps(arg_s_pl )

ll_Rows = ids_sd_components.Rowcount()
li_Succ = ids_sd_components.setfilter("nrowid=" + String(al_sd_rowid))
li_Succ = ids_sd_components.filter()
ll_Rows = ids_sd_components.Rowcount()

// Verteilungsstrategie setzen
ll_RetVal = iuo_CartDistribution.of_set_allocation_mode(iuo_CartDistribution.BYORDER)
ll_RetVal = of_reset_backlog_page(TRAY)
ll_RetVal = of_reset_backlog_page(DRAWERFOOD)
ll_RetVal = of_reset_backlog_page(DRAWER_MULTI_RUNG)

if al_sd_rowid =  1000007  then
	al_sd_rowid = al_sd_rowid
end if


// -----------------------------------------------------------------
// Hauptschleife - alle Komponenten in das Cartdiagram verteilen
// -----------------------------------------------------------------
li_Succ = of_sd_distribute_components_alloc( ll_min_fit_factor_setting, arg_departure, arg_unit, al_content_master_row_id, al_sd_cart_key, arg_s_galley, arg_s_stowage_only, arg_s_pl, as_loadinglist, lb_Entire_Container_Empty )

// -----------------------------------------------------------------
// Items zusammenfassen
// -----------------------------------------------------------------
ll_RetVal = iuo_CartDistribution.of_combine_item()

// -----------------------------------------------------------------
// Texte anpassen -> Qty / Header / Bold etc.
// -----------------------------------------------------------------
for ll_Column = 1 to ll_MaxColumns
	for ll_Row = 1 to ll_MaxRows			
		lb_Suppress_Watermark_Downline = FALSE
		lb_Watermark_Downline = FALSE
		if of_get_type(ll_Row, ll_Column) = TRAY or of_get_type(ll_Row, ll_Column) = DRAWERFOOD Then
			// --------------------------------------------------------------------------------------
			// Food Tray / Food Drawer				
			// --------------------------------------------------------------------------------------				
			li_Succ = of_sd_distribute_components_tray(ll_column, ll_row, arg_unit, rads_distribution_contents, al_content_master_row_id, al_sd_cart_key, al_page, lb_watermark_downline, lb_suppress_watermark_downline)
		End If
								
		if of_get_type(ll_Row, ll_Column) = DRAWER_MULTI_RUNG Then
			// -----------------------------------------------------------------------------------
			// DRAWER_MULTI_RUNG: Aufgabe: feste Inhalte VOR DISTRIBUTED CONTENT einsortieren)
			// -----------------------------------------------------------------------------------
			li_Succ = of_sd_distribute_components_multi(ll_column, ll_row, arg_unit, rads_distribution_contents, al_content_master_row_id, al_sd_cart_key, al_page, lb_watermark_downline, lb_suppress_watermark_downline)
		End If			
		
	Next
Next

// -------------------------------------------------------------------
// Suche & entferne EMPTY Drawers & Co
// -------------------------------------------------------------------
li_Succ = of_sd_distribute_components_empty( lb_entire_container_empty, ll_maxcolumns, ll_maxrows, iuo_CartDistribution, al_sd_rowid, al_sd_cart_key, lb_no_components, arg_s_pl, arg_departure, arg_s_stowage)

// Nachbearbeitung Backlog, wird nur aktiv wenn auch etwas eingetragen ist
ll_RetVal = of_fill_backlog_page()	

//// -------------------------------------------------------------------------------------
//// Content Sheet Header: "alle Contents" - auch wenn Distribution nicht enabled
//// -------------------------------------------------------------------------------------
//li_Succ = of_sd_add_content_sheet_header(arg_s_carttype, arg_unit, rauo_content_sheet, al_content_master_row_id,rads_distribution_contents)

DESTROY iuo_CartDistribution

If il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ids_TR_Exclusions.RowCount: " + String(ids_TR_Exclusions.rowcount()))

li_Succ = ids_sd_components.setfilter("")
li_Succ = ids_sd_components.filter()
ll_Rows = ids_sd_components.Rowcount()

Return 1

end function

public function long of_sd_add_error (long al_row_id, string as_galley, string as_stowage, string as_cart, string as_loadinglist, string as_component, string as_text, long al_distribution, string as_parameter, string as_definition, string as_unit, string as_information);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_add_error (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long al_row_id
*	 string as_galley
*	 string as_stowage
*	 string as_cart
*	 string as_loadinglist
*	 string as_component
*	 string as_text
*	 long al_distribution
*	 string as_parameter
*	 string as_definition
*	 string as_unit
*
* Beschreibung:		Add Entry "Secondary Distribution Error" (ids_SD_Message / cen_out_sd_message)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: long
*
*/

Integer	li_Succ
Long		ll_New_Row
Long		ll_MSG_Key


if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_add_error Text " + as_COMPONENT + " / " + as_PARAMETER)

ll_MSG_Key = f_Sequence ("SEQ_CEN_OUT_SD_message", sqlca)
If ll_MSG_Key = -1 Then
	uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
									 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
	 Return -1
end if

ll_New_Row = ids_SD_Message.insertrow(0)

li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nresult_key", il_Result_Key )						
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "ntransaction", il_transaction )
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nrowid", al_Row_id)
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "npage", ii_Current_Page)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nsd_msg_key", ll_MSG_Key)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nmsgtype", MSG_ERROR)
// Secondary Distribution Error Report
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CGALLEY",as_galley)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CSTOWAGE",as_stowage)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CCART",as_cart)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CLOADINGLIST",as_LOADINGLIST)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CCOMPONENT",as_COMPONENT)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CTEXT",as_TEXT)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "NDISTRIBUTION",al_DISTRIBUTION)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CPARAMETER",as_PARAMETER)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CPACKINGLIST",as_Definition)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CUNIT",as_unit)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cbacklog", as_Information)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "nrow",arg_l_row)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncolumn",arg_l_column)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "cobject",arg_s_object)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "nitems", arg_dec_items)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncounter",arg_l_counter)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "ntype", arg_l_type)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "cpackinglist", lsText)

ids_SD_Message.sort()

Return ll_New_Row

end function

public function integer of_sd_set_filter_rowid (long al_content_master_row_id);
Integer	li_Succ
Long		ll_Rows

If al_content_master_row_id = 0 Then
	li_Succ = ids_SD_Components.SetFilter("")
	li_Succ = ids_SD_Cart.SetFilter("")
	li_Succ = ids_SD_Cart_Drawer.SetFilter("")
	li_Succ = ids_SD_Drawer_Content.SetFilter("")
	li_Succ = ids_SD_Message.SetFilter("")
	
Else
	li_Succ = ids_SD_Components.SetFilter("nrowid=" + String(al_content_master_row_id))
	li_Succ = ids_SD_Cart.SetFilter("nrowid=" + String(al_content_master_row_id))
	li_Succ = ids_SD_Cart_Drawer.SetFilter("nrowid=" + String(al_content_master_row_id))
	li_Succ = ids_SD_Drawer_Content.SetFilter("nrowid=" + String(al_content_master_row_id))
	li_Succ = ids_SD_Message.SetFilter("nrowid=" + String(al_content_master_row_id))

End If

li_Succ = ids_SD_Components.Filter()
li_Succ = ids_SD_Components.Sort()
ll_Rows = ids_SD_Components.RowCount()

li_Succ = ids_SD_Cart.Filter()
ll_Rows = ids_SD_Cart.RowCount()

li_Succ = ids_SD_Cart_Drawer.Filter()
li_Succ = ids_SD_Cart_Drawer.Sort()
ll_Rows = ids_SD_Cart_Drawer.RowCount()

li_Succ = ids_SD_Drawer_Content.Filter()
li_Succ = ids_SD_Drawer_Content.Sort()
ll_Rows = ids_SD_Drawer_Content.RowCount()

li_Succ = ids_SD_Message.Filter()
li_Succ = ids_SD_Message.Sort()
ll_Rows = ids_SD_Message.RowCount()

Return 1

end function

public function integer of_sd_add_content_sheet_header (string arg_s_carttype, string arg_unit, uo_content_sheet rauo_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_sd_add_content_sheet_header (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 17.05.2016
//
// Argument(e):
// string arg_s_carttype
//	 string arg_unit
//	 uo_content_sheet rauo_content_sheet
//	 long al_content_master_row_id
//	 datastore rads_distribution_contents
//
// Beschreibung:		Content Spec Header
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	17.05.2016		Erstellung
//
//
// Return: integer
//
// --------------------------------------------------------------------------------


Integer		li_Succ
Long			llMaxColumns, llMaxRows, llMaxlength
Long			ll_New_Row
Integer		li_Return = 1
Long			llFound
Long			llRetVal
Long			llLayoutDetailKey
Long			ll_Column
Long			ll_Row
Long			ll_Start_Pos
Long			ll_Sort_Counter
Long			ll_Count_Fixed
Long			ll_temp_qty
Long			ll_Content_Header_Detail_Key
Boolean		lb_true = TRUE
String		ls_temp_content_pl
String		ls_temp_content
s_distrib_items		lstr_item[]
s_distrib_items		lstr_item_empty[]
s_distrib_items		lstr_item_fixed[]


// NAM CR 16008 bei non sky ist content spec = overflow
If ib_non_sky then
//	return li_Return
end if
	// -------------------------------------------------------------------------------------
	// Content Sheet Header: "alle Contents" - auch wenn Distribution nicht enabled
	// -------------------------------------------------------------------------------------
	llRetVal = iuo_CartDistribution.of_get_cart_dimension( arg_s_carttype, il_AirlineKey, il_IndexKey, lDetailKey, llMaxColumns, llMaxRows, llMaxlength)
	If llRetVal = -1 Then
		if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components NO VALID CART (Dimensions)")
	Else
		for ll_Column = 1 to llMaxColumns
			for ll_Row = 1 to llMaxRows
				lstr_item = lstr_item_empty
				llFound = this.dsLayoutDetail.Find("ncolumn=" + string(ll_Column) + " and nrow=" + string(ll_Row), 1, this.dsLayoutDetail.Rowcount())							
				if llFound > 0 Then
					llLayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(llFound, "nlayout_detail_key")
					// -------------------------------------------------
					// Unterscheidung NON-Food Trays und Drawers & Rest
					// -------------------------------------------------
					Choose Case of_get_type(ll_Row, ll_Column)
						Case DRAWER, TRAY, DRAWERFOOD, TRAYNONFOOD, DRAWER_3RUNG, DRAWERFOOD_3RUNG, DRAWER_MULTI_RUNG
							// -----------------------------------------
							// 1. Durchgang - nur mit Header Flag
							// -----------------------------------------
							lstr_item_fixed = lstr_item_empty
							IF of_get_content_sheet_contents(llLayoutDetailKey, ll_Row, ll_Column, arg_unit, ll_Start_Pos, lstr_item_fixed, lb_true) > 0 Then
								ll_Sort_Counter = rauo_content_sheet.dsLoadingHeader.RowCount() + 1
								For ll_Count_Fixed = 1 To Upperbound(lstr_item_fixed)
									If trim(lstr_item_fixed[ll_Count_Fixed].sitem) > "" then
										ll_New_Row = rauo_content_sheet.dsLoadingHeader.InsertRow(0)
										ll_Content_Header_Detail_Key = (ll_Column * 1000) + ll_Row								
										li_Succ = rauo_Content_Sheet.dsLoadingHeader.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key	)
										li_Succ = rauo_content_sheet.dsLoadingHeader.SetItem(ll_New_Row, "nrowid", al_content_master_row_id)
										ls_temp_content_pl = lstr_item_fixed[ll_Count_Fixed].cpackinglist  
										li_Succ = rauo_content_sheet.dsLoadingHeader.SetItem(ll_New_Row, "cpackinglist", ls_temp_content_pl)
										ls_temp_content = lstr_item_fixed[ll_Count_Fixed].ctext 
										li_Succ = rauo_content_sheet.dsLoadingHeader.SetItem(ll_New_Row, "ctext", ls_temp_content)
										If Trim(ls_temp_content) = "" Then
											li_Succ = rauo_content_sheet.dsLoadingHeader.SetItem(ll_New_Row, "ctext", lstr_item_fixed[ll_Count_Fixed].sitem)
										End If
										if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components content sheet HEADER FIXED ITEM RowId=" + String(al_content_master_row_id) + " Detail=" + String(ll_Content_Header_Detail_Key)   + " C"+ String(ll_Column) + "R"  + String(ll_Row)  + " / "  + ls_temp_content + " / " + ls_temp_content_pl + " / " + lstr_item_fixed[ll_Count_Fixed].sitem)
										ll_temp_qty = lstr_item_fixed[ll_Count_Fixed].lcount 
										li_Succ = rauo_content_sheet.dsLoadingHeader.SetItem(ll_New_Row, "nquantity", ll_temp_qty)
										ll_Sort_Counter++
										li_Succ = rauo_content_sheet.dsLoadingHeader.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
									End If
								Next
							End If
							// -----------------------------------------
							// 2. Durchgang - nur ohne Header Flag
							// -----------------------------------------
							lstr_item_fixed = lstr_item_empty
							IF of_get_content_sheet_contents(llLayoutDetailKey, ll_Row, ll_Column, arg_unit, ll_Start_Pos, lstr_item_fixed, FALSE) > 0 Then
								ll_Sort_Counter = rads_distribution_contents.RowCount() + 1
								For ll_Count_Fixed = 1 To Upperbound(lstr_item_fixed)
									If trim(lstr_item_fixed[ll_Count_Fixed].sitem) > "" then
										If lstr_item_fixed[ll_Count_Fixed].lcount  = 0 then
											guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components qty=0 SKIP " + + lstr_item_fixed[ll_Count_Fixed].sitem)
											CONTINUE
										end if
										ll_New_Row = rads_distribution_contents.InsertRow(0)
										ll_Content_Header_Detail_Key = (ll_Column * 1000) + ll_Row								
										li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key	)
										li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nrowid", al_content_master_row_id)
										ls_temp_content_pl = lstr_item_fixed[ll_Count_Fixed].cpackinglist  
										li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "cpackinglist", ls_temp_content_pl)
										ls_temp_content = lstr_item_fixed[ll_Count_Fixed].ctext 
										li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", ls_temp_content)
										If Trim(ls_temp_content) = "" Then
											li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", lstr_item_fixed[ll_Count_Fixed].sitem)
										End If
										
										if il_Disable_Debug = 0 then
											If isnull(ls_temp_content) then ls_temp_content = "NULL"
											If isnull(ls_temp_content_pl) then ls_temp_content_pl = "NULL"			
											guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components content sheet CONTENT (w/o HEADER) FIXED ITEM RowId=" + String(al_content_master_row_id) + " Detail=" + String(ll_Content_Header_Detail_Key)   + " C"+ String(ll_Column) + "R"  + String(ll_Row)  + " / "  + ls_temp_content + " / " + ls_temp_content_pl + " / " + lstr_item_fixed[ll_Count_Fixed].sitem)
										End If
										ll_temp_qty = lstr_item_fixed[ll_Count_Fixed].lcount 
										li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nquantity", ll_temp_qty)
										ll_Sort_Counter++
										li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
									End If
								Next
							End If

					End Choose
				End If
			Next
		Next
	End if

Return li_Return

end function

protected function integer of_sd_distribute_components_alloc (long al_min_fit_factor_setting, date arg_departure, string arg_unit, long al_content_master_row_id, long al_sd_cart_key, string arg_s_galley, string arg_s_stowage_only, string arg_s_pl, string as_loadinglist, ref boolean ab_entire_container_empty);
/*
* Objekt : uo_cart_diagram
* Methode: of_sd_distribute_components_alloc (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 20.08.2012
*
* Argument(e):
*	 long al_min_fit_factor_setting
*	 date arg_departure
*	 string arg_unit
*	 long al_content_master_row_id
*	 long al_sd_cart_key
*	 string arg_s_galley
*	 string arg_s_stowage_only
*	 string arg_s_pl
*	 string as_loadinglist
*	 ref boolean ab_entire_container_empty
*
* Beschreibung:		aufgerufen von of_sd_distribute_components: Hauptschleife Verteilung
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			20.08.2012	aus of_sd_distribute_components herausgel$$HEX1$$f600$$ENDHEX$$st
* 1.1 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*
*
* Return: integer
*
*/


Integer		li_Succ
Boolean		lb_Breakpoint
Long			ll_Min_Fit_Factor
Long			llIndex
Boolean		lb_Dont_Distribute
Long			ll_Unallocated_Qty
Long			ll_number_of_Unallocated_Comp
String		ls_PL_To_Find
Long			ll_IndexKey, ll_Detail_Key
Long			ll_Rows
Long			ll_Count
Long			ll_Number
Long			llCount
Long			llRetVal
Long			ll_type
Long			ll_Column, ll_Row
Long			ll_Rungs, ll_Cols
Long			ll_sd_drawer_key
Long			ll_SD_Drawer_Row
String		ls_Find
String		ls_Error_PL
Long			ll_Drawer_Row
Long			llRemain
String		lsText
String		ls_Error_text
String		ls_Error_Info
String		ls_Error_Def
String		ls_Infomation
s_distrib_item_sub	lstr_Contents[]
s_distrib_item_sub	lstr_Contents_Empty[]
s_component	lstr_component_alloc
s_component	lstr_component_alloc_empty
DataStore	lds_Contents


lds_Contents = CREATE DataStore
lds_Contents.dataobject = "dw_packinglist_edit_content"
lds_Contents.SetTransObject(SQLCA)

if al_content_master_row_id =  1000007  then
	al_content_master_row_id = al_content_master_row_id
end if


// --------------------------------------
// Schleife $$HEX1$$fc00$$ENDHEX$$ber components
// --------------------------------------
// alle Komponenten in das Cartdiagram verteilen
For ll_Min_Fit_Factor = 4 to al_Min_Fit_Factor_Setting Step - 1
	for llIndex = 1 to ids_sd_components.RowCount()
		//if il_Disable_Debug = 0 Then
			If ids_sd_components.getitemnumber(llIndex, "nquantity") > 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components verteile " + ids_sd_components.getItemString(llindex,"cpackinglist") +  ": lquantity " + String(ids_sd_components.getItemNumber(llindex,"nquantity")))
			End If
		//End If
		
		If ids_sd_components.getItemString(llindex,"cpackinglist") = "FMH02B004" or ids_sd_components.getItemString(llindex,"cpackinglist") = "FMH02B003" Then
			lb_Breakpoint = TRUE
		End If
			
		// --------------------------------------------------------------------------------------
		// CBASE-CR-NAM-12050 Switch Off Secondary Distribution
		// --------------------------------------------------------------------------------------
		lb_Dont_Distribute = FALSE
		If ids_sd_components.getItemNumber(llindex,"ndontdistribute") = 1 then
			lb_Dont_Distribute = TRUE
			if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components " + ids_sd_components.getItemString(llindex,"cpackinglist") +  ": NO SECONDARY DISTRIBUTION")
			// add log? 
			CONTINUE
		End If
		ll_Unallocated_Qty = ids_sd_components.getItemNumber(llindex,"nunallocated")
		If isnull(ll_Unallocated_Qty) Then ll_Unallocated_Qty = ids_sd_components.getItemNumber(llindex,"nquantity")
		
		ll_number_of_Unallocated_Comp = ll_Unallocated_Qty
		
		If ll_Unallocated_Qty > 0 Then
			ab_Entire_Container_Empty = FALSE
			// Explosion => Inhalte lstr_Contents
			lstr_Contents = lstr_Contents_Empty
			ls_PL_To_Find = ids_sd_components.getItemString(llindex,"cpackinglist")
			ll_IndexKey = f_get_packinglist_key(ls_PL_To_Find)
			ll_Detail_key = f_get_packinglist_detail_key(ll_IndexKey, arg_departure )
			If of_is_explosion_enabled( ll_IndexKey, arg_Unit , arg_departure) Then
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components explosion " +  ls_PL_To_Find + " " + arg_Unit + " TRUE")	
				// Explosion mit in die Verteilung nehmen	
				ll_Rows = lds_Contents.Retrieve(ll_IndexKey, ll_Detail_Key, datetime(arg_Departure), 0)
				lds_Contents.SetSort("nsort a")
				lds_Contents.Sort()					
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components explosion rows " + String(ll_Rows) + " index " + String(ll_IndexKey)  + " / " + String(ll_Detail_Key))
				For ll_Count = 1 To lds_Contents.RowCount()
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components explosion content of " +  ids_sd_components.getItemString(llindex,"cpackinglist") + ": " + lds_Contents.GetItemString(ll_Count, "cpackinglist_detail"))
					lstr_Contents[ll_Count].ssnr = lds_Contents.GetItemString(ll_Count, "cpackinglist_detail")
					lstr_Contents[ll_Count].stext = lds_Contents.GetItemString(ll_Count, "cpackinglist_text")
					ll_Number = lds_Contents.GetItemNumber(ll_Count, "nquantity")
					If IsNULL(ll_Number) Then ll_Number = 0 
					lstr_Contents[ll_Count].sqty = String(ll_Number)
					If ll_Number = 0 Then lstr_Contents[ll_Count].sqty = ""
				Next				
			Else
				// Keine Inhalte hinzu
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components explosion " +  ls_PL_To_Find + " " + arg_Unit + " FALSE")	
			End If
			//ll_number_of_Unallocated_Comp = ll_Unallocated_Qty
			for llCount = 1 to ll_number_of_Unallocated_Comp
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components verteile " + ids_sd_components.getItemString(llindex,"cpackinglist") +  ": " + String(llCount) + " von " + String(ll_number_of_Unallocated_Comp) )
				lstr_component_alloc = lstr_component_alloc_empty
				lstr_component_alloc.ssnr = ids_sd_components.getItemString(llindex,"cpackinglist")
				lstr_component_alloc.stext = ids_sd_components.getItemString(llindex,"ctext")
				lstr_component_alloc.lquantity = ids_sd_components.getItemnumber(llindex,"nquantity")
				lstr_component_alloc.squantity = ""
				lstr_component_alloc.llength = ids_sd_components.getItemnumber(llindex,"nlength")
				lstr_component_alloc.str_item_props.stext = ids_sd_components.getItemString(llindex,"cdistr_text")
				lstr_component_alloc.str_item_props.smeal_control_code = ids_sd_components.getItemString(llindex,"cmeal_control_code")
				lstr_component_alloc.str_item_props.sclass = ids_sd_components.getItemString(llindex,"cclass")
				If ids_sd_components.getItemString(llindex,"cpackinglist") = "CAAF46829" Then
					lb_Breakpoint = TRUE
					
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components_alloc] " + ids_sd_components.getItemString(llindex,"cpackinglist") + " CLASS " + f_check_null(ids_sd_components.getItemString(llindex,"cclass")))
					
				End If
				lstr_component_alloc.str_item_props.lspml = ids_sd_components.getItemnumber(llindex,"nspml")
				lstr_component_alloc.str_item_props.llimit = ids_sd_components.getItemnumber(llindex,"nlimit")
				lstr_component_alloc.str_item_props.lremaining = ids_sd_components.getItemnumber(llindex,"nremaining")
				lstr_component_alloc.str_item_props.ldontdistribute = ids_sd_components.getItemnumber(llindex,"ndontdistribute")
				            
            If lstr_component_alloc.str_item_props.ldontdistribute = 1 Then
               guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components_alloc "  +  ids_sd_components.getItemString(llindex,"cpackinglist") + " ndontdistribute = 1")
               
               CONTINUE
               
            End If         
			
				// Allocate a suitable place in the cart
				llRetVal = iuo_CartDistribution.of_allocate_w_split(lstr_component_alloc, ll_Column, ll_Row, ll_Min_Fit_Factor, lstr_Contents, This, ids_sd_components.getItemNumber(llindex,"nquantity"))

				//If llRetVal < 0 AND ll_Min_Fit_Factor > 0 Then
				// Min Fit Levels
				// 1	arg_str_props.stext
				// 2	arg_str_props.smeal_control_code
				// 3	arg_str_props.sclass
				// 4	arg_str_props.lspml
				If llRetVal < 0 AND ll_Min_Fit_Factor > al_Min_Fit_Factor_Setting Then
					// --------------------------------------------------------------------
					// Wenn allocate zu Min Fit Factor nicht erfolgreich => n$$HEX1$$e400$$ENDHEX$$chste Runde
					// --------------------------------------------------------------------
					if il_Disable_Debug= 0 then
						guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components llRetVal < 0 AND ll_Min_Fit_Factor > 0 " + ids_sd_components.getItemString(llindex,"cpackinglist") )
					End If
					CONTINUE
				End If
				
				If llRetVal >= 0 Then
					ll_Unallocated_Qty -= 1 		
				End If
				
				If llRetVal >= 0 Then
					// ----------------------------------------------
					// Secondary Distr. : Drawer / Tray 
					// ----------------------------------------------
					ll_type = of_get_type(ll_Row, ll_Column) 
					CHOOSE CASE ll_type
						CASE DRAWER, TRAY, DRAWERFOOD, TRAYNONFOOD, DRAWER_3RUNG, DRAWERFOOD_3RUNG, DRAWER_MULTI_RUNG
							//ls_Find ="ncolumn="+String(ll_Column) + " AND nrung=" + String(ll_Row) + " and nrowid="+String( al_sd_rowid )
							ls_Find ="ncolumn="+String(ll_Column) + " AND nrung=" + String(ll_Row) + " and nrowid="+String( al_content_master_row_id )	
							ll_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
							If ll_Drawer_Row < 1 then
								ll_sd_drawer_key = f_Sequence ("SEQ_CEN_OUT_SD_DRAWER", sqlca)
								If ll_sd_drawer_key = -1 Then
									uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
																	 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
								end if
								ll_SD_Drawer_Row = ids_SD_Cart_Drawer.Insertrow(0)
								if ll_type = DRAWER_MULTI_RUNG Then
									ll_Rungs = 0
									ll_Cols = 0
									li_Succ = of_get_rungs_and_cols( ll_Row, ll_Column, ll_rungs, ll_Cols )
									li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nwidth", ll_Cols )
									li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nheight", ll_rungs )
								End If
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nresult_key", il_result_key )
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntransaction", il_transaction )
								//li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrowid", al_sd_rowid )
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrowid", al_content_master_row_id )
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_cart_key", al_sd_cart_key )
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nsd_drawer_key", ll_sd_drawer_key )
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ntype", ll_type )
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "ncolumn", ll_Column )
								li_Succ = ids_SD_Cart_Drawer.SetItem(ll_SD_Drawer_Row, "nrung", ll_Row )		
							End if
						CASE ELSE
							if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components INVALID TYPE " + String(ll_type))
					END CHOOSE
				End If
				
				// nur bei letzter Runde
				// was nicht reingepasst hat muss ins Backlog geschrieben werden
				// if llRetVal < 0 AND ll_Min_Fit_Factor = 0 Then
				if llRetVal < 0 AND ll_Min_Fit_Factor = al_Min_Fit_Factor_Setting Then
					llRemain = ids_sd_components.getItemNumber(llindex,"nquantity") - (llCount - 1)
					lsText = iuo_CartDistribution.of_get_item_description( lstr_component_alloc )
					//li_Succ = of_sd_add_content_backlog_tray(llIndex * llCount, ll_Row, ll_Column, lsText, TRAY, llRemain, al_content_master_row_id ) 
					li_Succ = of_sd_add_content_backlog_tray(llIndex * llCount, ll_Row, ll_Column, lsText, TRAY, 0, al_content_master_row_id ) 
				End If
				
				
				// -----------------------------------------------------------------------------
				// Error Log - kein Treffer (llRetVal < 0 => NICHT VERTEILT)
				// -----------------------------------------------------------------------------
				if llRetVal < 0 AND ll_Min_Fit_Factor = al_Min_Fit_Factor_Setting Then
					ls_Error_PL = lstr_component_alloc.ssnr
					ls_Error_text = lstr_component_alloc.stext	
					If ib_require_exact_match Then
						// bei Exact Match Schalter = ON: "No Parameters defined"
						ls_Error_Info = uf.translate("NO_PARMS_DEFINED") 
					Else
						// bei Exact Match Schalter = OFF: 
						//ls_Error_Info = uf.translate("Komponente konnte nicht verteilt werden") 
						ls_Error_Info = uf.translate("NO_PARMS_DEFINED") 
					End if
					ls_Error_Def = "ll_Min_Fit_Factor: " + String(ll_Min_Fit_Factor)
					ls_Infomation = ""
					If ll_Min_Fit_Factor > 3 Then	ls_Infomation = "/SPML"
					If ll_Min_Fit_Factor > 2 Then	ls_Infomation = "/CLASS" + ls_Infomation
					If ll_Min_Fit_Factor > 1 Then	ls_Infomation = "/CODE" + ls_Infomation
					If ll_Min_Fit_Factor > 0 Then	ls_Infomation = "/TYPE" + ls_Infomation
					If left(ls_Infomation, 1) = "/" Then ls_Infomation = Mid(ls_Infomation, 2)
					ls_Error_Def  =       lstr_component_alloc.str_item_props.stext
					ls_Error_Def += "/" + lstr_component_alloc.str_item_props.smeal_control_code
					ls_Error_Def += "/" + lstr_component_alloc.str_item_props.sclass
					If lstr_component_alloc.str_item_props.lspml = 1 Then
						ls_Error_Def += "/SPML=YES" 
					Else
						ls_Error_Def += "/SPML=NO" 							
					End if
					// Secondary Distribution Error: no match found
					li_Succ = of_sd_add_error(al_content_master_row_id , arg_s_galley, arg_s_stowage_only , arg_s_pl, &
														as_Loadinglist, ls_Error_PL, ls_Error_text, 0, &
														ls_Error_Info, ls_Error_Def, arg_unit, ls_Infomation)
				End If
				
				// --------------------------------------------------------------------------------
				// Error Log (llRetVal = 0 => es wurde verteilt, aber nicht alle Parameter passen)
				// --------------------------------------------------------------------------------
				if llRetVal > -1 AND ib_require_exact_match = FALSE AND ll_Min_Fit_Factor < 4 AND al_Min_Fit_Factor_Setting < 4 Then
					ls_Error_PL = lstr_component_alloc.ssnr
					ls_Error_text = lstr_component_alloc.stext						
					ls_Error_Info = uf.translate("Keine exakte $$HEX1$$dc00$$ENDHEX$$bereinstimmung") //"No Parameters defined"
					ls_Error_Def = "ll_Min_Fit_Factor: " + String(ll_Min_Fit_Factor)
					ls_Infomation = ""
					If ll_Min_Fit_Factor > 3 Then	ls_Infomation = "/SPML"
					If ll_Min_Fit_Factor > 2 Then	ls_Infomation = "/CLASS" + ls_Infomation
					If ll_Min_Fit_Factor > 1 Then	ls_Infomation = "/CODE" + ls_Infomation
					If ll_Min_Fit_Factor > 0 Then	ls_Infomation = "/TYPE" + ls_Infomation
					If left(ls_Infomation, 1) = "/" Then ls_Infomation = Mid(ls_Infomation, 2)
					ls_Error_Def  =       lstr_component_alloc.str_item_props.stext
					ls_Error_Def += "/" + lstr_component_alloc.str_item_props.smeal_control_code
					ls_Error_Def += "/" + lstr_component_alloc.str_item_props.sclass
					If lstr_component_alloc.str_item_props.lspml = 1 Then
						ls_Error_Def += "/SPML=YES" 
					Else
						ls_Error_Def += "/SPML=NO" 							
					End if
					// Secondary Distribution Error: no match found
					li_Succ = of_sd_add_error(al_content_master_row_id , arg_s_galley, arg_s_stowage_only , arg_s_pl, &
														as_Loadinglist, ls_Error_PL, ls_Error_text, 1, &
														ls_Error_Info, ls_Error_Def, arg_unit, ls_Infomation)
				End If
				
			Next
			
			// Wie viele sind noch $$HEX1$$fc00$$ENDHEX$$brig
			li_Succ = ids_sd_components.SetItem(llindex,"nunallocated", ll_Unallocated_Qty)
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components Nach Verteilung Min Fit=" + String(ll_Min_Fit_Factor) + " " + ids_sd_components.getItemString(llindex,"cpackinglist") + " unallocated " + String(ll_Unallocated_Qty))
		End If
	Next
Next

if IsValid(lds_Contents) then destroy lds_Contents

Return 1

end function

public function integer of_sd_distribute_components_tray (long al_column, long al_row, string arg_unit, ref datastore rads_distribution_contents, long al_content_master_row_id, long al_sd_cart_key, long al_page, ref boolean rab_watermark_downline, ref boolean rab_suppress_watermark_downline);
/*
* Objekt : uo_cart_diagram
* Methode: of_sd_distribute_components_tray (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 20.08.2012
*
* Argument(e):
* long al_column
*	 long al_row
*	 string arg_unit
*	 ref datastore rads_distribution_contents
*	 long al_content_master_row_id
*	 long al_sd_cart_key
*	 long al_page
*
* Beschreibung:		Aus of_sd_distribute_components (f$$HEX1$$fc00$$ENDHEX$$r Typ TRAY )
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			20.08.2012	Erstellung
* 1.1 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*
*
* Return: integer
*
*/

Integer						li_Succ
Boolean						lb_Header_Exists
Long							ll_Count
Long							ll_New_Row
Long							ll_Content_Header_Detail_Key
Long							ll_MaxContent
Long							ll_temp_qty
String						ls_temp_content_pl
String						ls_temp_content
Long							ll_Sort_Counter
Long							ll_Target_pos
Long							ll_Count_2
String						ls_Computed_Item
String						ls_Find
String						ls_temp
Long							ll_Drawer_Row
Long							ll_sd_drawer_key
Long							llIndex
Integer						li_Mod
Long							ll_leg_from_ccode
Long							ll_Backlog_row
String						ls_Backlog_Header
s_distrib_items			lstr_item[]
s_distrib_items			lstr_item_empty[]
s_distrib_items			lstr_Temp[]
s_component					lstr_component_x


DataStore	lds_temp
lds_temp = CREATE DataStore
lds_temp.DataObject = "dw_packinglist_edit_content"
lds_temp.SetTransObject(SQLCA)


//if of_get_type(ll_Row, ll_Column) = TRAY or of_get_type(ll_Row, ll_Column) = DRAWERFOOD Then
lb_Header_Exists = of_exists_content_sheet_header(al_Column, al_Row)
// --------------------------------------------------------------------------------------
// Food Tray / Food Drawer				
// --------------------------------------------------------------------------------------				
ll_MaxContent = of_get_maxcontent(al_Row, al_Column)				
lstr_item = lstr_item_empty

// F$$HEX1$$fc00$$ENDHEX$$r Content Sheet => Food Contents ohne Sub-Items
iuo_CartDistribution.of_get_row_without_sub (al_Column, al_Row, lstr_item)
For ll_Count = 1 To Upperbound(lstr_item)
	If trim(lstr_item[ll_Count].sitem) > "" then
		
		If lstr_item[ll_Count].lcount = 0 then
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components qty=0 SKIP " + + lstr_item[ll_Count].sitem)
			CONTINUE
		end if
		
		ll_New_Row = rads_distribution_contents.InsertRow(0)
		ll_Content_Header_Detail_Key = (al_Column * 1000) + al_Row								
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key	)
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nrowid", al_content_master_row_id)
		ls_temp_content_pl = lstr_item[ll_Count].cpackinglist  
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "cpackinglist", ls_temp_content_pl)
		ls_temp_content = lstr_item[ll_Count].ctext 
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", ls_temp_content)
		If Trim(ls_temp_content) = "" Then
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", lstr_item[ll_Count].sitem)
		End If
		
		if il_Disable_Debug= 0 then
			If isnull(ls_temp_content) then ls_temp_content = "NULL"
			If isnull(ls_temp_content_pl) then ls_temp_content_pl = "NULL"			
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components content sheet FOOD TRAY DISTRIBUTED ITEM ll_Rowid="+ String(al_content_master_row_id) + " / " + ls_temp_content + " / " + ls_temp_content_pl + " / " + lstr_item[ll_Count].sitem)
		End If
		ll_temp_qty = lstr_item[ll_Count].lcount 
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nquantity", ll_temp_qty)
		ll_Sort_Counter++
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
	End If
Next

lstr_item = lstr_item_empty				
// ------------------------------------------------------------------
// Nur wenn kein Header in diesem Einschub => Subitems
// ------------------------------------------------------------------
If lb_Header_Exists Then
	iuo_CartDistribution.of_get_row_without_sub (al_Column, al_Row, lstr_item)					
Else
	iuo_CartDistribution.of_get_row(al_Column, al_Row, lstr_item)					
End If

For ll_Count = 1 To Upperbound(lstr_item)
	lstr_Temp[upperbound(lstr_Temp) + 1] = lstr_item[ll_Count]

	If trim(lstr_Temp[upperbound(lstr_Temp)].sitem) > "" then 
		If lstr_Temp[upperbound(lstr_Temp)].bdistributed Then
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY/DRAWERFOOD DISTRIBUTED " + lstr_Temp[upperbound(lstr_Temp)].sitem )  
		Else
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY/DRAWERFOOD DISTRIBUTED ABER bdistributed=FALSE " + lstr_Temp[upperbound(lstr_Temp)].sitem )  	
		End If
	End If
	
	If lb_Header_Exists = FALSE Then
		// ------------------------------------------------------------------
		// Nur wenn kein Header in diesem Einschub => Explosion Content
		// ------------------------------------------------------------------
		If Upperbound(lstr_item[ll_Count].str_cont) > 0 then	
			For ll_Count_2 = 1 To Upperbound(lstr_item[ll_Count].str_cont)
				ll_Target_pos = upperbound(lstr_Temp) + 1							
				lstr_component_x.ssnr = lstr_item[ll_Count].str_cont[ll_Count_2].ssnr
				lstr_component_x.stext = lstr_item[ll_Count].str_cont[ll_Count_2].stext
				ls_Computed_Item = of_get_item_description( lstr_component_x )
				lstr_Temp[ll_Target_pos].sitem = ls_Computed_Item  
				// F$$HEX1$$fc00$$ENDHEX$$r Backlog
				lstr_Temp[ll_Target_pos].sparent = lstr_item[ll_Count].sitem
				lstr_Temp[ll_Target_pos].sparent = lstr_component_x.ssnr + " - " + lstr_component_x.stext
				lstr_Temp[ll_Target_pos].sparentpl = lstr_item[ll_Count].cpackinglist
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY Explosion content zur$$HEX1$$fc00$$ENDHEX$$ck " + lstr_item[ll_Count].str_cont[ll_Count_2].ssnr )
			Next
		End If
	Else
		guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components_tray] If lb_Header_Exists = TRUE ")
	End If
Next

// -------------------------------------------
// alle Items
// -------------------------------------------

// ----------------------------------------------------
// lstr_item => alles nach CEN_OUT_SD_CONTENT Speichern
// ----------------------------------------------------

// find drawer key
ls_Find ="ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) + " and nrowid="+String( al_content_master_row_id )
ll_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
If ll_Drawer_Row > 0 then
	ll_sd_drawer_key = ids_sd_cart_drawer.GetItemNumber(ll_Drawer_Row, "nsd_drawer_key")
	li_Succ = of_sd_save_distr_contents(lstr_item, al_content_master_row_id, al_sd_cart_key, al_page, ll_sd_drawer_key)
Else
	if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components PAGE="+String(al_page)+" KEIN DRAWER GEFUNDEN ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) )
End If

// ----------------------------------------------------
// Konsolidieren
// ----------------------------------------------------
guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components_tray 1 Upperbound lstr_item=" + String(Upperbound(lstr_item)))   
lstr_temp = lstr_item_empty
lstr_temp = lstr_item
lstr_item = lstr_item_empty
For ll_Count = 1 To Upperbound(lstr_temp)
   If trim(lstr_temp[ll_Count].cpackinglist) > "" then
      If lstr_temp[ll_Count].lcount > 0 then
         If NOT Isnull(lstr_temp[ll_Count].sitem) AND &
            lstr_temp[ll_Count].sitem > "" AND &
            lstr_temp[ll_Count].cpackinglist > "" AND &
            lstr_temp[ll_Count].ctext > "" AND & 
            lstr_temp[ll_Count].lcount > 0 Then
                  
            lstr_item[upperbound(lstr_item) + 1] = lstr_temp[ll_Count]
            guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components_tray " + lstr_temp[ll_Count].cpackinglist)   
         End If         
      End If
   End If
Next
guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components_tray 2 Upperbound lstr_item=" + String(Upperbound(lstr_item)))   
         

// ll_MaxContent = 10
//if Upperbound(lstr_item) > ll_MaxContent then
//	ll_MaxContent = Upperbound(lstr_item)
//End If

for llIndex = 1 to upperbound(lstr_item)
	If (llIndex < ll_MaxContent OR (llIndex = ll_MaxContent AND ll_MaxContent = upperbound(lstr_item)) OR (llIndex = ll_MaxContent AND NOT of_is_backlog_enabled())) Then					
		if llIndex <= upperbound(lstr_item) Then
			if lstr_item[llIndex].lcount = 0 Then
				if lstr_item[llIndex].sitem = ""  Then
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components lstr_item[llIndex].lcount=0 " + lstr_item[llIndex].sitem)
				Else
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components lstr_item[llIndex].lcount=0 " + lstr_item[llIndex].sitem)
				End If
			Elseif lstr_item[llIndex].lcount = 1 Then
				ls_temp = lstr_item[llIndex].sitem
				If pos(ls_temp, "'")  > 0 then
					li_Mod = f_replace_string(ls_temp, "'", "~~~'")
				End If
				
			Elseif lstr_item[llIndex].lcount > 1 Then
				lstr_component_x.ssnr = lstr_item[llIndex].cpackinglist
				lstr_component_x.stext = lstr_item[llIndex].ctext
				lstr_component_x.squantity = String(lstr_item[llIndex].lcount)
				If lstr_component_x.squantity = "0" Then lstr_component_x.squantity =""
				ls_Computed_Item = of_get_item_description( lstr_component_x )
				If pos(ls_Computed_Item, "'")  > 0 then
					li_Mod = f_replace_string(ls_Computed_Item, "'", "~~~'")
				End If

			End If
		End If
		
		// BOLD
		if llIndex <= upperbound(lstr_item) Then
			If lstr_item[llIndex].bbold = TRUE Then
				If lb_Header_Exists = FALSE Then
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY/DRAWERFOOD " + lstr_item[llIndex].sitem + "bbold = TRUE")
				Else
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY/DRAWERFOOD Header " + lstr_item[llIndex].sitem + "bbold = FALSE")
				End If
			End If
			// Distr. Content Top BOLD
			If lstr_item[llIndex].bdistributed = TRUE Then
				If lb_Header_Exists = FALSE Then
					if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY/DRAWERFOOD " + lstr_item[llIndex].sitem + "bdistributed=TRUE")
				Else
					if il_Disable_Debug = 0 Then	guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY/DRAWERFOOD Header " + lstr_item[llIndex].sitem + "bdistributed = FALSE")
				End If					
			End If
		End If
		
		ll_leg_from_ccode = lstr_item[llIndex].lleg
		If NOT IsNULL(ll_leg_from_ccode) Then
			If ll_leg_from_ccode > 1 Then
				If Trim(lstr_item[llIndex].sitem) > "" Then
					rab_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG FROM DIST " + String(ll_leg_from_ccode))
				End If
			Else
				If Trim(lstr_item[llIndex].sitem) > "" AND lstr_item[llIndex].lcount > 0 Then
					rab_Suppress_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[llIndex].sitem)
				End If
			End If
		Else
			If Trim(lstr_item[llIndex].sitem) > ""  AND lstr_item[llIndex].lcount > 0 Then
				rab_Suppress_Watermark_Downline = TRUE
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[llIndex].sitem)
			End If
		End If
		If il_Disable_Debug = 0 Then
			If rab_Watermark_Downline Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG ab_Watermark_Downline=TRUE " + String(ll_leg_from_ccode) +" / "+ lstr_item[llIndex].sitem)
			Else
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG ab_Watermark_Downline=FALSE " + String(ll_leg_from_ccode) +" / "+ lstr_item[llIndex].sitem)
			End If
		End If
	else
		// --------------------------------------------
		// Backlog
		// --------------------------------------------
		If il_Disable_Debug = 0 Then
			If Trim(lstr_item[llIndex].sitem) > "" Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY llIndex " + String(llIndex) + " < ll_MaxContent " + String(ll_MaxContent) + " SEE BACKLOG...")
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY BACKLOG " + lstr_item[llIndex].sitem )
			End If
		End If
	
	
		lstr_component_x.ssnr = lstr_item[llIndex].cpackinglist
		lstr_component_x.stext = lstr_item[llIndex].ctext
		lstr_component_x.squantity = String(lstr_item[llIndex].lcount)
		If lstr_component_x.squantity = "0" Then lstr_component_x.squantity =""
		ls_Computed_Item = of_get_item_description( lstr_component_x )
		If pos(ls_Computed_Item, "'")  > 0 then
			li_Mod = f_replace_string(ls_Computed_Item, "'", "~~~'")
		End If
	
		//li_Succ = of_sd_add_content_backlog_tray(llIndex * al_Row, al_Row, al_Column, ls_Computed_Item, TRAY, 0, al_content_master_row_id ) 
		//	of_sd_add_content_backlog_drawer(ll_Backlog_row, al_Row, al_Column, lds_temp,  DRAWER_MULTI_RUNG , ls_Backlog_Header, al_content_master_row_id)							
	
		If Trim(lstr_item[llIndex].sitem) > "" Then
			ll_Backlog_row = lds_temp.insertrow(0)
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY BACKLOG QTY " + lstr_item[llIndex].cpackinglist  + " / " + String(lstr_item[llIndex].lcount))
			li_Succ = lds_temp.SetItem(ll_Backlog_row, "nquantity", lstr_item[llIndex].lcount)
			li_Succ = lds_temp.SetItem(ll_Backlog_row, "details_cunit", "")
			li_Succ = lds_temp.SetItem(ll_Backlog_row, "cpackinglist_text", lstr_item[llIndex].ctext )
			li_Succ = lds_temp.SetItem(ll_Backlog_row, "cpackinglist_detail", lstr_item[llIndex].cpackinglist )								
			li_Succ = lds_temp.SetItem(ll_Backlog_row, "cadd_on_text", "" )
			li_Succ = lds_temp.SetItem(ll_Backlog_row, "cadd_on_text", lstr_item[llIndex].sparent )								
		Else
			If Trim(lstr_item[llIndex].sitem) > "" Then
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components TRAY llIndex "+String(llIndex)+" < ll_MaxContent " + String(ll_MaxContent) + " BACKLOG EMPTY SITEM")
			End If
		End If
		
		// -------------------------------------------------------------------
		// Backlog
		// -------------------------------------------------------------------
		For ll_Backlog_row = 1 To lds_Temp.RowCount()
			ls_Backlog_Header = lds_temp.getitemstring(ll_Backlog_row, "cadd_on_text")

			//of_sd_add_content_backlog_drawer(ll_Backlog_row, al_Row, al_Column, lds_temp,  DRAWER_MULTI_RUNG , ls_Backlog_Header, al_content_master_row_id)									
			//li_Succ = of_sd_add_content_backlog_tray(llIndex * llCount, ll_Row, ll_Column, lsText, TRAY, 0, al_content_master_row_id ) 
			
				//of_sd_add_content_backlog_drawer(ll_Backlog_row, al_Row, al_Column, lds_temp,  TRAY , ls_Backlog_Header, al_content_master_row_id)			
			//	of_sd_add_content_backlog_drawer(ll_Backlog_row, al_Row, al_Column, lds_temp,  DRAWER_MULTI_RUNG , ls_Backlog_Header, al_content_master_row_id)						
//			of_sd_add_content_backlog_tray(ll_Backlog_row, al_Row, al_Column, /*string arg_s_text*/, /*long arg_l_type*/, /*decimal arg_dec_qty*/, al_content_master_row_id)
		Next
	end if
Next

//If ib_Downline_by_Mealcode AND of_is_downline_enabled(arg_unit) AND rab_Watermark_Downline Then
//End if				

if IsValid(lds_temp) then destroy lds_temp

Return 1
end function

public function integer of_sd_distribute_components_multi (long al_column, long al_row, string arg_unit, ref datastore rads_distribution_contents, long al_content_master_row_id, long al_sd_cart_key, long al_page, ref boolean rab_watermark_downline, ref boolean rab_suppress_watermark_downline);
/*
* Objekt : uo_cart_diagram
* Methode: of_sd_distribute_components_multi (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 20.08.2012
*
* Argument(e):
* long al_column
*	 long al_row
*	 string arg_unit
*	 ref datastore rads_distribution_contents
*	 long al_content_master_row_id
*	 long al_sd_cart_key
*	 long al_page
*
* Beschreibung:		Aus of_sd_distribute_components (f$$HEX1$$fc00$$ENDHEX$$r Typ MULTIRUNG )
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			20.08.2012	Erstellung
* 1.1 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*
*
* Return: integer
*
*/

Integer						li_Succ
Boolean						lb_Header_Exists
Long							ll_Count
Long							ll_New_Row
Long							ll_Content_Header_Detail_Key
Long							ll_MaxContent
Long							ll_temp_qty
String						ls_temp_content_pl
String						ls_temp_content
Long							ll_Sort_Counter
Long							ll_Target_pos
Long							ll_Start_Pos
Long							ll_Count_2
String						ls_Computed_Item
String						ls_Find
Long							ll_Content
Long							ll_Found
Long							ll_Count_Fixed
Long							ll_LayoutDetailKey
String						ls_temp
Long							ll_Drawer_Row
Long							ll_sd_drawer_key
Long							ll_Index
Integer						li_Mod
Long							ll_leg_from_ccode
Long							ll_rungs
Long							ll_Cols
Long							ll_Backlog_row
String						ls_Backlog_Header
s_distrib_items			lstr_item[]
s_distrib_items			lstr_item_fixed[]
s_distrib_items			lstr_item_empty[]
s_distrib_items			lstr_Temp[]
s_component					lstr_component_x


DataStore	lds_temp
lds_temp = CREATE DataStore
lds_temp.DataObject = "dw_packinglist_edit_content"
lds_temp.SetTransObject(SQLCA)

// ---------------------------------------------------------------------------------
// DRAWER_MULTI_RUNG: Aufgabe: feste Inhalte VOR DISTRIBUTED CONTENT einsortieren
// ---------------------------------------------------------------------------------
lb_Header_Exists = of_exists_content_sheet_header(al_Column, al_Row)

// Abmessungen
li_Succ = of_get_rungs_and_cols( al_Row, al_Column, ll_rungs, ll_Cols )

ll_MaxContent = of_get_maxcontent(al_Row, al_Column)
If il_Disable_Debug = 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DRAWER_MULTI_RUNG Am Ende dann den Text $$HEX1$$e400$$ENDHEX$$ndern Maxcontent=" +  String(ll_MaxContent) + " Col: "+ String(al_Column) + " Row: " + String(al_Row))
End If
lstr_item = lstr_item_empty
lstr_temp = lstr_item_empty

// --------------------------------------------------------------------------
// Verteilter Content nach Content Sheet dsLoadingContents 
// --------------------------------------------------------------------------
li_Succ = of_distr_content_4_contentsheet( rads_distribution_contents, iuo_CartDistribution, al_Row, al_Column, al_content_master_row_id)
// --------------------------------------------------------------------------
// Ende Verteilter Content nach Content Sheet dsLoadingContents 
// --------------------------------------------------------------------------

lstr_item = lstr_item_empty
// ------------------------------------------------------------------
// Nur wenn kein Header in diesem Einschub => Subitems
// ------------------------------------------------------------------
If lb_Header_Exists Then
	iuo_CartDistribution.of_get_row_without_sub (al_Column, al_Row, lstr_item)
Else
	iuo_CartDistribution.of_get_row(al_Column, al_Row, lstr_item)
End If

For ll_Count = 1 To Upperbound(lstr_item)
	lstr_Temp[upperbound(lstr_Temp) + 1] = lstr_item[ll_Count]
	If trim(lstr_Temp[upperbound(lstr_Temp)].sitem) > "" then 
		If lstr_Temp[upperbound(lstr_Temp)].bdistributed Then
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DISTRIBUTED=TRUE " + lstr_Temp[upperbound(lstr_Temp)].sitem )  
		Else
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DISTRIBUTED=FALSE " + lstr_Temp[upperbound(lstr_Temp)].sitem )  
		End If
	End If
	
	If Upperbound(lstr_item[ll_Count].str_cont) > 0 then	
		For ll_Count_2 = 1 To Upperbound(lstr_item[ll_Count].str_cont)
			ll_Target_pos = upperbound(lstr_Temp) + 1							
			lstr_component_x.ssnr = lstr_item[ll_Count].str_cont[ll_Count_2].ssnr
			lstr_component_x.stext = lstr_item[ll_Count].str_cont[ll_Count_2].stext
			ls_Computed_Item = of_get_item_description( lstr_component_x )
			lstr_Temp[ll_Target_pos].sitem = ls_Computed_Item  
			// F$$HEX1$$fc00$$ENDHEX$$r Backlog
			lstr_Temp[ll_Target_pos].sparent = lstr_item[ll_Count].sitem
			lstr_Temp[ll_Target_pos].sparent = lstr_component_x.ssnr + " - "  + lstr_component_x.stext
			
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components Explosion DRAWER_MULTI_RUNG content zur$$HEX1$$fc00$$ENDHEX$$ck " + lstr_item[ll_Count].str_cont[ll_Count_2].ssnr )  
			End If					
		Next
	End If
Next

// ----------------------------------------------------
// Start FIXED CONTENT dazwischenquetschen
// ----------------------------------------------------
lstr_item_fixed = lstr_item_empty
lstr_temp = lstr_item_empty

ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
if ll_Found > 0 Then
	ll_Content			= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
	ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
	
	If il_Disable_Debug = 0 Then	
		If lb_Header_Exists Then
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components BEFORE FIXED CONTENT lb_Header_Exists=TRUE")
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components BEFORE FIXED CONTENT lb_Header_Exists=FALSE")
		End If
	End If	
			
	If of_get_fixed_content(ll_LayoutDetailKey, ll_Content, al_Row, al_Column, drawer_multi_rung, arg_unit, ll_Start_Pos, lstr_item_fixed, lb_Header_Exists ) > 0 Then
		lstr_temp = lstr_item_empty
		For ll_Count_Fixed = 1 To Upperbound(lstr_item)
			lstr_temp[ll_Count_Fixed] = lstr_item[ll_Count_Fixed]
		Next
		lstr_item = lstr_item_empty
		For ll_Count_Fixed = 1 To Upperbound(lstr_item_fixed)
			lstr_item[ll_Count_Fixed] = lstr_item_fixed[ll_Count_Fixed] 
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components FIXED CONTENT " + String(ll_Count_Fixed) + " " + lstr_item_fixed[ll_Count_Fixed].sitem)
			If lstr_item_fixed[ll_Count_Fixed].bbold Then
				lstr_item[ll_Count_Fixed].bbold = TRUE
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components FIXED CONTENT BOLD " + String(ll_Count_Fixed) + " " + lstr_item_fixed[ll_Count_Fixed].sitem)
			End If
		Next
	End If
	
	For ll_Count_Fixed = 1 To Upperbound(lstr_temp)
		If upperbound(lstr_item) <= ll_MaxContent OR Trim(lstr_temp[ll_Count_Fixed].sitem) > "" Then							
			lstr_item[upperbound(lstr_item) + 1] = lstr_temp[ll_Count_Fixed]
			If il_Disable_Debug = 0 Then
				If Trim(lstr_temp[ll_Count_Fixed].sitem) > "" Then
					If lstr_temp[ll_Count_Fixed].bdistributed then
						if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DISTRIBUTED CONTENT bdistributed=TRUE " + String(upperbound(lstr_item)) + " " + lstr_temp[ll_Count_Fixed].sitem)
					Else
						if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DISTRIBUTED CONTENT " + String(upperbound(lstr_item)) + " " + lstr_temp[ll_Count_Fixed].sitem)
					End If
				End If
			End If
		End If
	Next					
End If

lstr_temp = lstr_item
lstr_item = lstr_item_empty
For ll_Count_Fixed = 1 To Upperbound(lstr_temp)
	If lstr_temp[ll_Count_Fixed].sitem > "" Then
		lstr_item[upperbound(lstr_item) + 1] = lstr_temp[ll_Count_Fixed] 
		If Trim(lstr_temp[ll_Count_Fixed].sitem) > "" Then
			If lstr_temp[ll_Count_Fixed].bdistributed Then
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ALL CONTENT bdistributed=TRUE " + String(upperbound(lstr_item)) + " " + lstr_temp[ll_Count_Fixed].sitem)
			Else
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ALL CONTENT bdistributed=FALSE " + String(upperbound(lstr_item)) + " " + lstr_temp[ll_Count_Fixed].sitem)
			End if
			If lstr_temp[ll_Count_Fixed].bbold Then
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ALL CONTENT bbold=TRUE " + String(upperbound(lstr_item)) + " " + lstr_temp[ll_Count_Fixed].sitem)
			Else
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ALL CONTENT bbold=FALSE " + String(upperbound(lstr_item)) + " " + lstr_temp[ll_Count_Fixed].sitem)
			End if
		End If
	End If
Next

If upperbound(lstr_item) < ll_MaxContent Then
	For ll_Count_Fixed = 1 To Upperbound(lstr_temp)
		If upperbound(lstr_item) < ll_MaxContent Then
			If lstr_temp[ll_Count_Fixed].sitem = "" Then
				lstr_item[upperbound(lstr_item) + 1] = lstr_temp[ll_Count_Fixed]
			End If
		End If
	Next					
End If
// ----------------------------------------------------
// Ende FIXED CONTENT dazwischenquetschen
// ----------------------------------------------------

// ----------------------------------------------------
// lstr_item => alles nach CEN_OUT_SD_CONTENT Speichern
// ----------------------------------------------------
//ls_Find ="ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) + " and nrowid="+String( al_sd_rowid )
ls_Find ="ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) + " and nrowid="+String( al_content_master_row_id )
ll_Drawer_Row = ids_sd_cart_drawer.Find(ls_Find, 1, ids_sd_cart_drawer.RowCount() )
If ll_Drawer_Row > 0 then
	ll_sd_drawer_key = ids_sd_cart_drawer.GetItemNumber(ll_Drawer_Row, "nsd_drawer_key")
	li_Succ = of_sd_save_distr_contents(lstr_item, al_content_master_row_id, al_sd_cart_key, al_page, ll_sd_drawer_key)
Else
	if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components PAGE="+String(al_page)+" KEIN DRAWER GEFUNDEN ncolumn="+String(al_Column) + " AND nrung=" + String(al_Row) )
End If

for ll_Index = 1 to upperbound(lstr_item) 
	If lstr_item[ll_index].bdistributed = TRUE Then
		if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components GESAMTER CONTENT bdistributed=TRUE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
	Else
		if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components GESAMTER CONTENT bdistributed=FALSE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
	End If
	If lstr_item[ll_Index].bbold = TRUE Then
		if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components GESAMTER CONTENT bbold=TRUE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
	Else
		if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components GESAMTER CONTENT bbold=FALSE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
	End If

	If (ll_Index < ll_MaxContent OR (ll_Index = ll_MaxContent AND ll_MaxContent = upperbound(lstr_item)) OR (ll_Index = ll_MaxContent AND NOT of_is_backlog_enabled())) Then					
	
		If lstr_item[ll_Index].bbold = TRUE Then
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components lstr_item[ll_Index].bbold = TRUE " + lstr_item[ll_Index].sitem )
			End If
		End If
	
		// Spalte zwei belegen? 
		If ll_Cols > 1 AND ll_Index > (ll_MaxContent / 2) Then
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components SPALTE 2: BLANK " + "t_content_quantity_" + string(ll_Index, "0") + "_col_02_row_" + string(al_Row, "00"))
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components SPALTE 2: BLANK " + "t_content_quantity_" + string(ll_Index - Integer(ll_MaxContent / 2), "0") + "_col_02_row_" + string(al_Row, "00"))
		End If
		
		if ll_Index <= upperbound(lstr_item) Then
			if lstr_item[ll_Index].lcount = 0 Then
				if lstr_item[ll_Index].sitem = ""  Then
				Else									
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components lstr_item[ll_Index].lcount=0 " + lstr_item[ll_Index].sitem )
				End If
			Elseif lstr_item[ll_Index].lcount = 1 Then
				ls_temp = lstr_item[ll_Index].sitem
				If pos(ls_temp, "'")  > 0 then
					li_Mod = f_replace_string(ls_temp, "'", "~~~'")
				End If
			Elseif lstr_item[ll_Index].lcount > 1 Then								
				lstr_component_x.ssnr = lstr_item[ll_Index].cpackinglist
				lstr_component_x.stext = lstr_item[ll_Index].ctext
				lstr_component_x.squantity = String(lstr_item[ll_Index].lcount)
				If lstr_component_x.squantity = "0" Then lstr_component_x.squantity =""
				ls_Computed_Item = of_get_item_description( lstr_component_x )
				If pos(ls_Computed_Item, "'")  > 0 then
					li_Mod = f_replace_string(ls_Computed_Item, "'", "~~~'")
				End If
			End If
		End If
		
		ll_leg_from_ccode = lstr_item[ll_Index].lleg
		If NOT IsNULL(ll_leg_from_ccode) Then
			If ll_leg_from_ccode > 1 Then
				If Trim(lstr_item[ll_Index].sitem) > "" Then
					rab_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG FROM DIST " + String(ll_leg_from_ccode))
				End If
			Else
				If Trim(lstr_item[ll_Index].sitem) > ""  AND lstr_item[ll_Index].lcount > 0 Then
					rab_Suppress_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
				End If
			End If
		Else
			If Trim(lstr_item[ll_Index].sitem) > ""  AND lstr_item[ll_Index].lcount > 0 Then
				rab_Suppress_Watermark_Downline = TRUE
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If	
		If il_Disable_Debug = 0 Then
			If rab_Watermark_Downline Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG lb_Watermark_Downline=TRUE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			Else
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DOWNLINE LEG lb_Watermark_Downline=FALSE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If
	Else
		// BACKLOG
		If il_Disable_Debug = 0 Then
			If Trim(lstr_item[ll_Index].sitem) > "" Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ll_Index " + String(ll_Index) + " < ll_MaxContent " + String(ll_MaxContent) + " SEE BACKLOG...")
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components BACKLOG " + lstr_item[ll_Index].sitem )
			End If
		End If
		If Trim(lstr_item[ll_Index].sitem) > "" Then
			ll_Backlog_row = lds_temp.insertrow(0)
			If lds_temp.RowCount() > 0 Then
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components BACKLOG QTY " + lstr_item[ll_Index].cpackinglist  + " / " + String(lstr_item[ll_Index].lcount))
				li_Succ = lds_temp.SetItem(ll_Backlog_row, "nquantity", lstr_item[ll_Index].lcount)
				li_Succ = lds_temp.SetItem(ll_Backlog_row, "details_cunit", "")
				li_Succ = lds_temp.SetItem(ll_Backlog_row, "cpackinglist_text", lstr_item[ll_Index].ctext )
				li_Succ = lds_temp.SetItem(ll_Backlog_row, "cpackinglist_detail", lstr_item[ll_Index].cpackinglist )								
				li_Succ = lds_temp.SetItem(ll_Backlog_row, "cadd_on_text", "" )
				li_Succ = lds_temp.SetItem(ll_Backlog_row, "cadd_on_text", lstr_Temp[ll_Index].sparent )								
			End If
		Else
			If Trim(lstr_item[ll_Index].sitem) > "" Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components ll_Index "+String(ll_Index)+" < ll_MaxContent " + String(ll_MaxContent) + " BACKLOG EMPTY SITEM")
			End If
		End If
	End If
	
	// Backlog
	For ll_Backlog_row = 1 To lds_Temp.RowCount()
		ls_Backlog_Header = lds_temp.getitemstring(ll_Backlog_row, "cadd_on_text")
		//of_sd_add_content_backlog_drawer(ll_Backlog_row , al_Row, al_Column, lds_temp,  of_get_type(al_Row, al_Column) , ls_Backlog_Header, al_content_master_row_id )		
	Next
	lds_temp.reset()
Next				

//	If ib_Downline_by_Mealcode AND of_is_downline_enabled(arg_unit) AND lb_Watermark_Downline Then
//		guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components PRINT DOWNLINE LEG FROM DIST R" + String(al_Row) + " C" + String(al_Column))
//	Else
//		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components PRINT DOWNLINE LEG lb_Suppress_Watermark_Downline=TRUE R" + String(al_Row) + " C" + String(al_Column))
//	End if				

if IsValid(lds_temp) then destroy lds_temp

Return 1
end function

protected function integer of_sd_distribute_components_empty (ref boolean rab_entire_container_empty, long al_maxcolumns, long al_maxrows, ref uo_cart_distribution rauo_cart_distribution, long al_sd_rowid, long al_sd_cart_key, boolean ab_no_components, string arg_s_pl, date arg_departure, string arg_s_stowage);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_distribute_components_empty (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 20.08.2012
*
* Argument(e):
* ref boolean rab_entire_container_empty
*	 long al_maxcolumns
*	 long al_maxrows
*	 ref uo_cart_distribution rauo_cart_distribution
*	 long al_sd_rowid
*	 long al_sd_cart_key
*	 boolean ab_no_components
*	 string arg_s_pl
*	 date arg_departure
*	 string arg_s_stowage
*
* Beschreibung:		Leere Beh$$HEX1$$e400$$ENDHEX$$lter finden / aussteuern
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	20.08.2012		Erstellung
*
*
* Return: integer
*
*/

Integer				li_Succ
Long					ll_Column
Long					ll_Row
Long					ll_Count
Boolean				lb_Empty
Long					ll_PL_Index
Long					ll_PL_Detail_Key
Long					ll_Rows
Long					ll_NewRow
s_distrib_items	lstr_item[]
s_distrib_items	lstr_item_empty[]
DataStore			lds_Contents_2

// -------------------------------------------------------------------
// Suche & entferne EMPTY Drawers & Co
// -------------------------------------------------------------------
for ll_Column = 1 to al_MaxColumns
	for ll_Row = 1 to al_MaxRows
		if of_get_type(ll_Row, ll_Column) = TRAY or of_get_type(ll_Row, ll_Column) = DRAWERFOOD OR of_get_type(ll_Row, ll_Column) = drawer_multi_rung OR of_get_type(ll_Row, ll_Column) = drawer_3rung Then
			lstr_item = lstr_item_empty
			rauo_Cart_Distribution.of_get_row(ll_Column, ll_Row, lstr_item)
			lb_Empty = TRUE
			For ll_Count = 1 To Upperbound(lstr_item)
				//If not isnull(lstr_item[ll_Count].sitem) AND trim(lstr_item[ll_Count].sitem) > "" then
				If not isnull(lstr_item[ll_Count].sitem) AND trim(lstr_item[ll_Count].sitem) > "" AND lstr_item[ll_Count].lcount > 0 then
					
					If of_get_type(ll_Row, ll_Column) = drawer_multi_rung AND lstr_item[ll_Count].bdistributed Then
						lb_Empty = FALSE
						If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DRAWER_MULTI_RUNG HAS DISTRIBUTED CONTENT not empty C" + String(ll_Column) + " / R" + String(ll_Row) + " " + lstr_item[ll_Count].sitem)	
					End If
					
					If (of_get_type(ll_Row, ll_Column) = TRAY OR of_get_type(ll_Row, ll_Column) = DRAWERFOOD) AND lstr_item[ll_Count].bdistributed Then
						lb_Empty = FALSE
						If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DRAWERFOOD/TRAY HAS DISTRIBUTED CONTENT not empty C" + String(ll_Column) + " / R" + String(ll_Row) + " " + lstr_item[ll_Count].sitem)	
					End If
					
					If of_get_type(ll_Row, ll_Column) = drawer_multi_rung AND lb_Empty Then
						lb_Empty = FALSE
						If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components DRAWER_MULTI_RUNG lb_Empty=TRUE BUT not empty " + String(ll_Column) + " / " + String(ll_Row) + " => " + lstr_item[ll_Count].sitem)	
					End If
					
					exit
				end if
			Next
			
			// Remove Empty Drawer / Tray
			li_Succ = of_sd_handle_empty_contents(  ll_Row, ll_Column, lb_empty, rab_entire_container_empty, al_sd_rowid, al_sd_cart_key )
			
		elseif of_get_type(ll_Row, ll_Column) = TRAYNONFOOD Then
			rab_Entire_Container_Empty = FALSE
		End If			
	Next
Next

// Alles leer?
If rab_Entire_Container_Empty AND ab_No_Components Then
	// gibt es Inhalte
	ll_PL_Index = f_get_packinglist_key(arg_s_pl)
	If ll_PL_Index > 0 Then
		ll_pl_Detail_key = f_get_packinglist_detail_key(ll_PL_Index, arg_departure )
		If ll_pl_Detail_key > 0 Then
			lds_Contents_2 = create datastore
			lds_Contents_2.Dataobject = "dw_uo_packinglist_detail"
			lds_Contents_2.settransobject(SQLCA)
			ll_Rows = lds_Contents_2.retrieve(ll_PL_Index,ll_pl_Detail_key, datetime(arg_departure ))
			if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components NACH DIST BEH$$HEX1$$c400$$ENDHEX$$LTER EMPTY CHECK CONTENTS " + String(ll_PL_Index) + " / " + String(ll_pl_Detail_key) + " Rows" + String(ll_Rows) )
			If ll_Rows > 0 Then
				rab_Entire_Container_Empty = FALSE
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components NACH DIST BEH$$HEX1$$c400$$ENDHEX$$LTER EMPTY ABER CONTENTS (pl detail) " + arg_s_pl)
			End If
			destroy lds_Contents_2
		end if
	End If
End If

If rab_Entire_Container_Empty AND ab_No_Components Then
	if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_distribute_components NACH DIST GESAMTER BEH$$HEX1$$c400$$ENDHEX$$LTER EMPTY " + arg_s_pl )

	ll_NewRow = ids_TR_Exclusions.InsertRow(0)
	ids_TR_Exclusions.SetItem(ll_NewRow, 1, arg_s_pl)
	ids_TR_Exclusions.SetItem(ll_NewRow, 2, arg_s_stowage)	
End if
// -------------------------------------
// Ende EMPTY-ausssteuern
// -------------------------------------


DESTROY lds_Contents_2

Return 1

end function

public function string of_get_ramp_box (string as_box_from, string as_box_to, long al_box_mode);/*
* Objekt : uo_cart_diagram
* Methode: of_get_ramp_box (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.08.2012
*
* Argument(e):
*	 string		as_box_from
*	 string		as_box_to
*	 long			al_box_mode
*
* Beschreibung:		Erzeuge Ramp Box String, je nach Setting aus Box From / Box To 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.08.2012		Erstellung
*
*
* Return: string
*
*/

String	ls_RampBox


ls_RampBox					= ""
		
// ------------------------------------------------------------------------------
// Ermittlung Ramp Box - CBASE-NAM-CR-12025
// ------------------------------------------------------------------------------
//ll_ramp_box_mode = This.dsCartdiagramSheet.GetItemNumber(ll_Row, "nramp_box_mode")
If al_Box_Mode = 1 Then
	ls_RampBox = as_Box_From 
elseif al_Box_Mode = 2 Then
	ls_RampBox = as_Box_to
else
	If NOT Isnull(as_Box_From) Then ls_rampbox = as_Box_From
	If NOT Isnull(as_Box_To) AND Trim(as_Box_To) > "" Then ls_rampbox += "-" + as_Box_To	
End If
						
Return ls_RampBox

end function

public function integer of_sd_remove_empty_drawers (long al_row_id);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_remove_empty_drawers (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.08.2012
*
* Argument(e):
* long al_row_id
*
* Beschreibung:		Remove Drawers with flag EMPTY = 1
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.08.2012		Erstellung
*
*
* Return: integer
*
*/



Integer	li_Succ
Long		ll_Count 
Long		ll_Empty
Long		ll_Row_ID
Long		ll_Type
Long		ll_Column
Long		ll_Rung


For ll_Count = 1 To ids_sd_cart_drawer.RowCount()
	ll_Row_ID = ids_sd_cart_drawer.GetItemNumber(ll_Count, "nrowid")
	If ll_Row_ID <> al_Row_ID Then CONTINUE
	ll_Empty = ids_sd_cart_drawer.GetItemNumber(ll_Count, "nempty")
	If ll_Empty = 1 Then
		ll_Type = ids_sd_cart_drawer.GetItemNumber(ll_Count, "ntype")
		ll_Column = ids_sd_cart_drawer.GetItemNumber(ll_Count, "ncolumn")
		ll_Rung = ids_sd_cart_drawer.GetItemNumber(ll_Count, "nrung")
		ll_Type = ids_sd_cart_drawer.GetItemNumber(ll_Count, "ntype")
		CHOOSE CASE ll_Type
			CASE DRAWER_MULTI_RUNG
				li_Succ = of_remove_drawer(ll_Rung, ll_Column)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(ll_Column, "00") + "_r_" + string(ll_Rung, "00"), FALSE)
			CASE TRAY
				li_Succ = of_remove_tray(ll_Rung, ll_Column)
				li_Succ = of_modify ("DESTROY t_wtrmrk_dwnln_c_" + string(ll_Column, "00") + "_r_" + string(ll_Rung, "00"), FALSE)
		CASE ELSE
	END CHOOSE
			
	End If
Next

Return 1
end function

public function integer of_sd_draw_comp_tray (long al_column, long al_row, ref datastore rads_distribution_contents, long al_content_master_row_id, string arg_unit);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_draw_comp_tray (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 27.08.2012
*
* Argument(e):
* long al_row
*	 long al_column
*	 string arg_unit
*
* Beschreibung:		Draw distributed contents (Tray / Food Drawer)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	27.08.2012		Erstellung - ausgelagert aus SD Draw Distributed Components
* 1.1 			U.Paudler19.09.2012		Adjust Textsize CR NAM 12035
* 1.2 			O.Hoefer	22.11.2012		ge$$HEX1$$e400$$ENDHEX$$nderte Anforderung Textsize => 2 feste Stufen: normal/gross
* 1.3 			O.Hoefer	26.11.2012		Problem - Overflow missing
* 1.4 			O.Hoefer	29.01.2013		Problem - Overflow zu viel
* 1.5 			O.Hoefer	04.02.2013		Overflow again
* 1.6 			O.Hoefer	04.06.2013		Overflow again
* 1.7 			O.Hoefer	11.07.2013		Overflow again
* 1.8 			O.Hoefer	26.08.2019		Overflow (Type Tray vs. Type Drawer) issue #5320 Overflow sheet shows other unit than shown on cartdiagram
* 1.9 			O.Hoefer	10.12.2019		#5828 Overflow
*
*
* Return: integer
*
*/


Boolean		lb_Header_Exists
Boolean		lb_Watermark_Downline
Boolean		lb_Suppress_Watermark_Downline
Boolean		lb_Content_Spec_Drawer
Boolean		lb_Content_Spec_PL
Boolean		lb_Breakpoint
Boolean		lb_Overflow
Boolean		lb_backlog_switch
Integer		li_Succ
Integer		li_Mod
Long			ll_MaxContent
Long			ll_Count
Long			ll_New_Row
Long			ll_Index
Long			ll_Content_Header_Detail_Key
Long			ll_Sort_Counter
Long			ll_temp_qty
Long			ll_Count_2
Long			ll_Target_pos
Long			ll_leg_from_ccode
Long			ll_index_key
Long			ll_Found
Long			ll_Content
Long			ll_LayoutDetailKey
Long			ll_Number_of_Distr_Comp
Long			ll_Number_of_Fixed_Content
Long			ll_Show_Type
Long			ll_Type
String		ls_DWObject
String		ls_temp_content_pl, ls_temp_content
String		ls_Mod_String
String		ls_Computed_Item
String		ls_MSG
String		ls_Header
String		ls_Text
String		ls_Parent
Decimal		ldec_Qty
s_distrib_items	lstr_item[], lstr_item_empty[], lstr_temp[]
s_component	lstr_component_x


lb_Header_Exists = of_exists_content_sheet_header(al_Column, al_Row)

lb_backlog_switch = of_is_backlog_enabled()

// --------------------------------------------------------------------------------------
// Food Tray / Food Drawer				
// --------------------------------------------------------------------------------------				
ll_MaxContent = of_get_maxcontent(al_Row, al_Column)	

if al_Row = 2 and  al_Column = 1 Then
	lb_Breakpoint = TRUE
End If

lstr_item = lstr_item_empty
// F$$HEX1$$fc00$$ENDHEX$$r Content Sheet => Food Contents ohne Sub-Items
// --------------------------------------------------------------------------------------
// Daten aus DataStore Drawer Contents bef$$HEX1$$fc00$$ENDHEX$$llen			
// --------------------------------------------------------------------------------------				
lstr_item = lstr_item_empty
li_Succ = of_sd_get_distr_content(al_Column, al_Row, lstr_item)

ll_Number_of_Distr_Comp = Upperbound(lstr_item)

For ll_Count = 1 To Upperbound(lstr_item)
	If trim(lstr_item[ll_Count].sitem) > "" then
		If lstr_item[ll_Count].lcount = 0 then
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray qty=0 SKIP " + + lstr_item[ll_Count].sitem)
			CONTINUE
		end if
		
		ll_New_Row = rads_distribution_contents.InsertRow(0)
		ll_Content_Header_Detail_Key = (al_Column * 1000) + al_Row								
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key	)
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nrowid", al_content_master_row_id)
		ls_temp_content_pl = lstr_item[ll_Count].cpackinglist  
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "cpackinglist", ls_temp_content_pl)
		ls_temp_content = lstr_item[ll_Count].ctext 
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", ls_temp_content)
		If Trim(ls_temp_content) = "" Then
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", lstr_item[ll_Count].sitem)
		End If						
		if il_Disable_Debug = 0 then
			If isnull(ls_temp_content) then ls_temp_content = "NULL"
			If isnull(ls_temp_content_pl) then ls_temp_content_pl = "NULL"			
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray content sheet FOOD TRAY DISTRIBUTED ITEM al_Rowid="+ String(al_content_master_row_id) + " / " + ls_temp_content + " / " + ls_temp_content_pl + " / " + lstr_item[ll_Count].sitem)
		End If
		ll_temp_qty = lstr_item[ll_Count].lcount 
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nquantity", ll_temp_qty)
		ll_Sort_Counter++
		li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
	End If
Next

For ll_Count = 1 To Upperbound(lstr_item)
	lstr_Temp[upperbound(lstr_Temp) + 1] = lstr_item[ll_Count]
	If trim(lstr_Temp[upperbound(lstr_Temp)].sitem) > "" then 
		If lstr_Temp[upperbound(lstr_Temp)].bdistributed Then
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD DISTRIBUTED " + lstr_Temp[upperbound(lstr_Temp)].sitem )  
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD DISTRIBUTED BUT bdistributed=FALSE " + lstr_Temp[upperbound(lstr_Temp)].sitem )  
		End If
	End If
	
	If lb_Header_Exists = FALSE Then
		// ------------------------------------------------------------------
		// Nur wenn kein Header in diesem Einschub => Explosion Content
		// ------------------------------------------------------------------
		If Upperbound(lstr_item[ll_Count].str_cont) > 0 then	
			For ll_Count_2 = 1 To Upperbound(lstr_item[ll_Count].str_cont)
				ll_Target_pos = upperbound(lstr_Temp) + 1							
				lstr_component_x.ssnr = lstr_item[ll_Count].str_cont[ll_Count_2].ssnr
				lstr_component_x.stext = lstr_item[ll_Count].str_cont[ll_Count_2].stext
				ls_Computed_Item = of_get_item_description( lstr_component_x )
				lstr_Temp[ll_Target_pos].sitem = ls_Computed_Item  
				// F$$HEX1$$fc00$$ENDHEX$$r Backlog
				lstr_Temp[ll_Target_pos].sparent = lstr_item[ll_Count].sitem
				
				lstr_Temp[ll_Target_pos].sparent = lstr_component_x.ssnr + " - " + lstr_component_x.stext
				
				
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY Explosion content zur$$HEX1$$fc00$$ENDHEX$$ck " + lstr_item[ll_Count].str_cont[ll_Count_2].ssnr )
			Next
		End If
	Else
		if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray If lb_Header_Exists = TRUE ")
	End If
Next

// -------------------------------------------
// Items konsolidieren
// -------------------------------------------
guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray 1 Upperbound lstr_item " + String(Upperbound(lstr_item)))	
lstr_temp = lstr_item_empty
lstr_temp = lstr_item
lstr_item = lstr_item_empty
For ll_Count = 1 To Upperbound(lstr_temp)
	If trim(lstr_temp[ll_Count].sitem) > "" then
		If lstr_temp[ll_Count].lcount > 0 then
			If 	NOT Isnull(lstr_temp[ll_Count].sitem) AND &
				lstr_temp[ll_Count].sitem > "" AND &
				lstr_temp[ll_Count].cpackinglist > "" AND &
				lstr_temp[ll_Count].ctext > "" AND & 
				lstr_temp[ll_Count].lcount > 0 Then
						
				lstr_item[upperbound(lstr_item) + 1] = lstr_temp[ll_Count]
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray " + lstr_temp[ll_Count].cpackinglist + " Qty: " + String( lstr_temp[ll_Count].lcount))	
			End If
			
		End If
	End If
Next
guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray 2 Upperbound lstr_item " + String(Upperbound(lstr_item)))	
			
// -------------------------------------------
// alle Items
// -------------------------------------------
for ll_Index = 1 to upperbound(lstr_item)
	If (ll_Index < ll_MaxContent OR (ll_Index = ll_MaxContent AND ll_MaxContent = upperbound(lstr_item)) OR &
		(ll_Index = ll_MaxContent AND NOT lb_backlog_switch)) Then					
	
		ls_DWObject = "t_content_tray_" + string(ll_Index) + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		if ll_Index <= upperbound(lstr_item) Then
			if lstr_item[ll_Index].lcount = 0 Then
				if lstr_item[ll_Index].sitem = ""  Then
					of_modify_text( ls_DWObject, "")
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray lstr_item[ll_Index].lcount=0 " + lstr_item[ll_Index].sitem)	
				Else
					of_modify_text( ls_DWObject, " ")
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray lstr_item[ll_Index].lcount=0 " + lstr_item[ll_Index].sitem)
				End If
			Elseif lstr_item[ll_Index].lcount > 0 Then
				lstr_component_x.ssnr = lstr_item[ll_Index].cpackinglist
				lstr_component_x.stext = lstr_item[ll_Index].ctext
				lstr_component_x.squantity = String(lstr_item[ll_Index].lcount)
				ls_Computed_Item = of_get_item_description( lstr_component_x )
				
				If ll_Index = 1 AND lstr_item[ll_Index].bdistributed = FALSE Then
					ls_Computed_Item = of_get_item_description( lstr_component_x, TRUE )
				End If
				
				If pos(ls_Computed_Item, "'")  > 0 then
					li_Mod = f_replace_string(ls_Computed_Item, "'", "~~~'")
				End If
				of_modify_text( ls_DWObject, ls_Computed_Item)
			Else
				of_modify_text( ls_DWObject,  lstr_item[ll_Index].sitem)
			End If
		Else
			 of_modify_text( ls_DWObject, "???")
		End If
		of_adjust_font({ls_DWObject}, 8, FALSE, FALSE)
		// BOLD
		if ll_Index <= upperbound(lstr_item) Then
			// Distr. Content Top BOLD
			If lstr_item[ll_Index].bdistributed = TRUE Then
				If lb_Header_Exists = FALSE Then
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD " + lstr_item[ll_Index].sitem + "  bdistributed=TRUE")
				Else
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD Header " + lstr_item[ll_Index].sitem + "  bdistributed = FALSE")
				End If					
			End If
		End If
		
		if ll_Index <= upperbound(lstr_item) Then
			If lstr_item[ll_Index].bbold = TRUE Then
				If lb_Header_Exists = FALSE Then
					of_adjust_font({ls_DWObject}, 8, TRUE, FALSE)
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD " + lstr_item[ll_Index].sitem + "bbold = TRUE")
				Else
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD Header " + lstr_item[ll_Index].sitem + "bbold = FALSE")
				End If
			End If
//			// Distr. Content Top BOLD
//			If lstr_item[ll_Index].bdistributed = TRUE Then
//				If lb_Header_Exists = FALSE Then
//					//of_adjust_font({ls_DWObject}, 8, TRUE, FALSE)
////					of_modify_dw(ls_DWObject + '.font.weight="700"')
//					//if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD " + lstr_item[ll_Index].sitem + "bdistributed=TRUE")
//				Else
//					//if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY/DRAWERFOOD Header " + lstr_item[ll_Index].sitem + "bdistributed = FALSE")
//				End If					
//			End If
		End If
		
		ll_leg_from_ccode = lstr_item[ll_Index].lleg
		If NOT IsNULL(ll_leg_from_ccode) Then
			If ll_leg_from_ccode > 1 Then
				If Trim(lstr_item[ll_Index].sitem) > "" Then
					lb_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray DOWNLINE LEG FROM DIST " + String(ll_leg_from_ccode))
				End If
			Else
				If Trim(lstr_item[ll_Index].sitem) > "" AND lstr_item[ll_Index].lcount > 0 Then
					lb_Suppress_Watermark_Downline = TRUE
					guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
				End If
			End If
		Else
			If Trim(lstr_item[ll_Index].sitem) > ""  AND lstr_item[ll_Index].lcount > 0 Then
				lb_Suppress_Watermark_Downline = TRUE
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If
		If il_Disable_Debug = 0 Then
			If lb_Watermark_Downline Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray DOWNLINE LEG lb_Watermark_Downline=TRUE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			Else
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray DOWNLINE LEG lb_Watermark_Downline=FALSE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If						
		of_set_position( ls_DWObject, TRUE)
	else
		// --------------------------------------------
		// Backlog
		// --------------------------------------------
		lb_Overflow = TRUE
		//If il_Disable_Debug = 0 Then
			If Trim(lstr_item[ll_Index].sitem) > "" Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY ll_Index " + String(ll_Index) + " < ll_MaxContent " + String(ll_MaxContent) + " SEE BACKLOG...")
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_tray TRAY BACKLOG " + lstr_item[ll_Index].sitem )
			End If
		//End If
		ls_DWObject = "t_content_tray_" + string(ll_Index) + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")

		If lb_backlog_switch then
			of_modify_text( ls_DWObject, is_Overflow_MSG_2)
			ls_Parent =  lstr_item[ll_Index].sparent
			If isnull(ls_Parent) then ls_Parent = ""
			
			lstr_component_x.ssnr = lstr_item[ll_Index].cpackinglist
			lstr_component_x.stext = lstr_item[ll_Index].ctext
			lstr_component_x.squantity = ""
			ls_Computed_Item = of_get_item_description( lstr_component_x )
			
			//li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, lstr_item[ll_Index].lcount , "", ls_Computed_Item, ll_Index  , DRAWER_MULTI_RUNG, ls_Parent, al_content_master_row_id ) 
			//li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, lstr_item[ll_Index].lcount , "", ls_Computed_Item, ll_Index  , TRAY, "", al_content_master_row_id ) 
			
			//issue #5320 Overflow sheet shows other unit than shown on cartdiagram
			ll_Type = of_get_type( al_row,al_column)
			If ll_Type = 3 then 
				ll_Type = 13
			End If
			
			// issue #5828 Cartdiagramm Overflow
			If ll_Type = TRAY then 
				ll_Type = TRAYNONFOOD
			End If
			li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, lstr_item[ll_Index].lcount , "", ls_Computed_Item, ll_Index  , ll_Type  , "", al_content_master_row_id ) 

			//li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, lstr_item[ll_Index].lcount , "", ls_Computed_Item, ll_Index  , TRAYNONFOOD, "", al_content_master_row_id ) 

			
		End If
		of_adjust_font({ls_DWObject}, 8, FALSE, FALSE)		
		
		// ----------------------------------------------------------------------------------------------------
		// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
		// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
		//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
		//							 should appear automatically and a Content spec should be generated
		// ----------------------------------------------------------------------------------------------------
		If ib_non_sky then
			of_modify_text(ls_DWObject, is_Overflow_MSG_1)
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_comp_tray non sky BACKLOG => CONTENT SPEC " + ls_Parent + " /" + ls_Computed_Item) 
			// add content spec ###########					
		End If
	
	end if
	

next
// --------------------------------------------
// "..." ersetzen durch BLANK
// --------------------------------------------
If upperbound(lstr_item) < ll_MaxContent Then
	for ll_Index = upperbound(lstr_item) + 1 to ll_MaxContent
		ls_DWObject = "t_content_tray_" + string(ll_Index) + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		of_modify_text( ls_DWObject, " ")
	Next			
End If

//U.Paudler 19.09.2012 Hier pr$$HEX1$$fc00$$ENDHEX$$fen of der Eintrag der einzige ist
if upperbound(lstr_item) = 1 then
	of_adjust_font({ls_DWObject}, 8, TRUE, FALSE)
	ll_index_key = f_get_packinglist_key( lstr_item[1].cpackinglist )
	If of_check_explode(ll_index_key, arg_unit) Then
		of_adjust_text_size_small_big({ls_DWObject}, ll_MaxContent)
		li_Succ = of_vertical_center_text_within_drawer( {ls_DWObject}, al_column, al_row)
	End If
end if

// --------------------------------------------------------------------------------------
// Content Sheet Indicator - auch fixed content checken
// --------------------------------------------------------------------------------------				
If lb_Content_Spec_Drawer = FALSE then
	lstr_item = lstr_item_empty
	ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
	if ll_Found > 0 Then
		ll_Content				= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
		ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
		ll_Show_Type 			= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
		//li_Succ = of_get_fixed_content(ll_layoutdetailkey, CONTENT , al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, TRUE)
		
		If of_get_type(al_Row, al_Column) = TRAYNONFOOD Then
			li_Succ = of_get_fixed_content_tray(ll_layoutdetailkey, ll_Show_Type , al_row, al_column, TRAYNONFOOD, arg_unit , 1, lstr_item, FALSE)
		Else
			li_Succ = of_get_fixed_content(ll_layoutdetailkey, CONTENT , al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, TRUE)
		End If
		ll_Number_of_Fixed_Content = upperbound(lstr_item) 
		for ll_Index = 1 to upperbound(lstr_item) 
			
			// #####################
			if ll_Index > ll_MaxContent OR (ll_Index = ll_MaxContent AND upperbound(lstr_item) > ll_MaxContent) Then
				if of_is_backlog_enabled() Then
					//lsText =  of_get_item_description(lstr_component)
					// Backlog
					ldec_Qty = lstr_item[ll_Index].lcount
					ls_header = uf.translate("Tray")  //lstr_item[ll_Index].sparent
					lstr_component_x.ssnr = lstr_item[ll_Index].cpackinglist
					lstr_component_x.stext = lstr_item[ll_Index].ctext
					ls_Text = of_get_item_description(lstr_component_x)

					//li_Succ = of_add_backlog   ( al_row, al_column, ls_DWObject, ldec_Qty , "", ls_Text,  ll_Index,  PACKINGLIST, ls_header)
					//li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, ldec_Qty , "", ls_Text,  ll_Index,  PACKINGLIST, ls_header, al_content_master_row_id ) 
					li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, ldec_Qty , "", ls_Text,  ll_Index,  TRAYNONFOOD, ls_header, al_content_master_row_id ) 
				
				End If
			End If
				// ######################	
			
			
			If ll_Index > 1 then
				// nur Header pro$$HEX1$$fc00$$ENDHEX$$fen = 1. Eintrag
				CONTINUE
			End If
			
			If trim(lstr_item[ll_Index].cpackinglist) > "" Then
				
				ll_index_key = f_get_packinglist_key(lstr_item[ll_Index].cpackinglist)
				lb_Content_Spec_PL = of_is_content_spec_enabled(ll_index_key , is_CSC, idt_departure )
				If lb_Content_Spec_PL Then
					If ll_Index = 1 Then
						// ###############
						lb_Content_Spec_Drawer = TRUE
					End if
				End if
			End if
		Next
	End If
else
	lstr_item = lstr_item_empty
	ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
	if ll_Found > 0 Then
		ll_Content			= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
		ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
	
		li_Succ = of_get_fixed_content(ll_layoutdetailkey, CONTENT , al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, TRUE)
		ll_Number_of_Fixed_Content = upperbound(lstr_item) 
	End If
End If

If NOT ib_Disable_Content_Spec_MSG Then
	// --------------------------------------------------------------------------
	// Content Sheet Indicator
	// --------------------------------------------------------------------------
	If lb_Content_Spec_Drawer = TRUE Then
		// Auf die letzte Zeile die Nachricht "Overflow" / "Overflow & Content Spec"
		If lb_Overflow AND of_is_backlog_enabled() Then
			ls_MSG = is_Overflow_MSG_3
		Else
			ls_MSG = is_Overflow_MSG_1		
		End if
		
		// CBASE-NAM-CR-16008 if the content doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator "content spec" should appear and a Content spec should be generated
		If lb_Overflow AND ib_non_sky Then
			ls_MSG = is_Overflow_MSG_1		
		End if
		
		ls_DWObject = "t_content_std_text_" + string(ll_MaxContent, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		//ls_Alternative_Object = "t_content_text_"  + string(ll_MaxContent,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		of_modify_text(ls_DWObject , ls_MSG)

		ls_DWObject = "t_content_tray_" + string(ll_MaxContent) + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		of_modify_text(ls_DWObject , ls_MSG)		

		If il_Disable_Debug = 0 Then
			//of_modify_dw(ls_DWObject + ".Color='" + String(rgb(0,255,0)) + "'" )
			//of_modify_dw(ls_Alternative_Object + ".Color='" + String(rgb(0,255,0)) + "'" )
		End if
	End if
End If

//U.Paudler 19.09.2012 Hier pr$$HEX1$$fc00$$ENDHEX$$fen of der Eintrag der einzige ist
if ll_Number_of_Distr_Comp = 0 and ll_Number_of_Fixed_Content= 1 then
	ls_DWObject = "t_content_tray_" + string(1) + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
	If upperbound(lstr_item) > 0 then
		of_adjust_font({ls_DWObject}, 8, TRUE, FALSE)
		ll_index_key = f_get_packinglist_key( lstr_item[1].cpackinglist )
		If of_check_explode(ll_index_key, arg_unit) Then
			of_adjust_text_size_small_big({ls_DWObject}, ll_MaxContent)
			li_Succ = of_vertical_center_text_within_drawer( {ls_DWObject}, al_column, al_row)
		end if
	end if
end if

If ib_Downline_by_Mealcode = TRUE  AND of_is_downline_enabled(arg_unit) AND lb_Watermark_Downline = TRUE Then
	li_Succ = of_draw_watermark_downline(al_Row, al_Column, of_get_type(al_Row, al_Column), rgb(200,200,200))
End if				

Return 1

end function

public function integer of_init_cd_tripticket (string as_unit, long al_airline_key, ref uo_tripticket rauo_tripticket);/*
* Objekt : uo_client_label
* Methode: of_init_cd_tripticket (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 20.08.2012
*
* Argument(e):
*	 		string				as_unit
*	 		long					al_airline_key
*	 ref	uo_cart_diagram	rauo_diagram
*
* Beschreibung:		fill Trip Ticket Information from Secondary Distribution Results
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	20.08.2012		Erstellung
*
*
* Return: long
*
*/

Integer	li_Succ
Long		ll_Rowid
String	ls_Area, ls_Workstation, ls_Class_1, ls_Stowage 
String	ls_packinglist, ls_pl_description, ls_PL_Unit
Long		ll_Class_Number
Long		ll_Row
Long		ll_Rows



//ll_Rows = rauo_tripticket.ids_packinglists.Saveas("c:\temp\cbase\tripticket_xxx"+string(n)+".xls",excel5!,true)


ll_Rows = rauo_tripticket.ids_packinglists.RowCount()
//li_Succ = rauo_tripticket.ids_packinglists.Reset()
//ll_Rows = rauo_tripticket.ids_packinglists.RowCount()
//
//If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_init_cd_tripticket BEGIN")
//
//For ll_Row = 1 to  ids_sd_master.rowcount()
//	ll_Rowid					= ids_sd_master.GetItemNumber(ll_Row, "nrowid")
//	If ids_sd_cart.Find("nrowid=" + String(ll_Rowid), 1, ids_sd_cart.RowCount()) < 1 then
//		CONTINUE		
//	End if
//	
//	ls_Class_1				= ids_sd_master.GetItemString(ll_Row, "CCLASS_1")
//	ll_Class_Number		= f_get_class_key(ls_Class_1 , al_airline_key )			
//	ls_PL_Unit				= ids_sd_master.GetItemString(ll_Row, "CPL_UNIT")
//	ls_Area 					= ids_sd_master.GetItemString(ll_Row, "CAREA")
//	ls_Workstation			= ids_sd_master.GetItemString(ll_Row, "CMULTI_WS_1")
//	ls_packinglist 		= ids_sd_master.GetItemString(ll_Row, "CPACKINGLIST")
//	ls_pl_description		= ids_sd_master.GetItemString(ll_Row, "CTEXT")
//	ls_Stowage 				= trim(ids_sd_master.GetItemString(ll_Row, "cstowage"))
//	// -----------------------------------------------------
//	// Include in TripTicket
//	// -----------------------------------------------------
//	rauo_tripticket.of_add_packinglist(ls_PL_Unit, ls_packinglist, ls_pl_description, ls_Workstation, ls_Stowage, ls_Class_1, ll_Class_Number, ls_Area )
//	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".Include in TripTicket " + ls_packinglist)
//next
//
//If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_init_cd_tripticket END " )
//
ll_Rows = rauo_tripticket.ids_packinglists.RowCount()
	
	
Return 1

end function

public function integer of_count_cart_diagram_pages (string as_unit, long al_airline_key, ref datastore rads_unassigned, ref datastore rads_eq, ref datastore rads_cartdiagramsheet, ref uo_tripticket rauo_tripticket);/*
* Objekt : uo_client_label
* Methode: of_count_cart_digram_pages (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 01.08.2012
*
* Argument(e):
*	 		string				as_unit
*	 		long					al_airline_key
*	 ref	uo_cart_diagram	rauo_diagram
*	 ref	datastore			rads_unassigned
*	 ref	datastore			rads_eq
*
* Beschreibung:		Count pages for Cart Diagram
*							Detect unassigned carts
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer		01.08.2012		Erstellung
* 1.1				K.Winckler	08.11.2012		CBASE-NAM-CR-12033 (Druckausschluesse nach Airline-Workstation Kombi)
* 1.2 			O.Hoefer		12.12.2012		CBASE-NAM-CR-12071 Masterdata View => all local settings are ignored
* 1.3 			O.Hoefer		06.02.2013		CBASE-NAM-CR-12033 NEU Nicht durcken, wenn TR cart aktiv
* 1.4 			O.Hoefer		12.02.2013		$$HEX1$$c400$$ENDHEX$$nderung unassigned-handling
* 1.5 			O.Hoefer		15.02.2013		Bugfix suppress Workstation
* 1.6 			O.Hoefer		28.04.2014		$$HEX1$$c400$$ENDHEX$$nderung unassigned-handling (4.99 Error 140 NTS: checkbox "print"=OFF => unassigned)
* 1.7 			O.Hoefer		08.05.2014		$$HEX1$$c400$$ENDHEX$$nderung unassigned-handling (4.99 Error 140 NTS: no print [TR] => not unassigned)
*
* Return: long
*
*/


String		ls_Area, ls_Workstation, ls_Temp_PL, ls_Class_1, ls_Class, ls_Stowage, ls_Loadinglist, ls_Temp
String		ls_packinglist, ls_pl_description, ls_Area_WS, ls_PL_Unit
String		ls_Sort
Long		ll_IndexKey, ll_Belly, ll_DetailKey, ll_unassigned_Row, ll_Found, ll_pages, ll_Class_Number
Long		ll_EQ
Long		ll_Eq_Rows
Integer	li_Succ
Long		ll_Row
Long		ll_New_Row
Long		ll_Page_Counter
Long		ll_Sequence
Long		ll_Row_id
Long		ll_Columns, ll_Rungs
Long		ll_Force_TR_Diagram	
Long		ll_Force_Diagram	
Long		ll_workstation_key
Long		ll_TR_Cart_Switch
Long		ll_Diagram_Enabled
Boolean	lb_No_Entry
Boolean	lb_Workstation_OFF
Boolean	lb_TR_Cart_Exists
Boolean	lb_Suppress_Print_because_TR_Cart_is_printed

ll_Eq_Rows = rads_EQ.rowcount()

// ---------------------------------------------------------------------------------------------
// Schleife f$$HEX1$$fc00$$ENDHEX$$r Seitenz$$HEX1$$e400$$ENDHEX$$hlung
// ---------------------------------------------------------------------------------------------
If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages BEGIN")

// Sort 
//ls_Sort = of_get_cd_sort( is_section )
// guoLog.uf_debug( "["+ this.classname( )+".of_get_cd_sort " + is_section + " " + ls_Sort)
//li_Succ = rads_CartdiagramSheet.SetSort(ls_Sort)
//li_Succ = rads_CartdiagramSheet.Sort()

ls_Sort = rads_CartdiagramSheet.Describe("DataWindow.Table.Sort")
guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages rads_CartdiagramSheet.Sort " + ls_Sort)

li_Succ = rads_CartdiagramSheet.Sort()

//rads_CartdiagramSheet.saveas("c:\temp\cbase\count_ds_CartdiagramSheet_" + String(cpu()) + ".xls",excel5!,true)

lb_TR_Cart_Exists = of_exists_tr_cart_per_unit(as_unit)

ll_Pages = rads_CartdiagramSheet.Rowcount()
For ll_Row = 1 to rads_CartdiagramSheet.Rowcount()
	ls_Area		   	= ""
	ls_Workstation 	= ""
	ll_IndexKey 		= rads_CartdiagramSheet.GetItemNumber(ll_Row, "lindex_key")
	ls_Temp_PL			= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
	ll_DetailKey 		= rads_CartdiagramSheet.GetItemNumber(ll_Row, "ldetail_key")
	ll_Belly 			= rads_CartdiagramSheet.GetItemNumber(ll_Row, "nbelly")
	ls_Class				= rads_CartdiagramSheet.GetItemString(ll_Row, "sclass")
	ls_Class_1			= rads_CartdiagramSheet.GetItemString(ll_Row, "sclass_1")
	ls_Area 				= rads_CartdiagramSheet.GetItemString(ll_Row, "sarea")
	ls_Workstation		= rads_CartdiagramSheet.GetItemString(ll_Row, "sworkstation")
	ls_Loadinglist		= rads_CartdiagramSheet.GetItemString(ll_Row, "sloadinglist")
	ls_Temp_PL			= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
	ls_packinglist 	= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
	ls_Stowage 			= trim(rads_CartdiagramSheet.GetItemString(ll_Row, "sstowage"))
	// TR Cart Switch
	ll_TR_Cart_Switch = rads_CartdiagramSheet.GetItemNumber(ll_Row, "ntransporter_cart")
		
	ll_workstation_key= rads_CartdiagramSheet.GetItemNumber(ll_Row, "nworkstation_key")

	guoLog.uf_debug( "["+ this.classname( )+".COUNT PAGES Row: " + String(ll_Row) + " " + ls_packinglist + " / " + ls_Stowage)
	
	If isnull(ls_Class_1) then
		guoLog.uf_debug( "["+ this.classname( )+".Warning sclass_1 is EMPTY " + ls_Temp_PL + " / " + ls_Stowage)
		ls_Class_1 = "-"
	end if

	// CBASE-NAM-CR-12033: Pruefung und Aufruf angepasst
	lb_Workstation_OFF = of_check_workstation_exclude(ll_workstation_key, al_airline_key)
	If lb_Workstation_OFF Then
		guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF local workstation exclusion " + ls_packinglist)
	End If
	
	// CBASE-NAM-CR-12071: "all those local settings are ignored and all Cart Diagrams 
	//                      will be printed and previewed for which a Cart is defined in central Master Data"
	If ib_enable_masterdata_view Then
		If lb_Workstation_OFF Then
			lb_Workstation_OFF = FALSE
			guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF locally ("+ls_Workstation+"), but ib_enable_masterdata_view=ON " + ls_packinglist)
		End If
	End If
	
	ll_Force_Diagram = 0 
	ll_Force_TR_Diagram = 0 
	ls_PL_Unit	= rads_CartdiagramSheet.GetItemString(ll_Row, "spl_unit")
	ll_EQ			= rads_EQ.Find("cunit='" + ls_PL_Unit + "'", 1, rads_EQ.RowCount())
	If ll_EQ > 0 then	
		ll_Force_Diagram	= rads_EQ.GetItemNumber(ll_EQ, "nforce_print")
		ll_Force_TR_Diagram = rads_EQ.GetItemNumber(ll_EQ, "nforce_print")
		If ll_Force_Diagram = 1 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages  " + ls_Temp_PL + " ("+ls_Workstation+"), ll_Force_Diagram 1 => 0 " + ls_packinglist)
		End If
		If ll_Force_TR_Diagram = 1 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages  " + ls_Temp_PL + " ("+ls_Workstation+"), ll_Force_TR_Diagram 1 => 0 " + ls_packinglist)
		End If
	End If
	
	lb_No_Entry = FALSE
	If isnull( s_app.sMandant) or  	s_app.sMandant = "" then  s_app.sMandant = "002"
	ll_Diagram_Enabled = of_is_cartdiagram_enabled(ll_IndexKey, s_app.sMandant, as_unit, lb_No_Entry)
	If ll_Force_Diagram = 0 Then
		// wenn nforce_print = 1, dann trotz fehlender area allocation drucken, sonst nicht
		If lb_No_Entry then
			ll_Diagram_Enabled = 0 
		End If
	End If
	
	If lb_Workstation_OFF Then
		If ll_Diagram_Enabled > 0 Then
			ll_Diagram_Enabled = 0 
			guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF locally ("+ls_Workstation+"), ll_Diagram_Enabled 1 => 0 " + ls_packinglist)
		End If
		If ll_Force_Diagram = 1 Then
			ll_Force_Diagram = 0
			guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF locally ("+ls_Workstation+"), ll_Force_Diagram 1 => 0 " + ls_packinglist)
		End If
	End If
	
	//	//ll_TR_Cart_Switch
	// ----------------------------------------------------------
	// CBASE-NAM-CR-12033-centralCDs_revisedV5.doc
	//	Update 06/02/2013 NTS: If the following criteria are ALL TRUE, no Cart Diagram should get generated,
	//									but the Item List should show in the TR Cart Diagram only:
	//	Item List is allocated to a Galley and Stowage Position which has Type TR Cart
	//	Unit of Item List is setup in Airline Information Tab Miscellaneous in section Equipment and checkbox Print Cart Diagram is active
	//	A TR Cart is setup under Local-Catering Unit Setup Cart Diagrams and Trans-porters
	// If one or all are not true a Cart Diagram for the respective Item List should be printed.
	// ----------------------------------------------------------
	// Suppress Diagram if 
	//	ll_Force_TR_Diagram = 1 
	// ll_TR_Cart_Switch = 1
	// lb_TR_Cart_Exists = TRUE
	If ll_Force_TR_Diagram = 1 AND ll_TR_Cart_Switch = 1 AND lb_TR_Cart_Exists = TRUE Then
		lb_Suppress_Print_because_TR_Cart_is_printed = TRUE
		guoLog.uf_debug( "["+ this.classname( )+".SUPPRESS CART DIAGRAM because TR Cart is printed () " + ls_packinglist)
	Else
		lb_Suppress_Print_because_TR_Cart_is_printed = FALSE
	End If

	// 06.02.2013 CBASE-NAM-CR-12033 nicht drucken
	if (ll_Diagram_Enabled < 1 AND ll_Force_Diagram = 0) OR lb_Suppress_Print_because_TR_Cart_is_printed = TRUE then
		guoLog.uf_debug( "["+ this.classname( )+".Page Counter Row " + String(ll_Row) + " Exclude " + ls_Temp_PL)
		
		// 2014-04-28 NTS: checkbox "print"=OFF => unassigned
		//If of_is_cartdiagram_enabled(ll_IndexKey, s_app.sMandant, as_unit, lb_No_Entry) < 1 Then
			
			If lb_Suppress_Print_because_TR_Cart_is_printed Then
				// -----------------------------------------------------------------------
				// if not printed, but checkbox=ON then NOT UNASSIGNED (4.99 Issue 147)
				// -----------------------------------------------------------------------
				guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages NOT PRINTED BUT NOT UNASSIGNED " + ls_Temp_PL)
			
			ELSE
			
				guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages UNASSIGNED " + ls_Temp_PL)
				
				ll_unassigned_Row =  rads_unassigned.InsertRow(0)
				li_Succ = rads_unassigned.SetItem(ll_unassigned_Row , "cpackinglist", ls_Temp_PL)	
				ls_Temp = rads_CartdiagramSheet.GetItemString(ll_Row, "stext")
				li_Succ = rads_unassigned.SetItem(ll_unassigned_Row , "ctext", ls_Temp)
				li_Succ = rads_unassigned.SetItem(ll_unassigned_Row , "cstowage", ls_Stowage)	
				
				// ----------------------------------------------------------
				// Diagram not enabled - Unassigned in Sec. Distr. DataStore
				// ----------------------------------------------------------
				ll_New_Row	= ids_sd_message.InsertRow(0)
				ll_Sequence = f_Sequence ("SEQ_CEN_OUT_SD_message", sqlca)
				If ll_Sequence <> -1 Then
					li_Succ = ids_sd_message.SetItem(ll_New_Row, "NSD_MSG_KEY", ll_Sequence)
				else
					uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
													 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
				end if
				ll_Row_id	= rads_CartdiagramSheet.GetItemNumber(ll_Row, "nrowid")
				li_Succ		= ids_sd_message.SetItem(ll_New_Row, "nresult_key", il_Result_Key )						
				li_Succ		= ids_sd_message.SetItem(ll_New_Row, "ntransaction", il_transaction )
				li_Succ		= ids_sd_message.SetItem(ll_New_Row, "nrowid", ll_Row_id)
				li_Succ		= ids_sd_message.SetItem(ll_New_Row, "cpackinglist", ls_Temp_PL)
				li_Succ		= ids_sd_message.SetItem(ll_New_Row, "ctext", ls_Temp)
				li_Succ		= ids_sd_message.SetItem(ll_New_Row, "cstowage", left(ls_Stowage, 1000))
				li_Succ		= ids_sd_message.SetItem(ll_New_Row, "nmsgtype", MSG_UNASSIGNED )
		
//		Else
//			guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages EXCLUDE BUT NOT UNASSIGNED " + ls_Temp_PL)
//		End If

		End If
			
		ll_pages --
		// -----------------------------------------------------
		// Diagram not enabled - but include in TripTicket!
		// -----------------------------------------------------
		ll_Class_Number = f_get_class_key(ls_Class_1 , al_airline_key )			
		ls_PL_Unit					= rads_CartdiagramSheet.GetItemString(ll_Row, "spl_unit")
		ls_Area 						= rads_CartdiagramSheet.GetItemString(ll_Row, "sarea")
		ls_Workstation				= rads_CartdiagramSheet.GetItemString(ll_Row, "sworkstation")
		ls_packinglist 			= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
		ls_pl_description			= rads_CartdiagramSheet.GetItemString(ll_Row, "stext")
		ls_Area_WS					= ls_Area
		If NOT IsNULL(ls_Workstation) Then
			If Trim(ls_Workstation) > "" Then
				ls_Area_WS += "-" + ls_Workstation			
			End If
		End If
		rauo_tripticket.of_add_packinglist(ls_PL_Unit, ls_packinglist, ls_pl_description, ls_Area_WS, ls_Stowage, ls_Class_1, ll_Class_Number, ls_Area )
		if il_Disable_Debug = 0 then
			guoLog.uf_debug( "["+ this.classname( )+".Diagram not enabled - but include in TripTicket " + ls_packinglist)
		End If


		// ############ CONTENT SPEC f$$HEX1$$fc00$$ENDHEX$$r nicht edruckte Stauorte???

		CONTINUE
	Else
		// -----------------------------------------------------
		// Diagram is enabled - include in TripTicket!
		// -----------------------------------------------------
		ll_Class_Number	= f_get_class_key(ls_Class_1 , al_airline_key )			
		ls_PL_Unit			= rads_CartdiagramSheet.GetItemString(ll_Row, "spl_unit")
		ls_Area 				= rads_CartdiagramSheet.GetItemString(ll_Row, "sarea")
		ls_Workstation		= rads_CartdiagramSheet.GetItemString(ll_Row, "sworkstation")
		
		// -----------------------------------------------------
		// If not allocated: Area / WS Empty
		// -----------------------------------------------------		
		If lb_No_Entry Then
			ls_Area			= ""
			ls_Workstation	= ""
		End If
		
		// -----------------------------------------------------
		// Central
		// -----------------------------------------------------		
		If ll_Force_Diagram = 1 AND lb_No_Entry Then
			ls_Area			= ""
			ls_Workstation	= ""
		End If
		ls_packinglist		= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
		ls_pl_description	= rads_CartdiagramSheet.GetItemString(ll_Row, "stext")
		ls_Area_WS			= ls_Area
		If NOT IsNULL(ls_Workstation) Then
			If Trim(ls_Workstation) > "" Then
				ls_Area_WS += "-" + ls_Workstation			
			End If
		End If
		rauo_tripticket.of_add_packinglist(ls_PL_Unit, ls_packinglist, ls_pl_description, ls_Area_WS, ls_Stowage, ls_Class_1, ll_Class_Number, ls_Area )
		if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".Diagram not enabled - but include in TripTicket " + ls_packinglist)
		ls_PL_Unit = rads_CartdiagramSheet.GetItemString(ll_Row, "spl_unit")
		ll_EQ = rads_EQ.Find("cunit='" + ls_PL_Unit + "'", 1, rads_EQ.RowCount())
		If ll_EQ < 1 then	
			ls_Temp_PL = rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
			if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".Page Count NO VALID EQ " + String(ll_Row) + " Exclude " + ls_Temp_PL)
			ll_pages --
			CONTINUE
		Else
			ls_Temp_PL = rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".Page Count " + String(ll_Row) + " Include " + ls_Temp_PL)
		End If
		// -----------------------------------------------------
		// Secondary Distr: Pages
		// -----------------------------------------------------
		ll_Page_Counter++
		ll_New_Row	= ids_sd_cart.InsertRow(0)
		
		guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_digram_pages ids_sd_cart  " + ls_packinglist + &
						"  nrowid=" + String(ll_Row_id) + " page= " + String(ll_Page_Counter))
		
		ll_Sequence = f_Sequence ("SEQ_CEN_OUT_SD_CART", sqlca)
		If ll_Sequence <> -1 Then
			li_Succ = ids_sd_cart.SetItem(ll_New_Row, "NSD_CART_KEY", ll_Sequence)
		else
			uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
											 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
		end if
		ll_Row_id	= rads_CartdiagramSheet.GetItemNumber(ll_Row, "nrowid")
		li_Succ		= ids_sd_cart.SetItem(ll_New_Row, "nresult_key", il_result_key )						
		li_Succ		= ids_sd_cart.SetItem(ll_New_Row, "ntransaction", il_transaction )
		li_Succ		= ids_sd_cart.SetItem(ll_New_Row, "nrowid", ll_Row_id)
		li_Succ		= ids_sd_cart.SetItem(ll_New_Row, "npage", ll_page_Counter)
		ll_EQ			= rads_EQ.Find("cunit='" + ls_PL_Unit + "'", 1, rads_EQ.RowCount())
		If ll_EQ > 0 then	
			ll_Columns			= rads_EQ.GetItemNumber(ll_EQ, "ncolumns")
			ll_Rungs				= rads_EQ.GetItemNumber(ll_EQ, "nrows")
			li_Succ				= ids_sd_cart.SetItem(ll_New_Row, "ncolumns", ll_Columns)
			li_Succ				= ids_sd_cart.SetItem(ll_New_Row, "nrungs", ll_Rungs)
			ll_Force_Diagram	= rads_EQ.GetItemNumber(ll_EQ, "ncolumns")
		End if
	End If		
Next

If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_count_cart_diagram_pages END " + String(ll_pages))
	
Return ll_pages

end function

public function integer of_create_or_load_sec_distr (long al_result_key, long al_transaction, ref uo_distribution rauo_distribution, long al_airline_key, string as_unit, ref datastore rads_unassigned, ref datastore rads_eq, boolean ab_contentsheet, ref datastore rads_cartdiagramsheet, ref uo_tripticket rauo_tripticket, ref uo_content_sheet rauo_contentsheet);/*
* Objekt : uo_client_label
* Methode: of_create_or_load_sec_distr (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 08.08.2012
*
* Argument(e):
*	 		long					al_result_key
*	 		long					al_transaction
*	 ref	uo_cart_diagram	rauo_diagram
*	 ref	uo_distribution	rauo_distribution
*	 		long					al_airline_key
*	 		string				as_unit
*	 ref	datastore			rads_unassigned
*	 ref	datastore			rads_eq
*	 		boolean				ab_contentsheet
*
* Beschreibung:		Load from DB or fill Secondary Distribution DataStores
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	08.08.2012		Erstellung
* 1.1 			O.Hoefer	28.11.2012		Never Load from DB, always create new
* 1.3 			O.Hoefer	16.01.2014		CBASE-UK-CR-2013-013 Additional text
* 1.4 			O.Hoefer	27.02.2014		CBASE-UK-CR-2013-002 Galley Group
*
*
* Return: long
*
*/

Integer	li_Succ
Long		ll_Rows
Long		ll_Row
Long		ll_num_rows
Long		ll_Belly
Long		ll_RowId
Long		ll_pages
Long		ll_sd_cart_key
Long		ll_Current_Page
Long		ll_Found
Long		ll_IndexKey
Long		ll_DetailKey
Long		ll_Galley_Group
Long		ll_New_Row
Long		ll_Temp_Sort
String		ls_Find
String		ls_Container
String		ls_loadinglist
String		ls_File
String		ls_Stowage
String		ls_Stowage_Only
String		ls_Galley
String		ls_packinglist
String		ls_Sort
String		ls_Add_on_Text
Boolean	lb_explode
Boolean	lb_Breakpoint


// ---------------------------------------------------------------------------------------------
// Immer gespeicherte secondary distribution l$$HEX1$$f600$$ENDHEX$$schen
// ---------------------------------------------------------------------------------------------
li_Succ = of_delete_secondary_distribution(al_result_key, al_transaction)

// ---------------------------------------------------------------------------------------------
// Create or load secondary distribution
// ---------------------------------------------------------------------------------------------
ll_rows = ids_SD_Master.Retrieve(al_result_key, al_transaction)
If ll_rows > 0 AND ib_enable_secondary_distr_saving = TRUE Then
	// ---------------------------------------------------------------------------------------------
	// Wenn secondary distribution gespeichert ist: DataStores laden
	// ---------------------------------------------------------------------------------------------
	ll_rows = ids_SD_Components		.Retrieve(al_result_key, al_transaction)
	ll_rows = ids_SD_Cart 				.Retrieve(al_result_key, al_transaction)
	ll_rows = ids_SD_Cart_Drawer		.Retrieve(al_result_key, al_transaction)
	ll_rows = ids_SD_Drawer_Content	.Retrieve(al_result_key, al_transaction)
	ll_rows = ids_SD_Message			.Retrieve(al_result_key, al_transaction)
Else
	// ---------------------------------------------------------------------------------------------
	// Wenn keine secondary distribution gespeichert ist: neu erstellen 
	// 1. Master 
	// ---------------------------------------------------------------------------------------------	
	ll_num_rows = rads_CartdiagramSheet.Rowcount()
	For ll_Row = 1 to rads_CartdiagramSheet.Rowcount()
		li_Succ = rads_CartdiagramSheet.SetItem(ll_Row, "nresult_key", al_result_key )	
		li_Succ = rads_CartdiagramSheet.SetItem(ll_Row, "ntransaction", al_transaction )			
	Next
	
	ls_Sort = rads_CartdiagramSheet.Describe("DataWindow.Table.Sort")
	guoLog.uf_debug( "["+ this.classname( )+".of_create_or_load_sec_distr rads_CartdiagramSheet.Sort " + ls_Sort)
	
	li_Succ = rads_CartdiagramSheet.Sort()
	
	If ll_num_rows > 0 then
		ls_File = f_gettemppath() +  "rads_CartdiagramSheet_temp_"+String(cpu())+".csv"
		//ll_num_rows = rads_CartdiagramSheet.SaveAs(ls_File , CSV!, FALSE)
		//li_Succ = rads_CartdiagramSheet.rowscopy(1, rads_CartdiagramSheet.Rowcount(), Primary!, lds_SD_Master, 1, Primary!)
		//ll_num_rows = ids_SD_Master.ImportFile(ls_File)

		//rads_CartdiagramSheet.SaveAs(f_gettemppath() +  "rads_CartdiagramSheet_temp_"+String(cpu())+".xls" , excel5!, TRUE)
      
		For ll_Row = 1 to rads_CartdiagramSheet.Rowcount()
			ll_New_Row = ids_SD_Master.InsertRow(0)
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  1, rads_CartdiagramSheet.GetItemNumber(ll_Row,  1)   )   
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  2, rads_CartdiagramSheet.GetItemNumber(ll_Row,  2)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  3, rads_CartdiagramSheet.GetItemDateTime(ll_Row,  3)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  4, rads_CartdiagramSheet.GetItemNumber(ll_Row,  4)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  5, rads_CartdiagramSheet.GetItemNumber(ll_Row,  5)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  6, rads_CartdiagramSheet.GetItemString(ll_Row,  6)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  7, rads_CartdiagramSheet.GetItemString(ll_Row,  7)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  8, rads_CartdiagramSheet.GetItemString(ll_Row,  8)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row,  9, rads_CartdiagramSheet.GetItemString(ll_Row,  9)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 10, rads_CartdiagramSheet.GetItemDateTime(ll_Row, 10)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 11, rads_CartdiagramSheet.GetItemString(ll_Row, 11)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 12, rads_CartdiagramSheet.GetItemString(ll_Row, 12)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 13, rads_CartdiagramSheet.GetItemString(ll_Row, 13)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 14, rads_CartdiagramSheet.GetItemString(ll_Row, 14)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 15, rads_CartdiagramSheet.GetItemString(ll_Row, 15)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 16, rads_CartdiagramSheet.GetItemNumber(ll_Row, 16)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 17, rads_CartdiagramSheet.GetItemString(ll_Row, 17)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 18, rads_CartdiagramSheet.GetItemString(ll_Row, 18)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 19, rads_CartdiagramSheet.GetItemString(ll_Row, 19)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 20, rads_CartdiagramSheet.GetItemString(ll_Row, 20)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 21, rads_CartdiagramSheet.GetItemString(ll_Row, 21)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 22, rads_CartdiagramSheet.GetItemNumber(ll_Row, 22)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 23, rads_CartdiagramSheet.GetItemString(ll_Row, 23)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 24, rads_CartdiagramSheet.GetItemString(ll_Row, 24)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 25, rads_CartdiagramSheet.GetItemNumber(ll_Row, 25)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 26, rads_CartdiagramSheet.GetItemNumber(ll_Row, 26)   )
			ll_Temp_Sort = rads_CartdiagramSheet.GetItemNumber(ll_Row, "nrowid")   
			guoLog.uf_debug( "["+ this.classname( )+".of_create_or_load_sec_distr] Sort test: " + String(ll_Temp_Sort ) + " " + rads_CartdiagramSheet.GetItemString(ll_Row, 15) + " " + rads_CartdiagramSheet.GetItemString(ll_Row, 28))
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 27, rads_CartdiagramSheet.GetItemNumber(ll_Row, 27)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 28, rads_CartdiagramSheet.GetItemString(ll_Row, 28)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 29, rads_CartdiagramSheet.GetItemString(ll_Row, 29)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 30, rads_CartdiagramSheet.GetItemString(ll_Row, 30)   )
			li_Succ = ids_SD_Master.SetItem(ll_New_Row, 31, rads_CartdiagramSheet.GetItemNumber(ll_Row, 31)   )
			
			
			
			// 16.01.2014
			ls_Add_on_Text =  rads_CartdiagramSheet.GetItemString(ll_Row, "cadd_on_text")
			If NOT IsNULL(ls_Add_on_Text) Then
				li_Succ = ids_SD_Master.SetItem(ll_New_Row, "cadd_on_text",ls_Add_on_Text)
			End If
			//li_succ = dsCartdiagramsheet.setitem(ll_NewRow,"cadd_on_text", ls_add_on_text)

			// 27.02.2014
			ll_Galley_Group =  rads_CartdiagramSheet.GetItemNumber(ll_Row, "nGalley_Group")
			If NOT IsNULL(ls_Add_on_Text) Then
			//	li_Succ = ids_SD_Master.SetItem(ll_New_Row, "nGalley_Group",ll_Galley_Group)
			End If
			
			ll_Belly = rads_CartdiagramSheet.GetItemNumber(ll_Row, "nbelly")
			//li_Succ = ids_SD_Master.SetItem(ll_Row, "nresult_key", al_result_key )   
			//li_Succ = rads_CartdiagramSheet.SetItem(ll_Row, "ntransaction", al_transaction )         
		Next

		If ll_num_rows > 0 Then
			If ib_Enable_Secondary_Distr_Saving Then
				li_Succ = ids_SD_Master.update()
				If li_Succ = 1 Then
					//commit;
				End if
			End if
		End if
		
		If il_Disable_Debug = 1 Then
			FileDelete(ls_File)
		End if

		// ------------------------------------------------------
		//	2. Component List
		//	------------------------------------------------------
		If ib_enable_masterdata_view Then 
			ids_SD_Master.SetSort("nrowid asc")
			ids_SD_Master.Sort()
		End If
		
		For ll_Row = 1 to ids_SD_Master.Rowcount()
			// Liste der Komponenten f$$HEX1$$fc00$$ENDHEX$$llen
			ls_Stowage			= trim(ids_SD_Master.GetItemString(ll_Row, "cstowage"))
			ls_Galley			= Left(ls_Stowage, pos(ls_Stowage, "-") -1 )
			ls_Stowage_Only	= mid(ls_Stowage, pos(ls_Stowage, "-") +1 )
			ll_Belly 			= ids_SD_Master.GetItemNumber(ll_Row, "nbelly")
			If not isnull(ll_Belly) and ll_Belly > 0 then
				lb_breakpoint = TRUE
			End If
			ls_packinglist 	= ids_SD_Master.GetItemString(ll_Row, "cpackinglist")
			ll_RowId				= ids_SD_Master.GetItemNumber(ll_Row, "nrowid")
			li_Succ = of_sd_fill_component_list( rauo_Distribution, ll_RowId, ls_Stowage, ls_packinglist, ll_Belly)
		Next
		If ids_SD_Components.RowCount() > 0 Then
			If ib_Enable_Secondary_Distr_Saving Then
				li_Succ = ids_SD_Components.update()
				If li_Succ = 1 Then
					//commit;
				End if
			End if
		End if
		
		// ------------------------------------------------------
		//	3. List of Carts
		//	------------------------------------------------------
		ll_pages = of_count_cart_diagram_pages(as_unit, al_airline_key, rads_unassigned, rads_eq, rads_cartdiagramsheet, rauo_tripticket)
		If ids_SD_Cart.RowCount() > 0 Then
			If ib_Enable_Secondary_Distr_Saving Then
				li_Succ = ids_SD_Cart.update()
				If li_Succ = 1 Then
					//commit;
				End if
			End If
		End if
		
		// ------------------------------------------------------
		//	4. Drawers / Trays per Cart
		//	------------------------------------------------------
		
		For ll_Row = 1 to ids_SD_Cart.Rowcount()
			ll_RowId				= ids_SD_Cart.GetItemNumber(ll_Row, "nrowid")
			ll_sd_cart_key		= ids_SD_Cart.GetItemNumber(ll_Row, "nsd_cart_key")
			ll_Current_Page	= ids_SD_Cart.GetItemNumber(ll_Row, "npage")
			ls_Find = "nrowid=" + String(ll_RowId)
			ll_Found = ids_SD_Master.Find(ls_Find, 1,ids_SD_Master.RowCount())
			
			if ll_Found > 0 then
				// Liste der Trays / Drawer f$$HEX1$$fc00$$ENDHEX$$llen
				ls_Stowage				= trim(ids_SD_Master.GetItemString(ll_Found, "cstowage"))
				ll_Belly 				= ids_SD_Master.GetItemNumber(ll_Found, "nbelly")
				ls_packinglist 		= ids_SD_Master.GetItemString(ll_Found, "cpackinglist")
				ls_loadinglist 		= ids_SD_Master.GetItemString(ll_Found, "cloadinglist")
				ll_IndexKey				= ids_SD_Master.GetItemNumber(ll_Found, "nindex_key")
				ll_DetailKey			= ids_SD_Master.GetItemNumber(ll_Found, "ndetail_key")
				ls_Galley				= Left(ls_Stowage, pos(ls_Stowage, "-") -1 )
				ls_Stowage_Only		= mid(ls_Stowage, pos(ls_Stowage, "-") +1 )

				//If pos(ls_Stowage,"156") >0 or  pos(ls_Stowage,"115")>0 or pos(ls_Stowage,"612")>0 or pos(ls_Stowage,"622")>0  then
					//guoLog.uf_debug( "["+ this.classname( )+".CONTENT SPEC")
				//end if

				isStowage = ls_Stowage
				if of_sd_init(as_unit, ll_IndexKey,  ll_DetailKey, al_Airline_key, idt_Departure) > 0 then				
					ls_Container = of_get_container_short_name()
					If of_is_explosion_enabled(ll_IndexKey, as_Unit, idt_Departure) Then
						lb_explode = TRUE
						If il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".uodiagram.of_is_explosion_enabled " + as_Unit + " " + ls_packinglist + " TRUE")
					ELSE
						lb_explode = FALSE
						If il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".uodiagram.of_is_explosion_enabled " + as_Unit + " " + ls_packinglist + " FALSE")
					End If				
					li_Succ = of_sd_distribute_components( rauo_Distribution, ls_Galley, ls_Stowage_Only, ls_Stowage, ls_packinglist, ll_Belly, ls_Container, as_unit, &
								idt_Departure, lb_explode, rauo_ContentSheet, ab_Contentsheet, ll_RowId, rauo_ContentSheet.dsLoadingContents, ll_RowId, &
								ll_sd_cart_key, ll_Current_Page, ls_loadinglist )
				Else
					// Kein "guter" Container?
					If il_Disable_Debug=0 Then guoLog.uf_debug( "["+ this.classname( )+".uodiagram.of_sd_init " + as_Unit + " " + ls_packinglist + " INIT FAILED")					
				End if
			End if
		Next
		
		li_Succ = ids_SD_Cart_Drawer.SetFilter("")
		li_Succ = ids_SD_Cart_Drawer.Filter()
		If ids_SD_Cart_Drawer.RowCount() > 0 Then
			If ib_Enable_Secondary_Distr_Saving Then
				li_Succ = ids_SD_Cart_Drawer.update()
				If li_Succ = 1 Then
					//commit;
				End if
			End If
		End if
		
		// ------------------------------------------------------
		//	5. Drawer / Tray Content
		//	------------------------------------------------------
		If ids_sd_drawer_content .RowCount() > 0 Then
			If ib_Enable_Secondary_Distr_Saving Then
				li_Succ = ids_SD_drawer_content.update()
				If li_Succ = 1 Then
					//commit;
				End if
			End if
		End if
		
		// ------------------------------------------------------
		//	6. Backlog / Error / Info
		//	------------------------------------------------------
		If ids_SD_Message.RowCount() > 0 Then
			If ib_Enable_Secondary_Distr_Saving Then
				li_Succ = ids_SD_Message.update()
				If li_Succ = 1 Then
					//commit;
				End if
			End If
		End if
		
		If ib_Enable_Secondary_Distr_Saving Then
			commit;
		End If
	End if
End If

// Debug
//If il_Disable_Debug = 0 Then
If s_app.itrace > 0 then	
//	ids_SD_Master				.SaveAs(f_gettemppath() + String(al_result_key) + "_ids_SD_Master_" 		 	+ String(datetime(today(),now()),"yyyymmddhhmmssfff")+"_.xls", Excel5!, TRUE)
//	ids_SD_Components			.SaveAs(f_gettemppath() + String(al_result_key) + "_ids_SD_Components_"    	+ String(datetime(today(),now()),"yyyymmddhhmmssfff")+"_.xls", Excel5!, TRUE)
//	ids_SD_Cart					.SaveAs(f_gettemppath() + String(al_result_key) + "_ids_SD_Cart_"          	+ String(datetime(today(),now()),"yyyymmddhhmmssfff")+"_.xls", Excel5!, TRUE)
//	ids_SD_Cart_Drawer		.SaveAs(f_gettemppath() + String(al_result_key) + "_ids_SD_Cart_Drawer_"   	+ String(datetime(today(),now()),"yyyymmddhhmmssfff")+"_.xls", Excel5!, TRUE)
//	ids_SD_Drawer_Content	.SaveAs(f_gettemppath() + String(al_result_key) + "_ids_SD_Drawer_Content_"	+ String(datetime(today(),now()),"yyyymmddhhmmssfff")+"_.xls", Excel5!, TRUE)
//	ids_SD_Message				.SaveAs(f_gettemppath() + String(al_result_key) + "_ids_SD_Message_" 			+ String(datetime(today(),now()),"yyyymmddhhmmssfff")+"_.xls", Excel5!, TRUE)
	
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Master.RowCount " + String(ids_SD_Master.RowCount()))
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Components.RowCount " + String(ids_SD_Components.RowCount()))
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Cart.RowCount " + String(ids_SD_Cart.RowCount()))
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Cart_Drawer.RowCount " + String(ids_SD_Cart_Drawer.RowCount()))
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Drawer_Content.RowCount " + String(ids_SD_Drawer_Content.RowCount()))
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Message.RowCount " + String(ids_SD_Message.RowCount()))
	
	ls_Sort = ids_SD_Master.Describe("DataWindow.Table.Sort")
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Master.Sort " + ls_Sort)

	ls_Sort = rads_CartdiagramSheet.Describe("DataWindow.Table.Sort")
	guoLog.uf_debug( "["+ this.classname( )+".rads_CartdiagramSheet.Sort " + ls_Sort)

	ls_Sort = ids_SD_Cart.Describe("DataWindow.Table.Sort")
	guoLog.uf_debug( "["+ this.classname( )+".ids_SD_Cart.Sort " + ls_Sort)
	
End if

// ---------------------------------------------------------------------------------------------
// Ende Secondary Distribution - count pages
// ---------------------------------------------------------------------------------------------
IF ib_enable_secondary_distr_saving = FALSE Then
	ll_pages = of_count_cart_diagram_pages(as_unit, al_airline_key, rads_unassigned, rads_EQ, rads_cartdiagramsheet, rauo_tripticket )
Else
	ll_pages = ids_SD_Cart.RowCount()
	// Trip Ticket DataStore f$$HEX1$$fc00$$ENDHEX$$llen
	li_Succ = of_init_cd_tripticket(as_unit, al_airline_key,	rauo_tripticket)
End If

Return ll_pages

end function

public function integer of_create_acrobat (ref datastore dsacrobat, string as_file_name);/*************************************************************
* Objekt : w_print_center
* Methode: wf_create_acrobat (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 28.09.2009
* Argument(e):
* ref datastore dsacrobat
*  string sfilename
*  boolean bshow
*
* Return: integer
*
*
**************************************************************
*  Modifikationen:
*  Datum         Version    Autor             Kommentar
* --------------------------------------------------------------------------------
*  ??.??.????    1.0        ?                 Erstellt
*  28.09.2009    1.1        Ulrich Paudler    Performanceverbesserungen: dsacrobat als Reference $$HEX1$$fc00$$ENDHEX$$bergeben, Defaultprinter am Ende nicht setzen (kostet 3-4 sec) 
*  19.12.2012    1.2        D.Bunk            Anpassungen f$$HEX1$$fc00$$ENDHEX$$r $$HEX1$$fc00$$ENDHEX$$berarbeitetes PDF Handler Objekt
*  24.04.2014    1.3        Oliver H$$HEX1$$f600$$ENDHEX$$fer      PDF Titel variieren
*
*************************************************************/
string		lsTemppath
long 			lOpenFlags 		= 1
long 			lZoomType		= 2
string		sAcrobatFile	= ""
Long			ll_pos
String		ls_Document_Name

// -------------------------------------------------------------------
// Pdf erstellen
// -------------------------------------------------------------------
lsTemppath = f_gettemppath()
if len(lsTemppath) > 0 Then
	sAcrobatFile = as_File_Name
	sAcrobatFile = f_valid_filename(sAcrobatFile)
else
	uf.mbox("Achtung", "Fehler beim Erzeugen der PDF-Datei. [2]", StopSign!)
	return -1
end if

ll_Pos = lastpos(sAcrobatFile, "\")
ls_Document_Name = Mid(sAcrobatFile, ll_pos + 1)

//if s_app.uo_PDF.of_convert(dsAcrobat, "ReportBrowser", sAcrobatFile) <> 0 then 
if s_app.uo_PDF.of_convert(dsAcrobat, ls_Document_Name, sAcrobatFile) <> 0 then 
	uf.mbox("Achtung", "Fehler beim Erzeugen der PDF-Datei. [5]", StopSign!)
	return -1
end if

if not FileExists(sAcrobatFile) Then 
	uf.mbox("Achtung", "Fehler beim Erzeugen der PDF-Datei. [6]", StopSign!)
End if	

// ------------------------------------
// Defaultdrucker setzen
// ------------------------------------	
f_setcurrentdirectory(s_app.scurrentdirectory)	
//wf_chc_trace(10,"wf_create_acrobat:  Ende")
return 0
end function

public function integer of_cart_diagram_merge (ref uo_documents rauo_product, string as_pdffiles[], boolean ab_printdirectly, boolean ab_use_printer_allocation, string as_printer_cart_diagram);/*
* Objekt : uo_client_label
* Methode: of_cart_diagram_merge (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.08.2012
*
* Argument(e):
* ref		uo_documents		rauo_product
*	 		string				as_pdffiles[]
*	 		boolean				ab_printdirectly
*	 		boolean				ab_use_printer_allocation
*	 		string				as_printer_cart_diagram
*
* Beschreibung:		Merge PDF Files and Print the Document if "PrintDirectly" is ON
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.08.2012		Erstellung
*
*
* Return: integer
*
*/

String	ls_Printer_Name

// Erst mal pr$$HEX1$$fc00$$ENDHEX$$fen ob es etwas zum zusammenfassen gibt
if upperbound(as_PdfFiles) > 0 then
	if isvalid(w_progress_with_cancel) then
		w_progress_with_cancel.wf_setstatus( uf.translate("Zusammenfassen")  )
	End If
	
	If s_app.ilanguage < 2 Then
		// ---------------------------------------------------------------------------------------------------
		// wegen Fehler bei Merge mit Schalter MultilingualSupport: bei Sprache > 2 alternative Merge-Funktion
		// ---------------------------------------------------------------------------------------------------
		if s_app.uo_pdf.of_concatenate(as_PdfFiles, rauo_Product.sCartdiagramSheetFile, true) <> 0 then
			if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".uo_client_label.of_create_cartdiagram s_app.uo_pdf.of_concatenate FAILED")
		End If
		If ab_PrintDirectly  Then
			// Wenn Dokumententyp-spezifischer Drucker aktiv - > diesen verwenden ... TBR 20.06.2012
			IF ab_use_printer_allocation THEN
				ls_Printer_Name = as_printer_cart_diagram
			Else
				ls_Printer_Name = rauo_Product.sPrinter
			End if
			s_app.uo_pdf.of_print(rauo_Product.sCartdiagramSheetFile, ls_Printer_Name)					
		End If
	else
		if s_app.uo_pdf.of_concatenate(as_PdfFiles, rauo_Product.sCartdiagramSheetFile, true) <> 0 then
			if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".uo_client_label.of_create_cartdiagram s_app.uo_pdf.of_concatenate FAILED")
		End If
		If ab_PrintDirectly  Then
			// Wenn Dokumententyp-spezifischer Drucker aktiv - > diesen verwenden ... TBR 20.06.2012
			IF ab_use_printer_allocation THEN
				ls_Printer_Name = as_printer_cart_diagram
			Else
				ls_Printer_Name = rauo_Product.sPrinter
			End if
			s_app.uo_pdf.of_print(rauo_Product.sCartdiagramSheetFile, ls_Printer_Name)					
		End If
	End If
End If

Return 1
end function

public function integer of_cart_diagram_content_sheet (boolean ab_contentsheet, long al_rowid, ref uo_content_sheet rauo_contentsheet);/*
* Objekt : uo_client_label
* Methode: of_cart_diagram_content_sheet (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.08.2012
*
* Argument(e):
* boolean ab_contentsheet
*	 long al_rowid
*
* Beschreibung:		Versorge Content Sheet DataStores
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.08.2012		Erstellung
*
*
* Return: integer
*
*/


Integer	li_Succ
Long		ll_Distr_Counter
Long		ll_Index_key
Long		ll_level
Long		ll_Found
Long		ll_Tmp_Row
Long		ll_Tmp_Det
String	ls_Header_PL_Nr




// NAM CR 16008 bei non sky ist content spec = overflow
If ib_non_sky then
//	return 1
end if


// ------------------------------------------------------
// Feste Inhalte nach Content Sheet $$HEX1$$fc00$$ENDHEX$$bertragen ("Header")
// ------------------------------------------------------
If ab_Contentsheet Then	
	For ll_Distr_Counter = 1 To rauo_ContentSheet.dsLoadingHeader.RowCount()
		If rauo_ContentSheet.dsLoadingHeader.GetItemNumber(ll_Distr_Counter, "nrowid") = al_RowId Then
			ls_Header_PL_Nr = rauo_ContentSheet.dsLoadingHeader.GetItemString(ll_Distr_Counter, "cpackinglist")
			// Artikel?
			ll_Index_key = f_get_packinglist_key(ls_Header_PL_Nr)
			If ll_Index_key > 0 Then			
				select	npacking_list_level  
				into		:ll_level
				from		cen_packinglists
				where		npackinglist_index_key = :ll_Index_key 
				and :idt_departure between dvalid_from and dvalid_to;
				If SQLCA.SQLcode = 0 Then
					If ll_level = 2 Then		
						//li_Succ = iuoContentSheet.dsLoadingHeader.RowsCopy(ll_Distr_Counter, ll_Distr_Counter, Primary!, dsloadingheader, 1, Primary!)
					Else
						// Artikel => raus?	
						if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram HEADER SKIP ARTICLE " + ls_Header_PL_Nr)
					End If
				End If
			End If
		End If			
	Next	
	// --------------------------------------------------------------
	// Ende Content Sheet - "Header"
	// --------------------------------------------------------------					
	
	// "Referentielle Integrit$$HEX1$$e400$$ENDHEX$$t"
	For ll_Distr_Counter = rauo_ContentSheet.dsLoadingContents.RowCount() To 1 STEP -1
		ll_Tmp_Row = rauo_ContentSheet.dsLoadingContents.GetItemNumber(ll_Distr_Counter, "nrowid")
		ll_Tmp_Det = rauo_ContentSheet.dsLoadingContents.GetItemNumber(ll_Distr_Counter, "ndetail_key")
		ls_Header_PL_Nr= rauo_ContentSheet.dsLoadingContents.GetItemString(ll_Distr_Counter, "cpackinglist")
		ll_Found = rauo_ContentSheet.dsloadingheader.Find("nrowid = " + String(ll_Tmp_Row) + " and ndetail_key = " + String(ll_Tmp_Det) , 1, rauo_ContentSheet.dsloadingheader.RowCount())
		If ll_Found = 0 Then			
			if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram NO HEADER SKIP CONTENTS " + ls_Header_PL_Nr)
//			li_Succ = rauo_ContentSheet.dsLoadingContents.DeleteRow(ll_Distr_Counter)
		End If	
	Next 				
End If	


Return 1

end function

public function integer of_create_cart_diagram_page (long al_row, long al_rowid, long al_airline_key, string as_unit, ref long ral_cartpages, boolean ab_contentsheet, string as_current_printer_1, ref uo_documents rauo_product, long al_flightnumber, string as_suffix, string as_from, string as_to, string as_actype, string as_time, string as_owner, string as_version, long al_leg_nr, long al_number_of_pages, string as_fbox_from, string as_fbox_to, long al_watermark, string as_ramp_time, string as_kitchen_time, string as_ops, long al_routing_id, ref long ral_filecounter, ref string ras_pdffiles[], ref long ral_backlogpages, ref uo_content_sheet rauo_contentsheet, ref uo_distribution rauo_distribution);
/*
* Objekt : uo_client_label
* Methode: of_create_cart_diagram_page (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.08.2012
*
* Argument(e):
*	 long al_row
*	 long al_rowid
*	 ref uo_cart_diagram rauo_diagram
*	 long al_airline_key
*	 string as_unit
*	 ref long ral_cartpages
*	 boolean ab_contentsheet
*	 string as_current_printer_1
*	 uo_documents rauo_product
*	 integer ai_flightnumber
*	 string as_suffix
*	 string as_from
*	 string as_to
*	 string as_actype
*	 string as_time
*	 string as_owner
*	 string as_version
*	 long al_leg_nr
*	 long al_number_of_pages
*	 string as_fbox_from
*	 string as_fbox_to
*	 long al_watermark
*	 string as_ramp_time
*	 string as_kitchen_time
*	 string as_ops
*	 long al_routing_id
*	 ref long ral_filecounter
*	 ref string ras_pdffiles[]
*	 ref long ral_backlogpages
*
* Beschreibung:		Create Cart Diagram Page (and backlog Page)
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			23.08.2012	Erstellung
* 1.1 			Oliver Hoefer			17.12.2012	Secondary Distr. disabled => List of Components from uo_Distribution
* 1.2 			Oliver Hoefer			17.04.2013	UK Healthmark
* 1.3 			Matthias Barfknecht 	04.10.2013	Backlogs auch verschieben
* 1.4 			Oliver Hoefer			16.01.2014	CBASE-UK-CR-2013-013 - Additional Text aus Loading list
* 1.5 			Oliver Hoefer			23.01.2014	CBASE-UK-CR-2013-006 - Overflow Information on Main Page
* 1.6 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
* 1.7 			Oliver Hoefer			16.03.2017	Best Before Date - request #1961 CR-RUS-1961
* 1.8 			Oliver Hoefer			03.05.2019	#4896 Text$$HEX1$$fc00$$ENDHEX$$berlappung wegen Move Left
* 1.9 			Oliver Hoefer			22.07.2022	Barcode for NAM request #6466
*
*
* Return: integer
*
*/

Integer	li_Succ
Long		ll_IndexKey
Long		ll_DetailKey
Long		ll_Belly
Long		ll_Cart_Page_Row
String	ls_Class_String, ls_Class_1, ls_Area, ls_Workstation, ls_PL_Unit, ls_Multi_WS_1, ls_Multi_WS_2, ls_Loadinglist
String	ls_Stowage, ls_Container, ls_pl_description, ls_packinglist, ls_Header
Long		ll_Catering_Leg, ll_ramp_box_mode
String	ls_currentpage, ls_area_WS, ls_Class, ls_RampBox
Boolean	lb_explode, lb_Aisle
Blob		lb_Blob
Integer	li_Offset
Long		ll_FileSize
LOng		ll_Workstation_key
String	ls_Target_File
String	ls_File_Prefix, ls_Cart_Page_PDF_Name
String	ls_Additional_text
String	ls_Additional_Label_text	
String	ls_JASPER_File
String	ls_bookmark
String	ls_AC
String	ls_stowage_bc
Boolean	lb_Bookmark	
Integer	li_hidebarcode, li_vpsbarcode
Long		ll_Stowage_key
Long		ll_Start, ll_End	
String	ls_Human_Readable_Part, ls_Flight_Key
s_component	lstr_component[]
DataStore	lds_Cartdiagram, lds_Backlog
DataStore	lds_Datastore


lds_Datastore		= CREATE	DataStore
lds_Cartdiagram	= CREATE	DataStore
lds_Backlog			= CREATE	DataStore

lds_Cartdiagram.DataObject="dw_packinglist_edit_content"
lds_Cartdiagram.SetTransobject(SQLCA)
lds_Backlog.DataObject="dw_uo_layout_backlog"


guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page] Row Id = " +  " : " + String( al_rowid ) )

il_master_row = al_rowid

ii_current_page = ral_CartPages + 1

ll_IndexKey 		= ids_sd_master.GetItemNumber(al_Row, "nindex_key")
ll_DetailKey 		= ids_sd_master.GetItemNumber(al_Row, "ndetail_key")
ll_Belly 			= ids_sd_master.GetItemNumber(al_Row, "nbelly")
ls_Class_String	= ids_sd_master.GetItemString(al_Row, "cclass")
ls_Class_1			= ids_sd_master.GetItemString(al_Row, "cclass_1")
ls_Area 				= ids_sd_master.GetItemString(al_Row, "carea")
ls_Workstation		= ids_sd_master.GetItemString(al_Row, "cworkstation")

String	ls_Value, ls_Default, ls_Section
Integer	li_config
// ----------------------------------------------------------------------
// Barcode Setting
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then	
	// #6466 NAM Barcode	
	If inv_doc_gen_settings.il_NENABLE_NAM_BARCODE = 1  Then
		ib_nam_barcode_on_cartdiagram = TRUE
	ELSE
		ib_nam_barcode_on_cartdiagram = FALSE
	End if	
Else
	If is_section > "" Then
		ls_Section = is_section
	Else
		ls_Section = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(ls_Section) = "" Then ls_Section = "docbrowser"
	End if
	
	if ls_Section <> "docbrowser" Then
		li_config = integer(Mid(ls_Section,11))
		ls_Default ="Default" +string(li_config)
	Else
		ls_Default ="Default"
	End If
	// #6466 NAM Barcode
	//ls_Value = of_profilestring(s_app.suser,ls_Default,"CartDiagramNAMBarcode","0")
	ls_Value = f_unitprofilestring("Default","CartDiagramNAMBarcode","0", is_CSC) 
	If ls_Value = "1" Then
		ib_nam_barcode_on_cartdiagram = TRUE
	ELSE
		ib_nam_barcode_on_cartdiagram = FALSE
	End if		
End if

// --------------------------------------------------------------
// UK Barcode on Cart Diagram Page
// --------------------------------------------------------------
If of_is_barcode_enabled(as_unit) Then
	ib_barcode_on_cartdiagram = TRUE
	guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page] " +  "Barcode ON for " + as_unit)	
Else
	ib_barcode_on_cartdiagram = FALSE
	guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page] " +  "Barcode OFF for " + as_unit)		
End If
	
li_hidebarcode = Integer(f_mandant_profilestring(sqlca, s_app.sMandant, "LabelHideBarcode", "Default", "0"))
li_vpsbarcode= Integer(f_mandant_profilestring(sqlca, s_app.sMandant, "LabelVPSBarcode", "Default", "0"))

	
If li_hidebarcode = 1 and li_vpsbarcode = 1 Then
	ib_BarCode_on_CartDiagram = TRUE
	
	// check printing group
	If ib_PPMBARCODE4GROUP Then
		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page] " +  " GROUP Barcode ON for " + as_unit)		
	else
		ib_BarCode_on_CartDiagram = FALSE
		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page] " +  " GROUP Barcode OFF for " + as_unit)		
	End If
End if
		
	
If ib_Cart_Diagram_Bookmark Then
	ls_bookmark = ls_area + " - " + ls_Workstation
	if ls_bookmark <> is_Bookmark_Group then
		lb_Bookmark = TRUE
		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page] " +  "Bookmark: " + is_Bookmark_Group + " => " +  ls_bookmark)
		
		is_Bookmark_Group = ls_bookmark
	End If
End If

ls_PL_Unit 			= ids_sd_master.GetItemString(al_Row, "cpl_unit")
ls_Multi_WS_1		= ids_sd_master.GetItemString(al_Row, "cmulti_ws_1")
ls_Multi_WS_2		= ids_sd_master.GetItemString(al_Row, "cmulti_ws_2")
ls_packinglist		= ids_sd_master.GetItemString(al_Row, "cpackinglist")
If Isnull(ls_Multi_WS_2) Then ls_Multi_WS_2 = ""
ls_Multi_WS_2 = Trim(ls_Multi_WS_2)
If NOT Isnull(ls_Multi_WS_1) Then
	ls_Multi_WS_1 += ls_Multi_WS_2
End If
ls_Loadinglist		= ids_sd_master.GetItemString(al_Row, "cloadinglist")
ls_Additional_text= ids_sd_master.GetItemString(al_Row, "cadd_on_text")
ll_Workstation_key= Long(ids_sd_master.GetItemString(al_Row, "nworkstation_key"))

if ls_packinglist = "BGFF238" then
	ls_packinglist = ls_packinglist
end if 

guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page =====================  START  ===================== ")

//		if of_is_cartdiagram_enabled(ll_IndexKey, s_app.sMandant, ls_Unit) < 1 then
//			ls_Temp_PL = ids_sd_master.GetItemString(al_Row, "spackinglist")
//			If isnull(ls_Class_1) then
//				guoLog.uf_debug( "["+ this.classname( )+".Warning sClass_1 is EMPTY " + ls_Temp_PL + " / " + ls_Stowage)
//			End If
//			ll_Found = lds_unassigned.Find("cpackinglist='" + ls_temp_pl + "'", 1, lds_unassigned.RowCount())
//			guoLog.uf_debug( "["+ this.classname( )+".Cart Diagram Page " + String(al_Row) + " Exclude " + ls_Temp_PL)
//			continue
//		End If	
		
ll_Catering_Leg = ids_sd_master.GetItemNumber(al_Row, "ncatering_leg")
If IsNULL(ll_Catering_Leg) Then ll_Catering_Leg = 1 
if ll_Catering_Leg < 1 then ll_Catering_Leg = 1 // 05.03.2019 HR: Integer$$HEX1$$fc00$$ENDHEX$$berlauf korrigieren
ii_Catering_Leg = ll_Catering_Leg
ls_Stowage = trim(ids_sd_master.GetItemString(al_Row, "cstowage"))	
isStowage = ls_Stowage

//If trim(ls_Stowage) = "156" or  trim(ls_Stowage) = "115" or trim(ls_Stowage) = "612" or  trim(ls_Stowage) = "622"  then
	//guoLog.uf_debug( "["+ this.classname( )+".CONTENT SPEC")
//end if

Select cs.nstowage_key
into :ll_Stowage_key
  From cen_galley ga, cen_stowage cs
 Where ga.naircraft_key = :il_Aircraft_Key
   And cs.ngalley_key = ga.ngalley_key      
   And ((ga.cgalley || '-' || cs.cstowage || Trim(cs.cplace) = :ls_Stowage) OR (ga.cgalley || '-' || cs.cstowage || ' ' || Trim(cs.cplace) = :ls_Stowage));

//	guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR of_init")							
if of_init(ll_IndexKey, ll_DetailKey, al_Airline_key, as_Unit, lds_Cartdiagram, datetime(idt_Departure), lds_Backlog) > 0 then
	ls_Container = of_get_container_short_name()
	ral_CartPages++
	// Beschreibung
	ls_packinglist			= ids_sd_master.GetItemString(al_Row, "cpackinglist")
	ls_pl_description		= ids_sd_master.GetItemString(al_Row, "ctext")
	ls_Header = trim(ls_packinglist)+ " - " + trim(ls_pl_description)
	//If ii_Do_NOT_Trace = 0 Then 
		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page ############   " + as_Unit + " " + ls_packinglist + "   ############") 
	// End If
	
	if ls_packinglist = "BGFF238" Then
		ls_packinglist=ls_packinglist
	End If
	
//	// ------------------------------------------------------------------------
//	// Secondary Distr. disabled => List of Components from uo_Distribution
//	// -------------------------------------------------------------------------
//	if ib_enable_meal_distribution = TRUE  then		
//		li_Succ = of_fill_component_list(rauo_Distribution, lstr_component, ls_stowage, ls_packinglist, ll_Belly)
//		li_Succ = of_create_component_list(lstr_component)
//	end if
	
	If of_is_explosion_enabled(ll_IndexKey, as_Unit, idt_departure) Then
		lb_explode = TRUE
		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".uodiagram.of_is_explosion_enabled " + as_Unit + " " + ls_packinglist + " TRUE")
	ELSE
		lb_explode = FALSE
		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".uodiagram.of_is_explosion_enabled " + as_Unit + " " + ls_packinglist + " FALSE")
	End If
	al_RowId = ids_sd_master.GetItemNumber(al_Row , "nrowid")
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".uo_client_label.of_create_cartdiagram content sheet " + ls_packinglist + " al_RowId " + String(al_RowId))
	// ------------------------------------------------------
	// Verteilte Komponenten zeichnen
	// ------------------------------------------------------
	guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR of_sd_draw_distributed_components " + ls_packinglist)
	//il_disable_debug = 0 
	
	//oDS.saveas("c:\temp\cbase\cart_diagram_1_" + ls_File_Prefix + String(ral_CartPages,"000") + "_" + String(now(), "hhmmssfff") + ".PSR"	, PSReport! , true)
	
	of_sd_draw_distributed_components(rauo_Distribution, ls_Stowage, ls_packinglist, ll_Belly, ls_Container, as_unit, &
																	date(idt_Departure), lb_explode, rauo_ContentSheet, ab_Contentsheet, al_RowId, &
																	rauo_ContentSheet.dsLoadingContents)

	//oDS.saveas("c:\temp\cbase\cart_diagram_2_" + ls_File_Prefix + String(ral_CartPages,"000") + "_" + String(now(), "hhmmssfff") + ".PSR"	, PSReport! , true)

	guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram NACH of_sd_draw_distributed_components " + ls_packinglist)
	// ------------------------------------------------------
	// Feste Inhalte nach Content Sheet $$HEX1$$fc00$$ENDHEX$$bertragen ("Header")
	// ------------------------------------------------------
	li_Succ = of_cart_diagram_content_sheet(ab_contentsheet, al_Rowid, rauo_contentsheet )

		
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR of_print_prepare "+ ls_packinglist)
	// Variable Daten im Datawindow f$$HEX1$$fc00$$ENDHEX$$llen
	of_print_prepare(as_current_printer_1 , rauo_Product.sAirline, al_FlightNumber, as_Suffix, ls_Header, as_From, as_To, &
										as_ACType, ls_Stowage, ral_CartPages, ll_Belly, date(idt_Departure), as_Time, ls_Class_String, ls_Container, &
										as_Owner, as_Version, ls_Area, ls_Workstation, ls_Loadinglist, al_Leg_nr)
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR of_print_init "+ ls_packinglist)
	of_print_init()
	
	// --------------------------------------------------------------
	// Mengenfelder LINKS ausrichten
	// --------------------------------------------------------------
	of_align_objects("t_content_quantity", ALIGN_LEFT, FALSE)
	
	// --------------------------------------------------------------
	// F$$HEX1$$fc00$$ENDHEX$$r neuen Header / Footer: weitere Values erg$$HEX1$$e400$$ENDHEX$$nzen
	// --------------------------------------------------------------
	ls_currentpage				= String(ral_CartPages) + "/" + String(al_Number_of_Pages) 
	ls_Class						= ls_Class_String
	ls_Workstation				= ls_Area + "-" + ls_Workstation
	ls_Area_WS					= ls_Area + "-" + ls_Workstation
	If NOT Isnull(ls_Multi_WS_1) AND Trim(ls_Multi_WS_1) > ls_Workstation Then
		ls_Workstation = ls_Multi_WS_1		
	End If
	// ------------------------------------------------------------------------------
	// Ermittlung Ramp Box - CBASE-NAM-CR-12025
	// ------------------------------------------------------------------------------
	ll_ramp_box_mode = ids_sd_master.GetItemNumber(al_Row, "nramp_box_mode")
	ls_RampBox = of_get_ramp_box(as_FBox_From, as_FBox_to, ll_ramp_box_mode)

	//guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR of_print_prepare_new_h_f "+ ls_packinglist)				
	of_print_prepare_new_h_f(ls_Loadinglist, ls_packinglist, ls_pl_description, ls_rampbox, ls_Stowage, &
													ls_Class, ls_Workstation, ls_currentpage, FALSE)
	//guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram NACH of_print_prepare_new_h_f "+ ls_packinglist)				

	// -----------------------------------------------------------------------
	// AISLE READY
	// -----------------------------------------------------------------------
	lb_Aisle = of_is_aisle_enabled(ll_IndexKey, ll_DetailKey)
	If lb_Aisle Then
		li_Succ = of_draw_watermark_aisle(FALSE)
	End If				
		
	// ------------------------------------------	
	// Belly (CBASE-UK-CR-2013-012)					
	// ------------------------------------------
	If ib_Belly_Watermark Then
		If NOT IsNULL(ll_Belly) AND ll_Belly > 0 Then
			li_Succ = of_draw_watermark_belly(ll_Belly  )			
		End If	
	End If
	
	// ------------------------------------------	
	// Wasserzeichen (ausser Downline / AISLE)					
	// ------------------------------------------
	li_Succ = of_draw_watermark(al_Watermark, al_FlightNumber , as_Ramp_Time , as_Kitchen_Time , as_Ops, ls_class, "" , &
															al_airline_key, as_Unit, al_routing_id , FALSE, as_Suffix )
				
	// --------------------------------------------------------------
	// Wasserzeichen und Drawer Pictures sortieren (Front to Back Order...)
	// --------------------------------------------------------------
	of_move_to_background(FALSE)
	
	// --------------------------------------------------------------
	// Objekt-Breite
	// --------------------------------------------------------------
	of_check_object_width()

	li_Offset = -25 // of_get_min_offset("detail", FALSE) 
	
	If bHasDimensions = TRUE then
		//  #4896
		li_Offset = 0 // -14
	
	Else
		li_Succ = of_move_objects( "detail", li_Offset, 0, FALSE)
	End If
	
	li_Succ = of_modify("r_frame.visible='0'" , FALSE)

	// --------------------------------------------------------------
	// Add. Text 
	// --------------------------------------------------------------
	If ib_Draw_Add_Text Then
		ls_Additional_Label_text = ""
		ls_Additional_Label_text = of_get_additional_label_text(  ll_IndexKey, as_unit, idt_departure   )
		
		If ls_Additional_Label_text = ls_Additional_text Then
			ls_Additional_Label_text = ""
		End If
		
		li_Succ = of_draw_additional_text( ls_Additional_text, ls_Additional_Label_text)
		guoLog.uf_debug( "["+ this.classname( )+".Draw Addditonal text " + ls_Additional_text  + " "  + ls_Additional_Label_text)
	End If

	// --------------------------------------------------------------
	// UK Healthmark
	// --------------------------------------------------------------
	If of_is_healthmark_enabled(as_unit) Then
		li_Succ = of_draw_healthmark( as_unit, FALSE)
	End If
	
	// --------------------------------------------------------------
	// Best Before Date
	// --------------------------------------------------------------
	If ib_Print_Best_Before  Then
		li_Succ = of_draw_best_before_date( )
	End If

	// --------------------------------------------------------------
	// Barcode Bitmap
	// --------------------------------------------------------------
	
	//	ll_Prt_Grp = lds_Prt_Grp.Retrieve ( il_Printing_Group , datetime(idt_Departure))
	//
	//If f_unitprofileString("PPMBARCODE4GROUP", String(ll_Key) , "0",  s_app.swerk ) = "1" Then
	//	lb_NO_PPM_CODE = FALSE 
	//Else
	//	lb_NO_PPM_CODE = TRUE
	//End If	
		
//	If ib_BarCode_on_CartDiagram  Then
//		li_Succ = of_draw_barcode( ll_IndexKey, ll_Stowage_key ) 
//	Else
//		ib_BarCode_on_CartDiagram = ib_BarCode_on_CartDiagram		
//	End If
	


	If ib_NAM_BarCode_on_CartDiagram  Then
		/*
		1. The flight number $$HEX2$$13202000$$ENDHEX$$including airline. For example AA 023
		2. The departure date in US format:  9-10-2020
		3. The city pair $$HEX2$$13202000$$ENDHEX$$DFW-FRA
		4. The stowage position of the cart.
		5. Dept time
		6. Aircraft type	
		AA 1234 04-04-2022 DFW-FRA G9-OVN9 E    08:55 LH 788
		AA123404-04-2022DFW-FRAG9-OVN9 E   08:55LH 788
		*/			

		select cflight_key into :ls_Flight_key from cen_out where nresult_key = :il_result_key ;

		ls_Human_Readable_Part = ls_Flight_key 

		li_Succ = of_draw_nam_barcode( ll_IndexKey, ll_Stowage_key, ls_Human_Readable_Part ) 
		
	ELSE
		// draw Header Barcode
		If ib_BarCode_on_CartDiagram  Then
			li_Succ = of_draw_barcode( ll_IndexKey, ll_Stowage_key ) 
		Else
			ib_BarCode_on_CartDiagram = ib_BarCode_on_CartDiagram		
		End If
		
	End If
	
	// lds_Datastore.saveas("c:\temp\cbase\cart_diagram_MOVE_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_lds_Datastore.PSR", PSReport! , true)
	// lds_Datastore.saveas("c:\temp\cbase\cart_diagram_WM2_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_lds_Datastore.PSR", PSReport! , true)
	//	oDS.saveas("c:\temp\cbase\cart_diagram_" + ls_File_Prefix + String(ral_CartPages,"000") + "_" + String(now(), "hhmmssfff") + ".PSR"	, PSReport! , true)

	//if ii_Do_NOT_Trace = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR of_getfullstate "+ ls_packinglist)							
	// --------------------------------------------------------------
	// Ende Values f$$HEX1$$fc00$$ENDHEX$$r Header / Footer
	// --------------------------------------------------------------
	of_getfullstate(lb_Blob)
	lds_Datastore.SetFullState(lb_Blob)
	//if ii_Do_NOT_Trace = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram NACH lds_Datastore.SetFullState "+ ls_packinglist)							
	
	ral_FileCounter++
	
	ls_File_Prefix = f_get_airline_name(al_airline_key )
	ls_File_Prefix += String(al_flightnumber , "000") + "_" + as_From + "_" + as_to + "_" +String(idt_departure, "YYYYMMDD")
	ls_File_Prefix += "_CD_" + String(il_transaction) + "_" 
	ls_Cart_Page_PDF_Name =  "_" + ls_File_Prefix + String(ral_CartPages,"000") + "_" + String(now(), "hhmmssfff") + ".PDF"	

	If s_app.itrace > 0 then
		lds_Datastore.saveas("c:\temp\cbase\"+ ls_File_Prefix + "_" +String(ral_CartPages,"000") + "_" + String(now(), "hhmmssfff") + "_"+ ls_packinglist +".PSR", PSReport! , true)
	end if
	
	ras_PdfFiles[ral_FileCounter] = f_gettemppath() + ls_Cart_Page_PDF_Name //"CBASE-CARTDIAGRAM-" + String(Rand(32767)) + String(now(), "hhmmssfff") + ".PDF"
//	If FileExists(ras_PdfFiles[ral_FileCounter]) Then
//		ras_PdfFiles[ral_FileCounter] = f_gettemppath() + "CBASE-CARTDIAGRAM-" + String(Rand(32767)) + String(now(), "hhmmssfff") + ".PDF"
//	End If

	rauo_Product.icartdiagramsheet		= 1
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR of_create_acrobat "+ ls_packinglist)							
	If of_create_acrobat( lds_Datastore, ras_PdfFiles[ral_FileCounter]) = -1 then
		rauo_Product.icartdiagramsheet	= 0
		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram ERROR of_create_acrobat "+ ls_packinglist)			
	End If
	
	// ---------------------------------------------------------------------------
	// PDF plus Bookmark
	// ---------------------------------------------------------------------------
	if fileexists(ras_PdfFiles[ral_FileCounter]) then
		If ib_Cart_Diagram_Bookmark then
			If lb_Bookmark Then
				ll_Start = CPU()
				li_Succ =  s_app.uo_PDF.of_add_bookmark( ras_PdfFiles[ral_FileCounter], ls_bookmark )
				ll_End = CPU()
				guoLog.uf_debug( "["+ this.classname( )+".of_add_bookmark: duration " + string(ll_End - ll_Start) + " milliseconds")
				
			End If
		End If			
	End If
	
//	// ---------------------------------------------------------------------------
//	// DataStore to JASPER
//	// ---------------------------------------------------------------------------
//	ls_JASPER_File = ras_PdfFiles[ral_FileCounter] 
//	ls_JASPER_File = Left(ls_JASPER_File, Lastpos(ls_JASPER_File, ".") - 1)
//	ls_JASPER_File += ".jrxml" 
//	of_create_jasper_from_datastore( lds_Datastore, ls_JASPER_File)
	
	if not fileexists(ras_PdfFiles[ral_FileCounter]) then
		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram File does not exists of_create_acrobat "+ ras_PdfFiles[ral_FileCounter] )			
	Else
		ll_Filesize = Filelength(ras_PdfFiles[ral_FileCounter])
		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram Filesize "+ ras_PdfFiles[ral_FileCounter] + ": " +  String(ll_Filesize))			
		If ll_Filesize < 1 then
		//		guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram File does not exists of_create_acrobat "+ ras_PdfFiles[ral_FileCounter] )			
		End If
	//Else
		
		
	End If
	
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram NACH of_create_acrobat "+ ls_packinglist)							
	
	//If inv_copy_settings.ib_copy_activated Then
	If inv_copy_settings.ib_Copy_Page Then
		If FileExists(ras_PdfFiles[ral_FileCounter]) Then
			ls_Target_File = inv_copy_settings.is_single_page_path + inv_copy_settings.of_remove_path(ras_PdfFiles[ral_FileCounter])
			li_Succ = inv_copy_settings.of_copy_file(ras_PdfFiles[ral_FileCounter], ls_target_File)
		End If
	End If
	
	
	If inv_copy_settings.ib_Copy_Page Then
		If FileExists(ras_PdfFiles[ral_FileCounter]) Then
//			ls_Target_File = inv_copy_settings.is_single_page_path + inv_copy_settings.of_remove_path(ras_PdfFiles[ral_FileCounter])
//			li_Succ = inv_copy_settings.of_copy_file(ras_PdfFiles[ral_FileCounter], ls_target_File)
			// ###################################################################################
			// Erweiterung: jedes File aufheben, um sp$$HEX1$$e400$$ENDHEX$$ter nach Workstation zu Sortieren
			// ###################################################################################
			ll_Cart_Page_Row = ids_Diagram_Pages.InsertRow(0)
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NRESULT_KEY", il_result_key )
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NTRANSACTION", il_Transaction )					
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CUSER", "-1")
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NCOUNTER", ll_Cart_Page_Row )					
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CTYPE", "CD" )				
							
			if ib_user_defined Then
				if isnull(is_User) or trim(is_User) = "" Then is_User = "BARCODE"
				li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CUSER", is_User)
			End If
			
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CFILENAME", ls_Cart_Page_PDF_Name )	
			//li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NAREA_KEY",  ll_Area_key)					
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NWORKSTATION_KEY",  ll_Workstation_key)					
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CAREA",  ls_Area)					
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CWORKSTATION", ls_Workstation )					
//			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "cgalley",  ls_galley)					
			li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "cstowage", ls_stowage )					
			
			
			li_Succ = ids_Diagram_Pages.update()
		End If
	End If
	
   If (ib_Overflow_on_Main = TRUE AND il_Equipment_Width = 1) Then
		if ib_Print_Overflow and of_get_backlog_rowcount() > 0 then  
			guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page BACKLOG ON  MAIN PAGE" + ls_packinglist )
		End If
	Else

		if ib_Print_Overflow and of_get_backlog_rowcount()> 0 then   
			if ib_non_sky Then
				// ------------------------------------------------------------------------
				// Do not Print Backlog Page => Content Spec instead
				// ------------------------------------------------------------------------
				guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page Content Spec instead of backlog  " + ls_packinglist )
			else
				// ------------------------------------------------------------------------
				// Print Backlog Page to PDF
				// ------------------------------------------------------------------------
				li_Succ = of_create_cd_backlog_page( ral_backlogpages, al_row, ral_cartpages, ral_filecounter,  ras_pdffiles, &
											rauo_product, ls_rampbox, ls_stowage, ls_packinglist, ls_pl_description, ls_loadinglist, ls_class, &
											ls_workstation, as_version, ls_container, al_flightnumber, as_suffix,  ls_header,  as_from, as_to,  &
											as_actype, ll_belly, as_time, as_owner, ls_area, ls_class_string, ral_backlogpages, as_current_printer_1, &
											as_unit)
		
				//If inv_copy_settings.ib_copy_activated Then
				If inv_copy_settings.ib_Copy_Page Then
					If FileExists(ras_PdfFiles[ral_FileCounter]) Then
						//ls_Target_File = inv_copy_settings.is_target_path + inv_copy_settings.of_remove_path(ras_PdfFiles[ral_FileCounter])
						ls_Target_File = inv_copy_settings.is_single_page_path + inv_copy_settings.of_remove_path(ras_PdfFiles[ral_FileCounter])
						li_Succ = inv_copy_settings.of_copy_file(ras_PdfFiles[ral_FileCounter], ls_target_File)
						
						//MB 04.10.2013: Backlogs auch verschieben
				
						ll_Cart_Page_Row = ids_Diagram_Pages.InsertRow(0)
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NRESULT_KEY", il_result_key )
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NTRANSACTION", il_Transaction )					
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CUSER", "-1")
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NCOUNTER", ll_Cart_Page_Row )					
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CTYPE", "CD" )	
													
						if ib_user_defined Then
							if isnull(is_User) or trim(is_User) = "" Then is_User = "BARCODE"
							li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CUSER", is_User)
						End If
						
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CFILENAME", inv_copy_settings.of_remove_path(ras_PdfFiles[ral_FileCounter]) )	
						//li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NAREA_KEY",  ll_Area_key)					
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "NWORKSTATION_KEY",  ll_Workstation_key)					
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CAREA",  ls_Area)					
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CWORKSTATION", ls_Workstation )					
						li_Succ = ids_Diagram_Pages.SetItem(ll_Cart_Page_Row, "CSTOWAGE",  ls_Stowage)					
						
						li_Succ = ids_Diagram_Pages.update()
			
					End If
				End If
			End If			
		End If

	End If
Else
	if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".INIT FAILED " + ls_packinglist )
End If

odsbacklog.SetFilter("")
odsbacklog.Filter()				

if IsValid(lds_Cartdiagram) then destroy lds_Cartdiagram
if IsValid(lds_Backlog) then destroy lds_Backlog
if IsValid(lds_Datastore) then destroy lds_Datastore

guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram_page =====================   END   ===================== ")



Return 1

end function

public function integer of_tr_remove_entries (ref uo_distribution rauo_distribution, string as_unit, datastore ads_exclusions, ref datastore rads_cartdiagramsheet);/*
* Objekt : uo_cart_diagram
* Methode: of_tr_remove_entries (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.08.2012
*
* Argument(e):
*	 ref		uo_cart_diagram		rauo_cart_diagram
*	 ref		uo_distribution		rauo_distribution
*	 			string					as_unit
*	 			datastore				ads_exclusions
*
* Beschreibung:		Remove disabled entries, empty Drawers and those from exclusion list
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.08.2012		Erstellung
* 1.1 			O.Hoefer	21.08.2012		NAM CR 12033 - Force Printing (per Airline and Equipment Type) / override area alloc. setting
* 1.2 			O.Hoefer	14.01.2013		NULL uoStowage[X] Problem
* 1.3 			O.Hoefer	16.01.2013		Remove Missing Stowage
* 1.4 			O.Hoefer	13.03.2013		Bugfix bei TR Cart Diagram und MZV = OFF
* 1.5 			O.Hoefer	29.07.2013		Bugfix f$$HEX1$$fc00$$ENDHEX$$r Delete 
*
*
* Return: integer
*
*/


Integer	li_Succ
Long		ll_Count
Long		ll_IndexKey
Long		ll_DetailKey
Long		ll_Found
Long		ll_Content_Rows
Long		ll_Distr_Stowage_Counter
Long		ll_EQ_Rows
Long		ll_Force_Diagram
Long		ll_EQ
Long		ll_TR
String	ls_temp
String	ls_Stowage
String	ls_PL_Unit
Boolean	lb_Stowage_Missing
Boolean	lb_No_Entry
Boolean	lb_Row_Deleted
DataStore	ldsPLContents
DataStore	lds_EQ


// Airline Equipment
lds_EQ = CREATE DataStore
lds_EQ.DataObject = "dw_airlines_equipment"
lds_EQ.Settransobject(SQLCA)

ll_EQ_Rows = lds_EQ.Retrieve(il_AirlineKey)


ldsPLContents = CREATE DataStore
ldsPLContents.DataObject = "dw_uo_packinglist_detail_check_contents"
ldsPLContents.SetTransObject(SQLCA)

If s_app.itrace > 0 then
//	rads_CartdiagramSheet.SaveAs(f_gettemppath() +  "rads_CartdiagramSheet_TR_"+String(cpu())+".xls" , excel5!, TRUE)
end if


//// --------------------------------------------------------------------
//// Schleife - entferne alle mit ntransporter_cart <> 1
//// --------------------------------------------------------------------
//For ll_Count = rads_CartdiagramSheet.RowCount() to 1 step -1
//	ll_IndexKey = rads_CartdiagramSheet.GetItemNumber(ll_Count, "lindex_key")
//	ls_temp = f_get_packinglist(ll_IndexKey)
//	ll_Force_Diagram = 0 
//	ls_PL_Unit	= rads_CartdiagramSheet.GetItemString(ll_Count, "spl_unit")
//		
//	ll_TR = rads_CartdiagramSheet.GetitemNumber(ll_Count, "ntransporter_cart")
//
//
//Next

// --------------------------------------------------------------------
// Schleife - entferne alle mit of_is_cartdiagram_enabled = FALSE
// --------------------------------------------------------------------
For ll_Count = rads_CartdiagramSheet.RowCount() to 1 step -1
	ll_IndexKey = rads_CartdiagramSheet.GetItemNumber(ll_Count, "lindex_key")
	ls_temp = f_get_packinglist(ll_IndexKey)
	ll_Force_Diagram = 0 
	ls_PL_Unit					= rads_CartdiagramSheet.GetItemString(ll_Count, "spl_unit")
	ll_EQ			= lds_EQ.Find("cunit='" + ls_PL_Unit + "'", 1, lds_EQ.RowCount())
	If ll_EQ > 0 then	
		ll_Force_Diagram	= lds_EQ.GetItemNumber(ll_EQ, "nforce_print")
	End If
	If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"
	if of_is_cartdiagram_enabled(ll_IndexKey, s_app.sMandant, as_Unit, lb_No_Entry) < 1 AND ll_Force_Diagram = 0 then
		guoLog.uf_debug( "["+ this.classname( )+".luo_cart_diagram.of_is_cartdiagram_enabled: FALSE " + ls_temp)

		rads_CartdiagramSheet.deleterow(ll_Count)
	Else
		guoLog.uf_debug( "["+ this.classname( )+".luo_cart_diagram.of_is_cartdiagram_enabled: TRUE " + ls_temp + " / ll_Force_Diagram = " + String(ll_Force_Diagram))

		// --------------------------------------------------------------------
		// CR-NAM-12033 
		// --------------------------------------------------------------------
		If ll_Force_Diagram = 1 Then
			li_Succ = rads_CartdiagramSheet.SetItem(ll_Count, "sarea", "")
			li_Succ = rads_CartdiagramSheet.SetItem(ll_Count, "sworkstation", "")
		End If	
		
	End If
Next
	
// --------------------------------------------------------------------
// Schleife - entferne alle aus der Ausschlussliste
// --------------------------------------------------------------------
If ads_exclusions.RowCount() > 0 Then
	For ll_Count = rads_CartdiagramSheet.RowCount() to 1 step -1
		ll_IndexKey = rads_CartdiagramSheet.GetItemNumber(ll_Count, "lindex_key")
		ls_temp = f_get_packinglist(ll_IndexKey)
		ls_Stowage = trim(rads_CartdiagramSheet.GetItemString(ll_Count, "sstowage"))
		
		ll_Found = ads_exclusions.Find("#1='" + ls_temp + "' AND #2 = '" + ls_Stowage + "'", 1, ads_exclusions.RowCount())
		If ll_Found > 0 Then
			if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY DRAWER: " + ls_temp + " / " + ls_Stowage )

			rads_CartdiagramSheet.deleterow(ll_Count)
		End If
	Next
End If

	
// --------------------------------------------------------------------
// Schleife - leerer Distributed Content rauo_distribution
// --------------------------------------------------------------------
For ll_Count = rads_CartdiagramSheet.RowCount() to 1 step -1
	ll_IndexKey = rads_CartdiagramSheet.GetItemNumber(ll_Count, "lindex_key")
	ls_temp = f_get_packinglist(ll_IndexKey)
	ls_Stowage = trim(rads_CartdiagramSheet.GetItemString(ll_Count, "sstowage"))
	lb_Stowage_Missing = TRUE
		
	
	If IsValid(rauo_distribution) Then
	
		guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY DRAWER upperbound(rauo_distribution.uoStowages) : " + String(upperbound(rauo_distribution.uoStowages) ) )
	
		For ll_Distr_Stowage_Counter = 1 To upperbound(rauo_distribution.uoStowages) 
			If not isvalid(rauo_distribution.uoStowages[ll_Distr_Stowage_Counter]) then
				guoLog.uf_debug( "["+ this.classname( )+".of_tr_remove_entries not isvalid(rauo_distribution.uoStowages["+String(ll_Distr_Stowage_Counter)+"])" )
				continue
			End If
			
			If Trim(ls_Stowage) = Trim(rauo_distribution.uoStowages[ll_Distr_Stowage_Counter].sStowage) Then 
				lb_Stowage_Missing = FALSE
				If rauo_distribution.uoStowages[ll_Distr_Stowage_Counter].dsContent.RowCount() = 0 Then
					// Kein Content => LEER
					guoLog.uf_debug( "["+ this.classname( )+".of_tr_remove_entries REMOVE EMPTY DRAWER (NO CONTENT in rauo_distribution.uoStowages[ll_Distr_Stowage_Counter].dsContent): " + ls_temp + " / " + ls_Stowage )
					// If TR Drawer Empty   
					ll_IndexKey			= rads_CartdiagramSheet.GetItemNumber(ll_Count, "lindex_key")
					ll_DetailKey		= rads_CartdiagramSheet.GetItemNumber(ll_Count, "ldetail_key")
					ll_Content_Rows	= ldsPLContents.Retrieve(ll_IndexKey, ll_DetailKey)
					If ll_Content_Rows < 1 Then
					//	rads_CartdiagramSheet.deleterow(ll_Count)
					End If
				End If
			End If
		Next
		If lb_Stowage_Missing Then
			guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY DRAWER MISSING STOWAGE: " + ls_temp + " / " + ls_Stowage )
			//rads_CartdiagramSheet.deleterow(ll_Count)
			ll_IndexKey			= rads_CartdiagramSheet.GetItemNumber(ll_Count, "lindex_key")
			ll_DetailKey		= rads_CartdiagramSheet.GetItemNumber(ll_Count, "ldetail_key")
			ll_Content_Rows	= ldsPLContents.Retrieve(ll_IndexKey, ll_DetailKey)
			If ll_Content_Rows < 1 Then				
				//guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY CONTAINTER MISSING STOWAGE: " + ls_temp + " / " + ls_Stowage )
				guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY CONTAINTER NO CONTENTS: " + ls_temp + " / " + ls_Stowage )	
				rads_CartdiagramSheet.deleterow(ll_Count)
			ELSE
				guoLog.uf_debug( "["+ this.classname( )+".DO NOT REMOVE EMPTY CONTAINTER => HAS CONTENTS: " + ls_temp + " / " + ls_Stowage )
			End If
			
		End If
	
	End If
		
Next


// --------------------------------------------------------------------
// Schleife - leerer Distributed Content rauo_distribution
// --------------------------------------------------------------------
If IsValid(rauo_distribution) Then
	If upperbound(rauo_distribution.uoStowages) > 0 Then
		For ll_Count = rads_CartdiagramSheet.RowCount() to 1 step -1
			lb_Row_Deleted = FALSE
			ll_IndexKey			= rads_CartdiagramSheet.GetItemNumber(ll_Count, "lindex_key")
			ll_DetailKey		= rads_CartdiagramSheet.GetItemNumber(ll_Count, "ldetail_key")

			ls_temp = f_get_packinglist(ll_IndexKey)
			ls_Stowage = trim(rads_CartdiagramSheet.GetItemString(ll_Count, "sstowage"))
			lb_Stowage_Missing = TRUE
				
			guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY DRAWER upperbound(rauo_distribution.uoStowages) : " + String(upperbound(rauo_distribution.uoStowages) ) )
			For ll_Distr_Stowage_Counter = 1 To upperbound(rauo_distribution.uoStowages) 
				If not isvalid(rauo_distribution.uoStowages[ll_Distr_Stowage_Counter]) then
					guoLog.uf_debug( "["+ this.classname( )+".of_tr_remove_entries not isvalid(rauo_distribution.uoStowages["+String(ll_Distr_Stowage_Counter)+"])" )
					continue
				End If
				
				If Trim(ls_Stowage) = Trim(rauo_distribution.uoStowages[ll_Distr_Stowage_Counter].sStowage) Then 
					lb_Stowage_Missing = FALSE
					If rauo_distribution.uoStowages[ll_Distr_Stowage_Counter].dsContent.RowCount() = 0 Then
						// Kein Content => LEER
						guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY DRAWER (NO CONTENT in rauo_distribution.uoStowages[ll_Distr_Stowage_Counter].dsContent): " + ls_temp + " / " + ls_Stowage )
						// If TR Drawer Empty   
						ll_Content_Rows	= ldsPLContents.Retrieve(ll_IndexKey, ll_DetailKey)
						If ll_Content_Rows < 1 Then
							If NOT lb_Row_Deleted Then
								rads_CartdiagramSheet.deleterow(ll_Count)
								lb_Row_Deleted = TRUE
							End If
						End If
					End If
				End If
			Next
			If lb_Stowage_Missing Then
				
				//rads_CartdiagramSheet.deleterow(ll_Count)
				
				guoLog.uf_debug( "["+ this.classname( )+".REMOVE EMPTY DRAWER MISSING STOWAGE: " + ls_temp + " / " + ls_Stowage )
			End If
		Next
	End If
End If

DESTROY	ldsPLContents
DESTROY 	lds_EQ

Return 1

end function

public function integer of_count_tr_cart_pages (string as_unit, ref uo_tr_cart_allocation rauo_tr_alloc, long al_airline_key, long al_routing_id, integer ai_fill_type, ref datastore rads_cartdiagramsheet);/*
* Objekt : uo_client_label
* Methode: of_count_tr_cart_pages (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.08.2012
*
* Argument(e):
* 				string							as_unit
*	 ref		uo_cart_diagram				rauo_cart_diagram
*	 ref		uo_tr_cart_allocation		rauo_tr_alloc
*	 			long								al_airline_key
*	 			long								al_routing_id
*	 			integer							ai_fill_type
*
* Beschreibung:		Count Pages fpr TR Cart and Add Content 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.08.2012		aus Create Tr Cart Diagram ausgelagert
* 1.1 			O.Hoefer	12.02.2020		#5168 TR Cart plus Group
*
*
* Return: integer
*
*/

Long		ll_TRCartPagesMax
Long		ll_Dummy_1
Long		ll_Row
Long		ll_TR_Type
Boolean	lb_Break_on_Class
Boolean	lb_Group_Break
String	ls_Group_Class
String	ls_Area, ls_Workstation, ls_Class
String	ls_PL
Long		ll_IndexKey, ll_DetailKey, ll_Belly
Long		ll_Galley_Group
String	ls_Stowage
Long		ll_Count, ll_Page
Integer	li_TR_Group

// --------------------------------------------------------------------
// Schleife - Ermittle Anzahl Seiten
// --------------------------------------------------------------------
// TR Cart Typ ermitteln
If isnull( s_app.sMandant) or  s_app.sMandant = "" then  s_app.sMandant = "002"

If ib_Extended_tr_handling Then
	
	if rads_CartdiagramSheet.Rowcount() >  0 Then
		ll_IndexKey 		= rads_CartdiagramSheet.GetItemNumber(1, "lindex_key")
		ll_Dummy_1 = of_get_tr_cart_key(as_unit, ll_IndexKey, idt_departure , il_rungs, il_columns, il_multiply, il_AirlineKey)
	End If

else

	ll_Dummy_1 = of_get_tr_cart_type_old( s_app.smandant , as_unit , al_airline_key , al_Routing_ID ) 
End If


// Verteilungsobjekt: Abmessungen setzen
rauo_TR_Alloc.of_set_tr_cart_size(of_get_Multiply() , of_get_columns(), of_get_Rungs(), ll_Dummy_1 )
lb_Break_on_Class = of_is_use_class_enabled() 
ls_Group_Class = ""
If rads_CartdiagramSheet.Rowcount() > 0 Then
	ls_Group_Class = rads_CartdiagramSheet.GetItemString(1, "sclass")
End If
lb_Group_Break = FALSE
For ll_Row = 1 to rads_CartdiagramSheet.Rowcount()
	ls_Area		   = ""
	ls_Workstation	= ""
	ll_IndexKey 		= rads_CartdiagramSheet.GetItemNumber(ll_Row, "lindex_key")
	
	If ib_Extended_tr_handling Then
		ll_Dummy_1 = of_get_tr_cart_key(as_unit, ll_IndexKey, idt_departure , il_rungs, il_columns, il_multiply, il_AirlineKey)
	End If
		
	ll_DetailKey 		= rads_CartdiagramSheet.GetItemNumber(ll_Row, "ldetail_key")
	ls_PL					= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
	ll_Belly 			= rads_CartdiagramSheet.GetItemNumber(ll_Row, "nbelly")
	ls_Class				= rads_CartdiagramSheet.GetItemString(ll_Row, "sclass")
	ls_Area 				= rads_CartdiagramSheet.GetItemString(ll_Row, "sarea")
	ls_Workstation		= rads_CartdiagramSheet.GetItemString(ll_Row, "sworkstation")
	ll_Galley_Group	= rads_CartdiagramSheet.GetItemNumber(ll_Row, "ngalley_group")
	ll_TR_Type			= rads_CartdiagramSheet.GetItemNumber(ll_Row, "ntr_cart_key")	
	ls_Stowage			= rads_CartdiagramSheet.GetItemString(ll_Row, "sStowage")
	
	// #5168
	li_TR_Group       = rads_CartdiagramSheet.GetItemNumber(ll_Row, "ntrgroupnumber")
	
	// wenn "by Class": bei Gruppenwechsel neuen TR Cart erzwingen 
	lb_Group_Break = FALSE
	If lb_Break_on_Class Then
		If ls_Class <> ls_Group_Class Then
			ls_Group_Class = ls_Class
			lb_Group_Break = TRUE
		End If
	End If
	//guoLog.uf_debug( "["+ this.classname( )+".of_count_tr_cart_pages " + ls_PL + " " + ls_Class + " " + String(ll_Galley_Group) + " " + String(ll_TR_Type))
	guoLog.uf_debug( "["+ this.classname( )+".of_count_tr_cart_pages " + ls_PL + " Galleygroup " + String(ll_Galley_Group) + " TRGroup " +String(li_TR_Group) + " Stowage " + ls_Stowage)
	// F$$HEX1$$fc00$$ENDHEX$$lle St$$HEX1$$fc00$$ENDHEX$$ckliste in TR Cart
	rauo_TR_Alloc.of_add_content(ll_IndexKey, ll_DetailKey, ai_Fill_Type, lb_Group_Break, ll_Row, ll_Galley_Group, ls_Stowage, al_airline_key, li_TR_Group )
	// rauo_TR_Alloc.of_add_content(ll_IndexKey, ll_DetailKey, ai_Fill_Type, lb_Group_Break, ll_Row, ll_Galley_Group, ls_Stowage )
	//	rauo_TR_Alloc.of_add_content(ll_IndexKey, ll_DetailKey, ai_Fill_Type, lb_Group_Break, ll_Row, ll_Galley_Group, ls_Stowage, al_airline_key )

Next


ll_TRCartPagesMax = rauo_TR_Alloc.of_get_page_count()
// --------------------------------------------------------------------
// Ende Seitenz$$HEX1$$e400$$ENDHEX$$hlung
// --------------------------------------------------------------------

if s_app.itrace > 0 then
	rauo_TR_Alloc.ids_TR_Cart_Allocation.Saveas("c:\temp\cbase\TR_alloc_" + String(now(), "hhmmssfff")+ ".xls", Excel5!,true)
	rads_CartdiagramSheet.Saveas("c:\temp\cbase\rads_CartdiagramSheet_" + String(now(), "hhmmssfff")+ ".xls", Excel5!,true)
End If

// --------------------------------------------------------------------
// Zuordnung Stowage zu nPrintPage 
// 
// --------------------------------------------------------------------
if s_app.itrace > 0 then
	rauo_TR_Alloc.ids_TR_Cart_Allocation.SetFilter("")
	rauo_TR_Alloc.ids_TR_Cart_Allocation.Filter()	
	For ll_Count =  1 To rauo_TR_Alloc.ids_TR_Cart_Allocation.RowCount()
		ls_Stowage = rauo_TR_Alloc.ids_TR_Cart_Allocation.GetItemString(ll_Count, "cstowage")
		ll_Page = rauo_TR_Alloc.ids_TR_Cart_Allocation.GetItemNumber(ll_Count, "nPrintPage")
		guoLog.uf_debug( "["+ this.classname( )+".of_count_tr_cart_pages] TR Cart Stowage " + ls_Stowage + " => nPrintPage TR"  + String(ll_Page, "00"))
	Next
End If

Return ll_TRCartPagesMax

end function

public function integer of_create_tr_cartdigram_cs (boolean ab_content_sheet, long al_result_key, ref uo_distribution rauo_distribution, ref uo_content_sheet rauo_contentsheet, ref datastore rads_loading);/*
* Objekt : uo_client_label
* Methode: of_create_tr_cartdigram_cs (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.08.2012
*
* Argument(e):
*	 boolean ab_content_sheet
*	 long al_result_key
*	 ref uo_distribution rauo_distribution
*
* Beschreibung:		TR Carts - Content Sheet Master (rads_Loading)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.08.2012		Erstellung
*
*
* Return: integer
*
*/

Integer	li_Succ
String	ls_Distr_G, ls_Distr_S, ls_Distr_P
String	ls_Find_RowId
Long		ll_Count, ll_Found, ll_RowId
String	ls_Class

// -------------------------------------------------------------------
// Content Sheet
// -------------------------------------------------------------------
If ab_Content_sheet Then
	If Isvalid(rauo_ContentSheet) Then
		rauo_ContentSheet.ilresultkey = al_result_key
	End If	
	
	If Isvalid(rads_Loading) then
		
		If IsValid(rauo_distribution) Then
			If rauo_distribution.dsDistribution.RowCount() > 0 Then
				if il_Disable_Debug=0 then
					//rauo_distribution.dsDistribution.saveas(f_gettemppath() + "rauo_distribution_dsDistribution_" + String(Rand(32767)) + String(now(), "hhmmss") + ".XLS", excel5!, True)
				End if
				
				For ll_Count = 1 To rauo_distribution.dsDistribution.RowCount()
					//ll_RowId = rauo_distribution.dsDistribution.GetItemNumber(ll_Count , "nrowid")
					li_Succ = rauo_distribution.dsDistribution.RowsCopy(ll_Count, ll_Count, Primary!, rauo_ContentSheet.dsLoading, 1, Primary!)
					ls_Distr_G = rauo_distribution.dsDistribution.GetItemString(ll_Count, "cen_galley_cgalley")
					ls_Distr_S = rauo_distribution.dsDistribution.GetItemString(ll_Count, "cen_stowage_cstowage")
					ls_Distr_P = rauo_distribution.dsDistribution.GetItemString(ll_Count, "cen_stowage_cplace")
					If Isnull(ls_Distr_P) then ls_Distr_P = ""
					If Trim(ls_Distr_P) = "" Then 
						ls_Find_RowId = "cen_galley_cgalley='" + ls_Distr_G + "' AND cen_stowage_cstowage='" + ls_Distr_S + "'"
					Else
						ls_Find_RowId = "cen_galley_cgalley='" + ls_Distr_G + "' AND cen_stowage_cstowage='" + ls_Distr_S + "' and cen_stowage_cplace='" + ls_Distr_P + "'"
					End If
					ll_Found =  rads_Loading.Find(ls_Find_RowId, 1, rads_Loading.RowCount())
					If ll_Found > 0 Then
						ll_RowId = rads_Loading.GetItemNumber(ll_Found, "nrowid")
					
						If ll_RowId >= 1000000 Then
							ll_RowId = ll_RowId - 1000000
							li_Succ = rauo_ContentSheet.dsLoading.SetItem(1, "nrowid", ll_RowId)
						Else
							li_Succ = rauo_ContentSheet.dsLoading.SetItem(1, "nrowid", ll_RowId)
						End if
					End If	
					if il_disable_debug =0 then
						guoLog.uf_debug( "["+ this.classname( )+".of_create_tr_cartdiagram COPY rads_Loading ll_RowId " + String(ll_RowId) + " Found " + String(ll_Found)  + " Find: " + ls_Find_RowId)
					End if
				
				Next
			End If
		Else
			rads_Loading.SetFilter("")
			//rads_Loading.SetFilter(as_LabelFilter)
			rads_Loading.Filter()
			li_Succ = rads_Loading.RowsCopy(1, rads_Loading.RowCount(), Primary!, rauo_ContentSheet.dsLoading, 1, Primary!)
			rads_Loading.SetFilter("")
			rads_Loading.Filter()
		End If
	Else
		//rads_Loading.SetFilter(as_LabelFilter)
		rads_Loading.SetFilter("")
		rads_Loading.Filter()
		li_Succ = rads_Loading.RowsCopy(1, rads_Loading.RowCount(), Primary!, rauo_ContentSheet.dsLoading, 1, Primary!)
		rads_Loading.SetFilter("")
		rads_Loading.Filter()
	End If
End If

Return 1

end function

public function integer of_create_unassigned_cart_report (boolean ab_unassignedcarts, ref datastore rads_unassigned, ref uo_documents rauo_product, ref long ral_filecounter, ref string ras_pdffiles[]);/*
* Objekt : uo_client_label
* Methode: of_create_unassigned_cart_report (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 21.08.2012
*
* Argument(e):
* boolean ab_unassignedcarts
*	 ref datastore rads_unassigned
*	 ref uo_cart_diagram rauo_diagram
*	 ref uo_documents rauo_product
*	 ref long ral_filecounter
*	 ref string ras_pdffiles[]
*
* Beschreibung:		Create Unassigned Cart PDF Report
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	21.08.2012		Ausgelagert aus Create Cart Diagram
*
*
* Return: integer
*
*/


Integer	li_Succ
Long		ll_Count_Unassigned
Long		ll_unassigned_row

// ------------------------------------------------------------------------
// Report unassigned cart diagram.... 
// ------------------------------------------------------------------------
If ab_UnassignedCarts Then
	rads_unassigned.Reset()
	li_Succ = ids_sd_message.setfilter("")
	li_Succ = ids_sd_message.filter()		
	For ll_Count_Unassigned = 1 To ids_sd_message.RowCount()
		If ids_sd_message.GetItemNumber(ll_Count_Unassigned, "nmsgtype") = MSG_UNASSIGNED Then
			ll_unassigned_row = rads_unassigned.InsertRow(0)
			rads_unassigned.Setitem(ll_unassigned_row, "cpackinglist", ids_sd_message.GetItemString(ll_Count_Unassigned, "cpackinglist"))
			rads_unassigned.Setitem(ll_unassigned_row, "ctext", ids_sd_message.GetItemString(ll_Count_Unassigned, "ctext"))
			rads_unassigned.Setitem(ll_unassigned_row, "cstowage", ids_sd_message.GetItemString(ll_Count_Unassigned, "cstowage"))
		End If
	Next
	
	If rads_unassigned.RowCount() > 0 Then
		// Header f$$HEX1$$fc00$$ENDHEX$$llen
		rads_unassigned.object.t_departure.Text = String(idt_Departure, s_app.sdateformat)
		rads_unassigned.object.t_flight.Text = rauo_Product.sAirline + " " + String(rauo_Product.lFlightNumber, "000") 
		rads_unassigned.Sort()
		ral_FileCounter++
		ras_PdfFiles[ral_FileCounter] = f_gettemppath() + "CBASE-UNASSIGNED-CART-" + String(Rand(32767)) + String(now(), "hhmmss") + ".PDF"
		f_format_datastore_report(rads_unassigned, uf.translate("Unassigned Cart Diagram Report"))
		If of_create_acrobat(rads_unassigned, ras_PdfFiles[ral_FileCounter]) = -1 Then
			//lb_Error_on_Acrobat = TRUE
			rauo_Product.icartdiagramsheet = 0 
		End If
	End If
End If


Return 1

end function

public function boolean of_is_tr_header_in_footer ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_tr_header_in_footer (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 19.01.2010
* Argument(e):
* none
*
* Return: boolean
*
*
* Soll der Header im Footer erscheinen (TR Cart)
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  19.01.2010	1.0           Ulrich Paudler     Erstellung
*  02.02.2012	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter "Parameter statt Profile" (Service)
*                                               Variante "Section aus Instanzvariable" (WEB)
*  12.09.2012	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter je Airline statt je Betrieb (Tabelle CEN_AIRL_DIAG_FLAGS)
*
*************************************************************/

Long		ll_Value	
String	ls_Value

/*select * from CEN_AIRL_DIAG_FLAGS
 	NFLAG_ID	NAIRLINE_KEY	NHEAD_FOOT_CART	NHEAD_FOOT_TCART	NDISP_LOS_CART
1	1012	17988	0	1	1*/

// NEU: per Airline statt per Unit
If NOT isNull(isTRCartDiagramFooter) AND Trim(isTRCartDiagramFooter) > "" Then
	ls_Value = isTRCartDiagramFooter
Else
	select	NHEAD_FOOT_TCART
	into		:ll_Value
	from		CEN_AIRL_DIAG_FLAGS
	where		NAIRLINE_KEY	 = :il_airlinekey;
	If SQLCA.SQLCode <> 0 then
		ls_Value = "0"
	Else
		If isNULL(ll_Value) Then ll_Value = 0
		ls_Value = String(ll_Value)
		
	End If
End If

// Cacheing
if isNull(isTRCartDiagramFooter) or isTRCartDiagramFooter = "" Then
	isTRCartDiagramFooter = ls_Value
End If

if ls_Value = "1" Then
	return True
End If

return False

end function

public function integer of_get_level_of_service (ref string ras_los[]);/*
* Objekt : uo_cart_diagram
* Methode: of_get_level_of_service (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 12.09.2012
*
* Argument(e):
* ref string ras_los[]
*
* Beschreibung:		Neuer Header Bestandteil: Level of Service (zu Loadinglist)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	12.09.2012		Erstellung
* 1.1 			O.Hoefer	25.10.2012		es fehlte die Pr$$HEX1$$fc00$$ENDHEX$$fung, ob Enabled
*
*
* Return: integer
*
*/


Long		ll_Rows
String	ls_Temp
String	ls_Loadinglists[]
Long		ll_Count
Long		ll_Enabled
DataStore	lds_LOS


// Check enabled
SELECT	ndisp_los_cart  
INTO		:ll_Enabled  
FROM		cen_airl_diag_flags  
WHERE		nairline_key = :il_airlinekey   ;
If SQLCA.SQLCode = 0 Then
	If ll_Enabled = 0 Then
		ras_los = ls_Loadinglists
		Return 0		
	End If	
Else
	ras_los = ls_Loadinglists
	Return 0
End If


lds_LOS = CREATE DataStore
lds_LOS.DataObject = "dw_cart_level_of_service"
lds_LOS.SettRansObject(SQLCA)

If ids_sd_master.rowcount() = 0 then
	ll_rows = ids_SD_Master.Retrieve(il_result_key, il_transaction)
End If

If ids_sd_master.rowcount() > 0 then
	ls_Loadinglists = ids_sd_master.object.cloadinglist[1, ids_sd_master.RowCount()]
End if

If upperbound(ls_Loadinglists) > 0 then
	ll_Rows = lds_LOS.retrieve(ls_Loadinglists, idt_departure )
	lds_LOS.sort()
End if

For ll_Count = 1 To lds_LOS.RowCount()
	ls_Temp = lds_LOS.Getitemstring(ll_Count, "clevel_of_service")
	If not isnull(ls_Temp) AND trim(ls_Temp) > "" Then
		ras_LOS[upperbound(ras_LOS) + 1]	= ls_Temp
	End If
Next

DESTROY lds_LOS

Return Upperbound(ras_LOS)
end function

public function boolean of_is_content_spec_enabled (long arg_l_index, string arg_s_unit, date arg_d_departure);/*
* Objekt : uo_cart_diagram
* Methode: of_is_content_spec_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 14.09.2012
*
* Argument(e):
*	 long arg_l_index
*	 string arg_s_unit
*	 date arg_d_departure
*
* Beschreibung:		pr$$HEX1$$fc00$$ENDHEX$$fe Schalter Content Spec in Area Allocation (LOC_UNIT_PL_AREAS.ncontent_spec=1)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	14.09.2012		Erstellung
*
*
* Return: boolean
*
*/

long ll_Enabled
String	ls_PL


If ib_enable_masterdata_view = TRUE Then
	return FALSE
End If


ls_PL = f_get_packinglist(arg_l_index)

SELECT ncontent_spec  
into :ll_Enabled
    FROM LOC_UNIT_PL_AREAS,   
         LOC_UNIT_AREAS,   
         CEN_PACKINGLIST_INDEX,   
         LOC_UNIT_WORKSTATION  
   WHERE ( LOC_UNIT_PL_AREAS.NAREA_KEY = LOC_UNIT_AREAS.NAREA_KEY ) and  
         ( LOC_UNIT_PL_AREAS.NWORKSTATION_KEY = LOC_UNIT_WORKSTATION.NWORKSTATION_KEY ) and  
         ( LOC_UNIT_PL_AREAS.NPACKINGLIST_INDEX_KEY = CEN_PACKINGLIST_INDEX.NPACKINGLIST_INDEX_KEY ) and  
         ( ( loc_unit_pl_areas.npackinglist_index_key = :arg_l_index ) AND  
         ( loc_unit_pl_areas.cunit = :arg_s_unit ) )   AND 
			 loc_unit_pl_areas.ncartdiagram > 0
			USING SQLCA;
			
If SQLCA.SQLCode <> 0 Then
	// Error ?
	// Todo: ### Fehlerbehandlung ###
	ll_Enabled = 0
Else
	If IsNull(ll_Enabled) then
		ll_Enabled = 0 	
	End if
End If

If ll_Enabled = 1 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_is_content_spec_enabled " + ls_PL +  " TRUE" )
	Return TRUE
Else
	guoLog.uf_debug( "["+ this.classname( )+".of_is_content_spec_enabled " + ls_PL +  " FALSE" )
	Return FALSE
End if

return FALSE

end function

public function integer of_distr_content_4_cs (ref datastore rads_distribution_contents, long al_row, long al_column, long al_content_master_row_id);	/*
	* Objekt : uo_cart_diagram
	* Methode: of_distr_content_4_contentsheet (Function)
	* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
	* Datum  : 29.04.2011
	*
	* Argument(e):
	* ref datastore rads_distribution_contents
	*	 ref uo_cart_distribution rauocartdistribution
	*	 long al_row
	*	 long al_column
	*	 long al_content_master_row_id
	*
	* Beschreibung:		aus Distribution ausgelagert
	*
	* Aenderungshistorie:
	* Version 		Wer			Wann			Was und warum
	* 1.0 			O.Hoefer	29.04.2011		Erstellung
	*
	*
	* Return: integer
	*
	*/
	
	
	// --------------------------------------------------------------------------
	// Verteilter Content nach Content Sheet dsLoadingContents 
	// --------------------------------------------------------------------------
	Long	ll_Count
	Integer	li_Succ 
	Long		ll_Content_Header_Detail_Key
	String	ls_temp_content_pl
	String	ls_temp_content
	Long		ll_temp_qty
	Long		ll_Sort_Counter
	Long	ll_new_Row
	s_distrib_items	lstr_item[]


//	rauoCartDistribution.of_get_row_without_sub(al_Column, al_row, lstr_item)
	of_sd_get_distr_content( al_column, al_row, lstr_item)
	
	//lstr_item 
	
	For ll_Count = 1 To Upperbound(lstr_item)
		If trim(lstr_item[ll_Count].sitem) > "" Then
			if il_Disable_Debug= 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_distr_content_4_contentsheet content sheet dsLoadingContents llRowId=" + String(al_content_master_row_id) + " / " + lstr_item[ll_Count].sitem)
			End If
			
			ll_temp_qty = lstr_item[ll_Count].lcount 
			If ll_temp_qty = 0 then
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_distr_content_4_contentsheet qty=0 SKIP " + + lstr_item[ll_Count].sitem)
				End If
				CONTINUE
			end if
			
			If lstr_item[ll_Count].bdistributed = False then
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_distr_content_4_contentsheet NOT DISTRIBUTED SKIP " + + lstr_item[ll_Count].sitem)
				End If
				CONTINUE
			end if
			
			ll_New_Row = rads_distribution_contents.InsertRow(0)
			ll_Content_Header_Detail_Key = (al_Column * 1000) + al_row								
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key	)						
			li_Succ =rads_distribution_contents.SetItem(ll_New_Row, "nrowid", al_content_master_row_id)
			ls_temp_content_pl = lstr_item[ll_Count].cpackinglist  
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "cpackinglist", ls_temp_content_pl)
			ls_temp_content = lstr_item[ll_Count].ctext 
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", ls_temp_content)
			If Trim(ls_temp_content) = "" Then
				li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "ctext", lstr_item[ll_Count].sitem)
			End If
			if il_Disable_Debug= 0 then
				If isnull(ls_temp_content) then ls_temp_content = "NULL"
				If isnull(ls_temp_content_pl) then ls_temp_content_pl = "NULL"			
				//guoLog.uf_debug( "["+ this.classname( )+".of_create_distribution content sheet TRAY DISTRIBUTED ITEM llrowid="+ String(al_content_master_row_id) + " / " + ls_temp_content + " / " + ls_temp_content_pl + " / " + lstr_item[ll_Count].sitem)
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_distr_content_4_contentsheet content sheet DRAWER_MULTI_RUNG DISTRIBUTED ITEM llrowid="+ String(al_content_master_row_id) + " / " +  ls_temp_content_pl + " / " + ls_temp_content + " / " + lstr_item[ll_Count].sitem)
				End If
			End If
			ll_temp_qty = lstr_item[ll_Count].lcount // ids_distribution_results.GetItemNumber(ll_Distr_Counter , "nqty")
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nquantity", ll_temp_qty)
			ll_Sort_Counter++
			li_Succ = rads_distribution_contents.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
		End If
	Next
	// --------------------------------------------------------------------------
	// Ende Verteilter Content nach Content Sheet dsLoadingContents 
	// --------------------------------------------------------------------------
Return 1

end function

public function string of_overflow_message (string as_packinglist);/*
* Objekt : uo_cart_diagram
* Methode: of_overflow_message (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 18.09.2012
*
* Argument(e):
* string as_packinglist
*
* Beschreibung:		NAM CR 12008 - verschiedene Messages bei Overflow (abh. von Content Spec setting)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	18.09.2012		Erstellung
*
*
* Return: string
*
*/


Long		ll_Index_key
String	ls_Return

//is_Overflow_MSG_1 = uf.translate("weitere auf Inhaltsansicht") 
//is_Overflow_MSG_2 = uf.translate("$$HEX1$$dc00$$ENDHEX$$berlaufprotokoll mit weiteren Daten")
//is_Overflow_MSG_3 = uf.translate("siehe $$HEX1$$dc00$$ENDHEX$$berlaufprotokoll/Inhaltsansicht") 

If ib_Content_Spec = FALSE AND ib_Overflow = TRUE Then
	ls_Return = is_Overflow_MSG_2
End If

If ib_Content_Spec = TRUE AND ib_Overflow = TRUE Then
	ll_Index_key = f_get_packinglist_key(as_Packinglist)
	if of_is_content_spec_enabled(ll_Index_key, is_CSC, idt_Departure) Then
		ls_Return = is_Overflow_MSG_3
	Else
		ls_Return = is_Overflow_MSG_2
	End if
End If


// If ib_Overflow
// ib_Content_Spec


Return ls_Return
end function

public function long of_adjust_font (string arg_s_object[], long arg_l_size, boolean arg_b_bold, boolean arg_b_italic);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_adjust_font (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 24.09.2012
*
* Argument(e):	string arg_s_object
*						long arg_l_size
*                         boolean arg_b_bold
*                         boolean arg_b_italic
* Return: Long
*
*
* Anpassen der Texteigenschaften
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
* 24.09.2012	1.0	Ulrich Paudler		Erstellung
* 06.12.2012	1.1	Schriftart nicht $$HEX1$$e400$$ENDHEX$$ndern
*************************************************************/
long ll_counter
String ls_Text, ls_Font_Name

for ll_counter = 1 to upperbound(arg_s_object)

	ls_Text = trim(of_describe( arg_s_object[ll_counter] + ".text",FALSE))

	if len (ls_Text) < 1  or ls_Text = "!" or ls_Text = "???" then
		continue
	end if

	ls_Font_Name = of_describe( arg_s_object[ll_counter] + ".font.face",FALSE)
	

	of_modify_dw( arg_s_object[ll_counter] + ".font.height='-" + String(arg_l_size) +"'")

	if arg_b_bold then
		of_modify_dw( arg_s_object[ll_counter] + ".font.weight='" + String(FONT_BOLD ) + "'")
	else
		of_modify_dw( arg_s_object[ll_counter] + ".font.weight='" + String(FONT_NORMAL ) + "'")
	end if
	if arg_b_italic then
		of_modify_dw( arg_s_object[ll_counter] + ".font.italic='1'")
	else
		of_modify_dw( arg_s_object[ll_counter] + ".font.italic='0'")
	end if
next

return 0
end function

public function long of_adjust_text_size (string arg_s_object[], long arg_l_height_factor);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_adjust_text_size (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 18.09.2012
*
* Argument(e):	string arg_s_object[ll_counter]
*                         long arg_l_height_factor
* Return: Long
*
*
* Anpassen der Textgroesse an den Tray
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
* 18.09.2012	1.0	Ulrich Paudler		Erstellung
* 19.09.2012	1.1	Ulrich Paudler		Font nicht verkleinern
*************************************************************/
integer li_Calc_Size, li_Weight, li_Italic
Long ll_counter
Long li_H, li_W 
String ls_Font_Name
String ls_Text

boolean lb_Bold, lb_Italic

for ll_counter = 1 to upperbound(arg_s_object)
	ls_Text = trim(of_describe( arg_s_object[ll_counter] + ".text",FALSE))
	if len (ls_Text) < 1  or ls_Text = "!" or ls_Text = "???" then
		continue 
	end if

	ls_Font_Name = of_describe( arg_s_object[ll_counter] + ".font.face",FALSE)
	
	li_Weight = integer(of_describe( arg_s_object[ll_counter] + ".font.weight",FALSE))
	li_Italic= integer(of_describe( arg_s_object[ll_counter] + ".font.italic",FALSE))

	if li_Weight > FONT_NORMAL then lb_Bold =TRUE
	if li_Italic > 0 then  lb_Italic  =TRUE

	li_W = Integer(of_describe( arg_s_object[ll_counter] + ".width",FALSE))
	
	// H$$HEX1$$f600$$ENDHEX$$he an die maximale Anzahl der Zeilen anpassen
	// + 20% f$$HEX1$$fc00$$ENDHEX$$r Zwischenr$$HEX1$$e400$$ENDHEX$$ume
	li_H = Integer(dec(of_describe( arg_s_object[ll_counter] + ".height",FALSE)) * arg_l_height_factor * 1.2)


	li_Calc_Size = of_calc_font_size(ls_Text, li_H, li_W, ls_Font_Name, lb_Bold, lb_Italic, FALSE, FALSE)

	// do not reduce font size
	If li_Calc_Size > abs(long(of_describe(arg_s_object[ll_counter] + ".font.height",FALSE)))  Then
		If il_Disable_Debug = 0 Then 
			guoLog.uf_debug( "["+ this.classname( )+".of_adjust_text_size: " + arg_s_object[ll_counter] + " => " + ls_Font_Name +"FONT SIZE " + String(li_Calc_Size) + " height" + String(li_H) + " Width " + String(li_W) )
		end if
		of_modify_dw(arg_s_object[ll_counter] + ".font.face='" + ls_Font_Name + "'")
		of_modify_dw(arg_s_object[ll_counter] + ".font.height='-"+String(li_Calc_Size)+ "'")
		of_modify_dw(arg_s_object[ll_counter] + ".height='" + String (li_H) + "'")
	End If
next

return 0
end function

public function integer of_calc_font_size (string as_text, ref long al_height, ref long al_width, string as_font_name, boolean ab_bold, boolean ab_italic, boolean ab_underline, boolean ab_wrap);/*
* Objekt : uo_cart_diagram
* Methode: of_calc_font_size (Function)
* Autor  : Ulrich Paudler
* Datum  : 18.09.2012
*
* Argument(e):
*	 string  as_text
*	 long al_height
*	 long al_width
*	 string  as_font_name
*	 boolean ab_bold
*	 boolean ab_italic
*	 boolean ab_underline
*	 boolean ab_wrap
*
* Beschreibung:		Aufruf Font Size Calculation
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			u.Paudler	18.09.2012		Erstellung, kopiert von of_calc_font_size, ab_wrap hinzu
*
*
* Return: integer
*
*/


long	lHeight, lWidth
Integer li_size
Integer	iRet
String	ls_font, sret
Window	loWin
uo_font_calc uoFont


if isnull(as_text) then return -1
if trim(as_text) = "" then return -1


uoFont = create uo_font_calc

ls_font 	= as_font_name
li_size	= 8	

iRet = uoFont.of_getoptfontsize(as_text, &
							ls_font, &
							li_size, &
							ab_Bold, &
							ab_Italic, &
							ab_Underline, &
							al_height, &
							al_width, &
							ab_wrap)


iRet = uoFont.of_gettextsize(as_text, &
							ls_font, &
							li_size, &
							ab_Bold, &
							ab_Italic, &
							ab_Underline, &
							al_height, &
							al_width)

Destroy(uoFont)

If iRet >= 0 Then
	If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_calc_font_size returns " + string(li_size))
	return li_size	
Else	
	return -1
End If
end function

public function integer of_delete_secondary_distribution (long al_result_key, long al_transaction);/*
* Objekt : uo_cart_diagram
* Methode: of_delete_secondary_distribution (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.10.2012
*
* Argument(e):
*	 long al_result_key
*	 long al_transaction
*
* Beschreibung:		Delete Secondary Distribution Results from Tables
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.10.2012		Erstellung
*
*
* Return: integer
*
*/

If al_Result_Key < 1 OR al_Transaction < 1 Then
	Return -1
End If

delete from cen_out_sd					where nresult_key = :al_result_key and ntransaction = :al_transaction;
delete from cen_out_sd_comp			where nresult_key = :al_result_key and ntransaction = :al_transaction;
delete from cen_out_sd_cart			where nresult_key = :al_result_key and ntransaction = :al_transaction;
delete from cen_out_sd_drawer		where nresult_key = :al_result_key and ntransaction = :al_transaction;
delete from cen_out_sd_content		where nresult_key = :al_result_key and ntransaction = :al_transaction;
delete from cen_out_sd_message		where nresult_key = :al_result_key and ntransaction = :al_transaction;
COMMIT;


Return 1
end function

public function long of_is_cartdiagram_enabled (long arg_l_index, string arg_s_client, string arg_s_unit, ref boolean rab_no_entry);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_cartdiagram_enabled (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 21.10.2009
* Argument(e):
* long arg_l_index
*
* Return: long
*
* Pr$$HEX1$$fc00$$ENDHEX$$fung ob Cartdiagram zugelassen ist
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  21.10.2009	1.0           Ulrich Paudler     Erstellung
*  18.10.2012	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       NAM-CR-12071 Funktion Master Data Preview
*  23.10.2012	1.2           Oliver H$$HEX1$$f600$$ENDHEX$$fer       NAM-CR-12033 Keine Allocation => trotzdem drucken
*  28.11.2012	1.3           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Bugfix: G$$HEX1$$fc00$$ENDHEX$$ltigkeit fehlte
*
*************************************************************/

Long	ll_Setting


If ib_enable_masterdata_view Then
	// NAM-CR-12071 Funktion Master Data Preview ON
	Return 1
End If 


// CBASE-NAM-CR-16008 Cart Diagram/ Transporter checkbox in Area Allocation doesn$$HEX1$$1920$$ENDHEX$$t need to be maintained
If ib_non_sky Then
	ll_Setting = 1
	Return ll_Setting
End If


rab_no_entry = FALSE

SELECT loc_unit_pl_areas.ncartdiagram  into :ll_Setting
    FROM LOC_UNIT_PL_AREAS,   
         LOC_UNIT_AREAS,   
         CEN_PACKINGLIST_INDEX,   
         LOC_UNIT_WORKSTATION  
   WHERE ( LOC_UNIT_PL_AREAS.NAREA_KEY = LOC_UNIT_AREAS.NAREA_KEY ) and  
         ( LOC_UNIT_PL_AREAS.NWORKSTATION_KEY = LOC_UNIT_WORKSTATION.NWORKSTATION_KEY ) and  
         ( LOC_UNIT_PL_AREAS.NPACKINGLIST_INDEX_KEY = CEN_PACKINGLIST_INDEX.NPACKINGLIST_INDEX_KEY ) and  
         ( ( loc_unit_pl_areas.npackinglist_index_key = :arg_l_index ) AND  
         ( loc_unit_pl_areas.cclient = :arg_s_client ) AND  
         ( loc_unit_pl_areas.cunit = :arg_s_unit ) )   AND 
			 loc_unit_pl_areas.ncartdiagram > 0 AND
       ( :idt_departure  between LOC_UNIT_PL_AREAS.dvalid_From and LOC_UNIT_PL_AREAS.dvalid_To)
       
			USING SQLCA;
			
If SQLCA.SQLCode = 0 Then
	// Found an entry
ElseIf SQLCA.SQLCode = 100 Then
	// 0 Rows => not allocated, but should be printed
	// 23.10.2012 NAM CR 12033 2.3 
	ll_Setting = 1
	rab_no_entry = TRUE
End If

If isnull(ll_Setting) then ll_Setting = 0 




return ll_Setting

end function

public function long of_print (string as_printer, boolean ab_preview);
//public function long of_print (string as_printer, boolean ab_preview);

/* 
* Funktion:			of_print
* Beschreibung: 	drucken
* Besonderheit: 	keine
*
* Argumente:
* 	as_Printer 					Drucker
* 	ab_Preview 					Schalter, ob Preview gewollt
*
*
* Aenderungshistorie:
* 	Version 		Wer				Wann				Was und warum
*	1.0 			M.N$$HEX1$$fc00$$ENDHEX$$ndel 		31.10.2012		Erstellung
*
* Return Codes:
*	anzahl gedruckte zeilen
*/

// hilfsvariable
long ll_Rowcount

// hilfsvariable preview
s_print_preview 	lstr_Preview
window 				lw_Print


// Drucklayout
of_print_init()

if isValid(oDw) Then
	of_modify_dw("r_frame.visible='0'")
	of_modify_dw("r_detail.visible='0'")
	oDw.Modify("datawindow.printer='" + as_Printer + "'")
	oDw.SetRedraw(false)

	// preview gewollt
	if ab_preview then
		oDW.GetFullState(lstr_Preview.bData)
		OpenSheetWithParm ( lw_Print, lstr_Preview , "w_report_preview" , w_mdi_master, 0, Original!)
	else
		oDw.print()
	end if

	oDw.SetRedraw(true)
	ll_Rowcount = oDw.Rowcount() 
End If

if isValid(oDs) Then
	of_modify_dw("r_frame.visible='0'")
	of_modify_dw("r_detail.visible='0'")
	oDs.Modify("datawindow.printer='" + as_Printer + "'")

	// preview gewollt
	if ab_Preview then
		oDs.GetFullState(lstr_Preview.bData)
		OpenSheetWithParm ( lw_Print, lstr_Preview , "w_report_preview" , w_mdi_master, 0, Original!)
	else
		oDs.print()
	end if

	ll_Rowcount = oDs.Rowcount() 
End If
	
// Anzeigelayout
of_print_deinit()

return ll_Rowcount
end function

public function long of_get_fixed_content_drawer (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_do_not_explode);
/*
* Objekt : uo_cart_diagram
* Methode: of_get_fixed_content_drawer (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 03.03.2011
*
* Argument(e):
*    long arg_llayoutdetailkey
*    long arg_icontent
*    long arg_irow
*    long arg_icolumn
*    long arg_ltype
*    string arg_cunit
*    long arg_start_pos
*    ref s_distrib_items astr_items[]
*
* Beschreibung:      Diagramm-Inhalte sammeln (benutzt von Create Distribution)
*
* Aenderungshistorie:
* Version 	Wer 						Wann 		Was und warum
* 1.0 			Oliver Hoefer 			03.03.2011 	Erstellung
* 1.1 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*
*
* Return: long
*
*/


Long         ll_Row 
Long         lContentIndexKey,  lContentDetailKey, llAdditionalYOffset
Long         llMaxContent
Integer      li_Explode_Setting
Long         ll_no_of_rungs
LOng         ll_Ancestor, ll_Found
Long         ll_Start_Row, ll_Temp
Integer      li_Succ
String      ls_Text
Long         ll_Explosion_Counter
Long         ll_Col_Counter
Long         ll_Item_Counter
String      ls_Qty_Object
String      ls_Qty
String      ls_Filter,  lsText , ls_HeaderText, ls_HeaderPLandText
Long         ll_Rows
Long         ll_Original_Content
Long         ll_Content_Row
Integer      li_Content_Setting
Long         ll_Current_Index
Boolean      lb_Current_PL_Is_Header
String      ls_Pl_to_Check_For_Header
s_component lstr_component
datastore lds_Temp
Long         ll_Tmp_Setting
s_distrib_items   lstr_Empty[]
Long         ll_Number_of_Contents = 0 


ll_Original_Content = arg_icontent
astr_items = lstr_Empty

if il_Disable_Debug=0 Then
   If ab_do_not_explode Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer BEGIN FUNCTION ab_do_not_explode=TRUE")
   Else
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer BEGIN FUNCTION ab_do_not_explode=FALSE")
   End If
End If

//If arg_ltype <> DRAWER_MULTI_RUNG  Then
//   // Falscher Typ
//   if il_Disable_Debug=0 Then
//      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer arg_ltype <> DRAWER_MULTI_RUNG")
//   End If
//   Return -1
//End If

if il_Disable_Debug=0 Then
   guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer layoutdetailkey=" + String(arg_lLayoutDetailKey)  + " arg_iContent=" + String(arg_iContent) + " column=" + &
               String(arg_icolumn) + " row=" + String(arg_irow) + " type=" + String(arg_ltype) + " unit=" + arg_cunit + " Startpos=" + String(arG_start_pos)  )
End If

// Content Typ
If IsNULL(arg_iContent) Then arg_iContent = DISTRIBUTION
If arg_iContent = 0  Then arg_iContent = DISTRIBUTION
li_Content_Setting = arg_iContent
this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()


if il_Disable_Debug=0 Then
   choose case arg_iContent
      case DISTRIBUTION
         guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content_drawer *** DISTRIBUTION")
      Case CONTENT
         guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content_drawer *** CONTENT")         
      CASE EXPLOSION
         guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content_drawer *** EXPLOSION")         
      CASE ELSE
         guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content_drawer *** UNKNOWN")         
   End Choose
End If

if this.dsLayoutContents.RowCount() = 0 Then
   If il_Disable_Debug = 0 Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer KEIN INHALT?")
   End If
   Return 0
End If

ll_Found = dsLayoutDetail.Find("ncolumn=" + string( arg_icolumn ) + " and nrow=" + string(arg_irow), 1, this.dsLayoutDetail.Rowcount())
If ll_Found > 0 Then
   ll_Ancestor = dsLayoutDetail.GetItemNumber(ll_Found, "nancestor")
   ll_Found = dsLayoutDetail.Find("ntype=" + String(DRAWER_MULTI_RUNG) + " and nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())         
   If ll_Found > 0 Then
      ll_no_of_rungs = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrungs")
//      ll_no_of_columns = this.dsLayoutDetail.Getitemnumber(ll_Found, "ncolumns")
   End If
End If
      
llMaxContent =  of_get_maxcontent(arg_irow, arg_icolumn) //2 + (ll_no_of_rungs - 1) * 3
//llMaxContentEx = 2 + (ll_no_of_rungs - 1) * 3 // iMaxRowsContentExplosion3Rung
llAdditionalYOffset = 50
If ll_Ancestor > 0 Then
   // Erste Row zu diesem Drawer 
   ll_Found = dsLayoutDetail.Find("nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())    
   If ll_Found > 0 Then
      ll_Start_Row = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrow")
      if il_Disable_Debug=0 Then
         guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer StartRow: " + String(ll_Start_Row))
      End If
   End If
Else
   if il_Disable_Debug=0 Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer ll_Ancestor=0")
   End If
End If   
      
ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
   ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
   if ll_Row <> this.dsLayoutContents.RowCount() Then
      ls_Filter += " or "
   End If
Next

If Trim(ls_Filter) = "" Then 
   Return 0
End If 

this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()
if il_Disable_Debug=0 Then
   guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer dsPLContents.rowcount(): " + String(dsPLContents.rowcount()) + " Filter " + ls_Filter)
End If

// -------------------------------------------------
// Explode setting: override or keep existing
// -------------------------------------------------
If il_IndexKey > 0 Then
   li_Explode_Setting = of_get_explosion_setting(il_IndexKey, arg_cunit)
   Choose Case li_Explode_Setting
      Case 1 
         arg_iContent = EXPLOSION
         guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content_drawer] "  +  this.isStowage +" - " + "EXPLODE "  + string(il_IndexKey) )
         if il_Disable_Debug=0 Then
            guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXPLODE "  + string(il_IndexKey))
         End If
      Case 0
         arg_iContent = CONTENT
          guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content_drawer] "  +  this.isStowage +" - " + "CONTENT "  + string(il_IndexKey) )
         if il_Disable_Debug=0 Then
            guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer CONTENT "  + string(il_IndexKey))
         End If
      Case -1
          guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content_drawer] "  +  this.isStowage +" - " + "use existing "  + string(il_IndexKey) + "  " + String(arg_iContent) )
         // NO CHANGE: keep existing setting
         if il_Disable_Debug=0 Then
            guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXISTING "  + string(il_IndexKey)+ "  " + String(arg_iContent))
         End If

   End Choose
Else
   if il_Disable_Debug=0 Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer il_IndexKey=0" )
   End If
End If

// ----------------------------------
// Content wird zu Explosion
// ----------------------------------
If arg_iContent = CONTENT Then
   li_Content_Setting = CONTENT //EXPLOSION
   if il_Disable_Debug=0 Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer arg_iContent = CONTENT => EXPLOSION " )
   End If

ElseIf arg_iContent = DISTRIBUTION Then
   li_Content_Setting = DISTRIBUTION   
   if il_Disable_Debug=0 Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer arg_iContent = DISTRIBUTION " )
   End If
End If

If li_Content_Setting = EXPLOSION Then
   // ----------------------------------------------------------
   // --- EXPLOSION aufbauen                                 ---
   // ----------------------------------------------------------
   ll_Item_Counter = 0
   
Else
//   sError = "Error: undefined content"
//   if il_Disable_Debug=0 Then
//      guoLog.uf_debug( "["+ this.classname( )+".Error: undefined content")
//   End If
//   return -1
End If

// ------------------------------------------------------------------------
// Texte neu eintragen
// Unterscheidung Content vs. Exploded Content vs. Verteilung ohne Content
// ------------------------------------------------------------------------

If il_Disable_Debug = 0 Then
   //guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXPLOSION/DISTRIBUTION")
   If dsPLContents.RowCount() > 0 Then
      //dsPLContents.saveas("c:\temp\cbase\of_get_fixed_content_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_dsPLContents.PSR", PSReport! , true)
   End If
End If

if dsPLContents.RowCount() < 1 AND arg_iContent <> DISTRIBUTION Then
   // Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden UND keine Verteilung
   If il_Disable_Debug = 0 Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer dsPLContents.RowCount() < 1 AND arg_iContent <> DISTRIBUTION")
   End If
   li_succ = -9999
//   End If   
   

//Elseif arg_iContent = EXPLOSION Then // Explosion Layout
Elseif li_Content_Setting = EXPLOSION OR li_Content_Setting = CONTENT OR li_Content_Setting = DISTRIBUTION Then // Explosion Layout   
   // -------------------------------------------------
   // --- EXPLOSION                                 ---
   // -------------------------------------------------
   If il_Disable_Debug = 0 Then
      guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXPLOSION/DISTRIBUTIONCONTENT")
   End If
   // -------------------------------------------------
   // wenn das Objekt die Order Nummer ist: f$$HEX1$$fc00$$ENDHEX$$llen
   // -------------------------------------------------
   // ------------------------------------------------------------------------------------------------------------
   // Ab hier:      Header + Inhalt
   // ------------------------------------------------------------------------------------------------------------
   lds_Temp = create datastore
   lds_Temp.dataobject = "dw_packinglist_edit_content"
   lds_Temp.SetTransObject(sqlca)

   ll_Explosion_Counter = arg_start_pos - 1 

//   ll_Content_Row = 1
   For ll_Content_Row = 1 To dsPLContents.RowCount()
      ll_Number_of_Contents += 1
      
      lContentIndexKey      = this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
      lContentDetailKey      = this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")
   
      ll_Rows = lds_Temp.Retrieve(lContentIndexKey, lContentDetailKey, datetime(idt_Departure), 0)
      
      If li_Content_Setting <> EXPLOSION then
         lds_Temp.reset()
      end if
      
      lds_Temp.SetSort("nsort a")
      lds_Temp.Sort()
             
//      // ------------------------------------------------------------------------------------------------------------
//      // Wenn Header St$$HEX1$$fc00$$ENDHEX$$ckliste im Einschub vorhanden => nicht EXPLODE
//      // ------------------------------------------------------------------------------------------------------------
//      If ab_do_not_explode Then
//         lds_Temp.Reset()
//      End If

   
      // ------------------------------------------------------------------------------------------------------------
      // Wenn Header vorhanden und aktuelle St$$HEX1$$fc00$$ENDHEX$$ckliste <> Header => nicht EXPLODE
      // ------------------------------------------------------------------------------------------------------------
      If ab_do_not_explode Then
         lb_Current_PL_Is_Header = FALSE
         ls_Pl_to_Check_For_Header = f_get_packinglist( lContentIndexKey)
         lb_Current_PL_Is_Header = of_is_content_sheet_header( arg_llayoutdetailkey , ls_Pl_to_Check_For_Header )
         If NOT lb_Current_PL_Is_Header  Then
            lds_Temp.Reset()
            If il_Disable_Debug=0 Then
               guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer SUPPRESS (Not a Header): " + ls_Pl_to_Check_For_Header)
            End If
         Else
            If il_Disable_Debug=0 Then
               guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer SUPPRESS (PL IS Header): " + ls_Pl_to_Check_For_Header)
            End If
            
         End If
      End If
   
      ll_Explosion_Counter++

      lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
      lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
      lstr_component.squantity   = ""
      ls_HeaderText =  of_get_item_description(lstr_component)
      ls_HeaderPLandText = lstr_component.ssnr + " - "  + lstr_component.stext
      // ######################################################################
      ll_Current_Index = upperbound(astr_items) + 1
      astr_items[ll_Current_Index].sitem = ls_HeaderText
      
      astr_items[ll_Current_Index].cpackinglist   = lstr_component.ssnr
      astr_items[ll_Current_Index].ctext         = lstr_component.stext
            
      If ll_Original_Content = CONTENT Then      
         astr_items[ll_Current_Index].bcontent = TRUE
      End If
      
      If lb_Current_PL_Is_Header Then
         astr_items[ll_Current_Index].bbold = TRUE
         If il_Disable_Debug=0 Then
            guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer lb_Current_PL_Is_Header BOLD " + ls_HeaderText)
         End If
      End If

      // ------------------------------------------------------------------------------------------------------------
      // wenn keine Header PL vorhanden: Explosion Top BOLD 
      // ------------------------------------------------------------------------------------------------------------
      If ll_Original_Content = EXPLOSION AND ab_do_not_explode = FALSE Then   
         astr_items[ll_Current_Index].bbold = TRUE
         if il_Disable_Debug=0 Then
            guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer ll_Original_Content=EXPLOSION AND NO HEADER bbold=TRUE " + ls_HeaderText)
         End If
      End If
               
      astr_items[ll_Current_Index].lcount = this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")
      if il_Disable_Debug=0 Then
         guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer ls_HeaderText " + ls_HeaderText)
      End If
      // ######################################################################
      
      // ------------------------------------------------------------------------------------------------------------
      // wenn f$$HEX1$$fc00$$ENDHEX$$r die St$$HEX1$$fc00$$ENDHEX$$ckliste in Area Allocation "suppress" eingestellt ist: keine Inhalte zeigen
      // ------------------------------------------------------------------------------------------------------------
//      If of_explode( lContentIndexKey, arg_cunit, li_Explode_Setting, arg_icontent ) = FALSE Then
//         If il_Disable_Debug=0 Then
//            guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer SUPPRESS " + lstr_component.ssnr)
//         End If
//         CONTINUE
//      Else
//         If arg_icontent = content Then
//            If il_Disable_Debug=0 Then
//               guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer Parent = CONTENT => EXPLODE " + lstr_component.ssnr)
//            End If
//         End If
//      End If
      ll_Tmp_Setting = of_get_explosion_setting(lContentIndexKey, arg_cunit)
      Choose Case ll_Tmp_Setting
         Case 1 
            if il_Disable_Debug=0 Then
               guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXPLODE "  + string(lContentIndexKey) + " / " + lstr_component.ssnr)
            End If
         Case 0
            lds_Temp.Reset()
            if il_Disable_Debug=0 Then
               guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer SUPPRESS "  + string(lContentIndexKey) + " / " + lstr_component.ssnr)
            End If
         Case -1
            // NO CHANGE: keep existing setting
            if il_Disable_Debug=0 Then
               guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXISTING "  + string(lContentIndexKey)+  + " / " + lstr_component.ssnr +"  " + String(arg_iContent))
            End If
            If ll_Original_Content = CONTENT Then
               lds_Temp.Reset()
               if il_Disable_Debug=0 Then
                  guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXISTING=CONTENT "  + lstr_component.ssnr +" lds_Temp.RowCount() " + String(lds_Temp.RowCOunt()))
               End If
            Else
               if il_Disable_Debug=0 Then
                  guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer EXISTING<>CONTENT "  + lstr_component.ssnr +" lds_Temp.RowCount() " + String(lds_Temp.RowCOunt()))
               End If
            End If
            
      End Choose

      
      for ll_Row = 1 to lds_Temp.RowCount()
         //ll_Explosion_Counter++
         lstr_component.stext =lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
         lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
         lstr_component.squantity = String(lds_Temp.GetItemNumber(ll_Row, "nquantity")) 
         lsText = of_get_item_description(lstr_component)

         ll_Current_Index = upperbound(astr_items) + 1
         //astr_items[ll_Current_Index].sitem = ls_Qty + lsText
         astr_items[ll_Current_Index].sitem = lsText
         
         astr_items[ll_Current_Index].cpackinglist   = lstr_component.ssnr
         astr_items[ll_Current_Index].ctext         = lstr_component.stext
         
         astr_items[ll_Current_Index].lcount = lds_Temp.GetItemNumber(ll_Row, "nquantity")
         
         // Parent merken
         astr_items[ll_Current_Index].sparent = ls_HeaderPLandText //ls_HeaderText
         
         if il_Disable_Debug=0 Then
            guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer CONTENT " + lstr_component.squantity + " / " + lstr_component.ssnr + " / " + lstr_component.stext)
         End If
      Next
   Next

End If

if il_Disable_Debug=0 Then
   guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content_drawer END FUNCTION" )
End If

//if il_Disable_Debug=0 Then
//   If isvalid(ods) then
//      ods.saveas("c:\temp\cbase\of_get_fixed_content_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_CART_.PSR", PSReport! , true)
//   end if
//End If

if IsValid(lds_Temp) then destroy lds_Temp

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

Return ll_Number_of_Contents

end function

public function boolean of_check_explode (long al_index_key, string as_unit);/*
* Objekt : uo_cart_diagram
* Methode: of_check_explode (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 07.11.2012
*
* Argument(e):
*	 long			al_index_key		St$$HEX1$$fc00$$ENDHEX$$ckliste
*	 string		as_unit				Betrieb
*
* Beschreibung:		Area Allocation: Explosion ein oder aus?
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	07.11.2012		Erstellung
*
*
* Return: boolean
*
*/


Boolean	lb_return = FALSE
Integer	li_Explode_Setting
String	ls_PL


ls_PL = f_get_packinglist( al_index_key )

// -------------------------------------------------
// Explode setting: ON / OFF
// -------------------------------------------------
If al_Index_Key > 0 Then
	li_Explode_Setting = of_get_explosion_setting(al_Index_Key, as_unit)
	Choose Case li_Explode_Setting
		Case 1 
			lb_return = FALSE
			 guoLog.uf_debug("["+ this.classname( )+".of_check_explode] "  +  this.isStowage +" - " + "EXPLODE (area allocation) "  + ls_PL) // string(al_Index_Key) )
			if il_Disable_Debug= 0 or s_app.itrace > 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_explode: EXPLODE (area allocation) "  + ls_PL)
			End If

		Case 0
			lb_return = TRUE
			guoLog.uf_debug("["+ this.classname( )+".of_check_explode] "  +  this.isStowage +" - " + "SUPPRESS (area allocation) " + ls_PL) // string(al_Index_Key) )
			if il_Disable_Debug= 0 or s_app.itrace > 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_explode: SUPPRESS (area allocation) " + ls_PL)
			End If
		Case -1
			lb_return = FALSE
			if il_Disable_Debug= 0 or s_app.itrace > 0 then
				guoLog.uf_debug( "["+ this.classname( )+".of_explode: DEFAULT (area allocation) "  + ls_PL)
			End If
	End Choose
End If

Return lb_return

end function

public function boolean of_check_workstation_exclude (long al_workstation_key, long al_airline_key);/*
* Objekt : uo_cart_diagram
* Methode: check_workstation_exclude (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 24.10.2012
*
* Argument(e):
* long al_workstation_key
* long al_airline_key
*
* Beschreibung:		Check Workstation Exclusion Flag (loc_unit_workstation.nexclude_diagram)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	24.10.2012		Erstellung
* 1.1 			O.Hoefer	07.11.2012		Deaktiviert wegen Konzept$$HEX1$$e400$$ENDHEX$$nderung
* 1.2				K.Winckler	08.11.2012		CBASE-NAM-CR-12033 (Druckausschluesse nach Airline-Workstation Kombi)
*
* Return: boolean
*
*/

Boolean	lb_Return = FALSE
Long		ll_Exclude

// ########  ToDo: Anpassung "per Airline" #############
//SELECT	nexclude_diagram  
//INTO		:ll_Exclude
//FROM		loc_unit_workstation  
//WHERE		nworkstation_key = :al_Workstation_key   ;
//

// The New One:
SELECT	1 
INTO 		:ll_Exclude 
FROM 	loc_print_exclusion  
WHERE 	nworkstation_key = :al_Workstation_key  
AND 		nairline_key = :al_airline_key	;

IF SQLCA.SQLCode = 0 Then
	If ll_Exclude = 1 Then
		lb_Return = TRUE
	End If
End If


Return lb_Return

end function

public function long of_adjust_text_size_small_big (string arg_s_object[], long arg_l_height_factor);/*
* Objekt : uo_cart_diagram
* Methode: of_adjust_text_size_small_big (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.11.2012
*
* Argument(e):
* string arg_s_object[]
*	 long arg_l_height_factor
*
* Beschreibung:		angepasste Kopie von of_adjust_text_size wgeen neuer Anforderung
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.11.2012		Erstellung
* 1.1 			O.Hoefer	27.11.2012		Hinzu: ALIGN_CENTER
*
*
* Return: long
*
*/


boolean	lb_Bold, lb_Italic
integer	li_Calc_Size, li_Weight, li_Italic
Long		ll_counter
Integer	li_H
String	ls_Font_Name
String	ls_Text

/* 
Neue Anforderung: 

Instead of scaling the text the request is to only have 2 sizes a max and a min.
If a text has up to 20 Char then it will have the max size (defined below). 
Any text with more than 20 char will then have the current font size (bold if header as currently the case)

Max Font 0-20 CHAR (Font Size = 12 and Bold)
Min Font > 20 CHAR (Font Size = standard as is currently printed today)
Min Font = Microsoft Sans Serif, Font Size 8, Normal
*/

for ll_counter = 1 to upperbound(arg_s_object)
	ls_Text = trim(of_describe( arg_s_object[ll_counter] + ".text",FALSE))
	
	If Len(ls_Text) > 20 Then
		// no change(Min Font > 20 CHAR)
		continue 
	end if
		
	if len (ls_Text) < 1  or ls_Text = "!" or ls_Text = "???" then
		// no valid content or no valid object
		continue 
	end if

	ls_Font_Name = of_describe( arg_s_object[ll_counter] + ".font.face",FALSE)
	
	li_Weight = integer(of_describe( arg_s_object[ll_counter] + ".font.weight", FALSE))
	li_Italic = integer(of_describe( arg_s_object[ll_counter] + ".font.italic", FALSE))

	if li_Weight > FONT_NORMAL then	
		lb_Bold		= TRUE
	else
		lb_Bold		= FALSE
	end if
	if li_Italic > 0 then				lb_Italic	= TRUE

	// Zeil-H$$HEX1$$f600$$ENDHEX$$he: Ist-H$$HEX1$$f600$$ENDHEX$$he x 2 
	li_H = Integer(dec(of_describe( arg_s_object[ll_counter] + ".height",FALSE)) * 2)

	// -----------------------------------------------
	//guoLog.uf_debug( "["+ this.classname( )+".of_adjust_text_size_small_big " + ls_Text)
	// -----------------------------------------------
	// Gr$$HEX2$$f600df00$$ENDHEX$$e fest auf 12
	li_Calc_Size = 12 //of_calc_font_size(ls_Text, li_H, li_W, ls_Font_Name, lb_Bold, lb_Italic, FALSE, FALSE)
	//lb_Bold = TRUE

	// do not reduce font size
	If li_Calc_Size > abs(long(of_describe(arg_s_object[ll_counter] + ".font.height",FALSE)))  Then
		guoLog.uf_debug( "["+ this.classname( )+".of_adjust_text_size_small_big (" + arg_s_object[ll_counter] + ') "' + ls_Text + '" => ' + ls_Font_Name +"FONT SIZE " + String(li_Calc_Size) )
		of_modify_dw(arg_s_object[ll_counter] + ".font.face='" + ls_Font_Name + "'")
		of_modify_dw(arg_s_object[ll_counter] + ".font.height='-"+String(li_Calc_Size)+ "'")
		of_modify_dw(arg_s_object[ll_counter] + ".height='" + String (li_H) + "'")
		
//		If il_Disable_Debug = 0 and s_app.itrace > 0 then
//			of_modify_dw(arg_s_object[ll_counter] + ".Color='" + String(rgb(0,0,255)) + "'" )
//		else
			of_modify_dw(arg_s_object[ll_counter] + ".Color='" + String(rgb(0,0,0)) + "'" )	
//		end If

		If lb_Bold Then
			If of_check_center_setting() Then
				of_modify_dw(arg_s_object[ll_counter] + ".alignment='" + String(ALIGN_CENTER) + "'" )
				guoLog.uf_debug( "["+ this.classname( )+".of_adjust_text_size_small_big (" + arg_s_object[ll_counter] + ') "' + ls_Text + '" => CENTERED' )
				//ls_Error = oDw.modify(sObjects[i] + ".alignment='" + String(ALIGN_CENTER) + "'")
			Else
				guoLog.uf_debug( "["+ this.classname( )+".of_adjust_text_size_small_big (" + arg_s_object[ll_counter] + ') "' + ls_Text + '" BOLD => SETTINGS: NOT CENTERED' )
			End If
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_adjust_text_size_small_big (" + arg_s_object[ll_counter] + ') "' + ls_Text + '" NOT BOLD => NOT CENTERED' )
		End If
		
	End If
next

return 0
end function

public function integer of_sd_draw_comp_multi (long al_row, long al_column, string arg_unit, long al_master_row_id);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_draw_comp_multi (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 27.08.2012
*
* Argument(e):
* long al_row
*	 long al_column
*	 string arg_unit
*
* Beschreibung:		Draw distributed contents (Multi Rung)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	27.08.2012		Erstellung - ausgelagert aus SD Draw Distributed Components
* 1.1 			O.Hoefer	18.09.2012		Content Sheet Indicator CR NAM 12008
* 1.2 			U.Paudler19.09.2012		Adjust Textsize CR NAM 12035
* 1.3 			O.Hoefer	25.10.2012		Erg$$HEX1$$e400$$ENDHEX$$nzung Adjust Textsize CR NAM 12035
* 1.4 			O.Hoefer	22.11.2012		ge$$HEX1$$e400$$ENDHEX$$nderte Anforderung Textsize => 2 feste Stufen: normal/gross
* 1.5 			O.Hoefer	16.01.2013		Overflow Bugfix
* 1.6 			O.Hoefer	06.03.2013		Overflow again
* 1.7 			O.Hoefer	20.01.2014		WATERMARK check auch f$$HEX1$$fc00$$ENDHEX$$r nicht angezeigte Positionen
*
*
* Return: integer
*
*/

Boolean	lb_Header_Exists
Boolean	lb_Watermark_Downline
Boolean	lb_Suppress_Watermark_Downline
Boolean	lb_Content_Spec_PL     = FALSE
Boolean	lb_Content_Spec_Drawer = FALSE
Boolean	lb_Overflow            = FALSE
Boolean	lb_Breakpoint
Boolean	lb_Backlog_Switch
Integer	li_Succ
Integer	li_mod
Decimal	ldec_Qty
Long		ll_rungs, ll_Cols
Long		ll_MaxContent
Long		ll_Index
Long		ll_Xpos
Long		ll_leg_from_ccode
Long		ll_index_key
Long		ll_layoutdetailkey
Long		ll_Found
Long		ll_Content
Long		ll_Number_of_Distr_Comp
Long		ll_Number_of_Fixed_Content
Long		ll_Drawer_Explode_Setting
String	ls_Parent_Text 
Long		ll_Parent_Qty
String	ls_Parent_PL
String	ls_dwobject, ls_Alternative_Object
String	ls_header
String	ls_temp
String	ls_MSG
String	ls_Computed_Item
String	ls_Backlog_Text
String	ls_Parent_Backlog	
String	ls_Header_PL, ls_CS_Header_PL
s_distrib_items	lstr_item[], lstr_item_empty[], lstr_temp[]
s_distrib_items	lstr_item_fixed[]
s_component	lstr_component_x


// #### TEMP SETTING DEBUG ####
//il_Disable_Debug = 0
// #### TEMP SETTING DEBUG ####

If s_app.itrace >0 then
	il_Disable_Debug = 0
end if


lb_Backlog_Switch = of_is_backlog_enabled()

// ----------------------------------------------------------------------------
// DRAWER_MULTI_RUNG: Aufgabe: feste Inhalte VOR DISTRIBUTED CONTENT sortieren
// ----------------------------------------------------------------------------
lb_Header_Exists = of_exists_content_sheet_header(al_Column, al_Row)
// Abmessungen
li_Succ = of_get_rungs_and_cols( al_Row, al_Column, ll_rungs, ll_Cols )

// ----------------------------------------------------------------------------
// Check Content Spec f$$HEX1$$fc00$$ENDHEX$$r Drawer
// ----------------------------------------------------------------------------
If NOT ib_Disable_Content_Spec_MSG  Then
	// --------------------------------------------------------------------------------------
	// Content Sheet Indicator
	// --------------------------------------------------------------------------------------				
	lstr_item = lstr_item_empty
	ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
	if ll_Found > 0 Then
		ll_Content			= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
		ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
		li_Succ = of_get_fixed_content(ll_layoutdetailkey, ll_Content, al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, FALSE)
		ll_Number_of_Fixed_Content = upperbound(lstr_item) 
		lstr_item_fixed = lstr_item

		for ll_Index = 1 to upperbound(lstr_item) 
				If ll_Index = 1 Then
					ls_Parent_PL = lstr_item[ll_Index].cpackinglist
					ls_Parent_Text = lstr_item[ll_Index].ctext
					ll_Parent_Qty = lstr_item[ll_Index].lcount
				End If

			If trim(lstr_item[ll_Index].cpackinglist) > "" Then
				ll_index_key = f_get_packinglist_key(lstr_item[ll_Index].cpackinglist)
				If ll_index = 1 Then
					lb_Content_Spec_PL = of_is_content_spec_enabled(ll_index_key , is_CSC, idt_departure )
					If lb_Content_Spec_PL AND lb_Header_Exists Then
						If ll_Index = 1 Then
							lb_Content_Spec_Drawer = TRUE	
							ls_CS_Header_PL = lstr_item[ll_Index].cpackinglist
						End If
					End If
					If ll_Index = 1 Then
						If lb_Content_Spec_PL = FALSE AND ib_Non_sky = TRUE AND lb_Header_Exists = TRUE then
							if lstr_item[ll_Index].bbold  = TRUE AND lstr_item[ll_Index].bdistributed = FALSE Then
								lb_Content_Spec_Drawer = TRUE	
								ls_CS_Header_PL = ls_Parent_PL
								
								ls_parent_text = lstr_item[ll_Index].sitem
								
								li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL  , ls_parent_text, 1  ,al_row, al_column, TRUE )
								
//								of_sd_add_content_sheet_header( /*string arg_s_carttype*/, /*string arg_unit*/, /*uo_content_sheet rauo_content_sheet*/, al_ma , /*datastore rads_distribution_contents */)
								
								//if ls_CS_Header_PL = ls_Parent_PL then
								//	li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL  , ls_parent_text, 1  ,al_row, al_column, TRUE )
//								Else
//									li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL  , ls_parent_text, 1  ,al_row, al_column, FALSE )
//								end if
								
							End If
						End If
					End If
				End if
			End if
		Next
	End if
End if

ll_MaxContent = of_get_maxcontent(al_Row, al_Column)
If il_Disable_Debug = 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DRAWER_MULTI_RUNG Maxcontent=" +  String(ll_MaxContent) + " Col: "+ String(al_Column) + " Row: " + String(al_Row))
End If
lstr_item = lstr_item_empty
lstr_temp = lstr_item_empty
//				// --------------------------------------------------------------------------
//				// Verteilter Content nach Content Sheet dsLoadingContents 
//				// --------------------------------------------------------------------------
//				li_Succ = of_distr_content_4_contentsheet( rads_distribution_contents, uoCartDistribution, al_Row, al_Column, al_content_master_row_id)
//				// --------------------------------------------------------------------------
//				// Ende Verteilter Content nach Content Sheet dsLoadingContents 
//				// --------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// Daten aus DataStore Drawer Contents bef$$HEX1$$fc00$$ENDHEX$$llen			
// --------------------------------------------------------------------------------------				
lstr_item = lstr_item_empty
li_Succ = of_sd_get_distr_content(al_Column, al_Row, lstr_item)
ll_Number_of_Distr_Comp = upperbound(lstr_item)

if ll_Number_of_Distr_Comp = 0 then
	lstr_item = lstr_item_fixed
End if

for ll_Index = 1 to upperbound(lstr_item) //ll_MaxContent
	
	If ll_Index = 1 Then
		ls_Parent_PL = lstr_item[ll_Index].cpackinglist
		ls_Parent_Text = lstr_item[ll_Index].ctext
		ll_Parent_Qty = lstr_item[ll_Index].lcount
	End If
	
	// ################################################################
	If lstr_item[ll_Index].bcontent = FALSE AND lstr_item[ll_Index].bdistributed = TRUE Then
		ls_Parent_PL = lstr_item[ll_Index].cpackinglist
		ls_Parent_Text = lstr_item[ll_Index].ctext
		ll_Parent_Qty = lstr_item[ll_Index].lcount		
	End If
	
	
	If il_Disable_Debug = 0 Then
		If lstr_item[ll_Index].bdistributed = TRUE Then
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi GESAMTER CONTENT bdistributed=TRUE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi GESAMTER CONTENT bdistributed=FALSE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
		End if
	End If
	If il_Disable_Debug = 0 Then
		If lstr_item[ll_Index].bbold = TRUE Then
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi GESAMTER CONTENT bbold=TRUE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi GESAMTER CONTENT bbold=FALSE " + String(ll_Index) + " " + lstr_item[ll_Index].sitem )
		End if
	End If

//	If (ll_Index < ll_MaxContent OR (ll_Index = ll_MaxContent AND ll_MaxContent = upperbound(lstr_item) AND NOT lb_Content_Spec_Drawer) OR &
//						(ll_Index = ll_MaxContent AND NOT lb_Backlog_Switch AND NOT lb_Content_Spec_Drawer)) Then					
	If (ll_Index < ll_MaxContent OR &
		(ll_Index = ll_MaxContent AND ll_Index = upperbound(lstr_item) AND NOT lb_Content_Spec_Drawer) OR &
		(ll_Index = ll_MaxContent AND NOT lb_Backlog_Switch AND NOT lb_Content_Spec_Drawer) OR &
		(ll_Index = ll_MaxContent AND ll_Index = upperbound(lstr_item) AND lb_Backlog_Switch AND NOT lb_Content_Spec_Drawer)) Then
		
		ls_DWObject = "t_content_std_text_" + string(ll_Index, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		ls_Alternative_Object = "t_content_text_"  + string(ll_Index,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		If lstr_item[ll_Index].bbold = TRUE Then
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi lstr_item[ll_Index].bbold = TRUE " + lstr_item[ll_Index].sitem )
			End If
			of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, TRUE, FALSE)
		else
			of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, FALSE, FALSE)
		End If
		
		If ll_Index = 1 AND ll_Number_of_Distr_Comp = 1 Then
			of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, TRUE, FALSE)
		End If
		
		of_modify_dw(ls_DWObject + '.x="' + String(lXOffset + ((al_Column -1) * lDefaultWidth) + 14) +  '"')
		of_modify_dw(ls_Alternative_Object + '.x="' + String(lXOffset + ((al_Column -1) * lDefaultWidth) + 14) +  '"')
		// Spalte zwei belegen? 
		If ll_Cols > 1 AND ll_Index > (ll_MaxContent / 2) Then
			ls_DWObject					= "t_content_std_text_" + string(ll_Index - Integer(ll_MaxContent / 2), "00") + "_col_02_row_" + string(al_Row, "00")					
			ls_Alternative_Object	= "t_content_text_"     + string(ll_Index - Integer(ll_MaxContent / 2),  "0") + "_col_02_row_" + string(al_Row, "00")					
			of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, FALSE, FALSE)
			of_modify_text("t_content_quantity_" + string(ll_Index, "0") + "_col_02_row_" + string(al_Row, "00"), "")
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components SPALTE 2: BLANK " + "t_content_quantity_" + string(ll_Index, "0") + "_col_02_row_" + string(al_Row, "00"))
			of_modify_text("t_content_quantity_" + string(ll_Index - Integer(ll_MaxContent / 2), "0") + "_col_02_row_" + string(al_Row, "00"), "")
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components SPALTE 2: BLANK " + "t_content_quantity_" + string(ll_Index - Integer(ll_MaxContent / 2), "0") + "_col_02_row_" + string(al_Row, "00"))
			
			ll_Xpos = Long(of_describe(ls_DWObject + ".x" , FALSE))
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi XPOS " + ls_DWObject + ": " + String(ll_Xpos))
			End If
			If ll_Xpos > 0 Then
				of_modify_dw(ls_DWObject + ".x=" + String( ll_Xpos - 24 ))
			End If
			ll_Xpos = Long(of_describe(ls_Alternative_Object + ".x" , FALSE))
			If il_Disable_Debug = 0 Then 	guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi XPOS " + ls_Alternative_Object + ": " + String(ll_Xpos))
			If ll_Xpos > 0 Then
				of_modify_dw(ls_Alternative_Object + ".x=" + String( ll_Xpos - 24 ))
			End If
		End If
		
		// Distr. Content Top BOLD
		If lb_Header_Exists = FALSE Then
			If lstr_item[ll_Index].bdistributed = TRUE AND lstr_item[ll_Index].bbold = TRUE Then
				of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, TRUE, FALSE)
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi MULTIRUNG lb_Header_Exists=FALSE " + ls_DWObject + ".bbold & bdistributed= TRUE")
			End If
			// Kein Header vorhanden - Distr. Content
			If lstr_item[ll_Index].bdistributed = TRUE AND lstr_item[ll_Index].bbold = FALSE Then
				of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, TRUE, FALSE)
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi MULTIRUNG lb_Header_Exists=FALSE " + ls_DWObject + ".bbold=FALSE & bdistributed= TRUE")
			End If
		Else
			// Header vorhanden
			If lstr_item[ll_Index].bbold = TRUE Then
				of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, TRUE, FALSE)
				if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi MULTIRUNG lb_Header_Exists=TRUE " + ls_DWObject + ".bbold = TRUE")
			End If
		End If
		
		ls_temp = of_describe(ls_DWObject + ".text", FALSE)
		If Pos(ls_temp, "!") > 0 OR Pos(Upper(ls_temp), "INCORRECT") > 0 Then
			ls_temp = of_describe(ls_Alternative_Object + ".text", FALSE)
			If Pos(ls_temp, "!") > 0 OR Pos(Upper(ls_temp), "INCORRECT") > 0 Then
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi of_describe ERROR " + ls_Alternative_Object + ": " + ls_temp)
			End If
		End If
		
		if ll_Index <= upperbound(lstr_item) Then
			if lstr_item[ll_Index].lcount = 0 Then
				if lstr_item[ll_Index].sitem = ""  Then
					ls_Temp = ""				
				Else									
					ls_Temp = " "
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi lstr_item[ll_Index].lcount=0 " + lstr_item[ll_Index].sitem )
				End If
			Elseif lstr_item[ll_Index].lcount > 0 Then								
				lstr_component_x.ssnr = lstr_item[ll_Index].cpackinglist
				lstr_component_x.stext = lstr_item[ll_Index].ctext
				lstr_component_x.squantity = String(lstr_item[ll_Index].lcount)
				If lstr_component_x.squantity = "0" Then lstr_component_x.squantity =""
				ls_Computed_Item = of_get_item_description( lstr_component_x )
				
				If lstr_item[ll_Index].bdistributed = FALSE Then
					If lstr_item[ll_Index].bcontent = TRUE Then
						ls_Computed_Item = of_get_item_description( lstr_component_x, TRUE )
					else
						//ls_Parent_PL = lstr_component_x.ssnr
						//ls_parent_Text = lstr_component_x.stext
						//ll_parent_Qty = integer(lstr_component_x.squantity)
					End If
				End If
				
				If pos(ls_Computed_Item, "'")  > 0 then
					li_Mod = f_replace_string(ls_Computed_Item, "'", "~~~'")
				End If
				if upperbound(lstr_item) > 1 and ll_Index > 1 then
					ls_Temp = "  " + ls_Computed_Item
				else
					ls_Temp = ls_Computed_Item
				end if
			Else
				ls_Temp = lstr_item[ll_Index].sitem 
			End If
		Else
			ls_Temp = "???"
		End If
	
		of_modify_text(ls_DWObject, ls_Temp)
		of_modify_text(ls_Alternative_Object, ls_Temp)
		
		If lstr_item[ll_Index].bbold = TRUE Then
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi lstr_item[ll_Index].bbold = TRUE " + lstr_item[ll_Index].sitem )
			of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, TRUE, FALSE)
		End If
		If ll_Index = 1 AND ll_Number_of_Distr_Comp = 1 Then
			of_adjust_font({ls_DWObject, ls_Alternative_Object}, 8, TRUE, FALSE)
		End If
		
		If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_modify " + ls_Temp )
		
		//U.Paudler19.09.2012 Hier pr$$HEX1$$fc00$$ENDHEX$$fen of der Eintrag der einzige ist
		if (ll_Number_of_Distr_Comp = 1 AND ll_Number_of_Fixed_Content = 0) OR &
			(ll_Number_of_Distr_Comp = 0 AND ll_Number_of_Fixed_Content = 1) then
		
			// check "Suppress" lstr_component_x.ssnr
			ll_index_key = f_get_packinglist_key(lstr_component_x.ssnr)
			If of_check_explode(ll_index_key, arg_unit) Then
				of_adjust_text_size_small_big({ls_DWObject, ls_Alternative_Object}, ll_MaxContent)
				li_Succ = of_vertical_center_text_within_drawer( {ls_DWObject, ls_Alternative_Object}, al_column, al_row)
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi of_adjust_text_size_small_big SUPPRESS=TRUE" + " Col: "+ String(al_Column) + " Row: " + String(al_Row))
			End If
			
			If lb_Header_Exists Then
				of_adjust_text_size_small_big({ls_DWObject, ls_Alternative_Object}, ll_MaxContent)
				li_Succ = of_vertical_center_text_within_drawer( {ls_DWObject, ls_Alternative_Object}, al_column, al_row)
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi of_adjust_text_size_small_big lb_Header_Exists=TRUE" + " Col: "+ String(al_Column) + " Row: " + String(al_Row))
			End If
		end if
		
		ll_leg_from_ccode = lstr_item[ll_Index].lleg
		If NOT IsNULL(ll_leg_from_ccode) Then
			If ll_leg_from_ccode > 1 Then
				If Trim(lstr_item[ll_Index].sitem) > "" Then
					lb_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG FROM DIST " + String(ll_leg_from_ccode))
				End If
			Else
				If Trim(lstr_item[ll_Index].sitem) > ""  AND lstr_item[ll_Index].lcount > 0 Then
					lb_Suppress_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
				End If
			End If
		Else
			If Trim(lstr_item[ll_Index].sitem) > ""  AND lstr_item[ll_Index].lcount > 0 Then
				lb_Suppress_Watermark_Downline = TRUE
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If	
		If il_Disable_Debug = 0 Then
			If lb_Watermark_Downline Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Watermark_Downline=TRUE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			Else
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Watermark_Downline=FALSE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If
	Else
		// ########################################################
		// WATERMARK check auch f$$HEX1$$fc00$$ENDHEX$$r nicht angezeigte Positionen
		// ########################################################
		
		ll_leg_from_ccode = lstr_item[ll_Index].lleg
		If NOT IsNULL(ll_leg_from_ccode) Then
			If ll_leg_from_ccode > 1 Then
				If Trim(lstr_item[ll_Index].sitem) > "" Then
					lb_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG FROM DIST " + String(ll_leg_from_ccode))
				End If
			Else
				If Trim(lstr_item[ll_Index].sitem) > ""  AND lstr_item[ll_Index].lcount > 0 Then
					lb_Suppress_Watermark_Downline = TRUE
					If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
				End If
			End If
		Else
			If Trim(lstr_item[ll_Index].sitem) > ""  AND lstr_item[ll_Index].lcount > 0 Then
				lb_Suppress_Watermark_Downline = TRUE
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Suppress_Watermark_Downline " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If	
		If il_Disable_Debug = 0 Then
			If lb_Watermark_Downline Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Watermark_Downline=TRUE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			Else
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi DOWNLINE LEG lb_Watermark_Downline=FALSE " + String(ll_leg_from_ccode) +" / "+ lstr_item[ll_Index].sitem)
			End If
		End If
		// ########################################################
		
		If lb_Backlog_Switch Then
			lb_Overflow = TRUE
		End If
		// BACKLOG
		If il_Disable_Debug = 0 Then
			If Trim(lstr_item[ll_Index].sitem) > "" Then
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi ll_Index " + String(ll_Index) + " < ll_MaxContent " + String(ll_MaxContent) + " SEE BACKLOG...")
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi BACKLOG " + lstr_item[ll_Index].sitem )
			End If
		End If
		
		ls_DWObject = "t_content_std_text_" + string(ll_Index, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		
		If ll_Index = ll_MaxContent AND lb_Backlog_Switch then
			of_modify_text( ls_DWObject, is_Overflow_MSG_2)
			
			// ----------------------------------------------------------------------------------------------------
			// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
			// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
			//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
			//							 should appear automatically and a Content spec should be generated
			// ----------------------------------------------------------------------------------------------------
			If ib_non_sky then
				of_modify_text(ls_DWObject, is_Overflow_MSG_1)
				guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi non sky BACKLOG => CONTENT SPEC " + lstr_item[ll_Index].sitem)
				// add content spec ###########
				
			End If
			
			
		End If
				
		of_adjust_font({ls_DWObject}, 8, FALSE, FALSE)
		ls_Alternative_Object = "t_content_text_"  + string(ll_Index,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")

		If ll_Index = ll_MaxContent AND lb_Backlog_Switch then
			of_modify_text( ls_Alternative_Object, is_Overflow_MSG_2) 
		End If
		
		// ----------------------------------------------------------------------------------------------------
		// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
		// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
		//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
		//							 should appear automatically and a Content spec should be generated
		// ----------------------------------------------------------------------------------------------------
		If ib_non_sky then
			of_modify_text(ls_Alternative_Object, is_Overflow_MSG_1)
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi non sky BACKLOG => CONTENT SPEC " + lstr_item[ll_Index].sitem)
			// add content spec 					
		End If
		

		of_adjust_font({ls_Alternative_Object}, 8, FALSE, FALSE)
		If Trim(lstr_item[ll_Index].sitem) > "" Then
			
			If lb_Overflow Then
				
				lstr_component_x.ssnr = lstr_item[ll_Index].cpackinglist
				lstr_component_x.stext = lstr_item[ll_Index].ctext
				lstr_component_x.squantity = "" //String(lstr_item[ll_Index].lcount)
				lstr_component_x.lquantity = 0 
				//If lstr_component_x.squantity = "0" Then lstr_component_x.squantity =""
				ls_Computed_Item = of_get_item_description( lstr_component_x )
				
				ldec_Qty = lstr_item[ll_Index].lcount
				
				//If ll_Index = ll_maxContent and lb_Overflow = TRUE and lb_Content_Spec_Drawer = TRUE Then
				If ll_Index = ll_maxContent and lb_Overflow = TRUE Then
				
					ls_header = "" //lstr_item[ll_Index].sparent
					If not isnull(lstr_item[ll_Index].sparent) and trim (lstr_item[ll_Index].sparent) > "" Then
						ls_header = lstr_item[ll_Index].sparent
						//ls_Parent_PL = lstr_item[ll_Index].sparentpl
//						If ls_Parent_PL = "" and ls_header > "" then 
//							ls_Parent_PL = left(ls_header, pos(ls_header, " - "))
//							ls_Parent_PL = TRIM(ls_Parent_PL)
//						End If
					End If
				End If
				
				If lb_Overflow = TRUE Then
					li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, ldec_Qty , "", ls_Computed_Item, ll_Index, drawer_multi_rung, ls_header, al_master_row_id ) 
					If ib_non_sky Then
						// @@@@@@@@@@@@@@@@@@@
						il_Master_Row = al_master_row_id
						if ls_header > "" then
							ls_Backlog_Text = ls_header
							If left(ls_Backlog_Text, len (ls_Parent_PL)) = ls_Parent_PL then
								ls_Backlog_Text = mid(ls_Backlog_Text, len(ls_Parent_PL) + 3 )
								ls_Backlog_Text = trim(ls_Backlog_Text)
							end if
							if ls_CS_Header_PL = ls_Parent_PL then
								li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL  , ls_parent_text, 1  ,al_row, al_column, TRUE )
							Else
								li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL  , ls_parent_text, 1  ,al_row, al_column, FALSE )
							end if
							//li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL  , ls_parent_text, 1  ,al_row, al_column )
							//li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL  , ls_Backlog_Text, 1  ,al_row, al_column )

						Else
							//li_Succ = of_add_backlog_as_content_sheet( lstr_component_x.ssnr  , lstr_component_x.stext,  lstr_item[ll_Index].lcount ,al_row, al_column )
							if lstr_component_x.ssnr = ls_CS_Header_PL Then
								li_Succ = of_add_backlog_as_content_sheet( lstr_component_x.ssnr  , lstr_component_x.stext,  lstr_item[ll_Index].lcount ,al_row, al_column, TRUE )	
							Else
								li_Succ = of_add_backlog_as_content_sheet( lstr_component_x.ssnr  , lstr_component_x.stext,  lstr_item[ll_Index].lcount ,al_row, al_column, FALSE )		
							End If
						End If
					End If						
					
					
				End If			
			End If
		Else
			If Trim(lstr_item[ll_Index].sitem) > "" Then
				If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi ll_Index "+String(ll_Index)+" < ll_MaxContent " + String(ll_MaxContent) + " BACKLOG EMPTY SITEM")
			End If
			ls_DWObject = "t_content_std_text_" + string(ll_Index, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
			of_modify_dw(ls_DWObject + '.text=""')
			ls_Alternative_Object = "t_content_text_"  + string(ll_Index,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
			of_modify_dw(ls_Alternative_Object + '.text.""')						
		End If
	End If
	
	If trim(lstr_item[ll_Index].cpackinglist) > "" Then		
		ll_index_key = f_get_packinglist_key(lstr_item[ll_Index].cpackinglist)
		lb_Content_Spec_PL = of_is_content_spec_enabled(ll_index_key , is_CSC, idt_departure )
		If lb_Content_Spec_PL AND lb_Header_Exists Then
			//lb_Content_Spec_Drawer = TRUE
		End if
	End if
	
Next


If NOT ib_Disable_Content_Spec_MSG  Then
	// --------------------------------------------------------------------------------------
	// Content Sheet Indicator - auch fixed content checken
	// --------------------------------------------------------------------------------------				
	If lb_Content_Spec_Drawer = FALSE then
		lstr_item = lstr_item_empty
		ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
		if ll_Found > 0 Then
			ll_Content			= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
			ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
			
//			If ll_Drawer_Explode_Setting = EXplosion Then
			li_Succ = of_get_fixed_content(ll_layoutdetailkey, ll_Content, al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, FALSE)
//			Else
//				li_Succ = of_get_fixed_content(ll_layoutdetailkey, ll_Content, al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, TRUE)
//			End If
			
			ll_Number_of_Fixed_Content = upperbound(lstr_item) 
			If ll_Number_of_Distr_Comp = 0 then
				If ll_Number_of_Fixed_Content > ll_MaxContent AND lb_Backlog_Switch = TRUE Then
					lb_Overflow = TRUE
				End If
			Else
				If ll_Number_of_Distr_Comp > ll_MaxContent AND lb_Backlog_Switch = TRUE Then
					lb_Overflow = TRUE
				End If
			End If
						
			for ll_Index = 1 to upperbound(lstr_item) 

				If trim(lstr_item[ll_Index].cpackinglist) > "" Then
					ll_index_key = f_get_packinglist_key(lstr_item[ll_Index].cpackinglist)
					If ll_index = 1 Then
						lb_Content_Spec_PL = of_is_content_spec_enabled(ll_index_key , is_CSC, idt_departure )
						If lb_Content_Spec_PL AND lb_Header_Exists Then
                     If ll_Index = 1 Then
                        //###############
                        lb_Content_Spec_Drawer = TRUE                     
                     End If
				
						End If
					End if
					//If lb_Overflow AND ll_Index >= ll_MaxContent Then
					If lb_Overflow AND ll_Index >= ll_MaxContent Then
						ldec_Qty = lstr_item[ll_Index].lcount
						
						lstr_component_x.ssnr = lstr_item[ll_Index].cpackinglist
						lstr_component_x.stext = lstr_item[ll_Index].ctext
						lstr_component_x.squantity = "" //String(lstr_item[ll_Index].lcount)
						//If lstr_component_x.squantity = "0" Then lstr_component_x.squantity =""
						ls_Computed_Item = of_get_item_description( lstr_component_x )

						//of_draw_content_backlog_drawer(ll_Row, al_Row, al_column, dsTemp, DRAWER, lsHeaderText)
						ls_header = lstr_item[ll_Index].sparent
						ls_Parent_PL = lstr_item[ll_Index].sparentpl
						
						// #### 06.03.2013 ####
						If of_sd_find_backlog( al_row, al_column, ls_DWObject, ldec_Qty , "", ls_Computed_Item, ll_Index  , drawer_multi_rung, ls_header, al_master_row_id ) < 1 Then
							li_Succ = of_sd_add_backlog( al_row, al_column, ls_DWObject, ldec_Qty , "", ls_Computed_Item, ll_Index  , drawer_multi_rung , ls_header, al_master_row_id ) 
						End If	
												
						If ib_non_sky Then
							If lb_Overflow AND ll_Index = ll_MaxContent Then
								il_Master_Row = al_master_row_id
								ls_Parent_Backlog = ls_Parent_Text
								if left(ls_Parent_Backlog, len(ls_Parent_PL))  = ls_Parent_PL then
									ls_Parent_Backlog = mid(ls_Parent_Backlog, len(ls_Parent_PL) + 3)
									ls_Parent_Backlog = trim(ls_Parent_Backlog)
								end if
								//li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL , ls_Parent_Backlog, ll_Parent_Qty, al_row, al_Column)
								if ls_Parent_PL = ls_CS_Header_PL Then
									li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL , ls_Parent_Backlog, ll_Parent_Qty, al_row, al_Column, TRUE)																
								Else
									li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL , ls_Parent_Backlog, ll_Parent_Qty, al_row, al_Column, FALSE)								
								End If
								//li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL , ls_Parent_Text, ll_Parent_Qty ,al_row, al_column )
							End If	
						End If
						
						//If il_Disable_Debug = 0 Then
							If Trim(lstr_item[ll_Index].sitem) > "" Then
								guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi ll_Index " + String(ll_Index) + " < ll_MaxContent " + String(ll_MaxContent) + " SEE BACKLOG...")
								guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi BACKLOG " + lstr_item[ll_Index].sitem )
							End If
						//End If
					End If
					
				End if
			Next
		End If
	End If
	
	// --------------------------------------------------------------------------
	// Content Sheet Indicator
	// --------------------------------------------------------------------------
	If lb_Content_Spec_Drawer = TRUE AND lb_Header_Exists then 
		// Auf die letzte Zeile die Nachricht "Overflow" / "Overflow & Content Spec"
		If lb_Overflow AND lb_Backlog_Switch Then
			ls_MSG = is_Overflow_MSG_3 // see cs and overflow
		Else
			ls_MSG = is_Overflow_MSG_1	// see content spec	
		End if
		
		// CBASE-NAM-CR-16008 if the content doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator "content spec" should appear and a Content spec should be generated
		If lb_Overflow AND lb_Backlog_Switch AND ib_non_sky Then
			ls_MSG = is_Overflow_MSG_1	// see content spec	
		End if

		ls_DWObject = "t_content_std_text_" + string(ll_MaxContent, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		ls_Alternative_Object = "t_content_text_"  + string(ll_MaxContent,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		If ll_Cols > 1 Then
			ls_DWObject = "t_content_std_text_" + string(ll_MaxContent / 2, "00") + "_col_" + string(2, "00") + "_row_" + string(al_Row, "00")
			ls_Alternative_Object = "t_content_text_"  + string(ll_MaxContent / 2,  "0") + "_col_" + string(2, "00") + "_row_" + string(al_Row, "00")	
		End If
		of_modify_text(ls_DWObject , ls_MSG)
		of_modify_text(ls_Alternative_Object , ls_MSG)		
		//If il_Disable_Debug = 0 Then
		If il_Disable_Debug = 0 Then
//			of_modify_dw(ls_DWObject + ".Color='" + String(rgb(0,255,0)) + "'" )
//			of_modify_dw(ls_Alternative_Object + ".Color='" + String(rgb(0,255,0)) + "'" )
		End if
	ElseIf lb_Overflow = TRUE AND (lb_Content_Spec_Drawer = FALSE OR lb_Header_Exists = FALSE) Then
		// keine Header bzw. kein Content Spec - aber Overflow
		ls_MSG = is_Overflow_MSG_2 // see overflow
		
		// CBASE-NAM-CR-16008 if the content doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator "content spec" should appear and a Content spec should be generated
		If ib_non_sky Then
			ls_MSG = is_Overflow_MSG_1	// see content spec	
		End if
				
		ls_DWObject = "t_content_std_text_" + string(ll_MaxContent, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		ls_Alternative_Object = "t_content_text_"  + string(ll_MaxContent,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		If ll_Cols > 1 Then
			ls_DWObject = "t_content_std_text_" + string(ceiling(ll_MaxContent / 2), "00") + "_col_" + string(2, "00") + "_row_" + string(al_Row, "00")
			ls_Alternative_Object = "t_content_text_"  + string(ceiling(ll_MaxContent / 2),  "0") + "_col_" + string(2, "00") + "_row_" + string(al_Row, "00")	
		End If
		of_modify_text(ls_DWObject , ls_MSG)
		of_modify_text(ls_Alternative_Object , ls_MSG)		
		If il_Disable_Debug = 0 Then
//			of_modify_dw(ls_DWObject + ".Color='" + String(rgb(0,255,0)) + "'" )
//			of_modify_dw(ls_Alternative_Object + ".Color='" + String(rgb(0,255,0)) + "'" )
		End if
	End if
Else
	lstr_item = lstr_item_empty
	ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
	if ll_Found > 0 Then
		ll_Content			= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
		ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
	
		li_Succ = of_get_fixed_content(ll_layoutdetailkey, CONTENT , al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, FALSE)
		ll_Number_of_Fixed_Content = upperbound(lstr_item) 
	End If
End If

// ----------------------------------------------------------------------------
// wenn kein distr. content, aber EIN fixed content, dann Gr$$HEX2$$f600df00$$ENDHEX$$e anpassen
// ----------------------------------------------------------------------------
If ll_Number_of_Distr_Comp = 0 AND ll_Number_of_Fixed_Content = 1 Then
	If upperbound(lstr_item) < 1 then
		li_Succ = of_get_fixed_content(ll_layoutdetailkey, CONTENT , al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, FALSE)
	End If	
	If upperbound(lstr_item) > 0 then
		ll_index_key = f_get_packinglist_key( lstr_item[1].cpackinglist )
		
		ls_DWObject = "t_content_std_text_" + string(1, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		ls_Alternative_Object = "t_content_text_"  + string(1,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
		If of_check_explode(ll_index_key, arg_unit) Then
			guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi of_adjust_text_size_small_big SUPPRESS=TRUE "+ " Col: "+ String(al_Column) + " Row: " + String(al_Row))
			// anpassen text Size
			of_adjust_text_size_small_big({ls_DWObject, ls_Alternative_Object}, ll_MaxContent)
			li_Succ = of_vertical_center_text_within_drawer( {ls_DWObject, ls_Alternative_Object}, al_column, al_row)
		End If
		
		If lb_Header_Exists Then
			If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi lb_Header_Exists=TRUE of_adjust_text_size_small_big ")
			// anpassen text Size
			of_adjust_text_size_small_big({ls_DWObject, ls_Alternative_Object}, ll_MaxContent)
			li_Succ = of_vertical_center_text_within_drawer( {ls_DWObject, ls_Alternative_Object}, al_column, al_row)
		End If
		
	end if
End If

If ll_Number_of_Distr_Comp = 0 AND ll_Number_of_Fixed_Content > 0 Then
	If upperbound(lstr_item) > 0 then
		If lstr_item[1].bdistributed = FALSE Then
			lstr_component_x.ssnr = lstr_item[1].cpackinglist
			lstr_component_x.stext = lstr_item[1].ctext
			lstr_component_x.squantity = String(lstr_item[1].lcount)			
			ls_Computed_Item = of_get_item_description( lstr_component_x, TRUE )
			ls_DWObject = "t_content_std_text_" + string(1, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
			ls_Alternative_Object = "t_content_text_"  + string(1,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
			//If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi of_adjust_text_size ")
			of_modify_text(ls_DWObject, ls_Computed_Item)
			of_modify_text(ls_Alternative_Object, ls_Computed_Item)
		End If
	End If
End If


//If ll_Number_of_Distr_Comp = 1 AND ll_Number_of_Fixed_Content = 0 Then
//	If upperbound(lstr_item) > 0 then
//		If lstr_item[1].bdistributed = TRUE Then
//			lstr_component_x.ssnr = lstr_item[1].cpackinglist
//			lstr_component_x.stext = lstr_item[1].ctext
//			lstr_component_x.squantity = String(lstr_item[1].lcount)			
//			
//			ls_Computed_Item = of_get_item_description( lstr_component_x, TRUE )
//			ls_DWObject = "t_content_std_text_" + string(1, "00") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
//			ls_Alternative_Object = "t_content_text_"  + string(1,  "0") + "_col_" + string(al_Column, "00") + "_row_" + string(al_Row, "00")
//			//If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi of_adjust_text_size ")
//			of_modify_text(ls_DWObject, ls_Computed_Item)
//			of_modify_text(ls_Alternative_Object, ls_Computed_Item)
//		End If
//	End If
//End If

If ib_Downline_by_Mealcode AND of_is_downline_enabled(arg_unit) AND lb_Watermark_Downline Then
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components PRINT DOWNLINE LEG FROM DIST R" + String(al_Row) + " C" + String(al_Column))
		li_Succ = of_draw_watermark_downline(al_Row, al_Column, of_get_type(al_Row, al_Column) , rgb(0,255,0))
	Else								
		li_Succ = of_draw_watermark_downline(al_Row, al_Column, of_get_type(al_Row, al_Column), rgb(200,200,200))
	End If
Else
	If il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_multi PRINT DOWNLINE LEG lb_Suppress_Watermark_Downline=TRUE R" + String(al_Row) + " C" + String(al_Column))
End if


// #### TEMP SETTING DEBUG ####
//il_Disable_Debug = 1
// #### TEMP SETTING DEBUG ####


Return 1

end function

public function long of_get_fixed_content_tray (long arg_llayoutdetailkey, long arg_icontent, long arg_irow, long arg_icolumn, long arg_ltype, string arg_cunit, long arg_start_pos, ref s_distrib_items astr_items[], boolean ab_do_not_explode);
/*
* Objekt : uo_cart_diagram
* Methode: of_get_fixed_content (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 03.03.2011
*
* Argument(e):
*	 long arg_llayoutdetailkey
*	 long arg_icontent
*	 long arg_irow
*	 long arg_icolumn
*	 long arg_ltype
*	 string arg_cunit
*	 long arg_start_pos
*	 ref s_distrib_items astr_items[]
*
* Beschreibung:		Diagramm-Inhalte sammeln (benutzt von Create Distribution)
*
* Aenderungshistorie:
* Version 	Wer 						Wann			Was und warum
* 1.0 			Oliver Hoefer			03.03.2011	Erstellung
* 1.1 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*
*
* Return: long
*
*/


Long			ll_Row 
Long			lContentIndexKey,  lContentDetailKey, llAdditionalYOffset
Long			llMaxContent
Integer		li_Explode_Setting
Long			ll_no_of_rungs
LOng			ll_Ancestor, ll_Found
Long			ll_Start_Row, ll_Temp
Integer		li_Succ
String		ls_Text
Long			ll_Explosion_Counter
Long			ll_Col_Counter
Long			ll_Item_Counter
String		ls_Qty_Object
String		ls_Qty
String		ls_Filter,  lsText , ls_HeaderText, ls_HeaderPL, ls_HeaderPLandText
Long			ll_Rows
Long			ll_Original_Content
Long			ll_Content_Row
Integer		li_Content_Setting
Long			ll_Current_Index
Boolean		lb_Current_PL_Is_Header
String		ls_Pl_to_Check_For_Header
s_component lstr_component
datastore lds_Temp
Long			ll_Tmp_Setting
s_distrib_items	lstr_Empty[]
Long			ll_Number_of_Contents = 0 


ll_Original_Content = arg_icontent
astr_items = lstr_Empty

if il_Disable_Debug=0 Then
	If ab_do_not_explode Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content BEGIN FUNCTION ab_do_not_explode=TRUE")
	Else
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content BEGIN FUNCTION ab_do_not_explode=FALSE")
	End If
End If

//If arg_ltype <> DRAWER_MULTI_RUNG  Then
//	// Falscher Typ
//	if il_Disable_Debug=0 Then
//		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content arg_ltype <> DRAWER_MULTI_RUNG")
//	End If
//	Return -1
//End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content layoutdetailkey=" + String(arg_lLayoutDetailKey)  + " arg_iContent=" + String(arg_iContent) + " column=" + &
					String(arg_icolumn) + " row=" + String(arg_irow) + " type=" + String(arg_ltype) + " unit=" + arg_cunit + " Startpos=" + String(arG_start_pos)  )
End If

// Content Typ
If IsNULL(arg_iContent) Then arg_iContent = DISTRIBUTION
If arg_iContent = 0  Then arg_iContent = DISTRIBUTION
li_Content_Setting = arg_iContent
this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(arg_lLayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()


if il_Disable_Debug=0 Then
	choose case arg_iContent
		case DISTRIBUTION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** DISTRIBUTION")
		Case CONTENT
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** CONTENT")			
		CASE EXPLOSION
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** EXPLOSION")			
		CASE ELSE
			guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_get_fixed_content *** UNKNOWN")			
	End Choose
End If

if this.dsLayoutContents.RowCount() = 0 Then
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content KEIN INHALT?")
	End If
	Return 0
End If

ll_Found = dsLayoutDetail.Find("ncolumn=" + string( arg_icolumn ) + " and nrow=" + string(arg_irow), 1, this.dsLayoutDetail.Rowcount())
If ll_Found > 0 Then
	ll_Ancestor = dsLayoutDetail.GetItemNumber(ll_Found, "nancestor")
	ll_Found = dsLayoutDetail.Find("ntype=" + String(arg_ltype) + " and nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())			
	If ll_Found > 0 Then
		ll_no_of_rungs = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrungs")
//		ll_no_of_columns = this.dsLayoutDetail.Getitemnumber(ll_Found, "ncolumns")
	End If
End If
		
llMaxContent = of_get_maxcontent(arg_irow,arg_icolumn)

llAdditionalYOffset = 50
If ll_Ancestor > 0 Then
	// Erste Row zu diesem Drawer 
	ll_Found = dsLayoutDetail.Find("nancestor=" + string( ll_Ancestor ), 1, this.dsLayoutDetail.Rowcount())	 
	If ll_Found > 0 Then
		ll_Start_Row = this.dsLayoutDetail.Getitemnumber(ll_Found, "nrow")
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content StartRow: " + String(ll_Start_Row))
		End If
	End If
Else
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content ll_Ancestor=0")
	End If
End If	
		
ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
Next

If Trim(ls_Filter) = "" Then 
	Return 0
End If 

this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()
if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content dsPLContents.rowcount(): " + String(dsPLContents.rowcount()) + " Filter " + ls_Filter)
End If

// -------------------------------------------------
// Explode setting: override or keep existing
// -------------------------------------------------
If il_IndexKey > 0 Then
	li_Explode_Setting = of_get_explosion_setting(il_IndexKey, arg_cunit)
	Choose Case li_Explode_Setting
		Case 1 
			arg_iContent = EXPLOSION
			guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content_tray] "  +  this.isStowage +" - " + "EXPLODE "  + string(il_IndexKey) )
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLODE "  + string(il_IndexKey))
			End If
		Case 0
			arg_iContent = CONTENT
			guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content_tray] "  +  this.isStowage +" - " + "CONTENT "  + string(il_IndexKey) )
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content CONTENT "  + string(il_IndexKey))
			End If
		Case -1
			guoLog.uf_debug("["+ this.classname( )+".of_get_fixed_content_tray] "  +  this.isStowage +" - " + "use existing "  + string(il_IndexKey) + "  " + String(arg_iContent) )
			// NO CHANGE: keep existing setting
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING "  + string(il_IndexKey)+ "  " + String(arg_iContent))
			End If

	End Choose
Else
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content il_IndexKey=0" )
	End If
End If

// ----------------------------------
// Content wird zu Explosion
// ----------------------------------
If arg_iContent = CONTENT Then
	li_Content_Setting = CONTENT //EXPLOSION
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content arg_iContent = CONTENT => EXPLOSION " )
	End If

ElseIf arg_iContent = DISTRIBUTION Then
	li_Content_Setting = DISTRIBUTION	
	if il_Disable_Debug=0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content arg_iContent = DISTRIBUTION " )
	End If
End If

If li_Content_Setting = EXPLOSION Then
	// ----------------------------------------------------------
	// --- EXPLOSION aufbauen                                 ---
	// ----------------------------------------------------------
	ll_Item_Counter = 0
	
Else
//	sError = "Error: undefined content"
//	if il_Disable_Debug=0 Then
//		guoLog.uf_debug( "["+ this.classname( )+".Error: undefined content")
//	End If
//	return -1
End If

// ------------------------------------------------------------------------
// Texte neu eintragen
// Unterscheidung Content vs. Exploded Content vs. Verteilung ohne Content
// ------------------------------------------------------------------------

If il_Disable_Debug = 0 Then
	//guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLOSION/DISTRIBUTION")
	If dsPLContents.RowCount() > 0 Then
		//dsPLContents.saveas("c:\temp\cbase\of_get_fixed_content_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_dsPLContents.PSR", PSReport! , true)
	End If
End If

if dsPLContents.RowCount() < 1 AND arg_iContent <> DISTRIBUTION Then
	// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden UND keine Verteilung
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content dsPLContents.RowCount() < 1 AND arg_iContent <> DISTRIBUTION")
	End If
	li_succ = -9999
//	End If	
	

//Elseif arg_iContent = EXPLOSION Then // Explosion Layout
Elseif li_Content_Setting = EXPLOSION OR li_Content_Setting = CONTENT OR li_Content_Setting = DISTRIBUTION Then // Explosion Layout	
	// -------------------------------------------------
	// --- EXPLOSION                                 ---
	// -------------------------------------------------
	If il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLOSION/DISTRIBUTIONCONTENT")
	End If
	// -------------------------------------------------
	// wenn das Objekt die Order Nummer ist: f$$HEX1$$fc00$$ENDHEX$$llen
	// -------------------------------------------------
	// ------------------------------------------------------------------------------------------------------------
	// Ab hier:		Header + Inhalt
	// ------------------------------------------------------------------------------------------------------------
	lds_Temp = create datastore
	lds_Temp.dataobject = "dw_packinglist_edit_content"
	lds_Temp.SetTransObject(sqlca)

	ll_Explosion_Counter = arg_start_pos - 1 

//	ll_Content_Row = 1
	For ll_Content_Row = 1 To dsPLContents.RowCount()
		ll_Number_of_Contents += 1
		
		lContentIndexKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
		lContentDetailKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")
	
		ll_Rows = lds_Temp.Retrieve(lContentIndexKey, lContentDetailKey, datetime(idt_Departure), 0)
		
		If li_Content_Setting <> EXPLOSION then
			lds_Temp.reset()
		end if
		
		lds_Temp.SetSort("nsort a")
		lds_Temp.Sort()
				 
//		// ------------------------------------------------------------------------------------------------------------
//		// Wenn Header St$$HEX1$$fc00$$ENDHEX$$ckliste im Einschub vorhanden => nicht EXPLODE
//		// ------------------------------------------------------------------------------------------------------------
//		If ab_do_not_explode Then
//			lds_Temp.Reset()
//		End If

	
		// ------------------------------------------------------------------------------------------------------------
		// Wenn Header vorhanden und aktuelle St$$HEX1$$fc00$$ENDHEX$$ckliste <> Header => nicht EXPLODE
		// ------------------------------------------------------------------------------------------------------------
		If ab_do_not_explode Then
			lb_Current_PL_Is_Header = FALSE
			ls_Pl_to_Check_For_Header = f_get_packinglist( lContentIndexKey)
			lb_Current_PL_Is_Header = of_is_content_sheet_header( arg_llayoutdetailkey , ls_Pl_to_Check_For_Header )
			If NOT lb_Current_PL_Is_Header  Then
				lds_Temp.Reset()
				If il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content SUPPRESS (Not a Header): " + ls_Pl_to_Check_For_Header)
				End If
			Else
				If il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content SUPPRESS (PL IS Header): " + ls_Pl_to_Check_For_Header)
				End If
				
			End If
		End If
	
		ll_Explosion_Counter++

		lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
		lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
		lstr_component.squantity	= ""
		ls_HeaderText =  of_get_item_description(lstr_component)
		ls_HeaderPLandText = lstr_component.ssnr + " - " +  lstr_component.stext
		ls_HeaderPL = lstr_component.ssnr
		
		// ######################################################################
		ll_Current_Index = upperbound(astr_items) + 1
		astr_items[ll_Current_Index].sitem = ls_HeaderText
		
		astr_items[ll_Current_Index].cpackinglist	= lstr_component.ssnr
		astr_items[ll_Current_Index].ctext			= lstr_component.stext
				
		If ll_Original_Content = CONTENT Then		
			astr_items[ll_Current_Index].bcontent = TRUE
		End If
		
		If lb_Current_PL_Is_Header Then
			If ll_Content_Row =  1 then
				astr_items[ll_Current_Index].bbold = TRUE
				If il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content lb_Current_PL_Is_Header BOLD " + ls_HeaderText)
				End If
			End If
		End If

		// ------------------------------------------------------------------------------------------------------------
		// wenn keine Header PL vorhanden: Explosion Top BOLD 
		// ------------------------------------------------------------------------------------------------------------
		If ll_Original_Content = EXPLOSION AND ab_do_not_explode = FALSE Then	
			If ll_Content_Row =  1 then
				astr_items[ll_Current_Index].bbold = TRUE
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content ll_Original_Content=EXPLOSION AND NO HEADER bbold=TRUE " + ls_HeaderText)
				End If
			End If
		End If
					
		astr_items[ll_Current_Index].lcount = this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity")
		if il_Disable_Debug=0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content ls_HeaderText " + ls_HeaderText)
		End If
		// ######################################################################
		
		// ------------------------------------------------------------------------------------------------------------
		// wenn f$$HEX1$$fc00$$ENDHEX$$r die St$$HEX1$$fc00$$ENDHEX$$ckliste in Area Allocation "suppress" eingestellt ist: keine Inhalte zeigen
		// ------------------------------------------------------------------------------------------------------------
//		If of_explode( lContentIndexKey, arg_cunit, li_Explode_Setting, arg_icontent ) = FALSE Then
//			If il_Disable_Debug=0 Then
//				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content SUPPRESS " + lstr_component.ssnr)
//			End If
//			CONTINUE
//		Else
//			If arg_icontent = content Then
//				If il_Disable_Debug=0 Then
//					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content Parent = CONTENT => EXPLODE " + lstr_component.ssnr)
//				End If
//			End If
//		End If
		ll_Tmp_Setting = of_get_explosion_setting(lContentIndexKey, arg_cunit)
		Choose Case ll_Tmp_Setting
			Case 1 
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXPLODE "  + string(lContentIndexKey) + " / " + lstr_component.ssnr)
				End If
			Case 0
				lds_Temp.Reset()
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content SUPPRESS "  + string(lContentIndexKey) + " / " + lstr_component.ssnr)
				End If
			Case -1
				// NO CHANGE: keep existing setting
				if il_Disable_Debug=0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING "  + string(lContentIndexKey)+  + " / " + lstr_component.ssnr +"  " + String(arg_iContent))
				End If
				If ll_Original_Content = CONTENT Then
					lds_Temp.Reset()
					if il_Disable_Debug=0 Then
						guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING=CONTENT "  + lstr_component.ssnr +" lds_Temp.RowCount() " + String(lds_Temp.RowCOunt()))
					End If
				Else
					if il_Disable_Debug=0 Then
						guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content EXISTING<>CONTENT "  + lstr_component.ssnr +" lds_Temp.RowCount() " + String(lds_Temp.RowCOunt()))
					End If
				End If
				
		End Choose

		
		for ll_Row = 1 to lds_Temp.RowCount()
			//ll_Explosion_Counter++
			lstr_component.stext =lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
			lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
			lstr_component.squantity = String(lds_Temp.GetItemNumber(ll_Row, "nquantity")) 
			lsText = of_get_item_description(lstr_component)

			ll_Current_Index = upperbound(astr_items) + 1
			//astr_items[ll_Current_Index].sitem = ls_Qty + lsText
			astr_items[ll_Current_Index].sitem = lsText
			
			astr_items[ll_Current_Index].cpackinglist	= lstr_component.ssnr
			astr_items[ll_Current_Index].ctext			= lstr_component.stext
			
			astr_items[ll_Current_Index].lcount = lds_Temp.GetItemNumber(ll_Row, "nquantity")
			
			// Parent merken
			astr_items[ll_Current_Index].sparent = ls_HeaderPLandText //ls_HeaderText
			astr_items[ll_Current_Index].sparentpl = ls_HeaderPL
			
			
			if il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content CONTENT " + lstr_component.squantity + " / " + lstr_component.ssnr + " / " + lstr_component.stext)
			End If
		Next
	Next

End If

if il_Disable_Debug=0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_fixed_content END FUNCTION" )
End If

//if il_Disable_Debug=0 Then
//	If isvalid(ods) then
//		ods.saveas("c:\temp\cbase\of_get_fixed_content_"+ "_"  + "_" + String(Rand(32767)) + String(now(), "hhmmss") + "_CART_.PSR", PSReport! , true)
//	end if
//End If

if IsValid(lds_Temp) then destroy lds_Temp

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

Return ll_Number_of_Contents

end function

public function boolean of_check_center_setting ();/*
* Objekt : uo_cart_diagram
* Methode: of_check_center_setting (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 27.11.2012
*
* Argument(e):
* none
*
* Beschreibung:		check whether to center a text (if display setting is either PL XOR Text)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	27.11.2012		Erstellung
*
*
* Return: boolean
*
*/


string	sValue, ssection, sDefault
integer	iconfig



isCartDiagramComponentDisplay = ""

// ----------------------------------------------------------------------
// bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	sValue = String(inv_doc_gen_settings.il_ncart_component_display )
	if ibEdit Then		sValue = "0"
Else
	If trim(isCartDiagramComponentDisplay) > "" Then
		sValue = isCartDiagramComponentDisplay		
	Else
		
		If is_section > "" Then
			sSection = is_section
		Else			
			sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		end if	
		
		if sSection <> "docbrowser" Then
			iConfig = integer(Mid(sSection,11))
			sDefault ="Default" +string(iConfig)
		Else
			sDefault ="Default"
		End If
				
		// Ist das Diagram im Editmode
		if ibEdit Then
			sValue = "0"
		Elseif isNull(isCartDiagramComponentDisplay) or  isCartDiagramComponentDisplay= "" Then
			sValue =  of_profilestring(s_app.suser,sDefault,"CartDiagramComponentDisplay","0") 
			isCartDiagramComponentDisplay = sValue
		Else
			sValue = isCartDiagramComponentDisplay
		End If
	End If
End if

if sValue = "0" Then
	Return FALSE
	//ls_ArgItem= arg_str_component.ssnr + " - " + arg_str_component.stext
Elseif sValue = "1" Then
	Return TRUE
	//ls_ArgItem= arg_str_component.ssnr
Elseif sValue = "2" Then
	Return TRUE
	//ls_ArgItem= arg_str_component.stext	
End If

Return FALSE

end function

public function string of_get_item_description (s_component arg_str_component, boolean ab_fixed);/*
* Objekt : uo_cart_diagram
* Methode: of_get_item_description (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 27.11.2012
*
* Argument(e):
*	 s_component arg_str_component
*	 boolean ab_fixed
*
* Beschreibung:		Sonderfall - "Suppress Qty 1" bei Fixed Content
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	27.11.2012		Erstellung
*
*
* Return: string
*
*/

string sValue, ls_ArgItem, ssection, sDefault
integer iconfig


If NOT ab_Fixed Then 
	Return of_get_item_description(arg_str_component)
End If

// ----------------------------------------------------------------------
// 24.01.2012 bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	sValue = String(inv_doc_gen_settings.il_ncart_component_display )
	if ibEdit Then		sValue = "0"
Else
	If trim(isCartDiagramComponentDisplay) > "" Then
		sValue = isCartDiagramComponentDisplay		
	Else
		
		If is_section > "" Then
			sSection = is_section
		Else			
			sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		end if	
		
		if sSection <> "docbrowser" Then
			iConfig = integer(Mid(sSection,11))
			sDefault ="Default" +string(iConfig)
		Else
			sDefault ="Default"
		End If
				
		// Ist das Diagram im Editmode
		if ibEdit Then
			sValue = "0"
		Elseif isNull(isCartDiagramComponentDisplay) or  isCartDiagramComponentDisplay= "" Then
			sValue =  of_profilestring(s_app.suser,sDefault,"CartDiagramComponentDisplay","0") 
			isCartDiagramComponentDisplay = sValue
		Else
			sValue = isCartDiagramComponentDisplay
		End If
	End If
End if

if sValue = "0" Then
	ls_ArgItem= arg_str_component.ssnr + " - " + arg_str_component.stext
Elseif sValue = "1" Then
	ls_ArgItem= arg_str_component.ssnr
Elseif sValue = "2" Then
	ls_ArgItem= arg_str_component.stext	
End If

//// 10.02.2010 Ulrich Paudler [UP] 
////if len(arg_str_component.squantity)> 0 and not isNull(arg_str_component.squantity) Then
//if len(arg_str_component.squantity)> 0 and not isNull(arg_str_component.squantity) Then	
//	If isnumber(arg_str_component.squantity) then
//		If Trim(arg_str_component.squantity) <> "1" AND double(arg_str_component.squantity) <> 1 Then
//			ls_ArgItem = arg_str_component.squantity + " x " + ls_ArgItem
//		End If
//	end if
//End If 

If ab_Fixed AND arg_str_component.squantity = "1" Then
	If ib_suppress_qty_1 Then
		arg_str_component.squantity = ""
		guoLog.uf_debug( "["+ this.classname( )+".of_get_item_description FIXED CONTENT SUPPRESS QTY 1: " + ls_ArgItem)
	End If
End If


// NAM CR 12002 Always show Qty 
If isNull(arg_str_component.squantity) Then arg_str_component.squantity = ""
If ib_suppress_qty_1 = FALSE OR arg_str_component.squantity <> "1" Then
	If arg_str_component.squantity <> "0" AND Trim(arg_str_component.squantity) > "" then
		ls_ArgItem = arg_str_component.squantity + " x " + ls_ArgItem
	End if
End if

if il_Disable_Debug = 0 Then guoLog.uf_debug( "["+ this.classname( )+".of_get_item_description " + ls_ArgItem)


Return ls_ArgItem

end function

public function integer of_vertical_center_text_within_drawer (string as_object[], long al_column, long al_row);/*
* Objekt : uo_cart_diagram
* Methode: of_vertical_center_text_within_drawer (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 16.01.2013
*
* Argument(e):
* string as_object[]
*	 long al_column
*	 long al_row
*
* Beschreibung:		Center text object VERTICALLY within the surrounding DRAWER 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	16.01.2013		Erstellung
*
*
* Return: integer
*
*/


Integer	li_Succ
Integer	li_Return
Long		ll_Counter
Long		ll_Text_Object_Height
Long		ll_Drawer_Height
Long		ll_Type
Long		ll_rungs, ll_Cols 
Long		ll_Y_Pos_Orig
Long		ll_Y_Pos_Target
Long		ll_Y_Pos_Drawer
Long		ll_Topmost_Rung
String	ls_Text



ll_Type = of_get_type(al_Row, al_Column) 

for ll_counter = 1 to upperbound(as_object)
	ls_Text = trim(of_describe( as_object[ll_counter] + ".text",FALSE))

	if len (ls_Text) < 1  or ls_Text = "!" or ls_Text = "???" then
		// no valid content or no valid object
		continue 
	end if

	If Trim(ls_Text) = "" Then
		CONTINUE
	End If
	
	if len (ls_Text) > 20 then
		continue 
	end if
	
	ll_Text_Object_Height	= Long(of_describe( as_object[ll_counter] + ".height", FALSE))
	ll_Y_Pos_Orig				= Long(of_describe( as_object[ll_counter] + ".y", FALSE))
	
	
	ll_Drawer_Height = lDefaultHeight
	CHOOSE CASE ll_Type
		CASE	TRAYNONFOOD, TRAY
			// Height = 1 UNIT
			ll_Topmost_Rung = al_Row
			
		CASE DRAWER, DRAWERFOOD
			// Height = 2 UNITS
			ll_Drawer_Height *= 2
			ll_Topmost_Rung = al_Row
			
		CASE DRAWER_3RUNG, DRAWERFOOD_3RUNG
			// Height = 3 UNITS
			ll_Drawer_Height *= 3
			ll_Topmost_Rung = al_Row - 1
			
		CASE DRAWER_MULTI_RUNG
			li_Succ = of_get_rungs_and_cols( al_Row, al_Column, ll_rungs, ll_Cols )
			If	ll_rungs > 0 Then
				ll_Drawer_Height *= ll_rungs
			End If
			
			ll_Topmost_Rung = al_Row
			If ll_rungs > 2 Then
				//ll_Topmost_Rung = al_Row - 1
				ll_Topmost_Rung = al_Row + 1 - (ll_rungs - 1 )
			End If
			
	END CHOOSE
	
	
	// Calculate:
	
	ll_Y_Pos_Drawer = ii_Std_Cart_Top + ((ll_Topmost_Rung - 1) * lDefaultHeight)
	
	ll_Y_Pos_Target = ll_Y_Pos_Drawer + (ll_Drawer_Height / 2) - (ll_Text_Object_Height / 2)
	
	guoLog.uf_debug( "["+ this.classname( )+".of_vertical_center_text_within_drawer ll_Y_Pos_Target= "+String(ll_Y_Pos_Target)+"  ll_Y_Pos_Drawer=" + String(ll_Y_Pos_Drawer) + &
				"  ll_Drawer_Height="+ String(ll_Drawer_Height) + "  ll_Text_Object_Height=" + String(ll_Text_Object_Height) + &
				"  ii_Std_Cart_Top=" + String(ii_Std_Cart_Top))
	
	of_modify_dw(as_object[ll_counter] + ".y='" + String (ll_Y_Pos_Target) + "'")


Next

Return li_Return
end function

public function integer of_apply_tr_workstation_exclusions (string as_unit, ref uo_tr_cart_allocation rauo_tr_alloc, long al_airline_key, long al_routing_id, integer ai_fill_type, ref datastore rads_cartdiagramsheet);/*
* Objekt : uo_cart_diagram
* Methode: of_apply_tr_workstation_exclusions (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 17.01.2013
*
* Argument(e):
*	 string as_unit
*	 ref uo_tr_cart_allocation rauo_tr_alloc
*	 long al_airline_key
*	 long al_routing_id
*	 integer ai_fill_type
*	 ref datastore rads_cartdiagramsheet
*
* Beschreibung:		Aussteuern gem$$HEX3$$e400df002000$$ENDHEX$$Workstation Exclusion
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	17.01.2013		Erstellung
*
*
* Return: integer
*
*/


Integer		li_Succ
Long			ll_Entries
Long			ll_Workstation_Key
Long			ll_Row
Long			ll_Force_Diagram
Long			ll_EQ_Rows
Long			ll_EQ
Long			ll_Diagram_Enabled
Boolean		lb_Workstation_OFF
Boolean		lb_No_Entry
String		ls_packinglist
String		ls_Workstation
String		ls_PL_Unit

Long		ll_IndexKey //, ll_DetailKey, ll_Belly
DataStore	lds_Eq
lds_Eq	= CREATE DataStore
lds_Eq.DataObject = "dw_airlines_equipment"
lds_Eq.SetTransObject(SQLCA)
ll_EQ_Rows = lds_Eq.Retrieve(al_airline_key )

guoLog.uf_debug( "["+ this.classname( )+".of_apply_tr_workstation_exclusions BEGIN")

ll_Entries = rads_CartdiagramSheet.Rowcount()
//For ll_Row = 1 to rads_CartdiagramSheet.Rowcount()
For ll_Row = rads_CartdiagramSheet.Rowcount() to 1 step -1
//	ls_Area		   	= ""
//	ls_Workstation 	= ""
	ll_IndexKey 		= rads_CartdiagramSheet.GetItemNumber(ll_Row, "lindex_key")
//	ls_Temp_PL			= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
//	ll_DetailKey 		= rads_CartdiagramSheet.GetItemNumber(ll_Row, "ldetail_key")
//	ll_Belly 			= rads_CartdiagramSheet.GetItemNumber(ll_Row, "nbelly")
//	ls_Class				= rads_CartdiagramSheet.GetItemString(ll_Row, "sclass")
//	ls_Class_1			= rads_CartdiagramSheet.GetItemString(ll_Row, "sclass_1")
//	ls_Area 				= rads_CartdiagramSheet.GetItemString(ll_Row, "sarea")
	ls_Workstation		= rads_CartdiagramSheet.GetItemString(ll_Row, "sworkstation")
//	ls_Loadinglist		= rads_CartdiagramSheet.GetItemString(ll_Row, "sloadinglist")
//	ls_Temp_PL			= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
//	ls_Stowage 			= trim(rads_CartdiagramSheet.GetItemString(ll_Row, "sstowage"))
	ls_packinglist 		= rads_CartdiagramSheet.GetItemString(ll_Row, "spackinglist")
	ll_workstation_key	= rads_CartdiagramSheet.GetItemNumber(ll_Row, "nworkstation_key")
	
//	If isnull(ls_Class_1) then
//		guoLog.uf_debug( "["+ this.classname( )+".Warning sclass_1 is EMPTY " + ls_Temp_PL + " / " + ls_Stowage)
//		ls_Class_1 = "-"
//	end if
//
	// CBASE-NAM-CR-12033: Pruefung und Aufruf angepasst
	lb_Workstation_OFF = of_check_workstation_exclude(ll_workstation_key, al_airline_key)
	If lb_Workstation_OFF Then
		guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF local workstation exclusion " + ls_packinglist)
	End If
	
	// CBASE-NAM-CR-12071: "all those local settings are ignored and all Cart Diagrams 
	//                      will be printed and previewed for which a Cart is defined in central Master Data"
	If ib_enable_masterdata_view Then
		If lb_Workstation_OFF Then
			lb_Workstation_OFF = FALSE
			guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF locally ("+ls_Workstation+"), but ib_enable_masterdata_view=ON " + ls_packinglist)
		End If
	End If
	
	ll_Force_Diagram = 0 
	ls_PL_Unit	= rads_CartdiagramSheet.GetItemString(ll_Row, "spl_unit")
	ll_EQ			= lds_EQ.Find("cunit='" + ls_PL_Unit + "'", 1, lds_EQ.RowCount())
	If ll_EQ > 0 then	
		ll_Force_Diagram	= lds_EQ.GetItemNumber(ll_EQ, "nforce_print")
		If ll_Force_Diagram = 1 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_apply_tr_workstation_exclusions] " +ls_Workstation +" ll_Force_Diagram 1 => 0 " + ls_packinglist)
		End If
	End If
	
	lb_No_Entry = FALSE
	
   If s_app.smandant = "" or isnull( s_app.smandant) then s_app.smandant = "002"

	ll_Diagram_Enabled = of_is_cartdiagram_enabled(ll_IndexKey, s_app.sMandant, as_unit, lb_No_Entry)
	If ll_Force_Diagram = 0 Then
		// wenn nforce_print = 1, dann trotz fehlender area allocation drucken, sonst nicht
		If lb_No_Entry then
			ll_Diagram_Enabled = 0 
		End If
	End If
	
	If lb_Workstation_OFF Then
		If ll_Diagram_Enabled > 0 Then
			ll_Diagram_Enabled = 0 
			guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF locally ("+ls_Workstation+"), ll_Diagram_Enabled 1 => 0 " + ls_packinglist)
		End If
		If ll_Force_Diagram = 1 Then
			ll_Force_Diagram = 0
			guoLog.uf_debug( "["+ this.classname( )+".lb_Workstation_OFF locally ("+ls_Workstation+"), ll_Force_Diagram 1 => 0 " + ls_packinglist)
		End If
	End If
	

	if ll_Diagram_Enabled < 1 AND ll_Force_Diagram = 0 then
		guoLog.uf_debug( "["+ this.classname( )+".Counter Row " + String(ll_Row) + " Exclude " + ls_packinglist)
		
		li_Succ = rads_CartdiagramSheet.Deleterow(ll_Row)

//		CONTINUE
	else
		// Nothing

	End If		
Next

guoLog.uf_debug( "["+ this.classname( )+".of_apply_tr_workstation_exclusions END")
	

Return 1 //ll_TRCartPagesMax
end function

public function integer of_sd_draw_comp_drawer (long al_column, long al_row, ref datastore rads_distribution_contents, long al_content_master_row_id, string arg_unit, long al_master_content_setting);
/*
* Objekt : uo_cart_diagram
* Methode: of_sd_draw_comp_drawer (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 05.11.2012
*
* Argument(e):
*	 long al_column
*	 long al_row
*	 ref datastore rads_distribution_contents
*	 long al_content_master_row_id
*	 string arg_unit
*
* Beschreibung:		Drawer
*
* Aenderungshistorie:
* Version 	Wer						Wann			Was und warum
* 1.0 			Oliver Hoefer			05.11.2012	Erstellung
* 1.1 			Oliver Hoefer			22.11.2012	ge$$HEX1$$e400$$ENDHEX$$nderte Anforderung Textsize => 2 feste Stufen: normal/gross
* 1.2 			Oliver Hoefer			26.11.2012	Offener Issue - Backlog
* 1.3 			Oliver Hoefer			20.12.2012	Weitere $$HEX1$$c400$$ENDHEX$$nderungen wegen Backlog
* 1.4 			Oliver Hoefer			18.03.2013	Backlog / Content Spec
* 1.5 			Oliver Hoefer			16.04.2013	Backlog
* 1.6 			Margret N$$HEX1$$fc00$$ENDHEX$$ndel			08.05.2014 	dw_packinglist_content_edit durch dw_packinglist_edit_content ersetzt
*
*
* Return: integer
*
*/

String		ls_Filter, ls_Object, ls_Mod, lsText, lsHeaderText
long			ll_Row, lX1, lX2, lY1, lY2, lRowHeight, lYCounter, lPercentQuantity, lPercentUnit, lPercentText,  lWidthQuantity,  lWidthText
long			lContentIndexKey,  lContentDetailKey, llAdditionalYOffset
long			llMaxContent //, llMaxContentEx
long			llTextWidth
Long			ll_no_of_rungs
LOng			ll_Ancestor, ll_Found
Long			ll_Temp
Integer		li_Succ
String		ls_Text, ls_DWObject
Long			ll_index_key
Long			ll_Explosion_Counter
Long			ll_no_of_columns	= 1
Long			ll_Content_Row 
Long			ll_Item_Counter
Long			ll_Rows
Long			ll_Expl_Header_Width
Long			ll_layout_content_key_header[]
Integer		li_Content_Setting
Integer		li_Suppress_Setting
Boolean		lb_Header
Long			ll_Test_Count, ll_Temp_Key
Boolean		lb_NON_FOOD = FALSE
Boolean		lb_Header_Exists = FALSE
Decimal		ldec_Qty
String		ls_header
Boolean		lb_Content_Spec_Drawer = FALSE
s_distrib_items	lstr_item[], lstr_item_empty[], lstr_temp[]
Long			ll_Number_of_Fixed_Content, ll_index
datastore	lds_Temp
Long			ll_Content, ll_LayoutDetailKey
s_component lstr_component


ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
if ll_Found > 0 Then
	ll_Content				= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
	ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
End If

this.dsLayoutContents.SetFilter("nlayout_detail_key=" + string(ll_LayoutDetailKey))
this.dsLayoutContents.Filter() 
this.dsLayoutContents.Sort()

this.dsLayoutDimension.SetFilter("nlayout_detail_key=" + string(ll_LayoutDetailKey))
this.dsLayoutDimension.Filter()
this.dsLayoutDimension.Sort()
ll_Temp = dsLayoutDimension.RowCount() 

if this.dsLayoutContents.RowCount() = 0 Then
	// Noch nichts zugeordnet
	return 1
End If
		
//	DRAWER
llMaxContent		= iMaxRowsContent
//llMaxContentEx		= iMaxRowsContentExplosion

llMaxContent = of_get_maxcontent( al_row,al_column )
//llMaxContentEx = of_get_maxcontent( al_row, al_column   )

guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer llMaxContent " + String(llMaxContent))


llAdditionalYOffset = 0
lb_NON_FOOD = TRUE

		
// ----------------------------------------------------------------------------
// Check Content Spec f$$HEX1$$fc00$$ENDHEX$$r Drawer
// ----------------------------------------------------------------------------
If NOT ib_Disable_Content_Spec_MSG  Then
	// --------------------------------------------------------------------------------------
	// Content Sheet Indicator
	// --------------------------------------------------------------------------------------				
	lstr_item = lstr_item_empty
	ll_Found = this.dsLayoutDetail.Find("ncolumn=" + string(al_Column) + " and nrow=" + string(al_Row), 1, this.dsLayoutDetail.Rowcount())							
	if ll_Found > 0 Then
		ll_Content			= this.dsLayoutDetail.Getitemnumber(ll_Found, "ncontent")
		ll_LayoutDetailKey	= this.dsLayoutDetail.Getitemnumber(ll_Found, "nlayout_detail_key")
		li_Succ = of_get_fixed_content(ll_layoutdetailkey, ll_Content, al_row, al_column, DRAWER_MULTI_RUNG, arg_unit , 1, lstr_item, FALSE)
		ll_Number_of_Fixed_Content = upperbound(lstr_item) 

		for ll_Index = 1 to upperbound(lstr_item) 
			If trim(lstr_item[ll_Index].cpackinglist) > "" Then
				
				If ll_Index > 1 then
					continue
				end if
				
				ll_index_key = f_get_packinglist_key(lstr_item[ll_Index].cpackinglist)
				If ll_index = 1 Then
					lb_Content_Spec_Drawer = of_is_content_spec_enabled(ll_index_key , is_CSC, idt_departure )
				End if
			End if
		Next
	End if
End if		
		
		
ls_Filter = ""
For ll_Row = 1 to this.dsLayoutContents.RowCount()
	ls_Filter += "nlayout_content_key= " + string(this.dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key"))
	if ll_Row <> this.dsLayoutContents.RowCount() Then
		ls_Filter += " or "
	End If
	
	If dsLayoutContents.GetItemNumber(ll_Row, "nheader_flag" ) = 1 Then
		// This is a "header" for content sheet
		ll_layout_content_key_header[upperbound(ll_layout_content_key_header) + 1] = dsLayoutContents.Getitemnumber(ll_Row, "nlayout_content_key")
	End If
	
Next
this.dsPLContents.SetFilter(ls_Filter)
this.dsPLContents.Filter()
this.dsPLContents.Sort()

If ll_LayoutDetailKey  = 90318 Or ll_LayoutDetailKey  = 90926 Then
	li_Succ = 1
End If

// ----------------------------------------------------------
// Gibt es hier eine Header-PL?
// ----------------------------------------------------------
lb_Header_Exists = of_exists_content_sheet_header(al_column ,al_row )

li_Content_Setting = ll_Content 

If al_master_content_setting = 1 Then
	//If lb_Header_Exists = FALSE Then
	li_Content_Setting = EXPLOSION
	//End if
End If

If al_master_content_setting = -1 Then 
	li_Content_Setting = ll_Content
End If

guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer al_master_content_setting " + String(al_master_content_setting) + " C" + string(al_column) + " / R" + string(al_Row))
guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer ll_Content                " + String(ll_Content)                + " C" + string(al_column) + " / R" + string(al_Row))
guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer li_Content_Setting        " + String(li_Content_Setting)        + " C" + string(al_column) + " / R" + string(al_Row))

// ----------------------------------------------------------
// Texte neu eintragen
// Unterscheidung Content vs. Exploded Content
// ----------------------------------------------------------
if dsPLContents.RowCount() < 1 Then
	// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden

// ###### Test: alles in den Explode-Zweig - dort fallsweise suppress ermitteln #####
Else
	// -------------------------------------------------
	// EXPLOSION - alles in den Explode-Zweig - dort fallsweise suppress ermitteln
	// -------------------------------------------------
	lds_Temp = create datastore
	lds_Temp.dataobject = "dw_packinglist_edit_content"
	lds_Temp.SetTransObject(sqlca)
	
	ll_Item_Counter = 0
	For ll_Content_Row = 1 To dsPLContents.RowCount()
		lContentIndexKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "ndetail_key")
		lContentDetailKey		= this.dsPLContents.GetItemNumber(ll_Content_Row, "npackinglist_detail_detail_key")
		If ll_Content_Row = 1 then
			//lsHeaderText = f_get_packinglist( lContentIndexKey )
			//lsHeaderText = f_get_packinglist_text( lContentIndexKey, datetime(idt_departure ))
		End If
	
		ll_Rows = lds_Temp.Retrieve(lContentIndexKey, lContentDetailKey, datetime(idt_Departure), 0)
		
		If NOT ibEdit Then
			li_Suppress_Setting = of_get_explosion_setting(lContentIndexKey, arg_unit)
			Choose Case li_Suppress_Setting
			Case 1
				if il_Disable_Debug= 0 then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer EXPLODE " + string(lContentIndexKey) )			
				End If
			Case 0
				// Nicht Explosion
				lds_Temp.Reset()
				guoLog.uf_debug( "["+ this.classname( )+".*** uo_cart_diagram.of_draw_content_drawer NICHT EXPLOSION " + string(lContentIndexKey) )			
				
			Case -1
				If ll_Content <> EXPLOSION Then
					lds_Temp.Reset()
				End If
			End Choose			
		End If
		
		lds_Temp.SetSort("nsort a")
		lds_Temp.Sort()
	
		
		ls_Object = "t_content_header_" + string(0) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
		// ##################### JASPER
		If ibedit Then
			ls_Object = "t_content_header_" + string(1) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
		End If	
		
		// ------------------------------------------------------------------------------------------------------------
		// wenn mehrere PL exploded werden, dann wird header 2, 3, ... als Content eingetragen und umformatiert
		// ------------------------------------------------------------------------------------------------------------
		If ll_Content_Row > 1 Then
			ll_Item_Counter++
			ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
		End If
		of_modify_dw(ls_Object + '.font.weight="700"')
		// Header eintragen
		// 11.01.2010 Ulrich Paudler [UP]
		lstr_component.stext = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext")
		lstr_component.ssnr = this.dsPLContents.GetItemString(ll_Content_Row, "cen_packinglist_index_cpackinglist")
		// -------------------------------------
		// Header?
		// -------------------------------------
		lb_Header = FALSE
		ll_Temp_Key = dsPLContents.GetItemNumber(ll_Content_Row, "nlayout_content_key")
		For ll_Test_Count = 1 To upperbound(ll_layout_content_key_header)
			If ll_Temp_Key = ll_layout_content_key_header[ll_Test_Count] Then
				lb_Header = TRUE		
			End If
		Next
		If lb_header Then
			If il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer HEADER FLAG " + dsPLContents.GetItemString(ll_Content_Row, "cen_packinglists_ctext"))
			End If
		End If
						
		// ------------------------------------------------------------------------------------------------------------
		// 01.10.2010 Downline Watermark
		//  Downline Watermark an einem Drawer, der Teil einer Packing List ist: Dies wird im Content der Packing List 
		// in der Spalte "Leg" gepflegt (Leg-Nummer >1)	
		// ------------------------------------------------------------------------------------------------------------
		ii_PL_Leg_Number			= this.dsPLContents.GetItemNumber(ll_Content_Row, "nleg_number")
		If IsnULL(ii_PL_Leg_Number) Then ii_PL_Leg_Number = 0
	
		// ------------------------------------------------------------------------------------------------------------	
		// 30.03.2011, KF: Menge war immer blank!?!?!?
		// ------------------------------------------------------------------------------------------------------------
		// lstr_component.squantity	= ""
		// ------------------------------------------------------------------------------------------------------------
		if (this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity") <> 1.0 OR ib_suppress_qty_1 = FALSE) Then
			lstr_component.squantity	= string( this.dsPLContents.GetItemNumber(ll_Content_Row, "nquantity"))
			If il_Disable_Debug=0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer QUANTITY HINZU " + lstr_component.ssnr )
			End If
		Else
			lstr_component.squantity = ""
		End If
		lsHeaderText =  of_get_item_description(lstr_component)
		// ------------------------------------------------------------------------------------------------------------
		// wenn mehrere PL exploded werden, dann wird Header Nummer 2, 3,... als Content eingetragen und umformatiert
		// ------------------------------------------------------------------------------------------------------------
		If ll_Content_Row > 1 Then
			//guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer EXPLODE & BOLD " + lsHeaderText)
			ll_Expl_Header_Width = Integer(llTextWidth * .95 ) + lWidthQuantity 
		End If
		
		// ------------------------------------------------------------------------------------------------------------
		// wenn f$$HEX1$$fc00$$ENDHEX$$r die St$$HEX1$$fc00$$ENDHEX$$ckliste in Area Allocation "suppress" eingestellt ist: keine Inhalte zeigen
		// ------------------------------------------------------------------------------------------------------------
		If of_explode(lContentIndexKey, arg_unit, al_master_content_setting , ll_Content ) = FALSE Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer SUPPRESS " + lstr_component.ssnr)
			If dsPLContents.RowCount() = 1 AND ll_Content_Row = 1 Then
				//If li_Suppress_Setting = 0 Then
//					ll_index_key = f_get_packinglist_key( lstr_component.ssnr )
				If of_check_explode(lContentIndexKey, arg_unit) Then
					of_adjust_text_size_small_big({ls_Object}, iMaxRowsContent)
					li_Succ = of_vertical_center_text_within_drawer( {ls_Object}, al_column, al_row)
				End If
			End If
		
			CONTINUE
		Else
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer Parent = CONTENT => EXPLODE " + lstr_component.ssnr)
		End If
		
		
		ll_Item_Counter = ll_Content_Row
		// ------------------------------------
		// Details eintragen
		// ------------------------------------
		for ll_Row = 1 to lds_Temp.RowCount()
			ll_Item_Counter++
			// Mehr als angezeigt werden kann
			//if ll_Item_Counter >= llMaxContentEx Then //and lds_Temp.RowCount() > llMaxContentEx Then
			//if ll_Item_Counter >= llMaxContentEx  and (lds_Temp.RowCount() > llMaxContentEx ) Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer ll_Item_Counter=" + String(ll_Item_Counter) + &
							" lds_Temp.RowCount="+ String(lds_Temp.RowCount()) + &
							" ll_Content_Row="+ String(ll_Content_Row) )

			if ll_Item_Counter >= llMaxContent  and (lds_Temp.RowCount() + ll_Content_Row > llMaxContent ) Then
			
				lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
				lstr_component.ssnr  = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
				lstr_component.squantity	= ""
				lsText =  of_get_item_description(lstr_component)
				
				if ll_Item_Counter = llMaxContent Then	
					
					if of_is_backlog_enabled() Then
						// Text eintragen ..						
						//ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
						ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
						
						// ##################### JASPER
						If ibedit Then
							ls_Object = "t_content_text_" + string(ll_Row + 1) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
						End If	
						
						If ll_Content_Row > 1 Then
							ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
						End If						
						// 12.01.2010 Ulrich Paudler [UP]
						If lb_Content_Spec_Drawer Then
							of_modify_text( ls_Object, is_Overflow_MSG_3) // see cs and overflow
							guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr + " " + is_Overflow_MSG_3)
						Else
							of_modify_text( ls_Object, is_Overflow_MSG_2)
							guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr + " " + is_Overflow_MSG_2)
						End if
						
						//guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer BACKLOG " + lstr_component.ssnr)
					Else
						// Menge eintragen ..
						ls_Object = "t_content_quantity_" + string(ll_Row) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
						ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
						//ls_Mod = ls_Object + ".text='" + lds_Temp.GetItemString(ll_Row, "cpackinglist_text") + "'"
					End If
					
					// ----------------------------------------------------------------------------------------------------
					// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
					// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
					//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
					//							 should appear automatically and a Content spec should be generated
					// ----------------------------------------------------------------------------------------------------
					If ib_non_sky then
						of_modify_text(ls_Object, is_Overflow_MSG_1)
						guoLog.uf_debug( "["+ this.classname( )+".of_sd_draw_comp_drawer non sky BACKLOG => CONTENT SPEC " + lstr_component.ssnr)
						// add content spec ###########					
					End If
					
				End If
	
				// Backlog
				of_sd_add_content_backlog_drawer(ll_Row , al_Row, al_Column, lds_Temp,  DRAWER , lsHeaderText, al_content_master_row_id )		
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_distributed_components BACKLOG " + lsHeaderText + " / " + lsText )

				// ----------------------------------------------------------------------------------------------------
				// CBASE-NAM-CR-16008 Content Specs should follow the logic currently used for Overflow reports
				// 						 Meaning if the content of a placeholder on a Cart Diagram or a Transporter Cart
				//							 doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator >>Use content spec to display all Items<<
				//							 should appear automatically and a Content spec should be generated
				// ----------------------------------------------------------------------------------------------------
				If ib_non_sky then
					of_modify_text(ls_Object, is_Overflow_MSG_1)
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_comp_tray non sky BACKLOG => CONTENT SPEC " + lsHeaderText + " /" + lsText) 
					// add content spec ###########					
				End If

			Else
				// --------------------------------------------------
				// Normalfall: Menge / Text  eintragen
				// --------------------------------------------------
				// Menge eintragen ..
				ls_Object = "t_content_quantity_" + string(ll_Row) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
				If ll_Content_Row > 1 Then
					ls_Object = "t_content_quantity_" + string(ll_Item_Counter) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
				End If				
				ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
				If ll_Content_Row > 1 Then
					ls_Object = "t_content_text_" + string(ll_Item_Counter) + "_col_" + string(al_column, "00") + "_row_" + string(al_Row, "00")
				End If
				lstr_component.stext = lds_Temp.GetItemString(ll_Row, "cpackinglist_text")
				lstr_component.ssnr = lds_Temp.GetItemString(ll_Row, "cpackinglist_detail")
				lstr_component.squantity = ""
				lsText =  of_get_item_description(lstr_component)
			End If
		Next
	Next	
End If

if IsValid(lds_Temp) then destroy lds_Temp


Return 1

end function

public function boolean of_is_backlog_enabled_by_setup ();/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_is_backlog_enabled_by_setup (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 28.10.2009
* Argument(e):
* none
*
* Return: boolean
*
*
* Pr$$HEX1$$fc00$$ENDHEX$$fung ob die Backlogliste eingeschaltet ist
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  28.10.2009	1.0           Ulrich Paudler     Erstellung
*  02.02.2012	1.1           Oliver H$$HEX1$$f600$$ENDHEX$$fer       Schalter "Parameter statt Profile" (Service)
*                                               Variante "Section aus Instanzvariable" (WEB)
*
*************************************************************/

string sValue, ssection
Integer	iConfig

// ----------------------------------------------------------------------
// 24.01.2012 bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_nenable_overflow = 1 then
		return TRUE
	ELSE
		return FALSE
	end if
End If

ilCartDiagramBacklogCounter++

If is_section > "" Then
	sSection = is_section
Else
	sSection = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
	if trim(sSection) = "" Then sSection = "docbrowser"
	is_section = sSection
End If


If isCartDiagramBacklogSection = sSection Then
	If Trim(isCartDiagramBacklog) > "" AND NOT IsNULL(isCartDiagramBacklog) then
		// Use cached value
		if isCartDiagramBacklog = "1" Then 
			return True
		ElseIf isCartDiagramBacklog = "0" Then 
			return FALSE			
		End if
	End if
End If

If isCartDiagramBacklogSection = "" Then isCartDiagramBacklogSection = sSection

//if sSection <> "docbrowser" Then
//	iConfig = integer(Mid(sSection,11))
//	sSection ="Default" +string(iConfig)
//Else
//	sSection ="Default"
//End If
//

sValue = of_profilestring(s_app.suser, sSection, "PRINTCARTDIAGRAMBACKLOG","0") 

isCartDiagramBacklog = sValue

if sValue = "1" Then
	return True
End If

return False

end function

public function long of_sd_create_tr_component_list (long al_row_id[], ref uo_distribution rauo_distribution, ref datastore rads_trcartdiagram);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_create_tr_component_list (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
* long al_row_id
*
* Beschreibung:		Transporter Cart Diagram - List of Components
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	15.10.2012		Erstellung
* 1.1 			O.Hoefer	18.10.2012		$$HEX1$$c400$$ENDHEX$$nderung der Position des Textes "Weitere Elemente existieren..."
* 1.2 			O.Hoefer	04.04.2013		Bugfix Doppelte Eintr$$HEX1$$e400$$ENDHEX$$ge
* 1.3 			O.Hoefer	05.04.2013		Bugfix Doppelte Eintr$$HEX1$$e400$$ENDHEX$$ge
* 1.4 			O.Hoefer	22.10.2013		Bugfix TR ohne CD leere Liste
* 1.5 			O.Hoefer	19.10.2017		TR Component List Overflow
* 1.6 			O.Hoefer	25.10.2017		TR Component List Overflow
* 1.7 			O.Hoefer	24.03.2020		#4984 Adjust sorting of item lists on cart diagram
* 2.0 			O.Hoefer	03.08.2022		#6466 Space for Barcode on TR
*
*
* Return: long
*
*/

//ib_Barcode_on_TR

Integer	li_Succ
String	lsRet
Long		ll_RowId
Long		ll_Row
String	ls_ObjectName, ls_Text, sValue
Long		ll_Index, ll_Num_Components
Long		llX, llY, llHeight, llWidth, llYMax, llWidthAmount, ll_Space
Long		ll_Barcode_Space = 0
Boolean	lb_Breakpoint
String	ls_Original_Sort
Boolean	lb_Sort_by_PL_Class_Leg, lb_Sort_by_Class_Desc_Leg
Boolean	lb_Consolidate_Entries
Boolean	lb_Found_Double_Entry
String	ls_Section, ls_Default
String	ls_Filter	
Long		ll_Rows	
Integer	iConfig
Long		ll_Count
Long		ll_Comp_Counter, ll_Temp_Counter
String	ls_Temp_text, ls_temp_PL
Long		ll_Temp_Qty
Long		ll_Target_Index
String	ls_Stowage, ls_Galley, ls_Stowage_Only, ls_packinglist
Long		ll_galley, ll_Belly
Long		ll_Row_Id_Counter
Long		ll_Row_ID
Boolean	lb_Both
Long		ll_Count_TR
s_component	lstr_Component[]


llX				=  20
llY				=  10 //56
llYMax			= 825 - 50
llHeight			=  10
llWidth			= 142
llWidthAmount	=  30
ll_Space			=   5
ll_Barcode_Space = 130

If of_is_tr_barcode_enabled( ) THEN
	llYMax -= ll_Barcode_Space
	guoLog.uf_debug( "["+ this.classname( )+".of_sd_create_tr_component_list BARCODE llYMax  "+String(llYMax+ll_Barcode_Space)+" => " + String(llYMax) )
END IF

ll_Rows = ids_SD_Components.retrieve(il_result_key, il_transaction )
//if s_app.itrace > 0 then ids_SD_Components.saveas("c:\temp\cbase\ids_SD_Components_01_" +String(cpu())+".xls",excel5!,true )

//ids_SD_Components.reset()
//	ll_Rows = rauo_cart_diagram.ids_SD_Components.retrieve(rauo_cart_diagram.il_result_key, rauo_cart_diagram.il_transaction )

If ll_Rows < 1 then
//	// Liste LEER => neu f$$HEX1$$fc00$$ENDHEX$$llen
//	
	For ll_Row = 1 to rads_TRCartDiagram.Rowcount()
		// Liste der Komponenten f$$HEX1$$fc00$$ENDHEX$$llen
		ls_Stowage			= trim(rads_TRCartDiagram.GetItemString(ll_Row, "sstowage"))
		ls_Galley			= Left(ls_Stowage, pos(ls_Stowage, "-") -1 )
		ls_Stowage_Only	= mid(ls_Stowage, pos(ls_Stowage, "-") +1 )
		ll_Belly 			= rads_TRCartDiagram.GetItemNumber(ll_Row, "nbelly")
		ls_packinglist 	= rads_TRCartDiagram.GetItemString(ll_Row, "spackinglist")
		ll_RowId				= rads_TRCartDiagram.GetItemNumber(ll_Row, "nrowid")
		For ll_Row_Id_Counter = 1 To Upperbound(al_Row_Id)
			If al_Row_Id[ll_Row_Id_Counter] = ll_RowId Then
				li_Succ = of_sd_fill_component_list( rauo_Distribution, al_Row_Id[ll_Row_Id_Counter], ls_Stowage, ls_packinglist, ll_Belly)
			End If
		Next
	Next
End If

				
ll_Rows = ids_SD_Components.rowcount()
//if s_app.itrace > 0 then ids_SD_Components.saveas("c:\temp\cbase\ids_SD_Components_02_" +String(cpu())+".xls",excel5!,true )
// ----------------------------------------------------------------------
// bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 1 then
		lb_Sort_by_PL_Class_Leg = TRUE
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_PL_Class_Leg = FALSE
	end if
	
	If inv_doc_gen_settings.il_nenable_cart_comp_sort_by_pl_class = 2 then
		lb_Sort_by_Class_Desc_Leg = TRUE
		lb_Sort_by_PL_Class_Leg = FALSE 
		If inv_doc_gen_settings.il_nenable_cart_comp_distinct_pl = 1 Then
			lb_Consolidate_Entries = TRUE
		End If
	ELSE
		lb_Sort_by_Class_Desc_Leg = FALSE
	end if
	
Else
	
	If is_section > "" Then
		ls_Section = is_section
	Else
		ls_Section = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(ls_Section) = "" Then ls_Section = "docbrowser"
	End if
	
	if ls_Section <> "docbrowser" Then
		iConfig = integer(Mid(ls_Section,11))
		ls_Default ="Default" +string(iConfig)
	Else
		ls_Default ="Default"
	End If
	
	sValue = of_profilestring(s_app.suser,ls_Default,"CartDiagramCompSort","0") 
	If sValue = "1" Then
		lb_Sort_by_PL_Class_Leg = TRUE
		lb_Sort_by_Class_Desc_Leg = FALSE
	End If
	// #4984 Additional Sort Order
	If sValue = "2" Then
		lb_Sort_by_PL_Class_Leg = FALSE
		lb_Sort_by_Class_Desc_Leg = TRUE
	End If
	
	
	sValue = of_profilestring(s_app.suser,ls_Default,"CartDiagramCompDistinct","0") 
	If sValue = "1" Then
		lb_Consolidate_Entries = TRUE
	End if
End if

//li_Succ = ids_SD_Components.SetFilter("nrowid=" + String(al_Row_id))
For ll_Count = 1 To upperbound(al_Row_id)
//	ls_Filter += String(al_Row_id[ll_Count])
//	ls_Filter+= ","
//	ls_Filter += String(1000000 + al_Row_id[ll_Count])	
//	If ll_Count < upperbound(al_Row_id) Then ls_Filter+= ","

	// ohne CD
	ls_Filter += String(1000000 + al_Row_id[ll_Count])	
	If ll_Count < upperbound(al_Row_id) Then ls_Filter+= ","

Next
li_Succ = ids_SD_Components.SetFilter("nrowid in (" + ls_Filter + ")")
li_Succ = ids_SD_Components.Filter()
ll_Num_Components = ids_SD_Components.RowCount()


// 22.10.2013
If ll_Num_Components = 0 Then
	ls_Filter=""
	For ll_Count = 1 To upperbound(al_Row_id)
		// aus CD ohne TR
		ls_Filter += String(al_Row_id[ll_Count])	
		If ll_Count < upperbound(al_Row_id) Then ls_Filter+= ","
	Next
	li_Succ = ids_SD_Components.SetFilter("nrowid in (" + ls_Filter + ")")
	li_Succ = ids_SD_Components.Filter()
	ll_Num_Components = ids_SD_Components.RowCount()
End If


If lb_Sort_by_PL_Class_Leg Then	
	li_Succ = ids_SD_Components.SetSort("cpackinglist A, nclass_number A, cmeal_control_code A")
	li_Succ = ids_SD_Components.Sort()
Else
	li_Succ = ids_SD_Components.SetSort("nclass_number A, cpackinglist A, cmeal_control_code A")
	li_Succ = ids_SD_Components.Sort()
end if

// #4984 Adjust sorting of item lists on cart diagram
If lb_Sort_by_Class_Desc_Leg then
	li_Succ = ids_SD_Components.SetSort("nclass_number A, ctext A, cmeal_control_code A")
	li_Succ = ids_SD_Components.Sort()
End If

//if s_app.itrace > 0 then ids_SD_Components.saveas("c:\temp\cbase\ids_SD_Components_03_" +String(cpu())+".xls",excel5!,true )


// Keine Daten dann raus
if ll_Num_Components < 1 Then 
	if il_Disable_Debug = 0 Then
		guoLog.uf_debug( "["+ this.classname( )+".of_create_component_list upperbound(arg_component) < 1 RETURN")
	end if
	return 0
End If


If lb_Sort_by_PL_Class_Leg Then	
	ls_Original_Sort = ids_sd_components.Describe("DataWindow.Table.Sort")
	//li_Succ = ids_SD_Components.SetSort("cpackinglist A, nclass_number A, cmeal_control_code A")
//	li_Succ = ids_SD_Components.Sort()
//	ls_Original_Sort = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Describe("DataWindow.Table.Sort")
//	li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.SetSort("cpackinglist A, nclass_number A, cmeal_control_code A")
//	li_Succ = rauoDistribution.uoStowages[ll_Stowage_Counter].dsContent.Sort()
end if

// Umsortieren?
If lb_Consolidate_Entries Then
	ls_Temp_text = ids_sd_components.GetItemString(1, "ctext")
	ls_Temp_PL   = ids_sd_components.GetItemString(1, "cpackinglist") 
	lstr_Component[1].stext											= ids_sd_components.GetItemString(1, "ctext")  
	lstr_Component[1].ssnr											= ids_sd_components.GetItemString(1, "cpackinglist")
	lstr_Component[1].lquantity									= ids_sd_components.GetItemNumber(1, "nquantity") 
	lstr_Component[1].squantity									= ""
	lstr_Component[1].llength										= ids_sd_components.GetItemNumber(1, "nlength")
	lstr_Component[1].str_item_props.stext						= ids_sd_components.GetItemString(1, "CDISTR_TEXT") 
	lstr_Component[1].str_item_props.smeal_control_code	= ids_sd_components.GetItemString(1, "CMEAL_CONTROL_CODE") 
	lstr_Component[1].str_item_props.sclass					= ids_sd_components.GetItemString(1, "cclass")
	lstr_Component[1].str_item_props.lspml						= ids_sd_components.GetItemNumber(1, "nspml") 
	lstr_Component[1].str_item_props.llimit = 0
	If ids_sd_components.RowCount() > 1 Then
		For ll_Comp_Counter = 2 To ids_sd_components.RowCount()
			lb_Found_Double_Entry = FALSE
			ls_Temp_text = ids_sd_components.GetItemString(ll_Comp_Counter, "ctext") 
			ls_Temp_PL   = ids_sd_components.GetItemString(ll_Comp_Counter, "cpackinglist")
			
			If Upperbound(lstr_Component) > 0 then
				For ll_Temp_Counter = 1 To Upperbound(lstr_Component)
					IF lstr_Component[ll_Temp_Counter].stext = ls_Temp_text AND &
						lstr_Component[ll_Temp_Counter].ssnr  = ls_temp_PL Then
						lb_Found_Double_Entry = TRUE
						//ll_Temp_Qty = ids_sd_components.GetItemNumber(ll_Temp_Counter, "nquantity")
						ll_Temp_Qty = ids_sd_components.GetItemNumber(ll_Comp_Counter, "nquantity")
						lstr_Component[ll_Temp_Counter].lquantity = lstr_Component[ll_Temp_Counter].lquantity + ll_Temp_Qty						
					End If
				Next
			End If
			
			If lb_Found_Double_Entry = FALSE then
				ll_Target_Index = upperbound(lstr_Component) + 1
				lstr_Component[ll_Target_Index].stext		= ids_sd_components.GetItemString(ll_Comp_Counter, "ctext") 
				lstr_Component[ll_Target_Index].ssnr  		= ids_sd_components.GetItemString(ll_Comp_Counter, "cpackinglist") 
				lstr_Component[ll_Target_Index].lquantity = ids_sd_components.GetItemNumber(ll_Comp_Counter, "nquantity")
				lstr_Component[ll_Target_Index].squantity = ""
				lstr_Component[ll_Target_Index].llength 	=  ids_sd_components.GetItemNumber(ll_Comp_Counter, "nlength") 
				lstr_Component[ll_Target_Index].str_item_props.stext					= ids_sd_components.GetItemString(ll_Comp_Counter, "CDISTR_TEXT")
				lstr_Component[ll_Target_Index].str_item_props.smeal_control_code = ids_sd_components.GetItemString(ll_Comp_Counter, "CMEAL_CONTROL_CODE")
				lstr_Component[ll_Target_Index].str_item_props.sclass					= ids_sd_components.GetItemString(ll_Comp_Counter, "cclass")
				lstr_Component[ll_Target_Index].str_item_props.lspml					= ids_sd_components.GetItemNumber(ll_Comp_Counter, "nspml")
				lstr_Component[ll_Target_Index].str_item_props.llimit = 0
				
			end if
		Next
	End if	
Else
	For ll_Comp_Counter = 1 To ids_sd_components.RowCount()
		ll_Target_Index = upperbound(lstr_Component) + 1
		lstr_Component[ll_Target_Index].stext		= ids_sd_components.GetItemString(ll_Comp_Counter, "ctext") 
		lstr_Component[ll_Target_Index].ssnr  		= ids_sd_components.GetItemString(ll_Comp_Counter, "cpackinglist") 
		lstr_Component[ll_Target_Index].lquantity = ids_sd_components.GetItemNumber(ll_Comp_Counter, "nquantity") 
		lstr_Component[ll_Target_Index].squantity = ""
		lstr_Component[ll_Target_Index].llength 	=  ids_sd_components.GetItemNumber(ll_Comp_Counter, "nlength") 
		lstr_Component[ll_Target_Index].str_item_props.stext					= ids_sd_components.GetItemString(ll_Comp_Counter, "CDISTR_TEXT")  
		lstr_Component[ll_Target_Index].str_item_props.smeal_control_code = ids_sd_components.GetItemString(ll_Comp_Counter, "CMEAL_CONTROL_CODE")
		lstr_Component[ll_Target_Index].str_item_props.sclass					= ids_sd_components.GetItemString(ll_Comp_Counter, "cclass") 
		lstr_Component[ll_Target_Index].str_item_props.lspml					= ids_sd_components.GetItemNumber(ll_Comp_Counter, "nspml") 
		lstr_Component[ll_Target_Index].str_item_props.llimit = 0
	Next
End if

ll_Num_Components = upperbound(lstr_Component)

ls_ObjectName= "t_components_header"
ls_Text			= uf.translate("Mahlzeitenkomponenten")
of_create_text(ls_ObjectName, ls_Text,FONT_MS_SANS_SERIF, 8, FONT_BOLD, llX, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)
llY = llY+ 2 * llHeight 

For ll_Index = 1 to ll_Num_Components
	ls_ObjectName= "t_components_data_amount_" + string(ll_Index)
	
	ls_Text = string(lstr_Component[ll_Index].lquantity)
	
	if llY <= llYMax Then
		of_create_text(ls_ObjectName, ls_Text,FONT_MS_SANS_SERIF, 14, FONT_NORMAL, llX   , llY +  0.2 * llHeight , 2 *  llHeight , llWidthAmount, 0, 0,  RGB(0,0,0), 1)
	End If
	ls_ObjectName= "t_components_data_text_" + string(ll_Index)
	ls_Text = lstr_Component[ll_Index].stext
	if llY <= llYMax Then
		of_create_text(ls_ObjectName, ls_Text,FONT_MS_SANS_SERIF, 8, FONT_NORMAL, llX + llWidthAmount +ll_Space, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)
	End If
	llY = llY+ llHeight
	
	ls_ObjectName= "t_components_data_snr_" + string(ll_Index)
	ls_Text =lstr_Component[ll_Index].ssnr
	if llY <= llYMax Then
		of_create_text(ls_ObjectName,ls_Text,FONT_MS_SANS_SERIF, 8, FONT_NORMAL, llX +llWidthAmount +ll_Space, llY, llHeight , llWidth, 0, 0,  RGB(0,0,0), 1)
	End If
		
	//llY = llY + 2 * llHeight
	
	if llY > llYMax Then
		ll_Row_ID = ii_tr_counter
		
		ls_Text = string(lstr_Component[ll_Index].lquantity) + " x " + lstr_Component[ll_Index].ssnr + " - " + lstr_Component[ll_Index].stext
		
		li_Succ = of_sd_add_backlog( 0, 0, "", 0 , "", ls_Text, ll_Index, LISTOFCOMPONENTS, ls_Text, ll_Row_ID ) 
		guoLog.uf_debug( "["+ this.classname( )+".of_sd_create_tr_component_list BACKLOG  ("+String(al_row_id[1])+") " + ls_Text )

	End If
	
	llY = llY + 2 * llHeight
		
Next

if llY > llYMax Then
	llY = llYMax //- llHeight
	ls_ObjectName= "t_components_end"
	of_create_line(ls_ObjectName,llX - 10 , llY, llX + llWidth , llY, RGB(128, 128, 128))
	llY = llY+ llHeight
	ls_Text			= uf.translate("Weitere Elemente existieren...")
	of_create_text(ls_ObjectName, ls_Text,FONT_MS_SANS_SERIF, 8, FONT_BOLD, llX, llY, llHeight , llWidth, 0, 0,  RGB(255,0,0), 1)
Else
//	ls_Text			= "End"
End If

li_Succ = ids_SD_Components.SetFilter("")
li_Succ = ids_SD_Components.Filter()
ll_Num_Components = ids_SD_Components.RowCount()

If lb_Sort_by_PL_Class_Leg Then	
	//li_Succ = ids_SD_Components.SetSort(ls_Original_Sort)
	li_Succ = ids_SD_Components.Sort()
end if


Return ll_Num_Components

end function

public function integer of_sd_init_flight (long al_result_key, long al_transaction, boolean ab_require_exact_match, string as_csc, long al_airline_key);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_init_flight (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long al_result_key
*	 long al_transaction
*	 boolean ab_require_exact_match
*
* Beschreibung:		Initialize Result Key / Transation for Current Flight
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: integer
*
*/

String	ls_Value
Long		ll_Value, ll_Value_2

// Set Result Key and Transaction
il_result_key				= al_result_key
il_transaction				= al_transaction
ib_require_exact_match	= ab_require_exact_match
is_CSC						= as_CSC	

  SELECT cdeparture_time,   
         ckitchen_time  , naircraft_key
    INTO :is_Departure_Time,   
         :is_Kitchen_Time  ,
			:il_Aircraft_Key
    FROM cen_out  
   WHERE cen_out.nresult_key = :al_result_key;

ls_Value = f_unitprofilestring("w_local_cart_diagram" , "SUPPRESS_QTY_1" , "0" , as_CSC) 
If ls_Value = "1" Then 
	ib_suppress_qty_1 = TRUE
Else
	ib_suppress_qty_1 = FALSE
End if

  SELECT nforce_overflow_ind , NPRINT_OVERFLOW_ON_MAIN 
    INTO :ll_Value , :ll_Value_2 
    FROM cen_airlines  
   WHERE nairline_key = :al_airline_key   ;
		
IF ll_Value = 1 Then
	ib_Force_Overflow = TRUE
Else
	ib_Force_Overflow = FALSE
End If

ib_Print_Overflow = of_is_backlog_enabled_by_setup()

if of_check_non_sky(as_csc) then
	// NON Sky => n overflow => CONTENT SPEC
	//ib_Print_Overflow = FALSE
end if

IF ll_Value_2 = 1 Then
	ib_Overflow_on_Main = TRUE
Else
	ib_Overflow_on_Main = FALSE
End If

if ib_non_sky then
	ib_Overflow_on_Main = FALSE
end if


Return 1



end function

public function boolean of_exists_tr_cart_per_unit (string as_unit);/*
* Objekt : uo_cart_diagram
* Methode: of_exists_tr_cart_per_unit (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 06.02.2013
*
* Argument(e):
* string as_unit
*
* Beschreibung:		Are there any TR Cart Entries Set Up for a certain CSC
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	06.02.2013		Erstellung
*
*
* Return: boolean
*
*/


Boolean	lb_Return
Long		ll_Count


lb_Return = FALSE

select	count(*) 
into		:ll_Count
from		loc_unit_tr_cart 
where		cunit = :as_unit;

If ll_Count > 0 then
	lb_Return = TRUE
End If

Return lb_Return
end function

public function boolean of_is_healthmark_enabled (string as_unit);/*
* Objekt : uo_delivery_note
* Methode: is_healthmark_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 16.04.2013
*
* Argument(e):
* none
*
* Beschreibung:		Healthmark Schalter pro CSC
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	16.04.2013		Erstellung
*
*
* Return: boolean
*
*/


// Check Healthmark-Switch
String	ls_HM

ls_HM = f_unitprofileString("HEALTHMARK", "ENABLED", "FALSE", as_Unit)

If upper(ls_HM) = "TRUE" Then
	Return TRUE
Else
	Return FALSE
End If
	
end function

public function integer of_create_cd_backlog_page (ref long ral_backlogpages, long al_row, long al_cartpages, ref long ral_filecounter, ref string ras_pdffiles[], ref uo_documents rauo_product, string as_rampbox, string as_stowage, string as_packinglist, string as_pl_description, string as_loadinglist, string as_class, string as_workstation, string as_version, string as_container, integer ai_flightnumber, string as_suffix, string as_header, string as_from, string as_to, string as_actype, long al_belly, string as_time, string as_owner, string as_area, string as_class_string, long al_backlogpages, string as_current_printer_1, string as_unit);/*
* Objekt : uo_client_label
* Methode: of_create_cd_backlog_page (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.08.2012
*
* Argument(e):
* ref uo_cart_diagram rauo_diagram
*	 ref long ral_backlogpages
*	 long al_row
*	 long al_cartpages
*	 ref long ral_filecounter
*	 ref string ras_pdffiles[]
*	 ref uo_documents rauo_product
*	 string as_rampbox
*	 string as_stowage
*	 string as_packinglist
*	 string as_pl_description
*	 string as_loadinglist
*	 string as_class
*	 string as_workstation
*	 string as_version
*	 string as_container
*	 integer ai_flightnumber
*	 string as_suffix
*	 string as_header
*	 string as_from
*	 string as_to
*	 string as_actype
*	 long al_belly
*	 string as_time
*	 string as_owner
*	 string as_area
*	 string as_class_string
*	 long al_backlogpages
*	 string as_current_printer_1
*
* Beschreibung:		Print Backlog Page (PDF)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.08.2012		Erstellung
* 1.1 			O.Hoefer	17.04.2013		UK Healthmark
*
*
* Return: integer
*
*/

Blob	lb_Blob
String		ls_File_Prefix, ls_Cart_Page_PDF_Name
String		ls_Cart_Page_PSR_Name
Integer		li_Succ
DataStore	lds_Datastore


lds_Datastore = CREATE DataStore


// Backlog drucken
if of_is_backlog_enabled() and of_get_backlog_rowcount()> 0 then
	ral_BacklogPages++			
	//guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR BACKLOG "+ as_packinglist)							
	if isvalid(w_progress_with_cancel) then
		// wurde abgebrochen?
		if w_progress_with_cancel.bCancel then
			return -1000
		End If
		w_progress_with_cancel.wf_setposition(al_Row)
		w_progress_with_cancel.wf_setstatus( uf.translate("Seite ") +  string(al_CartPages) )
	End If
	of_print_prepare_backlog(as_current_printer_1 , rauo_Product.sAirline, ai_FlightNumber, as_Suffix, &
													as_Header, as_From, as_To, as_ACType, as_Stowage, al_BacklogPages, al_Belly, &
													idt_Departure, as_Time, as_Class_String, as_Container, as_Owner, as_Version, as_Area, &
													as_Workstation, as_Loadinglist)
	of_print_init()
	of_print_prepare_new_h_f(as_Loadinglist, as_packinglist, as_pl_description, as_rampbox, as_Stowage, &
									as_Class, as_Workstation, "", TRUE)
	// Leerseiten
	odsbacklog.SetFilter("trim(cbacklog)>'' or trim(cobject)>''")
	odsbacklog.Filter()
	
	// --------------------------------------------------------------
	// UK Healthmark
	// --------------------------------------------------------------
	If of_is_healthmark_enabled(as_unit) Then
		li_Succ = of_draw_healthmark( as_unit, TRUE )
	End If
		
	// --------------------------------------------------------------
	// SORTIERUNG 16.03.2011
	// --------------------------------------------------------------				
	odsbacklog.Sort()
	odsbacklog.GroupCalc()
	
//	If s_app.itrace > 0 then
//		odsbacklog.saveas( f_gettemppath() + ls_File_Prefix + String(al_CartPages,"000") + "_ODS_BACKLOG_" + String(now(), "hhmmssfff") + ".PDF"	, PSReport!, TRUE)
//		odsbacklog.saveas( f_gettemppath() + ls_File_Prefix + String(al_CartPages,"000") + "_ODS_BACKLOG_" + String(now(), "hhmmssfff") + ".xls", Excel5!, TRUE)
//	EnD IF
	
	
	// Druckfertiges DW in DS kopieren
	of_getfullstate_backlog( lb_Blob)
	lds_Datastore.SetFullState(lb_Blob)

	lds_Datastore.SetSort("ntype A, ncolumn A, nrow A, cpackinglist A, ncounter A")
	lds_Datastore.Sort()
	
	
	lds_Datastore.Sort()
	lds_Datastore.GroupCalc()
	
	ral_FileCounter++
	//ras_PdfFiles[ral_FileCounter] = f_gettemppath() + "CBASE-CARTDIAGRAM-BACKLOG-" + String(Rand(32767)) + String(now(), "hhmmssfff") + ".PDF"

//	ls_File_Prefix = f_get_airline_name(al_airline_key )
	ls_File_Prefix = as_owner
	ls_File_Prefix += String(ai_flightnumber , "000") + "_" + as_From + "_" + as_to + "_" +String(idt_departure, "YYYYMMDD")
	ls_File_Prefix += "_CD_" + String(il_transaction) + "_" 
	ls_Cart_Page_PDF_Name =  "_" + ls_File_Prefix + String(al_CartPages,"000") + "_BACKLOG_" + String(now(), "hhmmssfff") + ".PDF"	
	ls_Cart_Page_PSR_Name =  "_" + ls_File_Prefix + String(al_CartPages,"000") + "_BACKLOG_" + String(now(), "hhmmssfff") + ".PSR"	
	ras_PdfFiles[ral_FileCounter] = f_gettemppath() + ls_Cart_Page_PDF_Name
	
	If s_app.itrace > 0 then
//		lds_Datastore.saveas( f_gettemppath() + ls_Cart_Page_PSR_Name, PSReport!, TRUE)
//		lds_Datastore.saveas( f_gettemppath() + ls_Cart_Page_PSR_Name + ".xls", Excel5!, TRUE)
	EnD IF
	
	rauo_Product.icartdiagramsheet		= 1
	
	If of_create_acrobat(lds_Datastore, ras_PdfFiles[ral_FileCounter])=-1 Then
		//lb_Error_on_Acrobat = TRUE
		rauo_Product.icartdiagramsheet		= 0
	End If
End If

DESTROY lds_Datastore

Return 1
end function

public function integer of_draw_healthmark (string as_unit, boolean ab_backlog);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_healthmark (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 16.04.2013
*
* Argument(e):
* string as_unit
*
* Beschreibung:		Draw Healthmark
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	16.04.2013		Erstellung
*
*
* Return: integer
*
*/


Integer	li_Succ
Boolean	lb_Header_in_Footer
uo_healthmark	luo_healthmark


luo_healthmark = CREATE uo_healthmark


lb_Header_in_Footer = of_is_header_in_footer()

If NOT ab_Backlog then 
	If isvalid(ods) then
		li_Succ = luo_healthmark.of_draw_healthmark( ods, as_unit, luo_healthmark.cartdiagram, lb_Header_in_Footer)
	End If
	
	If isvalid(odw) then
		li_Succ = luo_healthmark.of_draw_healthmark( odw, as_unit, luo_healthmark.cartdiagram, lb_Header_in_Footer)
	End If
Else
	If isvalid(odsbacklog) then
		li_Succ = luo_healthmark.of_draw_healthmark( odsbacklog, as_unit, luo_healthmark.cartdiagram , lb_Header_in_Footer)
	End If
	
	If isvalid(odwbacklog) then
		li_Succ = luo_healthmark.of_draw_healthmark( odwbacklog, as_unit, luo_healthmark.cartdiagram, lb_Header_in_Footer)
	End If
	
	
End If


DESTROY	luo_healthmark



Return li_Succ
end function

public function long of_add_content_explosion (long irow, long icolumn, long ldetail, long lsort, boolean ab_header_flag);/* 
* Funktion/Event: of_add_content_explosion
* Beschreibung: 	Ordnet einen Inhalt und dessen Inhalt zu (per dragdrop)
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 iRow				Zeile
*	 iColumn			"Spalte"
*	 lDetail    	Zeiger auf den Inhalt
*	 nsort			Zeiger auf das Sortierfeld
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	22.09.2008	Erstellung
*	1.1			U.Paudler	16.04.2009	Pr$$HEX1$$fc00$$ENDHEX$$fungen verbessert
*	1.2			U.Paudler  	19.11.2009	Drawerfood und Traynonfood eingebaut
*	1.3			O.Hoefer  	05.06.2013	Header Flag hinzu
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	lX1
Long	lX2
Long	lFound, lFoundContent, lSequence, i, j, a, lLayoutDetailKey, lLayoutContentKey, lContentKey, lNull, lAncestor
Long iType, iCount
Boolean		lb_MultiRung = FALSE

SetNull(lNull)

// Den Datensatz der Position suchen
lFound 		= this.dsLayoutDetail.Find("ncolumn=" + string(icolumn) + " and nrow=" + string(irow), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
	sError = "Error: Row/Column mismatch"
	return -1
End If

// 31.05.2010, KF
// $$HEX1$$dc00$$ENDHEX$$ber das AncestorObject die Zeile/Spalte suchen und ggf. anpassen
lAncestor = this.dsLayoutDetail.GetItemNumber(lFound, "nancestor") 

lFound = this.dsLayoutDetail.Find("nancestor=" + string(lAncestor) + " and ntype <> " + string(BLOCKED), 1, this.dsLayoutDetail.Rowcount())

if lFound = 0 Then
	sError = "Error: Ancestor not found"
	return -1
Else
	
	iRow 		=  this.dsLayoutDetail.GetItemNumber(lFound, "nrow") 
	iColumn 	=  this.dsLayoutDetail.GetItemNumber(lFound, "ncolumn") 
	
	// Ins leere gedropped
	// 16.04.2009 Ulrich Paudler [UP]
	// Zur sicherheit die Logik umgedreht
	Choose Case this.dsLayoutDetail.GetItemNumber(lFound, "ntype") 
		Case TRAY, DRAWER, DRAWER_3RUNG, TRAYNONFOOD, DRAWERFOOD
		
		Case DRAWER_MULTI_RUNG
			// auch erlaubt
			lb_MultiRung = TRUE
			
		Case Else
			return 0
	end Choose
	
	lLayoutDetailKey = this.dsLayoutDetail.GetItemNumber(lFound, "nlayout_detail_key")
	this.dsLayoutDetail.SetItem(lFound, "ncontent", EXPLOSION)
End If

lSequence = f_sequence("SEQ_CEN_PL_LAYOUT_CONTENTS", sqlca)

if lSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

// Aktuelle Position merken
this.iCurrentRow = iRow
this.iCurrentColumn = iColumn

// Inhalt suchen
lFoundContent = this.dsPLContents.Find("ndetail_key = " + string(lDetail) + " and nsort = " + string(lSort), 1, this.dsPLContents.RowCount())

if lFoundContent > 0 Then 
	// ----------------------------------------------------------
	// Zuerst alle bestehenden Zuordnungen entfernen
	// ----------------------------------------------------------
	this.dsLayoutContents.SetFilter("")
	this.dsLayoutContents.Filter()
	this.dsLayoutContents.Sort()
	
	If NOT lb_MultiRung Then
		For i =  this.dsLayoutContents.RowCount() to 1 Step -1		
			// -------------------------------------------------------
			// Pr$$HEX1$$fc00$$ENDHEX$$fen, ob schon was drin ist im Einschub
			// wenn ja dann die Zeile l$$HEX1$$f600$$ENDHEX$$schen und die Zuweisung in 
			// cen_packinglist_details resetten
			// -------------------------------------------------------
			if this.dsLayoutContents.GetItemNumber(i, "nlayout_detail_key") = lLayoutDetailKey Then
				lContentKey = this.dsLayoutContents.GetItemNumber(i, "nlayout_content_key") 
				For j = 1 to this.dsPLContents.RowCount()
					if this.dsPLContents.GetItemNumber(j, "nlayout_content_key") = lContentKey Then
						this.dsPLContents.SetItem(j, "nlayout_content_key", lNull)
					End If
				Next		
				iCount ++
				this.dsLayoutContents.DeleteRow(i)
			End If
		Next
	End If
	
	//a = this.dsLayoutContents.InsertRow(0)
	If ab_header_flag Then
		a = this.dsLayoutContents.InsertRow(1)
	Else
		a = this.dsLayoutContents.InsertRow(0)
	End If
	
	// -------------------------------------
	// 2013-06-05 Header Flag
	// -------------------------------------
	If ab_header_flag Then
		dsLayoutContents.SetItem(a, "nheader_flag", 1 )
		if il_Disable_Debug= 0 then
			guoLog.uf_debug( "["+ this.classname( )+".of_add_content_explosion nlayout_content_key=" + String(lSequence) + " nlayout_detail_key="  + String(lLayoutDetailKey) + " Header Flag=ON")
		End If
	Else
		dsLayoutContents.SetItem(a, "nheader_flag", 0 )
	End If
	
	
	dsLayoutContents.SetItem(a, "nlayout_content_key", lSequence)
	dsLayoutContents.SetItem(a, "nlayout_detail_key", lLayoutDetailKey)
	
	this.dsPLContents.SetItem(lFoundContent, "nlayout_content_key", lSequence)
	
	// Messagebox("", "of_draw_content_explosion")
	of_draw_content(iRow, iColumn, is_CSC)
	
Else
	sError = "Error: Content not found"
	return -1
End If




return 1
end function

public function long of_add_content_explosion (long irow, long icolumn, long ldetail, long lsort);/* 
* Funktion/Event: of_add_content_explosion
* Beschreibung: 	Ordnet einen Inhalt und dessen Inhalt zu (per dragdrop)
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 iRow				Zeile
*	 iColumn			"Spalte"
*	 lDetail    	Zeiger auf den Inhalt
*	 nsort			Zeiger auf das Sortierfeld
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster		22.09.2008	Erstellung
*	1.1				U.Paudler	16.04.2009	Pr$$HEX1$$fc00$$ENDHEX$$fungen verbessert
*	1.2				U.Paudler  	19.11.2009	Drawerfood und Traynonfood eingebaut
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/


Return of_add_content_explosion(  irow,  icolumn,  ldetail, lsort , FALSE)


end function

public function long of_sd_find_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist, long arg_l_row_id);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_find_backlog (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long arg_l_row
*	 long arg_l_column
*	 string arg_s_object
*	 decimal arg_dec_items
*	 string arg_s_unit
*	 string arg_s_text
*	 long arg_l_counter
*	 long arg_l_type
*	 string arg_s_packinglist
*	 long arg_l_row_id
*
* Beschreibung:		Add Backlog Entry - Secondary Distribution
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: long
*
*/


Integer	li_Succ
Long		ll_New_Row
String	ls_Text, ls_Backlog
Long		ll_MSG_Key
String	ls_Find

if il_Disable_Debug= 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_find_backlog Text " + arg_s_text + " / "  + " Qty " + String(arg_dec_items))

Choose Case arg_l_type
	Case EMPTY, BLOCKED
//		ls_Text =uf.translate( "Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		
	Case DRAWER 
//		ls_Text =uf.translate( "Drawer Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0

	Case TRAYNONFOOD
		ls_Text =uf.translate( "Tray Non Food")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0
	Case DRAWERFOOD
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if
		
	Case TRAY 
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if

	Case PACKINGLIST
		ls_Text =  arg_s_packinglist
		// Keine Menge > raus
//		if arg_dec_items = 0.0 Then	
			ls_Backlog = arg_s_text
			//return 0
			//If arg_dec_items = 0 Then
				arg_dec_items = 1
			//End If
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
//		Else
//			If arg_dec_items = 1 Then
//				ls_Backlog = arg_s_text
//			Else				
//				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
//				If arg_dec_items = long(arg_dec_items) Then
//					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
//				Else
//					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
//				End if
//			End If
//		End If
		
	Case DRAWER_Multi_rung
		ls_Text =  arg_s_packinglist
		ls_Backlog = arg_s_text
		// Keine Menge > raus
		if arg_dec_items = 0.0 Then	
			//return 0
			ls_Backlog = arg_s_text
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
		Else
//			If arg_dec_items <> 1 Then
//				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
//				If arg_dec_items = long(arg_dec_items) Then
//					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
//				Else
//					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
//				End if
//			Else
				ls_Backlog = arg_s_text
//			End If
		End if

		If Trim(arg_s_packinglist) = "" Then
			ls_Text =  uf.translate("Drawer")
			arg_l_type = PACKINGLIST
		End If
		
end Choose

//ll_MSG_Key = f_Sequence ("SEQ_CEN_OUT_SD_message", sqlca)
//If ll_MSG_Key = -1 Then
//	uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
//									 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
//	 Return -1
//end if

ls_Find = "nrowid=" + String(arg_l_Row_id)
ls_Find += " AND nrow=" + String(arg_l_row)
ls_Find += " AND ncolumn=" + String(arg_l_column)
ls_Find += " AND nmsgtype=" +  String(MSG_BACKLOG)
ls_Find += " AND npage=" +  String(ii_Current_Page)
ls_Find += " AND nitems=" + String(arg_dec_items)

If Pos(ls_Backlog, "'") > 0 AND Pos(ls_Backlog, "~'") < 1 then
	//ls_Backlog = f_replace(ls_Backlog, "'", "~~~'")
	ls_Find += " AND cbacklog='" +  f_replace(ls_Backlog, "'", "~~~'") + "'"
Else
	ls_Find += " AND cbacklog='" + ls_Backlog + "'"
End If


If Pos(arg_s_text, "JLEH102") > 0  then
	ll_New_Row = ll_New_Row 
End If

ll_New_Row = ids_SD_Message.Find(ls_Find, 1, ids_SD_Message.RowCount())
if ll_New_Row < 0 then 
	ll_New_Row = 0 
End If

//If ib_extended_tr_handling Then
//	ll_New_Row = 0
//End If


Return ll_New_Row


end function

public function integer of_set_pl (string as_pl, string as_pl_desc);/*
* Objekt : uo_cart_diagram
* Methode: of_set_pl (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.10.2013
*
* Argument(e):
* string as_pl
*	 string as_pl_desc
*
* Beschreibung:		4.96 Error 21 - Print Packinglist (Header)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.10.2013		Erstellung
*
*
* Return: integer
*
*/


is_PL			= as_PL
is_PL_Desc	=	as_PL_Desc

return 1
end function

public function long of_draw_watermark_belly (long al_belly);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_watermark_belly (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 16.01.2014
*
* Argument(e):
* none
*
* Beschreibung:		CBASE-UK-CR-2013-012
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	16.01.2014		Erstellung
*
*
* Return: long
*
*/


Long			ll_Color
String		ls_Text
String		ls_ObjectName


ll_Color = RGB(0, 0, 0)

ls_ObjectName = "t_watermark_belly"
ls_Text = "BELLY " + String(al_Belly)

// Y Pos. = 1 to Offset (sp$$HEX1$$e400$$ENDHEX$$ter wird alles im Detail um Offset nach oben geschoben)
// =====================================================
// Font Type & Size wie im Datum (Header)
// =====================================================
of_create_text(ls_ObjectName, ls_Text,FONT_MS_SANS_SERIF, 24, FONT_NORMAL, 10 , 1 + 25, 38 , 150 , 0, 0,  ll_Color, 1)
//	li_Succ = of_set_position( ls_Name, FALSE)

		
Return 0
end function

public function boolean of_is_add_on_text_enabled ();/*
* Objekt : uo_cart_diagram
* Methode: of_is_add_on_text_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 16.01.2014
*
* Argument(e):
* none
*
* Beschreibung:		Enable per Airline: Add On text on Cart Diagram
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	16.01.2014		Erstellung
*
*
* Return: boolean
*
*/


Long		ll_Value	
String	ls_Value

//ib_Draw_Add_Text


select	NDISP_ADD_ON_TEXT_CART
into		:ll_Value
from		CEN_AIRL_DIAG_FLAGS
where		NAIRLINE_KEY	 = :il_airlinekey;
If SQLCA.SQLCode <> 0 then
	ls_Value = "0"
Else
	If isNULL(ll_Value) Then ll_Value = 0
	ls_Value = String(ll_Value)
	
End If


if ls_Value = "1" Then
	return True
End If


return False

end function

public function string of_get_additional_label_text (long al_packinglist_index_key, string as_unit, date adt_departure);/*
* Objekt : uo_cart_diagram
* Methode: of_get_additional_label_text (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 16.01.2014
*
* Argument(e):
*	 long al_packinglist_index_key
*	 string as_unit
*	 datastore adt_departure
*
* Beschreibung:		CBASE-UK-CR-2013-013 / Additional Text from the area allocation 
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	16.01.2014		Erstellung
*
*
* Return: string
*
*/


String	ls_return
Long		ll_Rows
DataStore 	lds_Flight_Label

//ls_Additional_Label_text

lds_Flight_Label = CREATE DataStore
lds_Flight_Label.DataObject = "dw_cart_flight_label_add_text"
lds_Flight_Label.SetTransObject(SQLCA)
ll_Rows = lds_Flight_Label.retrieve( al_packinglist_index_key, as_unit, adt_departure )
//li_Succ = lds_Flight_Label.Sort()

If ll_Rows > 0  Then
	ls_return = lds_Flight_Label.GetItemString(1, "loc_unit_pl_flight_label_ctext" )

End If

return ls_return
end function

public function long of_draw_additional_text (string as_text_1, string as_label_text_2);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_additional_text (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 16.01.2014
*
* Argument(e):
* string as_text
*
* Beschreibung:		CBASE-UK-CR-2013-013
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	16.01.2014		Erstellung
*
*
* Return: long
*
*/


Long			ll_Color
String		ls_ObjectName_1, ls_ObjectName_2
String		ls_Text_Left
String		ls_Text_Right
Long			ll_Y_pos = 770 + 70


ll_Color = RGB(0, 0, 0)
//ll_Color = RGB(0, 0, 255)

ls_ObjectName_1 = "t_additional_text_1"
ls_ObjectName_2 = "t_additional_text_2"


ls_Text_Left = as_Text_1
ls_Text_Right = as_label_text_2
If (Isnull(ls_Text_Left) OR Trim (ls_Text_Left) = "") AND &
	(NOT Isnull(ls_Text_Right) OR Trim (ls_Text_Right) > "") Then
		ls_Text_Left = ls_Text_Right
		ls_Text_Right = ""
End If

if ls_Text_Left > "" Then

	// Y Pos. = 1 to Offset (sp$$HEX1$$e400$$ENDHEX$$ter wird alles im Detail um Offset nach oben geschoben)
	// =====================================================
	// Font Type & Size 
	// =====================================================
	
	of_create_text(ls_ObjectName_1, ls_Text_Left,FONT_MS_SANS_SERIF, 17, FONT_BOLD, 10 , ll_Y_pos, 20 , 700 , 0, ALIGN_CENTER,  ll_Color, 1)
//ALIGN_CENTER
//	if ls_Text_Right > "" Then
//		of_create_text(ls_ObjectName_2, ls_Text_Right,FONT_MS_SANS_SERIF, 17, FONT_BOLD, 360 , ll_Y_pos, 20 , 350 , 0, ALIGN_CENTER,  ll_Color, 1)
//	End If
	//	li_Succ = of_set_position( ls_Name, FALSE)
End If
		
Return 0
end function

public function long of_draw_backlog_on_main ();/*
* Objekt : uo_cart_diagram
* Methode: of_draw_backlog_on_main (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.01.2014
*
* Argument(e):
* none
*
* Beschreibung:		Print Backlog Information on Diagram Page
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.01.2014		Erstellung
*
*
* Return: long
*
*/


Long		ll_Left = 520
Long		ll_Width = 200
Integer	li_Pixels_to_the_Left = 140
Integer	li_Succ 
Long		ll_Num_Rows
Long		ll_Count
String	ls_ObjectName
String	ls_Type
String	ls_Backlog
Long		ll_Row, ll_Column, ll_Qty
Long		ll_Height = 14	
String	ls_Text
Long		ll_X, ll_Y
Boolean	lb_Group_Change
Integer	li_offset_h
String	ls_Row, ls_Column
String	ls_Group_Crit, ls_Group_Compare
	


guoLog.uf_debug( "["+ this.classname( )+".of_draw_backlog_on_main START")

ll_X = ll_Left
ll_Y = 31 + 25 // plus Offset

ls_Row = uf.translate("Schiene")
ls_Column = uf.translate("Spalte")

li_Succ = dsBacklog.SetFilter('cpackinglist > ""')
li_Succ = dsBacklog.Filter()
// nur wenn etwas enthalten ist
if dsBacklog.Rowcount() > 0 Then
	// (Seitengr$$HEX2$$f600df00$$ENDHEX$$e - (Headerbacklog - Headercart) - Groupheader  - Groupfooter) /Detailh$$HEX1$$f600$$ENDHEX$$he
	li_Succ = dsBacklog.Sort()
	li_Succ =	dsBacklog.Groupcalc()
	li_Succ = dsBacklog.Sort()
	
	If s_app.itrace = 1 Then
	//	dsBacklog.saveas("c:\temp\cbase\dsBacklog_" +String(cpu())+".xls",excel5!,true )
	End If
	
	// Loop Rows Draw backlog ....
	ll_Num_Rows = dsBacklog.Rowcount()
	
	// -------------------------------------------------------------------------------------
	// wenn links Platz ist (componentlist nicht available => cart nach links schieben
	// -------------------------------------------------------------------------------------
	If ll_Num_Rows > 0 Then
		If bHasDimensions = FALSE then
			li_offset_h = - li_Pixels_to_the_Left
			ll_X -= li_Pixels_to_the_Left
			ll_Width += li_Pixels_to_the_Left
			of_move_objects( "detail", 0, li_offset_h, FALSE)
		End If
	End If	
	
	For ll_Count = 1 To dsBacklog.Rowcount()
	
		ls_ObjectName = "t_backlog_heading_" + String(ll_Count, "000")
		ls_Type		= dsBacklog.GetItemString(ll_Count, "cpackinglist")
		ls_Backlog	= dsBacklog.GetItemString(ll_Count, "cbacklog" )
		ll_Row		= dsBacklog.GetItemNumber(ll_Count, "nrow" )
		ll_Column	= dsBacklog.GetItemNumber(ll_Count, "ncolumn" )
		ll_Qty		= dsBacklog.GetItemNumber(ll_Count, "nitems" )

		ls_Group_Compare = ls_Type + " " + ls_Column + " " + String(ll_Column) + " " + ls_Row + " " + String(ll_Row)
	
		If ls_Group_Crit <> ls_Group_Compare then
			lb_Group_Change = TRUE
		End If
		
		If lb_Group_Change then
			ls_Text = ls_Type
			If ll_Column + ll_Row > 0 Then
				ls_Text+= " " + ls_Column + " " + String(ll_Column) + " " + ls_Row + " " + String(ll_Row)
			End If
			
			of_create_text(ls_ObjectName, ls_Text,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD, ll_X, ll_Y, ll_Height + 4, ll_Width, 0, 0,  RGB(0,0,0), 1)	
			ll_Y = ll_Y + ll_Height
			ls_Group_Crit = ls_Group_Compare
			lb_Group_Change = FALSE
		End If
		
		ls_ObjectName= "t_backlog_Qty_" + string(ll_Count)
		ls_Text = string(ll_Qty)

		of_create_text(ls_ObjectName, ls_Text,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, ll_X , ll_Y , ll_Height , 20, 0, 0, RGB(0,0,0), 1)
	
		ls_ObjectName= "t_backlog_Text_" + string(ll_Count)
		ls_Text = ls_Backlog
		of_create_text(ls_ObjectName, ls_Text,FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, ll_X + 20, ll_Y, ll_Height , ll_Width - 20, 0, 0, RGB(0,0,0), 1)
		
		ll_Y = ll_Y + ll_Height

	Next
		
End If

li_Succ = dsBacklog.SetFilter("")
li_Succ = dsBacklog.Filter()

Return 0

end function

public function integer of_get_label_group (string as_unit);/*
* Objekt : uo_cart_diagram
* Methode: of_get_label_group (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 27.02.2014
*
* Argument(e):
* string as_unit
*
* Beschreibung:		Ermittle Workstations zu Label Printing Group
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	27.02.2014		Erstellung
*
*
* Return: integer
*
*/


Long		ll_Label_Group_Key
Integer	li_Config
String	ls_Section
String	ls_Value
//String	ls_Default
Long		ll_Rows  
Long		ll_Empty_Array[]
Long		ll_Workstations[]
DataStore		lds_Workstations


lds_Workstations = CREATE DataStore
lds_Workstations.DataObject = "dw_labelgroup_ws"
lds_Workstations.SetTransObject (SQLCA)

//select * from loc_setup ls where ls.csection = 'docbrowser1' 
//and ls.ckey = 'Label Group1379' and ls.cvalue='12621'

//// -----------------------------------------------------------
//// Labeldruck Bereich, Groupe von Areas und Workstations
//// -----------------------------------------------------------	
//lLablGroupKey = long(f_profilestring(sSection, "Label Group"+sViewUnit,"0"))


If ib_use_doc_gen_settings Then
	ll_Label_Group_Key = inv_doc_gen_settings.il_nlabel_group_key 
Else
	
	If is_section > "" Then
		ls_Section = is_section
	Else
		ls_Section = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(ls_Section) = "" Then ls_Section = "docbrowser"
	End if
	
//	if ls_Section <> "docbrowser" Then
//		li_Config = integer(Mid(ls_Section,11))
//		ls_Default ="Default" +string(li_Config)
//	Else
//		ls_Default ="Default"
//	End If
	
	ls_Value = of_profilestring(s_app.suser, ls_Section,"Label Group"+as_unit ,"0") 
	If ls_Value <> "0" Then
		ll_Label_Group_Key = Long(ls_Value)
	End If
	
End if

If ll_Label_Group_Key > 0 Then
	ll_Rows = lds_Workstations.Retrieve( ll_Label_Group_Key, idt_Departure )
	//dw_labelgroup_ws	
	If ll_Rows > 0 Then
		il_Workstations = lds_Workstations.Object.nworkstation_key.Primary
	End If
Else
	il_Workstations = ll_Empty_Array
End If

DESTROY	lds_Workstations

Return 1
end function

public function integer of_create_unassigned_tr_cart_report (ref datastore rads_unassigned, ref long ral_filecounter, ref string ras_pdffiles[], long al_flight_number, string as_airline);/*
* Objekt : uo_cart_diagram
* Methode: of_create_unassigned_tr_cart_report (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 06.03.2014
*
* Argument(e):
* ref datastore rads_unassigned
*	 ref long ral_filecounter
*	 ref string ras_pdffiles[]
*	 long al_flight_number
*	 string as_airline
*
* Beschreibung:		Create Unassigned TR Cart PDF Report
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	06.03.2014		Erstellung
*
*
* Return: integer
*
*/


// ------------------------------------------------------------------------
// Report unassigned TR carts
// ------------------------------------------------------------------------
If rads_unassigned.RowCount() > 0 Then
	// Header f$$HEX1$$fc00$$ENDHEX$$llen
	rads_unassigned.object.t_title.Text = "Unassigned TR Cart Diagram Report"

	rads_unassigned.object.t_departure.Text = String(idt_Departure, s_app.sdateformat)
	rads_unassigned.object.t_flight.Text = as_Airline + " " + String(al_Flight_Number, "000") 
	rads_unassigned.Sort()
	ral_FileCounter++
	ras_PdfFiles[ral_FileCounter] = f_gettemppath() + "CBASE-UNASSIGNED-CART-" + String(Rand(32767)) + String(now(), "hhmmss") + ".PDF"
	f_format_datastore_report(rads_unassigned, uf.translate("Unassigned TR Cart Diagram Report"))
	If of_create_acrobat(rads_unassigned, ras_PdfFiles[ral_FileCounter]) = -1 Then
		//lb_Error_on_Acrobat = TRUE
		Return -1
	End If
Else
	Return 0
End If

Return 1

end function

public function long of_draw_tr_add_text_indicator (long arg_irow, long arg_icolumn, string arg_text);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_tr_add_text_indicator (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 12.03.2014
*
* Argument(e):
* long arg_irow
*	 long arg_icolumn
*	 string arg_text
*
* Beschreibung:		Vgl. Segment Indicator, additional Text f$$HEX1$$fc00$$ENDHEX$$r TR Cart
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	12.03.2014		Erstellung
*
*
* Return: long
*
*/


String		ls_Segment
Long			ll_Color
Long			ll_X2
Long			ll_Drawer_Height 
String		ls_DWObject
Long			ll_Row_Height
Integer		li_Y_Offset
Integer		li_Y_Pos


ll_Color				= 0 // Black
ls_Segment			= arg_text 
ll_Drawer_Height	= il_TR_DefaultHeight - 2
ll_Row_Height		= il_TR_DefaultHeight
li_Y_Offset			= il_TR_YOffset
li_Y_Pos				= li_Y_Offset  + (arg_iRow * il_TR_DefaultHeight) +  (ll_Drawer_Height / 2) - 15

// Aktuelle Position merken
this.iCurrentRow		= arg_iRow
this.iCurrentColumn	= arg_iColumn

ll_X2 = lXOffset + ((arg_iColumn -1) * lDefaultWidth) +  12
ls_DWObject = "t_tr_add_text_col_" + string(arg_iColumn, "00") + "_row_" + string(arg_iRow, "00")

of_create_text(ls_DWObject, ls_Segment ,FONT_MICROSOFT_SANS_SERIF, 8, FONT_BOLD , ll_X2, li_Y_pos, 12 , 250, 0, align_left  , ll_Color, 1)
//if of_register(sDWObject, arg_iRow, arg_iColumn) = -1 Then return -1
of_set_position(ls_DWObject,  TRUE)

Return 1

end function

public function long of_draw_tr_freetext (string as_text);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_tr_freetext (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.03.2014
*
* Argument(e):
* string as_text
*
* Beschreibung:		CBASE-UK-CR-2013-013
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.03.2014		Erstellung
*
*
* Return: long
*
*/


Long			ll_Color
String		ls_ObjectName_1
Long			ll_Y_pos = 770


ll_Y_pos = ll_Y_pos + 25

ll_Color = RGB(0, 0, 0)
//ll_Color = RGB(0, 0, 255)

//<DW Control Name>.Describe("<Linename>.Y2")
ll_Y_pos = Integer(  of_describe("l_line_5_1.Y2", FALSE) )


ls_ObjectName_1 = "t_free_text"
	
If as_Text > "" Then
	// Y Pos. = 1 to Offset (sp$$HEX1$$e400$$ENDHEX$$ter wird alles im Detail um Offset nach oben geschoben)
	// =====================================================
	// Font Type & Size 
	// =====================================================
	of_create_text(ls_ObjectName_1, as_Text, FONT_MS_SANS_SERIF, 12, FONT_NORMAL, 10 , ll_Y_pos, 20 , 350 , 0, 0,  ll_Color, 1)	
	//	li_Succ = of_set_position( ls_Name, FALSE)
End If
		
Return 0

end function

public function integer of_create_tr_backlog_page (ref long ral_backlogpages, long al_row, long al_cartpages, ref long ral_filecounter, ref string ras_pdffiles[], string as_rampbox, string as_stowage, string as_packinglist, string as_pl_description, string as_loadinglist, string as_class, string as_workstation, string as_version, string as_container, integer ai_flightnumber, string as_suffix, string as_header, string as_from, string as_to, string as_actype, long al_belly, string as_time, string as_owner, string as_area, string as_class_string, long al_backlogpages, string as_current_printer_1, string as_unit, string as_airline);/*
* Objekt : uo_client_label
* Methode: of_create_tr_backlog_page (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.08.2012
*
* Argument(e):
* ref uo_cart_diagram rauo_diagram
*	 ref long ral_backlogpages
*	 long al_row
*	 long al_cartpages
*	 ref long ral_filecounter
*	 ref string ras_pdffiles[]
*	 ref uo_documents rauo_product
*	 string as_rampbox
*	 string as_stowage
*	 string as_packinglist
*	 string as_pl_description
*	 string as_loadinglist
*	 string as_class
*	 string as_workstation
*	 string as_version
*	 string as_container
*	 integer ai_flightnumber
*	 string as_suffix
*	 string as_header
*	 string as_from
*	 string as_to
*	 string as_actype
*	 long al_belly
*	 string as_time
*	 string as_owner
*	 string as_area
*	 string as_class_string
*	 long al_backlogpages
*	 string as_current_printer_1
*
* Beschreibung:		Print Backlog Page (PDF)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.08.2012		Erstellung
* 1.1 			O.Hoefer	17.04.2013		UK Healthmark
*
*
* Return: integer
*
*/

Blob	lb_Blob
String		ls_File_Prefix, ls_Cart_Page_PDF_Name
String		ls_Cart_Page_PSR_Name
Integer		li_Succ
Long			ll_Count	
Long			ll_rows
DataStore	lds_Datastore


lds_Datastore = CREATE DataStore


// Backlog drucken
if of_is_backlog_enabled() and of_get_backlog_rowcount()> 0 then
	ral_BacklogPages++			
	//guoLog.uf_debug( "["+ this.classname( )+".of_create_cart_diagram VOR BACKLOG "+ as_packinglist)							
	if isvalid(w_progress_with_cancel) then
		// wurde abgebrochen?
		if w_progress_with_cancel.bCancel then
			return -1000
		End If
		w_progress_with_cancel.wf_setposition(al_Row)
		w_progress_with_cancel.wf_setstatus( uf.translate("Seite ") +  string(al_CartPages) )
	End If
	of_print_prepare_backlog(as_current_printer_1 , as_Airline, ai_FlightNumber, as_Suffix, &
													as_Header, as_From, as_To, as_ACType, as_Stowage, al_BacklogPages, al_Belly, &
													idt_Departure, as_Time, as_Class_String, as_Container, as_Owner, as_Version, as_Area, &
													as_Workstation, as_Loadinglist)
	of_print_init()
	of_print_prepare_new_h_f(as_Loadinglist, as_packinglist, as_pl_description, as_rampbox, as_Stowage, &
									as_Class, as_Workstation, "", TRUE)
	// Leerseiten
	
	ll_rows = odsbacklog.RowCount()
	
	odsbacklog.SetFilter("trim(cbacklog)>'' or trim(cobject)>''")
	odsbacklog.Filter()
	
	ll_rows = odsbacklog.RowCount()
	
	// --------------------------------------------------------------
	// UK Healthmark
	// --------------------------------------------------------------
	If of_is_healthmark_enabled(as_unit) Then
		li_Succ = of_draw_healthmark( as_unit, TRUE )
	End If
		
	// --------------------------------------------------------------
	// SORTIERUNG 16.03.2011
	// --------------------------------------------------------------				
	odsbacklog.Sort()
	odsbacklog.GroupCalc()
	
	// Qty ist bereits im Text
	For ll_Count = 1 To odsbacklog.RowCount()
		li_Succ = odsbacklog.setitem(ll_Count, "nitems", 0)
	Next
	
	// Druckfertiges DW in DS kopieren
	of_getfullstate_backlog( lb_Blob)
	lds_Datastore.SetFullState(lb_Blob)

	lds_Datastore.Sort()
	lds_Datastore.GroupCalc()
	
	ral_FileCounter++
	//ras_PdfFiles[ral_FileCounter] = f_gettemppath() + "CBASE-CARTDIAGRAM-BACKLOG-" + String(Rand(32767)) + String(now(), "hhmmssfff") + ".PDF"

//	ls_File_Prefix = f_get_airline_name(al_airline_key )
	ls_File_Prefix = as_owner
	ls_File_Prefix += String(ai_flightnumber , "000") + "_" + as_From + "_" + as_to + "_" +String(idt_departure, "YYYYMMDD")
	ls_File_Prefix += "_TR_" + String(il_transaction) + "_" 
	ls_Cart_Page_PDF_Name =  "_" + ls_File_Prefix + String(al_CartPages,"000") + "_BACKLOG_" + String(now(), "hhmmssfff") + ".PDF"	
	ls_Cart_Page_PSR_Name =  "_" + ls_File_Prefix + String(al_CartPages,"000") + "_BACKLOG_" + String(now(), "hhmmssfff") + ".PSR"	
	ras_PdfFiles[ral_FileCounter] = f_gettemppath() + ls_Cart_Page_PDF_Name
	
	If s_app.itrace > 0 then
		lds_Datastore.saveas( f_gettemppath() + ls_Cart_Page_PSR_Name, PSReport!, TRUE)
	EnD IF
	
	//rauo_Product.icartdiagramsheet		= 1
	
	If of_create_acrobat(lds_Datastore, ras_PdfFiles[ral_FileCounter])=-1 Then
		//lb_Error_on_Acrobat = TRUE
		//rauo_Product.icartdiagramsheet		= 0
		//Return -1
	End If
End If

//odsbacklog.Reset()
// Master Row

DESTROY lds_Datastore


ii_tr_counter++


Return 1
end function

public function long of_sd_add_backlog (long arg_l_row, long arg_l_column, string arg_s_object, decimal arg_dec_items, string arg_s_unit, string arg_s_text, long arg_l_counter, long arg_l_type, string arg_s_packinglist, long arg_l_row_id, string arg_s_stowage);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_add_backlog (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long arg_l_row
*	 long arg_l_column
*	 string arg_s_object
*	 decimal arg_dec_items
*	 string arg_s_unit
*	 string arg_s_text
*	 long arg_l_counter
*	 long arg_l_type
*	 string arg_s_packinglist
*	 long arg_l_row_id
*   string arg_s_stowage
*
* Beschreibung:		Add Backlog Entry - Secondary Distribution
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
* 1.1 			O.Hoefer	15.01.2014		CBASE-NAM-CR-14001
* 1.2 			O.Hoefer	06.06.2014		CBASE-NAM-CR-14005 TR Backlog
*
*
* Return: long
*
*/


Integer	li_Succ
Long		ll_New_Row
String	ls_Text, ls_Backlog
Long		ll_MSG_Key

if il_Disable_Debug= 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_add_backlog Text " + arg_s_text + " / "  + " Qty " + String(arg_dec_items))


If Pos(arg_s_text, "Cracker") > 0 then
	ll_New_Row = ll_New_Row 
End If

Choose Case arg_l_type
	Case EMPTY, BLOCKED
//		ls_Text =uf.translate( "Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		
	Case DRAWER 
//		ls_Text =uf.translate( "Drawer Non Food")
		ls_Text =uf.translate( "Unit")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0

	Case TRAYNONFOOD
		ls_Text =uf.translate( "Tray Non Food")
		ls_Backlog = arg_s_text
//		arg_l_row = 0
//		arg_l_column = 0
	Case DRAWERFOOD
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if
		
	Case TRAY 
		ls_Text =  uf.translate("Mahlzeitenverteilung")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		If arg_dec_items <> 1 AND arg_dec_items <> 0 Then
			If arg_dec_items = long(arg_dec_items) Then
				ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
			Else
				ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
			End if
		End if

	Case PACKINGLIST
		ls_Text =  arg_s_packinglist
		// Keine Menge > raus
//		if arg_dec_items = 0.0 Then	
			ls_Backlog = arg_s_text
			//return 0
			arg_dec_items = 1
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
//		Else
//			If arg_dec_items = 1 Then
//				ls_Backlog = arg_s_text
//			Else				
//				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
//				If arg_dec_items = long(arg_dec_items) Then
//					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
//				Else
//					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
//				End if
//			End If
//		End If
		
	Case DRAWER_Multi_rung
		ls_Text =  arg_s_packinglist
		ls_Backlog = arg_s_text
		// Keine Menge > raus
		if arg_dec_items = 0.0 Then	
			//return 0
			ls_Backlog = arg_s_text
		//Elseif arg_dec_items = 1.0 Then
		//	ls_Backlog = arg_s_text
		Else
//			If arg_dec_items <> 1 Then
//				//ls_Backlog = string(arg_dec_items) + " " + arg_s_unit + " " + arg_s_text
//				If arg_dec_items = long(arg_dec_items) Then
//					ls_Backlog = string(arg_dec_items, "0") + " x " + arg_s_text
//				Else
//					ls_Backlog = string(arg_dec_items, "0.00") + " x " + arg_s_text
//				End if
//			Else
				ls_Backlog = arg_s_text
//			End If
		End if

		If Trim(arg_s_packinglist) = "" Then
			ls_Text =  uf.translate("Drawer")
			arg_l_type = PACKINGLIST
		End If
		
		
	Case LISTOFCOMPONENTS
		ls_Text =uf.translate( "Component List")
		ls_Backlog = arg_s_text
		arg_l_row = 0
		arg_l_column = 0
		
		guoLog.uf_debug( "["+ this.classname( )+".Component List BACKLOG  ("+String(arg_l_Row_id)+") " + arg_s_text )
	
end Choose

ll_MSG_Key = f_Sequence ("SEQ_CEN_OUT_SD_message", sqlca)
If ll_MSG_Key = -1 Then
	uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
									 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
	 Return -1
end if

If Pos(ls_Backlog, "JLEH102") > 0  then
	ll_New_Row = ll_New_Row 
End If

ll_New_Row = ids_SD_Message.insertrow(0)
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nresult_key", il_Result_Key )						
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "ntransaction", il_transaction )
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nrowid", arg_l_Row_id)
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "npage", ii_Current_Page)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nsd_msg_key", ll_MSG_Key)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nmsgtype", MSG_BACKLOG)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nrow",arg_l_row)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncolumn",arg_l_column)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cobject",arg_s_object)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nitems", arg_dec_items)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cunit", arg_s_unit)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncounter",arg_l_counter)

li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncounter",ll_New_Row)

li_Succ = ids_SD_Message.setitem(ll_New_Row, "ntype", arg_l_type)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cbacklog", ls_Backlog)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cpackinglist", ls_Text)

li_Succ = ids_SD_Message.setitem(ll_New_Row, "cstowage", arg_s_stowage )


ids_SD_Message.sort()

Return ll_New_Row


end function

protected function string of_get_cd_sort (string as_section);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_get_cd_sort (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 02.05.2016
//
// Argument(e):
// string as_section
//
// Beschreibung:		Get Sort String for Cart Diagrams
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	02.05.2016		Erstellung
//
//
// Return: string
//
// --------------------------------------------------------------------------------


String	ls_Value
String	ls_Sort


If ib_use_doc_gen_settings Then
	/*	CBASE-NAM-CR-16008 CBASEweb only:
		For Cart Diagrams printed by flight please change sorting criterias to:
			1. Area
			2. Workstation
			3. Galley (ascending)
			4. Stowage position*/
	ls_Sort = "sarea ASC, sworkstation ASC, nsort_galley ASC, nsort_stowage ASC " 
	return ls_Sort
End If

ls_Value = f_profilestring(as_Section, "CartDiagramSortByGalley", "0") 

guoLog.uf_debug( "["+ this.classname( )+".of_get_cd_sort" + as_Section + " CartDiagramSortByGalley "  + ls_Value)

If ls_Value = "1" Then
	ls_Sort = "nsort_galley ASC, nsort_stowage ASC" //, sloadinglist ASC"
	//Only by Galley-Stowage position (ascending)
Else
	//ls_Sort = "nsort_galley ASC, nsort_stowage ASC, sloadinglist ASC"
	ls_Sort = "sarea ASC, sworkstation ASC, nsort_galley ASC, nsort_stowage ASC " 
	//1.	Area
	//2.	Workstation
	//3. Galley (ascending)
	//4. Stowage position (ascending; please note that if there is a F and an R entered in $$HEX1$$1c20$$ENDHEX$$Place$$HEX2$$1d202000$$ENDHEX$$F should come before R (Front and Rear)
End If

//li_Succ = This.dsCartdiagramSheet.SetSort("nclass_number ASC, nsort_galley ASC, nsort_stowage ASC, Sstowage ASC, sworkstation ASC, sloadinglist ASC")
//	li_Succ = This.dsCartdiagramSheet.SetSort("nsort_galley ASC, nsort_stowage ASC, sloadinglist ASC")
//1.	Area
//2.	Workstation
//3. Galley (ascending)
//4. Stowage position (ascending; please note that if there is a F and an R entered in $$HEX1$$1c20$$ENDHEX$$Place$$HEX2$$1d202000$$ENDHEX$$F should come before R (Front and Rear)


return ls_Sort
end function

public function boolean of_check_non_sky (string as_unit);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_check_non_sky (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 09.05.2016
//
// Argument(e):
// string as_unit
//
// Beschreibung:		Check if CSC is a NON-Sky Kitchen (CBASE-NAM-CR-16008)
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	09.05.2016		Erstellung
//
//
// Return: boolean
//
// --------------------------------------------------------------------------------

Long	ll_non_sky = 0 


SELECT	nnon_sky  
INTO		:ll_non_sky  
FROM		sys_units  
WHERE		cunit = :as_unit ;

If ll_non_sky > 0 Then
	ib_Non_Sky = TRUE
Else
	ib_Non_Sky = FALSE
End If

If ll_non_sky = 2 Then
	ib_Non_Sky_VIP = TRUE
Else
	ib_Non_Sky_VIP = FALSE
End If

Return ib_Non_Sky

end function

public function integer of_fill_non_sky_content_spec (string arg_s_carttype, string arg_unit, uo_content_sheet rauo_content_sheet, long al_content_master_row_id, datastore rads_distribution_contents);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_fill_non_sky_content_spec (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 17.05.2016
//
// Argument(e):
// string arg_s_carttype
//	 string arg_unit
//	 uo_content_sheet rauo_content_sheet
//	 long al_content_master_row_id
//	 datastore rads_distribution_contents
//
// Beschreibung:		Content Spec Header
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	17.05.2016		Erstellung
//
//
// Return: integer
//
// --------------------------------------------------------------------------------



Integer		li_Succ
Long			llMaxColumns, llMaxRows, llMaxlength
Long			ll_New_Row
Integer		li_Return = 1
Long			llFound
Long			llRetVal
Long			llLayoutDetailKey
Long			ll_Column
Long			ll_Row
Long			ll_Start_Pos
Long			ll_Sort_Counter
Long			ll_Count_Fixed
Long			ll_temp_qty
Long			ll_Content_Header_Detail_Key
Boolean		lb_true = TRUE
String		ls_temp_content_pl
String		ls_temp_content
s_distrib_items		lstr_item[]
s_distrib_items		lstr_item_empty[]
s_distrib_items		lstr_item_fixed[]

//DESTROY	ids_CSLoadingHeader
//DESTROY	ids_CSLoadingContents

If ids_CSLoadingHeader.RowCount() > 0 Then

	li_Succ = ids_CSLoadingHeader.RowsCopy( 1, ids_CSLoadingHeader.RowCount() , Primary!, rauo_content_sheet.dsLoadingHeader, 1, Primary!)
	li_Succ = ids_CSLoadingHeader.Reset()
	
//	li_Succ = ids_CSLoadingHeader.RowsCopy( 1, ids_CSLoadingHeader.RowCount() , Primary!, rauo_content_sheet.dsLoadingContents , 1, Primary!)
//	li_Succ = ids_CSLoadingHeader.RowsCopy( 1, ids_CSLoadingHeader.RowCount() , Primary!, rauo_content_sheet.dsLoadingHeader, 1, Primary!)
//	li_Succ = ids_CSLoadingHeader.Reset()
//	
	
End If


Return li_Return

end function

public function integer of_add_backlog_as_content_sheet (string as_packinglist, string as_text, long al_qty, long al_row, long al_column);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_add_backlog_as_content_sheet (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 24.05.2016
//
// Argument(e):
// string as_packinglist
//	 string as_text
//	 long al_qty
//
// Beschreibung:		Zwischenspeichern Overflow als Content Spec (NON SKY Cities CBASE-NAM-CR-16008)
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	24.05.2016		Erstellung
// 1.1 			O.Hoefer	22.08.2016		issue #1539 bei 2 identischen PL im gleichen Stauort trotzdem 2 mal drucken
//
//
// Return: integer
//
// --------------------------------------------------------------------------------

Integer	li_Succ
Long		ll_New_Row
Long		ll_Content_Header_Detail_Key
Long		ll_Sort_Counter
Long		ll_Found
String	ls_Find


guoLog.uf_debug( "["+ this.classname( )+".of_add_backlog_as_content_sheet " + as_Packinglist + " / " +  as_Text + " qty: " + String(al_qty )  + " (" + String(il_Master_Row) + ")")


if isnull(al_Row)  then al_Row = 1
if isnull(al_Column)  then al_Column = 1

ll_Sort_Counter = (1000 * al_Column) + al_Row

//ls_Find = "cpackinglist='" + as_Packinglist + "' AND nrowid=" + String(il_Master_Row)

ls_Find = "cpackinglist='" + as_Packinglist + "' AND nrowid=" + String(il_Master_Row) 
ls_Find += " AND nsort =" + String(ll_Sort_Counter)

ll_Found = ids_CSLoadingHeader.Find(ls_Find, 1, ids_CSLoadingHeader.RowCount())

If ll_Found > 0 then Return 0 

ll_New_Row = ids_CSLoadingHeader.InsertRow(0)

ll_Content_Header_Detail_Key = 1000 + ll_New_Row		

li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key)
li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
//li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key)
//li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				

li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nrowid", il_Master_Row)

li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "cpackinglist", as_Packinglist)
li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "ctext", as_Text)
li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nquantity", al_qty)
//ll_Sort_Counter++


//li_Succ = ids_CSLoadingHeader.Setitem(ll_New_Row, "ncontent_sheet", 1)

li_Succ = ids_CSLoadingHeader.Setitem(ll_New_Row, "ncontent_sheet", 1)

return 1

end function

public function long of_draw_tr_content_drawer (long arg_index_key, long arg_detailkey, long arg_irow, long arg_icolumn, long arg_ltype, boolean ab_explode, string as_unit, s_component as_distribution_items[], string as_suppressed_items[], string as_stowage);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_draw_tr_content_drawer (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 15.04.2009
*
* Argument(e):	long arg_llayoutdetailkey
*	 Long arg_icontent
*	 Long arg_irow
*	 Long arg_icolumn
* Return: Long
*
*
*
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
* ???			  1.0		??				Erstellung
* 15.04.2009 1.1	Ulrich Paudler	Spalte cen_packinglists_cunit nach details_cunit ge$$HEX1$$e400$$ENDHEX$$ndert
* 06.10.2009 1.2	Ulrich Paudler	Text l$$HEX1$$e400$$ENDHEX$$uft $$HEX1$$fc00$$ENDHEX$$ber den Rand hinaus
* 19.11.2009 1.3	Ulrich Paudler	Drawerfood und Traynonfood eingebaut
* 11.01.2010 1.4	Ulrich Paudler	Textweite begrenzen, Bedingte Anzeige der Artikelnummer/Text
* 18.01.2010 1.5	Ulrich Paudler	Menge 1 nicht anzeigen
* 02.02.2010 1.6	Ulrich Paudler	normalen Content fett 
* 08.02.2010 1.7	Ulrich Paudler	Textbreite und Y-Position angepasst
* 20.10.2010 1.8  Klaus F$$HEX1$$f600$$ENDHEX$$rster	Drawer $$HEX1$$fc00$$ENDHEX$$ber 3 Schienen eingebaut
* 14.12.2010 1.9  Oliver H$$HEX1$$f600$$ENDHEX$$fer	Kopie of_draw_content_drawer => of_draw_tr_content_drawer
* 18.04.2011 1.10 Oliver H$$HEX1$$f600$$ENDHEX$$fer	$$HEX1$$dc00$$ENDHEX$$bersetzung: DEUTSCH "mehr"
* 15.03.2012 1.11 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Consolidate similar items
* 18.09.2012 1.12 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Content Sheet Indicator CR NAM 12008
* 16.10.2012 1.13 Oliver H$$HEX1$$f600$$ENDHEX$$fer	CBASE-NAM-CR-12049-TR Cart / All Settings can be combined for both Diagram types
* 08.11.2012 1.14 Oliver H$$HEX1$$f600$$ENDHEX$$fer	CBASE-NAM-CR-12035 Font Size 
* 24.10.2013 1.15 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Bugfix Content Spec Indicator
* 06.06.2014 1.16 Oliver H$$HEX1$$f600$$ENDHEX$$fer	CBASE-NAM-CR-14005 Backlog
* 08.09.2014 1.17 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Backlog ohne Content Spec
* 15.09.2014 1.18 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Backlog wegen Content Spec (Items = Content Count)
* 08.12.2014 1.19 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Backlog f$$HEX1$$fc00$$ENDHEX$$r Distributed Components
* 16.06.2016 1.20 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Backlog Content Sheet non sky
* 16.12.2016 1.21 Oliver H$$HEX1$$f600$$ENDHEX$$fer	Distr. Content formatieren
*
*************************************************************/


Integer		li_Succ
String		ls_Filter, ls_Object, ls_Mod,  lsHeaderText
long			ll_Row, lX1, lX2, lY1, lY2, lRowHeight, lYCounter, lPercentQuantity, lPercentUnit  
long			lContentIndexKey,  lContentDetailKey, llAdditionali_Y_Offset
long			llMaxContent 
//long			llTextWidthlWidthQuantity
Long			ll_Content_Rows
Long			ll_Row_Height
String		ls_PL
Integer		li_Explode_Setting
Integer		li_Y_Offset
Long			ll_Count, ll_Offset
String		ls_Error
String		ls_Object2
String		ls_text
Boolean		lb_Content_Spec_Enabled
Long			ll_Count_Suppressed
Long			ll_Found
String		ls_Find
Long			ll_Index
Boolean		lb_Backlog_Created = FALSE 
String		ls_Parent_PL , ls_Parent_Text
Long			ll_Parent_Qty = 1
s_component lstr_component


li_Y_Offset = il_TR_YOffset
ll_Row_Height = il_tr_defaultheight

llMaxContent = 3


if ib_non_sky Then 
	ab_explode = TRUE
End if

////if of_is_tr_componentlist_enabled() and bHasDimensions Then
//if of_is_tr_componentlist_enabled() Then	
//	//llTextWidth = TEXTWIDTH1
//	llTextWidth = TEXTWIDTHTRSMALL //TEXTWIDTHSMALL1
//Else
//	llTextWidth = TEXTWIDTHSMALL1
//End If

//llTextWidth = Long(ii_TR_Cart_Width / il_columns)

lb_Content_Spec_Enabled = of_is_content_spec_enabled(arg_index_key , is_CSC, idt_departure )

ls_PL = f_get_packinglist( arg_index_key )

ls_Parent_PL = ls_PL
ls_Parent_Text = f_get_packinglist_text( arg_index_key , datetime(idt_departure ))

//If ls_PL = "PAADR0V215" then
//	il_Disable_Debug = 0 
//end if

If ab_explode = FALSE Then
	If il_Disable_Debug=0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer " + ls_PL + " ab_explode = FALSE")
	End if	
	// ----------------------------------------------------------
	// Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
	// ----------------------------------------------------------
	// 11.01.2010 Ulrich Paudler [UP]
	//if of_is_tr_componentlist_enabled() and bHasDimensions Then
//	if of_is_tr_componentlist_enabled() Then		
//		llTextWidth = TEXTWIDTHTRSMALL //TEXTWIDTHSMALL1
//	Else
//		llTextWidth = TEXTWIDTHSMALL1
//	End If
	
	//llTextWidth = Long(ii_TR_Cart_Width / il_columns)
	
	If il_Disable_Debug=0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer " + ls_PL + " llTextWidth " + String(TEXTWIDTHTRSMALL))
	End if	
	
	Choose Case arg_ltype
		Case TRAYNONFOOD
			lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 20
		Case Else
			lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
	end Choose
	lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth/2
	lRowHeight = 14
	lYCounter = 0
	
	llMaxContent = (il_tr_defaultheight - lRowHeight) / lRowHeight	
	llMaxContent -= 1
		
	guoLog.uf_debug("["+ this.classname( )+".of_draw_tr_content_drawer] "  +  this.isStowage +" - " + "MAXCONTENT " + String(llMaxContent))
	If il_Disable_Debug=0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer MAXCONTENT " + String(llMaxContent))
	End if	
	
	For ll_Row = 1 to llMaxContent
		lY1 = li_Y_Offset + ((arg_iRow - 1) *  ll_Row_Height) + (il_TR_DefaultHeight / 2 ) + (lRowHeight * lYCounter) - llAdditionali_Y_Offset	
		lY1 = lY1 + 1 + 	lRowHeight
		ls_Object = "t_content_std_text_" + string(ll_Row, "00") + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
		of_create_text(ls_Object, "...",FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, lX1 ,lY1 , 15 , TEXTWIDTHTRSMALL , 0, 0, 0, 1)
		if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then
			//return -1
		end if
		lYCounter ++
	Next

Else
	 
	lRowHeight = 14
	llMaxContent = (il_tr_defaultheight - lRowHeight) / lRowHeight	
	llMaxContent -= 1
		
	ls_PL = f_get_packinglist( arg_index_key )
	If il_Disable_Debug=0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer " + ls_PL + " ab_explode = TRUE")
	End if	
	
	If il_Disable_Debug=0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer " + ls_PL + " llTextWidth " + String(TEXTWIDTHTRSMALL))
	End if	
	
	// ----------------------------------------------------------
	// Textobjekte f$$HEX1$$fc00$$ENDHEX$$r die sp$$HEX1$$e400$$ENDHEX$$tere Anzeige der Contents
	// ----------------------------------------------------------
	lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
	lX2 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) +  lDefaultWidth / 2
	lRowHeight = 14
	lYCounter = 0

//	lPercentQuantity  	= 10
//	lPercentText		= 95
//
//	lWidthQuantity 		= llTextWidth * lPercentQuantity / 100
//	lWidthText			= llTextWidth * lPercentText / 100

	ls_Object = "t_content_header_" + string(0) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")

	lYCounter ++
	// 06.10.2009 Ulrich Paudler [UP] Text l$$HEX1$$e400$$ENDHEX$$uft $$HEX1$$fc00$$ENDHEX$$ber den Rand hinaus (da 5% f$$HEX1$$fc00$$ENDHEX$$r das einger$$HEX1$$fc00$$ENDHEX$$ckte draufgehen!)
//	lWidthText			= llTextWidth * lPercentText / 100
	
	If il_Disable_Debug=0 Then
//		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer llMaxContentEx " + String(llMaxContentEx))
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer llMaxContentEx " + String(llMaxContent))
	End if
	
//	For ll_Row = 1 to llMaxContentEx
	For ll_Row = 1 to llMaxContent
//		lY1 = li_Y_Offset + ((arg_iRow - 1) *  ll_Row_Height)+ 2+ (lRowHeight * lYCounter) - llAdditionali_Y_Offset
		lY1 = li_Y_Offset + ((arg_iRow - 1) *  ll_Row_Height) + (il_TR_DefaultHeight / 2 ) + (lRowHeight * lYCounter) - llAdditionali_Y_Offset	
		//lY1 = lY1 + 1 + 	lRowHeight
	
		Choose Case arg_ltype
			Case TRAYNONFOOD
				lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 20
			Case Else
				lX1 = lXOffset + ((arg_icolumn -1) * lDefaultWidth) + 14
		end Choose
		
		// Textfeld
		ls_Object = "t_content_text_" + string(ll_Row) + "_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
		of_create_text(ls_Object, "",FONT_MICROSOFT_SANS_SERIF, 8, FONT_NORMAL, lX1  , lY1, 15 ,TEXTWIDTHTRSMALL  , 0, 0,  0, 1)

		if of_register(ls_Object, arg_iRow, arg_icolumn) = -1 Then
			guoLog.uf_debug( "["+ this.classname( )+".Register FAILED " + ls_Object)
			//return -1
		end if

		lYCounter ++
	Next
//Else
//	sError = "Error: undefined content"
//	return -1
End If

// -------------------------------------------------
// Erstmal alle Texte wieder resetten
// -------------------------------------------------
this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
this.dsObjects.Filter()
this.dsObjects.Sort()

For ll_Row = 1 to this.dsObjects.RowCount()
	ls_Object = this.dsObjects.GetItemstring(ll_Row, "cobject")
	if of_check_string(ls_Object,"t_content_" ) Then
		// 12.01.2010 Ulrich Paudler [UP]
		of_modify_text( ls_Object , "")
	End If
Next

this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

// ----------------------------------------------------------
// Texte neu eintragen
// Unterscheidung Content vs. Exploded Content
// ----------------------------------------------------------

ll_Content_Rows = this.dsPLContents.Retrieve(arg_Index_Key, arg_DetailKey, datetime(idt_Departure))
// --------------------------------------------------------------
// Display of items on status Billing   added 08/18/2010
// Items that are on status billing in any drawer should 
// not be displayed in the cart diagram.
// --------------------------------------------------------------
If ib_discard_status_billing Then
	li_Succ = of_remove_contents_billing(dsPLContents)
End If
ll_Content_Rows = this.dsPLContents.RowCount()

//as_suppressed_items[]
For ll_Count_Suppressed = 1 To Upperbound(as_suppressed_items)
	//dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
	ls_Find = "cen_packinglist_index_cpackinglist='"  + as_suppressed_items[ll_Count_Suppressed] + "'"
	ll_Found = dsPLContents.Find(ls_Find, 1, dsPLContents.RowCount())
	If ll_Found > 0 then
		li_Succ = dsPLContents.RowsDiscard(ll_Found, ll_Count, Primary!)
		//if il_Disable_Debug= 0 then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer - Do not print  " + as_suppressed_items[ll_Count_Suppressed])
		//End If

	End If
Next

ll_Content_Rows = this.dsPLContents.RowCount()

if dsPLContents.RowCount() < 1 Then
	// Kein Content zum Einf$$HEX1$$fc00$$ENDHEX$$gen vorhanden
//Elseif arg_iContent = CONTENT Then // Content Layout
Else
	// -------------------------------------------------
	// Dann die Texte alle nochmal eintragen
	// -------------------------------------------------
	this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
	this.dsObjects.Filter()
	this.dsObjects.Sort()

	If ab_explode then
		
		String	ls_Row_A, ls_Row_B 
		// dsPLContents => unique
		dsPLContents.SetSort("cen_packinglist_index_cpackinglist A, cen_packinglists_ctext A") 
		dsPLContents.Sort()
		If dsPLContents.RowCount() > 1 Then
			For ll_Row = this.dsPLContents.RowCount() to 2 step -1
				ls_Row_A = dsPLContents.GetItemString(ll_Row, "cen_packinglists_ctext") + dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
				ls_Row_B = dsPLContents.GetItemString(ll_Row - 1, "cen_packinglists_ctext") + dsPLContents.GetItemString(ll_Row -1 , "cen_packinglist_index_cpackinglist")
				If ls_Row_A = ls_Row_B then
					If dsPLContents.GetItemNumber(ll_Row, "nquantity") > 0 then
						dsPLContents.SetItem(ll_Row - 1, "nquantity", dsPLContents.GetItemNumber(ll_Row    , "nquantity") + &
																					dsPLContents.GetItemNumber(ll_Row - 1, "nquantity"))
					End If
					
					li_Succ = dsPLContents.deleterow(ll_Row)
				End If
			Next
		End if
			
		dsPLContents.SetSort("nsort A") 
		dsPLContents.Sort() 
		
		For ll_Row = 1 to this.dsPLContents.RowCount()
					
			// 01.02.2010 Ulrich Paudler [UP]
			if ll_Row > this.dsObjects.RowCount() Then
				// sError = "Error: too many contents"
				// return -1
				//continue
			Else
				ls_Object = this.dsObjects.GetItemstring(ll_Row, "cobject")
				ll_Offset = ll_Row
			End If
	
			lstr_component.stext 	= this.dsPLContents.GetItemString(ll_Row, "cen_packinglists_ctext")
			lstr_component.ssnr 		= this.dsPLContents.GetItemString(ll_Row, "cen_packinglist_index_cpackinglist")
			// 10.02.2010 Ulrich Paudler [UP]
			if this.dsPLContents.GetItemNumber(ll_Row, "nquantity") > 0.0  and (this.dsPLContents.GetItemNumber(ll_Row, "nquantity") <> 1.0 OR ib_suppress_qty_1 = FALSE) Then
				lstr_component.squantity	= string( this.dsPLContents.GetItemNumber(ll_Row, "nquantity"))
			Else
				lstr_component.squantity	= ""
			End If
			//if ll_Row >= llMaxContent and dsPLContents.RowCount() > llMaxContent Then
			if		ll_Row >= llMaxContent and ((dsPLContents.RowCount() > llMaxContent) OR &
					(dsPLContents.RowCount() = llMaxContent AND (lb_Content_Spec_Enabled = TRUE OR ib_non_sky )) 	) Then
				if ll_Row = llMaxContent Then
					if of_is_backlog_enabled() Then
						// --- 18.04.2011 ----
						ls_Text = uf.translate( is_Overflow_MSG_2 )
						lb_Backlog_Created = TRUE 
						if ib_non_sky then
							ls_Text = uf.translate( is_Overflow_MSG_1 )
						End If
						of_modify_text( ls_Object , ls_Text)
						ls_Text =  of_get_item_description(lstr_component)
						li_Succ = of_sd_add_backlog( 0, 0, ls_Object, 0 , "", ls_Text, ll_Index, drawer_multi_rung, ls_PL, ii_tr_counter, as_stowage ) 
						if il_Disable_Debug= 0 then
							guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer  => BACKLOG " + ls_Text)
						End If
					Else
						// Backlog nicht enabled: letzte Zeilen f$$HEX1$$fc00$$ENDHEX$$llen
						ls_Text =  of_get_item_description(lstr_component)
						
						// --------------------------------------------------------------------------
						// Maskieren von Single Quotes
						// --------------------------------------------------------------------------
						li_Succ =  f_replace_string(ls_Text, "'", "~~~'")
						
						of_modify_text( ls_Object , ls_Text)
						
					End If
				Else
					ls_Text = of_get_item_description(lstr_component)
					li_Succ = of_sd_add_backlog( 0, 0, ls_Object, 0 , "", ls_Text, ll_Index, drawer_multi_rung, ls_PL, ii_tr_counter,  as_stowage) 
					if il_Disable_Debug= 0 then
						guoLog.uf_debug( "["+ this.classname( )+".of_draw_content_drawer  => BACKLOG " + ls_Text)
					End If
				End If
			Else
				ls_Text =  of_get_item_description(lstr_component)
				// --------------------------------------------------------------------------
				// Maskieren von Single Quotes
				// --------------------------------------------------------------------------
				li_Succ =  f_replace_string(ls_Text, "'", "~~~'")
				of_modify_text( ls_Object , ls_Text)
				// ###########################################
				of_modify_text( ls_Object , "  " + ls_Text)
				// ###########################################
				If il_Disable_Debug=0 then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer CONTENT: " + ls_Object + " " + ls_Text) 
				End if
				of_modify_dw(ls_Object + '.font.weight="400"')
				of_modify_dw(ls_Object + '.font.height="-8"')
			End If
	
//			// --------------------------------------------------------------------------
//			// Content Sheet Indicator
//			// --------------------------------------------------------------------------
//			if ll_Row = llMaxContent Then
//				If lb_Content_Spec_Enabled = TRUE then
//					// Auf die letzte Zeile die Nachricht "Content Spec"
//					lsText = is_Overflow_MSG_1
//					of_modify_text( ls_Object , lsText)
//				End If
//			End if
	
		Next
	// Ende zu If ab_explode.... 
	End If
		
//	this.dsObjects.SetFilter("" )
//	this.dsObjects.Filter()
//	this.dsObjects.Sort()

End If

// ---------------------------------------------------------
// Distributed Items
// ---------------------------------------------------------
If Upperbound(as_distribution_items) > 0 Then
//	this.dsObjects.SetFilter("ncolumn=" + string(arg_icolumn) + " and nrow= " + string(arg_iRow) + " and Match(cobject, 't_content_')" )
//	this.dsObjects.Filter()
//	this.dsObjects.Sort()
	
	//ll_Offset = dsPLContents.RowCount()
	If il_Disable_Debug=0 then
		guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer ll_Offset: " + String(ll_Offset)) 
	End if
	
	For ll_Count = 1 To Upperbound(as_distribution_items)
		ls_Object = "t_content_std_text_" + String(ll_Count + ll_Offset, "00") + "_col_"+String(arg_icolumn, "00" )+"_row_" + String(arg_irow, "00" )
		If ll_Count + ll_Offset > dsObjects.RowCount() Then
			If il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer CANNOT DRAW (ll_Count " + String(ll_Count) + " + ll_Offset " + String(ll_Offset) + "> dsObjects.RowCount " + String(dsObjects.RowCount()) + " )")
			End If			
			//CONTINUE
		End If 
		If il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer DISTRIBUTED ITEM " + ls_Object + ": " + as_distribution_items [ll_Count].ssnr)
		End if
		
		// --------------------------------------------------------------------------
		// Maskieren von Single Quotes
		// --------------------------------------------------------------------------
		ls_text = as_distribution_items[ll_Count].stext	
	
		lstr_component.stext 		= as_distribution_items[ll_Count].stext	
		lstr_component.ssnr  		= as_distribution_items[ll_Count].ssnr
		lstr_component.squantity	= as_distribution_items[ll_Count].squantity
		if lstr_component.squantity = "" Then
			lstr_component.squantity = String(as_distribution_items[ll_Count].lquantity )
		End If				
		ls_text =  of_get_item_description(lstr_component)
		
		
		li_Succ =  f_replace_string(ls_Text, "'", "~~~'")
		
//		ls_Parent_PL = as_distribution_items[ll_Count].ssnr	
//		ls_Parent_Text = ls_text
//		ll_Parent_Qty =  as_distribution_items[ll_Count].lquantity	
		
		// --------------------------------------------------------------------------
		// Backlog
		// --------------------------------------------------------------------------
		If ll_Count + ll_Offset >= llmaxContent Then
			li_Succ = of_sd_add_backlog( 0, 0, ls_Object, 0 , "", ls_text, ll_Index, drawer_multi_rung, ls_PL, ii_tr_counter, as_stowage ) 
			//li_Succ = of_sd_add_backlog( 0, 0, ls_Object, 0 , "", ls_text, ll_Index, drawer_multi_rung, ls_Parent_PL, ii_tr_counter, as_stowage ) 	
			// 12.01.15
			If ll_Count + ll_Offset = llmaxContent Then
				ls_Text = uf.translate( is_Overflow_MSG_2 )
				if ib_non_sky then
					ls_Text = uf.translate( is_Overflow_MSG_1 )
				End If
				of_modify_text( ls_Object , ls_Text)
				ls_Object2 = "t_content_text_" + String(ll_Count + ll_Offset, "0") + "_col_"+String(arg_icolumn, "00" )+"_row_" + String(arg_irow, "00" )
				of_modify_text(ls_Object2, ls_Text)
				lb_Backlog_Created = TRUE 
				
				//lsText =  of_get_item_description(lstr_component)
			End If	
			
			// --------------------------------------------------------------------------
			// NAM CR 16008 Content Spec as Backlog
			// --------------------------------------------------------------------------
			If ib_non_sky AND lb_Backlog_Created Then
				//	ls_Parent_PL = as_distribution_items[ll_Count].ssnr	
				//	ls_Parent_Text = ls_text
				//	ll_Parent_Qty =  as_distribution_items[ll_Count].lquantity					
				li_Succ = of_add_backlog_as_content_sheet( as_distribution_items[ll_Count].ssnr , as_distribution_items[ll_Count].stext, as_distribution_items[ll_Count].lquantity, arg_irow, arg_icolumn )	
			End If
			
			
		Else	
		
			of_modify_text(ls_Object, ls_text) //as_distribution_items[ll_Count])	
			ls_Object2 = "t_content_text_" + String(ll_Count + ll_Offset, "0") + "_col_"+String(arg_icolumn, "00" )+"_row_" + String(arg_irow, "00" )
			of_modify_text(ls_Object2, ls_text) //as_distribution_items[ll_Count])
			ls_error = of_describe(ls_Object + ".text", FALSE)
			
			If ls_error > "" Then
				If il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer DISTRIBUTED ITEM DESCRIBE " + ls_Object + ": " + ls_error)
				End If
				// Name?
				If ll_Count + ll_Offset <= dsObjects.RowCount() Then
					ls_Object = "t_content_std_text_" + String(ll_Count + ll_Offset, "0") + "_col_" + String(arg_icolumn, "00") + "_row_" + String(arg_irow, "00")
					// --------------------------------------------------------------------------
					// Maskieren von Single Quotes
					// --------------------------------------------------------------------------
					ls_text = as_distribution_items[ll_Count].stext	
					
					lstr_component.stext 		= as_distribution_items[ll_Count].stext	
					lstr_component.ssnr  		= as_distribution_items[ll_Count].ssnr
					lstr_component.squantity	= as_distribution_items[ll_Count].squantity
					if lstr_component.squantity = "" Then
						lstr_component.squantity = String(as_distribution_items[ll_Count].lquantity )
					End If				
					ls_text =  of_get_item_description(lstr_component)
					
					
					li_Succ =  f_replace_string(ls_Text, "'", "~~~'")
					of_modify_text(ls_Object, ls_text)
					//of_modify_text(ls_Object, as_distribution_items[ll_Count])
					of_modify_dw(ls_Object + '.font.weight="400"')
					of_modify_dw(ls_Object + '.font.height="-8"')
					
					If il_Disable_Debug = 0 Then
						guoLog.uf_debug( "["+ this.classname( )+".of_draw_tr_content_drawer DISTRIBUTED ITEM TRY " + ls_Object + ": " + ls_error)
					End If
					
					ls_Object2 = "t_content_text_" + String(ll_Count + ll_Offset, "0") + "_col_" + String(arg_icolumn, "00") + "_row_" + String(arg_irow, "00")					
					// --------------------------------------------------------------------------
					// Maskieren von Single Quotes
					// --------------------------------------------------------------------------
					ls_text = as_distribution_items[ll_Count].stext	
					
					lstr_component.stext 		= as_distribution_items[ll_Count].stext	
					lstr_component.ssnr  		= as_distribution_items[ll_Count].ssnr
					lstr_component.squantity	= as_distribution_items[ll_Count].squantity
					if lstr_component.squantity = "" Then
						lstr_component.squantity = String(as_distribution_items[ll_Count].lquantity )
					End If	
					ls_text =  of_get_item_description(lstr_component)
					
					li_Succ =  f_replace_string(ls_text, "'", "~~~'")
					of_modify_text(ls_Object2, ls_text) // as_distribution_items[ll_Count])
					// ###########################################
					of_modify_text(ls_Object2, "  " + ls_text)
					// ###########################################
					//of_modify_text(ls_Object2, as_distribution_items[ll_Count])
					of_modify_dw(ls_Object2 + '.font.weight="400"')
					of_modify_dw(ls_Object2 + '.font.height="-8"')
				End if
			End If
		End If
	Next

	this.dsObjects.SetFilter("" )
	this.dsObjects.Filter()
	this.dsObjects.Sort()

End If

If ab_explode = FALSE AND of_check_explode(arg_index_key, as_unit) Then
	ls_Object = "t_master_col_" + string(arg_icolumn, "00") + "_row_" + string(arg_iRow, "00")
	//U.Paudler 19.09.2012 Hier pr$$HEX1$$fc00$$ENDHEX$$fen of der Eintrag der einzige ist
	if Upperbound(as_distribution_items) = 0 then
		of_adjust_text_size_small_big({ls_Object}, llMaxContent)
	end if
End If

// --------------------------------------------------------------------------
// Content Sheet Indicator CR NAM 12008
// --------------------------------------------------------------------------
If lb_Content_Spec_Enabled = TRUE OR (ib_non_sky AND lb_Backlog_Created) then
	// Auf die letzte Zeile die Nachricht "Content Spec"
	ls_Text = is_Overflow_MSG_1
	If lb_Backlog_Created Then
		ls_Text = is_Overflow_MSG_3
	End If
	// CBASE-NAM-CR-16008 if the content doesn$$HEX1$$1920$$ENDHEX$$t fit the indicator "content spec" should appear and a Content spec should be generated
	If lb_Backlog_Created AND ib_non_sky Then
		ls_Text = is_Overflow_MSG_1
	End If
	
	ls_Object = "t_content_text_" + String(llMaxContent, "0") + "_col_" + String(arg_icolumn, "00") + "_row_" + String(arg_irow, "00")					
	of_modify_text( ls_Object , ls_Text)
	
	// 20.10.2013 IM10526202
	ls_Object2 = "t_content_std_text_" + String(llMaxContent, "00") + "_col_" + String(arg_icolumn, "00") + "_row_" + String(arg_irow, "00")					
	of_modify_text( ls_Object2 , ls_Text)
	
	If il_Disable_Debug = 0 Then
		ls_Text = ls_Object + ""
		//of_modify_dw(ls_Object + ".Color='" + String(rgb(0,0,255)) + "'" )
	End if
End if

// --------------------------------------------------------------------------
// NAM CR 16008 Content Spec as Backlog
// --------------------------------------------------------------------------
If ib_non_sky AND lb_Backlog_Created Then
	li_Succ = of_add_backlog_as_content_sheet( ls_Parent_PL , ls_Parent_Text, ll_Parent_Qty, arg_irow, arg_icolumn )	
End If


this.dsObjects.SetFilter("")
this.dsObjects.Filter()
this.dsObjects.Sort()

return 0


end function

public function integer of_add_backlog_as_content_sheet (string as_packinglist, string as_text, long al_qty, long al_row, long al_column, boolean ab_header);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_add_backlog_as_content_sheet (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 24.05.2016
//
// Argument(e):
// string as_packinglist
//	 string as_text
//	 long al_qty
//
// Beschreibung:		Zwischenspeichern Overflow als Content Spec (NON SKY Cities CBASE-NAM-CR-16008)
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	24.05.2016		Erstellung
// 1.1 			O.Hoefer	22.08.2016		issue #1539 bei 2 identischen PL im gleichen Stauort trotzdem 2 mal drucken
//
//
// Return: integer
//
// --------------------------------------------------------------------------------

Integer	li_Succ
Long		ll_New_Row
Long		ll_Content_Header_Detail_Key
Long		ll_Sort_Counter
Long		ll_Found
String	ls_Find


guoLog.uf_debug( "["+ this.classname( )+".of_add_backlog_as_content_sheet " + as_Packinglist + " / " +  as_Text + " qty: " + String(al_qty )  + " (" + String(il_Master_Row) + ")")


if isnull(al_Row)  then al_Row = 1
if isnull(al_Column)  then al_Column = 1

ll_Sort_Counter = (1000 * al_Column) + al_Row

//ls_Find = "cpackinglist='" + as_Packinglist + "' AND nrowid=" + String(il_Master_Row)

ls_Find = "cpackinglist='" + as_Packinglist + "' AND nrowid=" + String(il_Master_Row) 
ls_Find += " AND nsort =" + String(ll_Sort_Counter)

ll_Found = ids_CSLoadingHeader.Find(ls_Find, 1, ids_CSLoadingHeader.RowCount())

If ll_Found > 0 then Return 0 

ll_New_Row = ids_CSLoadingHeader.InsertRow(0)

ll_Content_Header_Detail_Key = 1000 + ll_New_Row		

li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key)
li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				
//li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "ndetail_key", ll_Content_Header_Detail_Key)
//li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nsort", ll_Sort_Counter)				

li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nrowid", il_Master_Row)

li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "cpackinglist", as_Packinglist)
li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "ctext", as_Text)
li_Succ = ids_CSLoadingHeader.SetItem(ll_New_Row, "nquantity", al_qty)
//ll_Sort_Counter++

If ab_Header Then
	li_Succ = ids_CSLoadingHeader.Setitem(ll_New_Row, "ncontent_sheet", 1)
Else
	li_Succ = ids_CSLoadingHeader.Setitem(ll_New_Row, "ncontent_sheet", 2)
End If

return 1

end function

public function integer of_create_jasper_from_datastore (datastore ads_diagram, string as_filename);
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_create_jasper_from_datastore (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 09.03.2017
//
// Argument(e):
// datastore ads_diagram
//	 string as_filename
//
// Beschreibung:		Export DataStore to JASPER
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	09.03.2017		Erstellung
//
//
// Return: integer
//
// --------------------------------------------------------------------------------

//uo_jasper_create_cd luo_jasper
//datetime dt_today
//Long ll_id
//String	ls_Stowage
//String	ls_File
//luo_jasper = create uo_jasper_create_cd
//
//ll_id = cpu()
//
////t_watermark_100
//
//ls_Stowage = ads_diagram.describe("f_stowageposition.text")
//
////f_stowageposition
//ls_File = Left(as_filename, lastpos(as_filename, ".") - 1)
//ls_File += "_" + ls_Stowage
//ls_File += ".jrxml"
//
//luo_jasper.is_jasperfile 					= ls_File //as_filename
//
////luo_jasper.is_jasper_sub_report_file 	= f_gettemppath()  + "jasper_label_sub_" + string(ls_PL) + ".jrxml"
//
//luo_jasper.idt_reference_date  = idt_departure  //dt_today
//luo_jasper.of_export_datastore(ads_diagram )
//
//Destroy(luo_jasper)

return 0

end function

public function long of_get_bestbefore_minutes (string as_client, string as_unit, long al_airlinekey);
/*
* Objekt: 	uo_client_label
* Methode:	of_get_bestbefore_minutes (Function)
*
* Argument(e):
*
* Beschreibung:		Wert f$$HEX1$$fc00$$ENDHEX$$r Offset zur Berechnung von Best Before holen
*
* Aenderungshistorie:
* Version 		Wer				Wann				Was und warum
* 1.0 				M.N$$HEX1$$fc00$$ENDHEX$$ndel 		29.05.2012		Erstellung
*
*
* Return: integer
*	long-wert
*/

// hilfsvariable
Long 	ll_BestBeforeMinutes = 0

// erstmal fest, was RUS nutzt (8400 = 140 stunden bzw. 5 tage, 20 stunden)
//ll_BestBeforeMinutes = long(ProfileInt(s_app.sProfile, this.classname(), "BestBeforeOffset", 8400))
il_Best_Before_Minutes = 8400

SELECT nMinutes  
 INTO :il_Best_Before_Minutes  
 FROM loc_unit_times_bb  
WHERE cClient = :as_Client
	AND cUnit = :as_Unit
	AND nAirline_Key = :al_AirlineKey
	AND dvalid_from <= :idt_Departure
	AND dvalid_to >= :idt_Departure;

if sqlca.sqlcode = 100 then
	il_Best_Before_Minutes = 0
elseif sqlca.sqlcode < 0 then 	
	f_db_error(sqlca, "")
	il_Best_Before_Minutes = 0
end if

return il_Best_Before_Minutes

end function

public function integer of_draw_best_before_date ();
// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_draw_best_before_date (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 16.03.2017
//
// Argument(e):
// string as_unit
//
// Beschreibung:		Zeichne Best Before Date - request #1961 CR-RUS-1961
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	16.03.2017		Erstellung
// 1.1 			O.Hoefer	11.04.2017		Band Header oder Footer
// 1.2 			O.Hoefer	12.04.2017		Ge$$HEX1$$e400$$ENDHEX$$nderte Anforderungen  #2402
// 1.4 			O.Hoefer	02.05.2017		Ge$$HEX1$$e400$$ENDHEX$$nderte Anforderungen  #2502
//
//
// Return: integer
//
// --------------------------------------------------------------------------------

Integer		li_Succ = 1
Long			ll_Color
Long			ll_Y_pos = 4
Long			ll_x_pos = 525
String		ls_ObjectName_1, ls_ObjectName_2, ls_ObjectName_3, ls_ObjectName_4, ls_ObjectName_5, ls_ObjectName_6, ls_ObjectName_7
String		ls_Text, ls_Text_2, ls_Text_Empty
Datetime		ldt_BestBeforeTime
Datetime		ldt_KitchenTime
DateTime		ldt_help
String		ls_Create
String		ls_Band
Long			ll_Font_Size = 10	
Long			ll_X_Offset = 50

uo_datetime_functions luo_DateFunctions


//ll_Y_pos = long (  of_describe("DataWindow.Detail.Height", FALSE))
//ll_Y_pos = long (  of_describe("DataWindow.Header.Height", FALSE))
//ll_Y_pos -= 46

ll_x_pos += ll_X_Offset

if of_is_header_in_footer( ) then
	ls_Band = "footer"
Else
	ls_Band = "header"
End If

ll_Color = RGB(0, 0, 0)
//ll_Color = RGB(0, 0, 255)


ls_ObjectName_1 = "t_best_before_text"
ls_ObjectName_2 = "t_best_before_desc"
ls_ObjectName_3 = "r_best_before"
ls_ObjectName_4 = "t_best_before_prod_date"
ls_ObjectName_5 = "t_best_before_cond"
ls_ObjectName_6 = "t_best_before_empty_rect"
ls_ObjectName_7 = "t_best_before_kitchen"


// =======================================================
// Part 1: Rectangle
// =======================================================
ls_Create = "create rectangle(band=" + ls_Band +" x='" + string(ll_x_pos) +  &
			   "' y='" + string(ll_Y_pos) + "' height='" + string(87) + &
				"' width='" + string(195 - ll_X_Offset) + "' name=" + ls_ObjectName_3 + &
				" resizeable=" + string(0)  + "  moveable=" + string(0)  + &
				" visible='1'" + &
				"  brush.hatch='" + string(7) + &
				"' pen.style='0' pen.width='" + string(1) + &
				"' pen.color='" + string(0) + &
				"' background.mode='2' background.color='0')"	

of_modify( ls_Create, FALSE)

// =======================================================
// Part 2: Fixed Text "Haltbarkeit:"
// =======================================================
ll_Y_pos = 9
ll_x_pos += 3
//of_create_text(ls_ObjectName_2, ls_Text_2, FONT_MS_SANS_SERIF, 9, FONT_BOLD, 10 , ll_Y_pos, 14 , 100 , 0, 0,  ll_Color, 1)	

ls_Text_2 = uf.translate("Lagerbedingungen Trockeneis") //"Haltbarkeit:")

ls_Create = "create text(band=" + ls_Band +" alignment='" + string(0) + "' " + &
			"text='" + ls_Text_2 + "' border='" + string(0) + "' color='" + String(ll_Color) + "' " + &
			"x='" + string(ll_x_pos) +  "' y='" + string(ll_Y_pos) + "' " + &
			" height='"+ String(13) + "' width='" + string(181 - ll_X_Offset) + "' " + &
			" name=" + ls_ObjectName_2 + &
			" visible='" + string(1) + "' resizeable=" + String(0) + "  moveable=" + String(0) + " font.face='" + FONT_MS_SANS_SERIF + "' " + &
			" font.height='" + String(ll_Font_Size) + "' font.weight='" + String(FONT_NORMAL) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"
			
of_modify( ls_Create, FALSE)			

// =======================================================
// Part 3: Fixed Text "Kitchen Time"
// =======================================================
ll_Y_pos = 29
//of_create_text(ls_ObjectName_2, ls_Text_2, FONT_MS_SANS_SERIF, 9, FONT_BOLD, 10 , ll_Y_pos, 14 , 100 , 0, 0,  ll_Color, 1)	
//ls_Text_2 = uf.translate("Trockeneisproduktionsdatum")
ls_Text_2 = uf.translate("K$$HEX1$$fc00$$ENDHEX$$chenzeit:")
ls_Create = "create text(band=" + ls_Band +" alignment='" + string(0) + "' " + &
			"text='" + ls_Text_2 + "' border='" + string(0) + "' color='" + String(ll_Color) + "' " + &
			"x='" + string(ll_x_pos) +  "' y='" + string(ll_Y_pos) + "' " + &
			" height='"+ String(13) + "' width='" + string(181 - ll_X_Offset) + "' " + &
			" name=" + ls_ObjectName_4 + &
			" visible='" + string(1) + "' resizeable=" + String(0) + "  moveable=" + String(0) + " font.face='" + FONT_MS_SANS_SERIF + "' " + &
			" font.height='" + String(ll_Font_Size) + "' font.weight='" + String(FONT_NORMAL) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"	
of_modify( ls_Create, FALSE)			

// =======================================================
// Part 4: Fixed Text "Best Before"
// =======================================================
ll_Y_pos = 61
//of_create_text(ls_ObjectName_2, ls_Text_2, FONT_MS_SANS_SERIF, 9, FONT_BOLD, 10 , ll_Y_pos, 14 , 100 , 0, 0,  ll_Color, 1)	
ls_Text_2 = uf.translate("Haltbar bis:")
ls_Create = "create text(band=" + ls_Band +" alignment='" + string(0) + "' " + &
			"text='" + ls_Text_2 + "' border='" + string(0) + "' color='" + String(ll_Color) + "' " + &
			"x='" + string(ll_x_pos) +  "' y='" + string(ll_Y_pos) + "' " + &
			" height='"+ String(13) + "' width='" + string(181 - ll_X_Offset) + "' " + &
			" name=" + ls_ObjectName_5 + &
			" visible='" + string(1) + "' resizeable=" + String(0) + "  moveable=" + String(0) + " font.face='" + FONT_MS_SANS_SERIF + "' " + &
			" font.height='" + String(ll_Font_Size) + "' font.weight='" + String(FONT_NORMAL) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"	
of_modify( ls_Create, FALSE)			


// =======================================================
// Part 5: Best Before Date
// =======================================================
ll_Y_pos = 75
//ll_x_pos = 630

// bestbefore bestimmen: f$$HEX1$$fc00$$ENDHEX$$r k$$HEX1$$fc00$$ENDHEX$$chenzeit tag erg$$HEX1$$e400$$ENDHEX$$nzen
ldt_help = datetime(date( idt_departure ), time(is_Kitchen_Time))
// abflug-termin kleiner als gleicher tag + k$$HEX1$$fc00$$ENDHEX$$chenzeit: tag um 1 reduzieren
if datetime(date(idt_departure), time(is_Departure_Time)) < ldt_help then
	ldt_help = datetime(relativedate(date(idt_departure),-1), time(is_Kitchen_Time))
End if
ldt_BestBeforeTime = luo_DateFunctions.of_rel_datetime_minutes(ldt_help, il_Best_Before_Minutes)
ls_Text = String(ldt_BestBeforeTime , s_app.sdateformat + " hh:mm")

ls_Create = "create text(band=" + ls_Band +" alignment='" + string(2) + "' " + &
			"text='" + ls_Text + "' border='" + string(0) + "' color='" + String(ll_Color) + "' " + &
			"x='" + string(ll_x_pos) +  "' y='" + string(ll_Y_pos) + "' " + &
			" height='"+ String(13) + "' width='" + string(83) + "' " + &
			" name=" + ls_ObjectName_1 + &
			" visible='" + string(1) + "' resizeable=" + String(0) + "  moveable=" + String(0) + " font.face='" + FONT_MS_SANS_SERIF + "' " + &
			" font.height='" + String(ll_Font_Size) + "' font.weight='" + String(FONT_BOLD) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"
			
of_modify( ls_Create, FALSE)			



// =======================================================
// Part 6: Kitchen Time
// =======================================================
ll_Y_pos = 42
//ll_x_pos = 630

// bestbefore bestimmen: f$$HEX1$$fc00$$ENDHEX$$r k$$HEX1$$fc00$$ENDHEX$$chenzeit tag erg$$HEX1$$e400$$ENDHEX$$nzen
ldt_help = datetime(date( idt_departure ), time(is_Kitchen_Time))
// abflug-termin kleiner als gleicher tag + k$$HEX1$$fc00$$ENDHEX$$chenzeit: tag um 1 reduzieren
if datetime(date(idt_departure), time(is_Departure_Time)) < ldt_help then
	ldt_help = datetime(relativedate(date(idt_departure),-1), time(is_Kitchen_Time))
End if
//ldt_BestBeforeTime = luo_DateFunctions.of_rel_datetime_minutes(ldt_help, il_Best_Before_Minutes)
//ls_Text =  is_kitchen_time // String(ldt_BestBeforeTime , s_app.sdateformat )
ls_Text =  String(ldt_help , s_app.sdateformat + " hh:mm")

//of_create_text(ls_ObjectName_1, ls_Text, FONT_MS_SANS_SERIF, 12, FONT_BOLD, 10 , ll_Y_pos, 20 , 100 , 0, 0,  ll_Color, 1)	

ls_Create = "create text(band=" + ls_Band +" alignment='" + string(2) + "' " + &
			"text='" + ls_Text + "' border='" + string(0) + "' color='" + String(ll_Color) + "' " + &
			"x='" + string(ll_x_pos) +  "' y='" + string(ll_Y_pos) + "' " + &
			" height='"+ String(14) + "' width='" + string(83) + "' " + &
			" name=" + ls_ObjectName_7 + &
			" visible='" + string(1) + "' resizeable=" + String(0) + "  moveable=" + String(0) + " font.face='" + FONT_MS_SANS_SERIF + "' " + &
			" font.height='" + String(ll_Font_Size) + "' font.weight='" + String(FONT_BOLD) + "' font.family='2' font.pitch='2'" + &
			" font.charset='0' font.italic='0' font.underline='0'" +&
			" background.mode='1'" + &
			" background.color='536870912')"
			
of_modify( ls_Create, FALSE)		


Return li_Succ


end function

public function integer of_draw_barcode (long al_pl_index_key, long al_stowage_key);/*
* Objekt : uo_cart_diagram
* Methode: of_draw_barcode (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 18.06.2019
*
* Argument(e):
* long al_pl_index_key
*	 long al_stowage_key
*
* Beschreibung:		Draw a Barcode on the Diagram Header
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	18.06.2019		Erstellung
*
*
* Return: integer
*
*/


Integer		li_Succ = -1
String		ls_ObjectName
String		ls_modify
String		ls_Band
String		ls_barcode_file
//Blob	 		lb_barcode
Long			ll_Qty = 1

String		ls_barcode
String		ls_Temp
Long			ll_Key
String		ls_PL

guoLog.uf_debug( "["+ this.classname( )+".of_draw_barcode] START")

ls_Band = is_Barcode_Band
if of_is_header_in_footer( ) then
	if is_Barcode_Band  = "footer" Then
		ls_Band  = "header"
	Else
		ls_Band  = "footer"
	End If
End If



ls_barcode_file =  f_gettemppath() + "cbase_barcode_" + string( al_pl_index_key , "000") + "_" + string(cpu()) + ".bmp"


//	Flug-Label VPS (WIKI)
// Barcode ID
//	npackinglistIndexKey
//	ddeparture
//	nresultKey
//	nstowageKey
//	nppmProdLabelKey

//	%001%0000020019311 8 0 42017000023495158000008154711000 0 08154711

ls_barcode = "%001%"

ls_Temp = String( al_pl_index_key , "000000000000")
//dwData.GetItemNumber(lRows,"cen_packinglist_index_npackinglist_index_key"), "000000000000")
ls_barcode += ls_Temp

//			String(strFlightInfo.dtDepartureDate),"YYYYMMDD")

ls_Temp = String( idt_departure,"DDMMYYYY") //  strFlightInfo.dtDepartureDate,"YYYYMMDD")
ls_barcode += ls_Temp

ls_Temp = String(   il_Result_Key,  "000000000000")
ls_barcode += ls_Temp


ls_Temp = String( al_stowage_key , "000000000000") //dwData.GetItemNumber(lRows, "cen_stowage_nstowage_key"), "000000000000")
ls_barcode += ls_Temp

					
ll_Key = 0
//select nppm_prod_label_key 

select min(nppm_prod_label_key) 
into :ll_Key
from cen_out_ppm_prod_label 
where nresult_key = :il_Result_Key
and nstowage_key = :al_stowage_key
and npl_index_key = :al_pl_index_key   ;

IF SQLCa.SQLCode = 0 Then
	//OK
Else
	SetNULL(ll_Key)
End If

If ll_Key = 0 Then
	SetNULL(ll_Key)
End If

if not isnull(ll_Key) Then

	ls_Temp = String(ll_Key,  "000000000000")
	ls_barcode += ls_Temp

	this.of_create_barcode(58, ls_barcode_file, ls_barcode, 120,120, 75)
	
	guoLog.uf_debug("["+ this.classname( )+".of_draw_barcode] "  +  this.isStowage +" - " + "VPS Flight Label Barcode " + " " + ls_barcode)
	
	// -----------------------------------------------------------
	
else
	guoLog.uf_debug("["+ this.classname( )+".of_draw_barcode] "  +  this.isStowage +" - " + "NO VPS Flight Label Barcode found "  )

end if

sRegisteredFiles[Upperbound(sRegisteredFiles) + 1] = ls_barcode_File

ls_ObjectName = "h_barcode_" + String(now(), "hhmmssfff")

ls_modify = "create bitmap(name=" + ls_ObjectName + " visible='" + String(1)  + "' resizeable=" + String(1) + "  moveable=" + String(1)  + &
 " band=" + ls_Band + " filename='" + ls_barcode_File + "'" + &
 " x='" + string(ii_Barcode_X) + "' y='" + string(ii_Barcode_Y) + &
 "' height='" + String(ii_Barcode_H) + "' width='" + String(ii_Barcode_W) + "' border='" + String(border_none ) + "' )"

li_Succ = of_modify(ls_modify, FALSE)

//of_set_position(ls_Name, TRUE, ab_backlog )
//dw .SetPosition ( ls_ObjectName,  is_barcode_band , TRUE )
		
if isValid(oDw) Then
	 oDw.SetPosition ( ls_ObjectName,  is_barcode_band , TRUE )
End If

if isValid(oDS) Then
	oDS.SetPosition ( ls_ObjectName,  is_barcode_band , TRUE )
End If		
		

guoLog.uf_debug( "["+ this.classname( )+".of_draw_barcode] END")


ls_modify = 'f_rampbox.visible=0'
li_Succ = of_modify(ls_modify, FALSE)

ls_modify = 't_f_rampbox.visible=0'
li_Succ = of_modify(ls_modify, FALSE)


il_Stowage_Keys[upperbound(il_Stowage_Keys) + 1] = al_Stowage_key

//SetNULL(lb_barcode)

Return li_Succ


end function

public function boolean of_is_barcode_enabled (string as_unit);
/*
* Objekt : uo_cart_diagram
* Methode: of_is_barcode_enabled (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
*
* Argument(e):
* none
*
* Beschreibung:		Barcode Schalter pro CSC
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	11.12.2017		Erstellung
* 1.1 			O.Hoefer	16.12.2019		#5850 
*
*
* Return: boolean
*
*/


// Check Barcode-Switch
String	ls_BC


//   	CUNIT	CSECTION	CKEY	CVALUE	DTIMESTAMP	CCHANGED	ROWID
//2	3201	PPMBARCODE4GROUP	4643	1	18.06.2019 09:48:17	CBASE	AABvEJAALAAAACmAAA


If f_unitprofileString("PPMBARCODE4GROUP", String(il_Printing_Group) , "0", as_Unit) = "1" then
	ib_PPMBARCODE4GROUP = TRUE
Else
	ib_PPMBARCODE4GROUP = FALSE
End If

ls_BC = f_unitprofileString("BARCODEONCD", "ENABLED", "0", as_Unit)

If upper(ls_BC) = "1" Then
	Return TRUE
Else
	Return FALSE
End If
	
Return TRUE	
end function

public function long of_add_text (string stext, long lx, long ly, long lheight, long lwidth, string as_font, boolean ab_bold, integer ai_size, integer ai_align);/* 
* Funktion/Event: of_add_text
* Beschreibung: 	Freitext platzieren
*						
* Besonderheit: 	keine
*
* Argumente:
* 	Name				Beschreibung
* 	 sText			Anzuzeigender Text
*
* Aenderungshistorie:
* 	Version 		Wer			Wann			Was und warum
*	1.0 			K.F$$HEX1$$f600$$ENDHEX$$rster	22.09.2008		Erstellung
*	 
*
* Return Codes:
*	 1		Alles OK
*	-1		Fehler
*  
*/
Long	lFound, a
LongLong lllSequence
String		sTName
// 02.02.2010 Ulrich Paudler [UP] Maximale xPosition ermitteln
if not of_check_boundary(lx, ly, lheight, lwidth) Then
	lx = long(oDw.object.r_frame.Width) - lwidth
End If

// --------------------------------------------------------------------------------------------------------------------
// 15.09.2020 HR: ALMID 6379: Umstellung auf LongLong
// --------------------------------------------------------------------------------------------------------------------
lllSequence = f_sequence_ll("seq_cen_pl_layout_add_obj", sqlca)

if lllSequence = -1 Then
	sError = "Error: Sequence failed"
	return -1
End If

sTName = "t_text_" + string(a) + "_" + string(now(), "hhmmss")
a = this.dsLayoutAddObjects.InsertRow(0)
this.dsLayoutAddObjects.SetItem(a, "nadd_object_key", lllSequence)
this.dsLayoutAddObjects.SetItem(a, "nlayout_key", this.lLayoutKey)
this.dsLayoutAddObjects.SetItem(a, "nobject_type", TEXTOBJECT) // 1 = text, 2 = bitmap, 3 = rectangle, 4 = content
this.dsLayoutAddObjects.SetItem(a, "cobject_name", sTName)
this.dsLayoutAddObjects.SetItem(a, "nheight", 20)
If ai_size > 10 then
	this.dsLayoutAddObjects.SetItem(a, "nheight", 40)
else
	this.dsLayoutAddObjects.SetItem(a, "nheight", 20)
end if

If ai_size > 10 then
	this.dsLayoutAddObjects.SetItem(a, "nwidth", 180)
Else
	this.dsLayoutAddObjects.SetItem(a, "nwidth", 100)
End If

// 19.01.2010 Ulrich Paudler [UP]
this.dsLayoutAddObjects.SetItem(a, "nxpos", of_get_xposition(lX, sTName ))
this.dsLayoutAddObjects.SetItem(a, "nypos", lY)
this.dsLayoutAddObjects.SetItem(a, "nborderstyle", 0)
this.dsLayoutAddObjects.SetItem(a, "ntextalign", ai_align) //0)
this.dsLayoutAddObjects.SetItem(a, "cfontname", as_font) //"Arial")
this.dsLayoutAddObjects.SetItem(a, "nfontcolor", RGB(0,0,0))
If ab_bold Then
	this.dsLayoutAddObjects.SetItem(a, "nfontweight", FONT_BOLD) 
Else
	this.dsLayoutAddObjects.SetItem(a, "nfontweight", FONT_NORMAL) 
End If
If ABS(ai_Size) < 4 Then
	this.dsLayoutAddObjects.SetItem(a, "nfontsize", 10)
Else
	this.dsLayoutAddObjects.SetItem(a, "nfontsize", ai_Size)
End If
this.dsLayoutAddObjects.SetItem(a, "cvalue", sText)
this.dsLayoutAddObjects.SetItem(a, "nresizeable", 1)
this.dsLayoutAddObjects.SetItem(a, "nmoveable", 1)

this.of_create_text(a)
	
return 1
end function

public function integer zzz_of_draw_barcode (long al_pl_index_key, long al_stowage_key);

// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: of_draw_barcode (Function)
// Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
// Datum  : 23.08.2017
//
// Argument(e):
//  long al_pl_index_key
//	 long al_stowage_key
//
// Beschreibung:		Draw a Barcode on the Diagram Header
//
// Aenderungshistorie:
// Version 		Wer			Wann			Was und warum
// 1.0 			O.Hoefer	23.08.2017		Erstellung
// 1.1 			O.Hoefer	15.02.2018		Korrektur Band bei Header / Footer Tausch
//
//
// Return: integer
//
// --------------------------------------------------------------------------------

Integer		li_Succ = 1
String		ls_ObjectName
String		ls_modify
String		ls_Band
String		ls_File
Blob	 		lb_barcode
Long			ll_Qty = 1


guoLog.uf_debug( "["+ this.classname( )+".zzz_of_draw_barcode] START")

ls_Band = is_Barcode_Band
if of_is_header_in_footer( ) then
	if is_Barcode_Band  = "footer" Then
		ls_Band  = "header"
	Else
		ls_Band  = "footer"
	End If
End If


// Get Blob
Selectblob cbase_functions.pf_get_2d_code_flightlabel_wo( :il_result_key ,
                                                     :idt_departure ,
                                                     :al_pl_index_key,
                                                     :al_stowage_key,
                                                     :ll_Qty)
into :lb_barcode																	  																	  
From dual;

If sqlca.sqlcode <> 0 then
	guoLog.uf_error( "["+ this.classname( )+".zzz_of_draw_barcode] ERROR")
	return -1
end if

// Blob to File
ls_File =  f_gettemppath() + "barcode_" + "CD" + "_" + String(now(), "hhmmssfff") + ".jpg"

If not isnull(lb_barcode) Then
	// ins Filesystem
	li_Succ = of_blob_to_file( ls_file, lb_barcode)

	sRegisteredFiles[Upperbound(sRegisteredFiles) + 1] = ls_File
	
	ls_ObjectName = "h_barcode_" + String(now(), "hhmmssfff")
	
	ls_modify = "create bitmap(name=" + ls_ObjectName + " visible='" + String(1)  + "' resizeable=" + String(1) + "  moveable=" + String(1)  + &
	 " band=" + ls_Band + " filename='" + ls_File + "'" + &
	 " x='" + string(ii_Barcode_X) + "' y='" + string(ii_Barcode_Y) + &
	 "' height='" + String(ii_Barcode_H) + "' width='" + String(ii_Barcode_W) + "' border='" + String(border_none ) + "' )"

	li_Succ = of_modify(ls_modify, FALSE)
	//	of_set_position(ls_Name, FALSE, ab_backlog )
		
End If

guoLog.uf_debug( "["+ this.classname( )+".zzz_of_draw_barcode] END")


ls_modify = 'f_rampbox.visible=0'
li_Succ = of_modify(ls_modify, FALSE)

ls_modify = 't_f_rampbox.visible=0'
li_Succ = of_modify(ls_modify, FALSE)


SetNULL(lb_barcode)

Return li_Succ


end function

public function integer of_create_barcode (long ai_type, string as_file, string as_text, long ai_width, long ai_height, long ai_dpi);/* ### Event: of_create_barcode *******************************************
 *
 * Beschreibung : Funktion zur Erstellung eines Barcodes
 *
 *	Parameter : 	ai_type 	= 	37: Barcode DataMatrix
 * 									 	14: Barcode Code128
 * 						as_file	=	Filename (incl Pfad) des Barcodes
 *						as_text 	= 	Text der im Barcode codiert werden soll
 *			 			ai_width	=	Breite des Barcodes
 *			 			ai_height	=	H$$HEX1$$f600$$ENDHEX$$he des Barcodes
 *			 			ai_dpi		=	Aufl$$HEX1$$f600$$ENDHEX$$sung des Barcodes
 *
 * Aenderungshistorie
 *  Version  Wer                        			Wann        		Was und warum
 *   1.0     	H.Rothenbach /LSY IS       	19.11.2007  	Erstellung
 *	  1.1 		H.Rothenbach /LSY IS       	05.06.2008  	Austausch des Barcodes
 *   1.2		Klaus								21.09.2012		Aus PPS $$HEX1$$fc00$$ENDHEX$$bernommen
 * ### END Eventdoku ***************************************************
 */

return iuoPpsBarcodes.of_create_barcode(ai_type, as_file, as_text, ai_width, ai_height, ai_dpi)
/*
long result
OLEObject myoleobject

myoleobject = CREATE OLEObject

//---------------------------------------------------------------------------------
// Code f$$HEX1$$fc00$$ENDHEX$$r TBarcode8
//---------------------------------------------------------------------------------
result = myoleobject.ConnectToNewObject("TBarCode8.TBarCode8")
	
myoleobject.LicenseMe("Mem: Lufthansa Systems Business Solutions GmbH", 3, 1, "71636CB6AA94C8F74F7A837E4F68D978", 33)
	
if  ai_type = 37 then
	 myoleobject.BarCode =71 
elseif  ai_type = 58 then
	 myoleobject.BarCode =58 
else
	myoleobject.BarCode =20 
	myoleobject.PrintDataText = FALSE //true
	myoleobject.BackStyle = 1 
	ai_width = myoleobject.CountModules() * 3
	ai_height = 60
end if

if isnull(as_text) then
	Messagebox("Achtung","Der $$HEX1$$fc00$$ENDHEX$$bergebene Barcodetext ist NULL. Es kann kein Barcode erstellt werden")
	myoleobject.text=" "
else
	myoleobject.text=as_text
	myoleobject.SaveImage(as_file, 0, ai_width,ai_height, 96, 96) 
end if

myoleobject.DisconnectObject() 
destroy myoleobject

return 1
*/
// #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

end function

public function long of_get_tr_cart_key (string as_unit, long al_index_key, date adt_ref_date, ref long ral_number_of_rungs, ref long ral_number_of_columns, ref long ral_number_of_pages, long al_airline_key);/*
* Methode: of_get_tr_cart_key (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.02.2014
*
* Argument(e):
*	 string as_unit
*	 long al_index_key
*	 date adt_ref_date
*	 ref integer rai_number_of_rungs
*	 ref integer rai_number_of_columns
*	 ref integer rai_number_of_pages			=> "2": add Page for Double Carts (Front-Rear x Left-Right x Height)
*
* Beschreibung:				Ermittle TR Cart f$$HEX1$$fc00$$ENDHEX$$r Betrieb, St$$HEX1$$fc00$$ENDHEX$$ckliste, Datum (via Workstation)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.02.2014		Erstellung
* 1.1 			O.Hoefer	06.01.2020		issue #5947 TR diagrams showing stowage locations in incorrect order
* 1.2 			O.Hoefer	12.02.2020		#5168 TR Cart assignment per Routing and Airline
*
*
* Return: long
*
*/


Long			ll_Rows
Long			ll_Return = -1
String		ls_PL
Long			ll_routing_id = 0
uo_CBASE_DataStore	lds_Allocated_TR



lds_Allocated_TR = CREATE uo_CBASE_DataStore
lds_Allocated_TR.DataObject = "dw_loc_unit_tr_cart_per_pl"
lds_Allocated_TR.SetTransObject(SQLCA)


ll_Rows = lds_Allocated_TR.Retrieve(as_Unit, al_Index_Key, adt_Ref_Date)

ls_PL = f_get_packinglist (al_Index_Key)

guoLog.uf_debug( "["+ this.classname( )+".of_get_tr_cart_key] " + as_Unit + " Airline " +String(al_airline_key) + " " + ls_PL)

// ---------------------------------------------------------
// #5168 Routing
// ---------------------------------------------------------
select nrouting_id into :ll_routing_id from cen_out where nresult_key = :il_result_key;
		
If al_Airline_key > 0 then
	lds_Allocated_TR.SetFilter("nairline_key=" + String(al_airline_key ) )
	If ll_Routing_ID  > -1 then 
		lds_Allocated_TR.SetFilter("nairline_key=" + String(al_airline_key ) + " and nrouting_id in (0," + String(ll_routing_id ) + ")")
	End If
	lds_Allocated_TR.Filter()
	ll_Rows = lds_Allocated_TR.Rowcount( )
Else
	// ---------------------------------------------------------
	// #5168 Routing
	// ---------------------------------------------------------
	select nrouting_id into :ll_routing_id from cen_out where nresult_key = :il_result_key;
	If ll_Routing_ID  > -1 then 
		lds_Allocated_TR.SetFilter("nrouting_id in (0," + String(ll_routing_id ) + ")")
		lds_Allocated_TR.Filter()
		ll_Rows = lds_Allocated_TR.Rowcount( )
	End If
End If


If ll_Rows > 0 Then
	ll_Return = lds_Allocated_TR.GetItemNumber(1, "ntr_cart_key")
	
	ral_Number_of_Rungs = lds_Allocated_TR.GetItemNumber(1, "nrungs")
	ral_Number_Of_Columns = lds_Allocated_TR.GetItemNumber(1, "ncolumns")
	If lds_Allocated_TR.GetItemNumber(1, "nmultiply") = 2 Then
		ral_Number_of_Pages = 2
	Else
		ral_Number_of_Pages = 1
	End If
		
	is_TR_Area		= lds_Allocated_TR.GetItemString(1, "carea")
	is_TR_WS			= lds_Allocated_TR.GetItemString(1, "loc_unit_workstation_ctext")
	is_TR_Freetext	= lds_Allocated_TR.GetItemString(1, "ccomment")
	
	
	il_rungs 		= ral_Number_of_Rungs	
	il_columns 		= ral_Number_of_Columns 
	il_multiply		= ral_Number_of_Pages

	// issue #5947 TR diagrams showing stowage locations in incorrect order	
	If lds_Allocated_TR.GetItemNumber(1, "loc_unit_tr_cart_nfill_top_down") = 1 Then
		ib_TR_Fill_Top_Down			= TRUE
	Else
		ib_TR_Fill_Top_Down			= FALSE
	End If
	
	is_TR_Name = lds_Allocated_TR.GetItemString(1, "cname")
	iscontainershortname = lds_Allocated_TR.GetItemString(1, "cname")
	is_TR_Cart_Area_WS = is_TR_Area + "-" + is_TR_WS
	
     guoLog.uf_debug( "["+ this.classname( )+".of_get_tr_cart_key] "+is_TR_Name+ "  "	+ String(ll_Return) + " " + String(ral_Number_of_Rungs) + " x " + String(ral_Number_of_Columns))

	
End If


DESTROY	lds_Allocated_TR


Return ll_Return

end function

public function long of_get_tr_cart_key_old (string as_unit, long al_index_key, date adt_ref_date, ref long ral_number_of_rungs, ref long ral_number_of_columns, ref long ral_number_of_pages);/*
* Methode: of_get_tr_cart_key (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.02.2014
*
* Argument(e):
*	 string as_unit
*	 long al_index_key
*	 date adt_ref_date
*	 ref integer rai_number_of_rungs
*	 ref integer rai_number_of_columns
*	 ref integer rai_number_of_pages			=> "2": add Page for Double Carts (Front-Rear x Left-Right x Height)
*
* Beschreibung:				Ermittle TR Cart f$$HEX1$$fc00$$ENDHEX$$r Betrieb, St$$HEX1$$fc00$$ENDHEX$$ckliste, Datum (via Workstation)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.02.2014		Erstellung
*
*
* Return: long
*
*/


Long			ll_Rows
Long			ll_Return = -1
DataStore	lds_Allocated_TR


lds_Allocated_TR = CREATE DataStore
lds_Allocated_TR.DataObject = "dw_loc_unit_tr_cart_per_pl"
lds_Allocated_TR.SetTransObject(SQLCA)

ll_Rows = lds_Allocated_TR.Retrieve(as_Unit, al_Index_Key, adt_Ref_Date)

If ll_Rows > 0 Then
	ll_Return = lds_Allocated_TR.GetItemNumber(1, "ntr_cart_key")
	
	ral_Number_of_Rungs = lds_Allocated_TR.GetItemNumber(1, "nrungs")
	ral_Number_Of_Columns = lds_Allocated_TR.GetItemNumber(1, "ncolumns")
	If lds_Allocated_TR.GetItemNumber(1, "nmultiply") = 2 Then
		ral_Number_of_Pages = 2
	Else
		ral_Number_of_Pages = 1
	End If
	
	
	is_TR_Area		= lds_Allocated_TR.GetItemString(1, "carea")
	is_TR_WS			= lds_Allocated_TR.GetItemString(1, "loc_unit_workstation_ctext")
	is_TR_Freetext	= lds_Allocated_TR.GetItemString(1, "ccomment")
	
	il_rungs 		= ral_Number_of_Rungs	
	il_columns 		= ral_Number_of_Columns 
	il_multiply		= ral_Number_of_Pages
	
	is_TR_Name = ""//lds_Allocated_TR.GetItemString(1, "cname")
	is_TR_Cart_Area_WS = is_TR_Area + "-" + is_TR_WS
	
End If


DESTROY	lds_Allocated_TR


Return ll_Return
end function

public function long of_get_tr_cart_type_old (string as_client, string as_unit, long al_airline_key, long al_routing_id);/*
* Objekt : uo_cart_diagram
* Methode: of_get_tr_cart_type (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 23.07.2010
*
* Argument(e):
* string as_unit
*	 long al_airline_key
*
* Beschreibung:		Ermittle zu verwendenden TR Cart Typ
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	23.07.2010		Erstellung
* 1.1 			O.Hoefer	18.10.2012		NAM-CR-12071 Funktion Master Data Preview
*
*
* Return: long
*
*/

Long		ll_TR_Type
String	ls_Type, ls_Description
Long		ll_Rungs, ll_Columns, ll_Multiply
Long		ll_Use_Class
Long		ll_Top_Down
Long		ll_Workstation_key, ll_area_key
String	ls_Area, ls_WS


If ib_enable_masterdata_view Then
	// NAM-CR-12071 Funktion Master Data Preview ON
	as_unit = ""
End If


is_TR_Cart_Area_WS = ""
ib_TR_Use_Class = FALSE
ib_TR_Fill_Top_Down = FALSE
// Lese Typ pro Client + CSC + Airline + Routing
SELECT loc_airline_tr_carts.ntr_cart_key  , cname  , nrungs, ncolumns, nmultiply, cdescription, nuse_class, nfill_top_down, nworkstation_key, narea_key
INTO :ll_TR_Type , :ls_Type, :ll_Rungs, :ll_Columns, :ll_Multiply, :ls_Description, :ll_Use_Class, :ll_Top_Down, :ll_Workstation_key, :ll_area_key
FROM loc_airline_tr_carts  , loc_unit_tr_cart
WHERE (loc_airline_tr_carts.cclient = :as_Client )   
AND    loc_airline_tr_carts.ntr_cart_key  = loc_unit_tr_cart.ntr_cart_key
AND    ( loc_airline_tr_carts.cunit = :as_Unit )   
AND   ( loc_airline_tr_carts.nairline_key = :al_Airline_key )  
and   loc_airline_tr_carts.nrouting_id = :al_routing_id ;

If SQLCA.SQLCode = 0 Then
	If ll_TR_Type > 0 AND NOT IsNULL(ll_TR_Type) Then
		isContainerShortName		= ls_Type
		il_Rungs						= ll_Rungs
		il_Columns					= ll_Columns
		il_Multiply					= ll_Multiply
		is_TR_Cart_Description	= ls_Description
		If ll_Use_Class = 1 Then
			ib_TR_Use_Class = TRUE			
		End If
		If ll_Workstation_key > 0 AND ll_area_key > 0 Then
			
			//SELECT	loc_unit_areas.carea,            loc_unit_workstation.cworkstation  
			//SELECT	loc_unit_areas.ctext,            loc_unit_workstation.ctext  
			SELECT	loc_unit_areas.carea,            loc_unit_workstation.ctext  
			INTO		:ls_Area,            :ls_WS  
			FROM		loc_unit_areas,            loc_unit_workstation  
			WHERE		loc_unit_workstation.narea_key = loc_unit_areas.narea_key
			and		loc_unit_workstation.narea_key = :ll_area_key    
			AND		loc_unit_workstation.nworkstation_key = :ll_Workstation_key    ;

			If SQLCA.SQLCode = 0 Then

				is_TR_Cart_Area_WS = ls_Area + "-" + ls_WS
			Else
				If SQLCA.SQLCode <> 100 Then
					f_db_error(sqlca, "of_get_tr_cart_type failed")			
				End If
			End If
		
		End if
		If ll_Top_Down = 1 Then
			ib_TR_Fill_Top_Down = TRUE
			if il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Fill_Top_Down TRUE")
			end if
		Else
			if il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Fill_Top_Down FALSE")
			end if
		End If
				
		If il_Disable_Debug = 0 then
			If ib_TR_Use_Class Then
				guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Use_Class=TRUE " + as_unit + " " +  String(al_airline_key ) )		
			ELse
				guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Use_Class=FALSE " + as_unit + " " +  String(al_airline_key ) )						
			End if
		End If
		
		Return ll_TR_Type
	Else
		if il_Disable_Debug = 0 Then
			guoLog.uf_debug( "["+ this.classname( )+".of_get_tr_cart_type NO VALID TR CART " + as_Client + " " + as_unit + " Airline "  + String(al_airline_key ) + " Routing " + String(al_routing_id ) )
		end if
		Return -1	
	End If

ElseIf SQLCA.SQLCode <> 100 Then
	f_db_error(sqlca, "of_get_tr_cart_type failed")			

Else
	// Wenn nicht gefunden: gibt es einen Default Typ pro Client + CSC
	SELECT ntr_cart_key  , cname , nrungs, ncolumns, nmultiply, cdescription, nuse_class
	INTO :ll_TR_Type, :ls_Type, :ll_Rungs, :ll_Columns, :ll_Multiply, :ls_Description, :ll_Use_Class
	FROM loc_unit_tr_cart  
	WHERE  cclient = :as_Client    
	AND       cunit = :as_unit
	AND  ndefault = 1;
	If SQLCA.SQLCode = 0 Then
		If ll_TR_Type > 0 AND NOT IsNULL(ll_TR_Type) Then
			isContainerShortName		= ls_Type
			il_Rungs						= ll_Rungs
			il_Columns					= ll_Columns
			il_Multiply					= ll_Multiply
			is_TR_Cart_Description	= ls_Description
			If ll_Use_Class = 1 Then
				ib_TR_Use_Class = TRUE
			End If
			If ll_Top_Down = 1 Then
				ib_TR_Fill_Top_Down = TRUE
				if il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Fill_Top_Down TRUE DEFAULT")
				end if
			Else
				if il_Disable_Debug = 0 Then
					guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Fill_Top_Down FALSE DEFAULT")
				end if
			End If
			
			If il_Disable_Debug = 0 then
				If ib_TR_Use_Class Then
					guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Use_Class=TRUE " + as_unit + " DEFAULT" )		
				ELse
					guoLog.uf_debug( "["+ this.classname( )+".ib_TR_Use_Class=FALSE " + as_unit + " DEFAULT" )						
				End if
			End If

			Return ll_TR_Type
		End If
	Else
		If SQLCA.SQLCode <> 100 Then
			f_db_error(sqlca, "of_get_tr_cart_type failed")			
		else
			if il_Disable_Debug = 0 Then
				guoLog.uf_debug( "["+ this.classname( )+".of_get_tr_cart_type NO VALID TR CART " + as_Client + " " + as_unit + " Airline "  + String(al_airline_key ) + " Routing " + String(al_routing_id ) )		
			end if
		end if
		
		Return -1
	End If
End If

if il_Disable_Debug = 0 Then
	guoLog.uf_debug( "["+ this.classname( )+".of_get_tr_cart_type NO VALID TR CART " + as_Client + " " + as_unit + " Airline "  + String(al_airline_key ) + " Routing " + String(al_routing_id ) )
end if


Return -1

end function

public function long of_set_file_to_blob (longlong arg_laddkey, string arg_sfile);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_blob_to_file (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 16.04.2009
*
* Argument(e):	long arg_laddkey
* Return: string
*
*
* Blob erst von file lesen und dann speichern
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*
*************************************************************/

Blob bBlob

if FileExists(arg_sfile) Then
	setnull(bBlob)
	f_file_to_blob(arg_sfile, bBlob, true)
					
	updateblob cen_pl_layout_add_obj
		set bbitmap= :bBlob,
		where nadd_object_key 	= :arg_lAddKey;
	if sqlca.sqlcode = 0 Then
		commit;
	Else
		f_db_error(sqlca, "Save Blob failed")
		return -1
	End If
Else
	uf.mbox("Achtung", "Datei ${" + arg_sfile + "} nicht gefunden!", Information!)
	return -2	
End If

return 1
end function

public function integer of_draw_tr_nam_barcode (long al_trolley_label_key);
/*
* Objekt : uo_cart_diagram
* Methode: of_draw_tr_nam_barcode (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 28.07.2022
*
* Argument(e):
* long al_trolley_label_key
*
* Beschreibung:		Draw Barcode on the TR Cart Diagram
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	28.07.2022		Erstellung als Kopie von of_draw_barcode
*
*
* Return: integer
*
*/


Integer		li_Succ = 1
String		ls_ObjectName
String		ls_modify
String		ls_Band
String		ls_barcode_file
Long			ll_Qty = 1

String		ls_barcode
String		ls_Temp
Long			ll_Key
String		ls_PL

Integer	li_Barcode_X 
Integer	li_Barcode_Y 
Integer	li_Barcode_W 
Integer	li_Barcode_H 


li_Barcode_X = 10 // ii_Barcode_X
li_Barcode_Y = 500// ii_Barcode_Y
li_Barcode_W = 100 //ii_Barcode_W
li_Barcode_H = 100 //ii_Barcode_H


// Position = Bottom of Detail Band
li_Barcode_Y = Long ( of_describe("DataWindow.Detail.Height", FALSE))
li_Barcode_Y -= 110

guoLog.uf_debug("["+ this.classname( )+".of_draw_tr_nam_barcode] START")

ls_Band = "detail" 

ls_barcode_file =  f_gettemppath() + "cbase_nam_barcode_" + string( al_trolley_label_key , "000") + "_" + string(cpu()) + ".bmp"


//	Flug-Label VPS (WIKI)
// Barcode ID
//	npackinglistIndexKey
//	ddeparture
//	nresultKey
//	nstowageKey
//	nppmProdLabelKey

//	%001%0000020019311 8 0 42017000023495158000008154711000 0 08154711

ls_barcode = "%005%" //"%001%"


ls_barcode += String( al_trolley_label_key , "000000000000") //dwData.GetItemNumber(lRows, "cen_stowage_nstowage_key"), "000000000000")

this.of_create_barcode(58, ls_barcode_file, ls_barcode, 120,120, 75)

guoLog.uf_allways("["+ this.classname( )+".of_draw_tr_nam_barcode] "  +  this.isStowage +" - " + "create NAM Barcode " + " " + ls_barcode)

sRegisteredFiles[Upperbound(sRegisteredFiles) + 1] = ls_barcode_File

ls_ObjectName = "d_barcode_" + String(now(), "hhmmssfff")

ls_modify = "create bitmap(name=" + ls_ObjectName + " visible='" + String(1)  + "' resizeable=" + String(1) + "  moveable=" + String(1)  + &
 " band=" + ls_Band + " filename='" + ls_barcode_File + "'" + &
 " x='" + string(li_Barcode_X) + "' y='" + string(li_Barcode_Y) + &
 "' height='" + String(li_Barcode_H) + "' width='" + String(li_Barcode_W) + "' border='" + String(border_none ) + "' )"

li_Succ = of_modify(ls_modify, FALSE)

//of_set_position(ls_Name, TRUE, ab_backlog )
//dw .SetPosition ( ls_ObjectName,  is_barcode_band , TRUE )
		
if isValid(oDw) Then
	 oDw.SetPosition ( ls_ObjectName,  ls_Band , TRUE )
End If

if isValid(oDS) Then
	oDS.SetPosition ( ls_ObjectName,  ls_Band , TRUE )
End If		
	
guoLog.uf_allways("["+ this.classname( )+".of_draw_tr_nam_barcode] "  +  this.isStowage +" - " + "END")

Return li_Succ


end function

public function integer of_draw_nam_barcode (long al_pl_index_key, long al_stowage_key, string as_readable_part);

/*
* Objekt : uo_cart_diagram
* Methode: of_draw_nam_barcode (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 22.07.2022
*
* Argument(e):
* long al_pl_index_key
* long al_stowage_key
* String as_readable_part
*
* Beschreibung:		Draw another  Barcode on the Diagram Header
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	22.07.2022		Created as copy of of_draw_barcode
*
*
* Return: integer
*
*/


Integer		li_Succ = 1
String		ls_ObjectName
String		ls_modify
String		ls_Band
String		ls_barcode_file
String		ls_Value
Long			ll_Qty = 1

String		ls_barcode
String		ls_Temp
Long			ll_Key
String		ls_PL
Boolean		lb_Barcode_without_cFlightkey = FALSE
Boolean		lb_Barcode_without_Newline = FALSE


Integer	li_Barcode_X 
Integer	li_Barcode_Y 
Integer	li_Barcode_W 
Integer	li_Barcode_H 


li_Barcode_X = 10 // ii_Barcode_X
li_Barcode_Y = 500// ii_Barcode_Y
li_Barcode_W = 100 //ii_Barcode_W
li_Barcode_H = 100 //ii_Barcode_H


// Position = Bottom of Detail Band
li_Barcode_Y = Long ( of_describe("DataWindow.Detail.Height", FALSE))
li_Barcode_Y -= 110

guoLog.uf_debug("["+ this.classname( )+".of_draw_nam_barcode] START")

ls_Band = "detail" 

ls_barcode_file =  f_gettemppath() + "cbase_nam_barcode_" + string( al_pl_index_key , "000") + "_" + string(cpu()) + ".bmp"


//	Flug-Label VPS (WIKI)
// Barcode ID
//	npackinglistIndexKey
//	ddeparture
//	nresultKey
//	nstowageKey
//	nppmProdLabelKey

//	%001%0000020019311 8 0 42017000023495158000008154711000 0 08154711

IF s_app.smandant = "" THEN s_app.smandant = "002"

ls_Value = f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagramBarcode", "IncludeFlightKey", "1")
IF ls_Value = "0" THEN
	lb_Barcode_without_cFlightkey = TRUE
END IF
ls_Value = f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagramBarcode", "IncludeNewline", "1")
IF ls_Value = "0" THEN
	lb_Barcode_without_Newline = TRUE
END IF

ls_barcode = "%001%" // "%001%" standard Format


ls_Temp = String( al_pl_index_key , "000000000000")
ls_barcode += ls_Temp
ls_Temp = String( idt_departure,"DDMMYYYY") //  strFlightInfo.dtDepartureDate,"YYYYMMDD")
ls_barcode += ls_Temp
ls_Temp = String( il_Result_Key,  "000000000000")
ls_barcode += ls_Temp
ls_Temp = String( al_stowage_key , "000000000000") //dwData.GetItemNumber(lRows, "cen_stowage_nstowage_key"), "000000000000")
ls_barcode += ls_Temp
					
ll_Key = 0
select min(nppm_prod_label_key) 
into :ll_Key
from cen_out_ppm_prod_label 
where nresult_key = :il_Result_Key
and nstowage_key = :al_stowage_key
and npl_index_key = :al_pl_index_key   ;

IF SQLCA.SQLCode = 0 Then
	// OK
Else
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_nam_barcode Error " + SQLCA.sqlerrtext + " " + String(SQLCA.SQLCode) )
	SetNULL(ll_Key)
End If
If ll_Key = 0 Then
	SetNULL(ll_Key)
End If

// no Key => no Barcode
IF IsNULL(ll_Key) OR ll_Key < 1 THEN
	guoLog.uf_debug( "["+ this.classname( )+".of_draw_nam_barcode no match in cen_out_ppm_prod_label " + String(al_pl_index_key)+"/"+String(al_stowage_key))							
	RETURN -1	
END IF

if not isnull(ll_Key) Then
	ls_Temp = String(ll_Key,  "000000000000")	
Else
	ls_Temp = "000000000000"	
End If
ls_barcode += ls_Temp
// End of "old" part

// Add "readable" part / cFlightKey
IF lb_Barcode_without_Newline = FALSE THEN
	ls_barcode += "~r~n"	
END IF
IF lb_Barcode_without_cFlightkey = FALSE THEN
	ls_barcode += as_Readable_Part
End If	

this.of_create_barcode(58, ls_barcode_file, ls_barcode, 120, 120, 75)
guoLog.uf_allways("["+ this.classname( )+".of_draw_nam_barcode] "  +  this.isStowage +" - " + "create NAM Barcode " + " " + ls_barcode)

sRegisteredFiles[Upperbound(sRegisteredFiles) + 1] = ls_barcode_File

ls_ObjectName = "d_barcode_" + String(now(), "hhmmssfff")

ls_modify = "create bitmap(name=" + ls_ObjectName + " visible='" + String(1)  + "' resizeable=" + String(1) + "  moveable=" + String(1)  + &
 " band=" + ls_Band + " filename='" + ls_barcode_File + "'" + &
 " x='" + string(li_Barcode_X) + "' y='" + string(li_Barcode_Y) + &
 "' height='" + String(li_Barcode_H) + "' width='" + String(li_Barcode_W) + "' border='" + String(border_none ) + "' )"

li_Succ = of_modify(ls_modify, FALSE)
		
if isValid(oDw) Then
	 oDw.SetPosition ( ls_ObjectName,  ls_Band , TRUE )
End If

if isValid(oDS) Then
	oDS.SetPosition ( ls_ObjectName,  ls_Band , TRUE )
End If		
	
guoLog.uf_debug("["+ this.classname( )+".of_draw_nam_barcode] END")

//il_Stowage_Keys[upperbound(il_Stowage_Keys) + 1] = al_Stowage_key

//SetNULL(lb_barcode)

Return li_Succ


end function

public function long of_sd_add_noshiftassignment (long al_row_id, string as_galley, string as_stowage, string as_cart, string as_component, string as_text, string as_unit, string as_information);/*
* Objekt : uo_cart_diagram
* Methode: of_sd_add_error (Function)
* Autor  : Oliver H$$HEX1$$f600$$ENDHEX$$fer
* Datum  : 13.08.2012
*
* Argument(e):
*	 long al_row_id
*	 string as_galley
*	 string as_stowage
*	 string as_cart
*	 string as_loadinglist
*	 string as_component
*	 string as_text
*	 long al_distribution
*	 string as_parameter
*	 string as_definition
*	 string as_unit
*
* Beschreibung:		Add Entry "Secondary Distribution Error" (ids_SD_Message / cen_out_sd_message)
*
* Aenderungshistorie:
* Version 		Wer			Wann			Was und warum
* 1.0 			O.Hoefer	13.08.2012		Erstellung
*
*
* Return: long
*
*/

Integer	li_Succ
Long		ll_New_Row
Long		ll_MSG_Key


//if il_Disable_Debug = 0 then guoLog.uf_debug( "["+ this.classname( )+".of_sd_add_error Text " + as_COMPONENT + " / " + as_PARAMETER)

ll_MSG_Key = f_Sequence ("SEQ_CEN_OUT_SD_message", sqlca)
If ll_MSG_Key = -1 Then
	uf.MBox ("Datenbankfehler", "Es konnte kein eindeutiger Schl$$HEX1$$fc00$$ENDHEX$$ssel (Sequence) ermittelt werden.~r~r" + &
									 "Keine Neuanlage m$$HEX1$$f600$$ENDHEX$$glich.", StopSign!)
	 Return -1
end if

ll_New_Row = ids_SD_Message.insertrow(0)

li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nresult_key", il_Result_Key )						
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "ntransaction", il_transaction )
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "nrowid", al_Row_id)
li_Succ = ids_SD_Message.SetItem(ll_New_Row, "npage", ii_Current_Page)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nsd_msg_key", ll_MSG_Key)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "nmsgtype", MSG_NOSHIFTASSIGNED)
// Secondary Distribution Error Report
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CGALLEY",as_galley)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CSTOWAGE",as_stowage)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CCART",as_cart)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "CLOADINGLIST",as_LOADINGLIST)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CCOMPONENT",as_COMPONENT)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CTEXT",as_TEXT)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "NDISTRIBUTION",al_DISTRIBUTION)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "CPARAMETER",as_PARAMETER)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "CPACKINGLIST",as_Definition)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "CUNIT",as_unit)
li_Succ = ids_SD_Message.setitem(ll_New_Row, "cbacklog", as_Information)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "nrow",arg_l_row)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncolumn",arg_l_column)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "cobject",arg_s_object)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "nitems", arg_dec_items)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "ncounter",arg_l_counter)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "ntype", arg_l_type)
//li_Succ = ids_SD_Message.setitem(ll_New_Row, "cpackinglist", lsText)

ids_SD_Message.sort()

Return ll_New_Row

end function

public function boolean of_is_tr_barcode_enabled ();// --------------------------------------------------------------------------------
// Objekt : uo_cart_diagram
// Methode: is_tr_barcode_enabled (Function)
// Autor  :
// --------------------------------------------------------------------------------
// Argument(e):
// none
// --------------------------------------------------------------------------------
// Return: boolean
// --------------------------------------------------------------------------------
//  Beschreibung:     Check Setting "Barcode on Transporter Cart Diagram"
//
//
// --------------------------------------------------------------------------------
//  Modifikationen:
//  Datum    Version        Autor              Kommentar
// --------------------------------------------------------------------------------
//  29.07.2022	                                Erstellung
//
// --------------------------------------------------------------------------------


Boolean lb_Ret= FALSE
String	ls_Section
Integer li_Config
String	ls_Value, ls_Default

// ----------------------------------------------------------------------
// bei Doc Gen Service nicht aus Profile, sondern Parameter
// ----------------------------------------------------------------------
If ib_use_doc_gen_settings Then
	If inv_doc_gen_settings.il_NENABLE_TR_BARCODE = 1 then
		lb_Ret = TRUE
		ib_BarCode_on_TR_CartDiagram = TRUE
	ELSE
		lb_Ret = FALSE
		ib_BarCode_on_TR_CartDiagram = FALSE
	end if
Else
	If is_section > "" Then
		ls_Section = is_section
	Else
		ls_Section = of_profilestring(s_app.suser,"settings_master", "ACTIVESETUP", "docbrowser")
		if trim(ls_Section) = "" Then ls_Section = "docbrowser"
	End if
	
	if ls_Section <> "docbrowser" Then
		li_config = integer(Mid(ls_Section,11))
		ls_Default ="Default" +string(li_config)
	Else
		ls_Default ="Default"
	End If
		
	// Barcode on TR Cart Diagram
	//ls_Value = of_profilestring(s_app.suser,ls_Default,"CartDiagramTRBarcode","0") 
	ls_Value = f_unitprofilestring("Default" , "CartDiagramTRBarcode", "" , is_CSC) 
	If ls_Value = "1" Then
		lb_Ret = TRUE
		ib_BarCode_on_TR_CartDiagram = TRUE
	ELSE
		lb_Ret = FALSE
		ib_BarCode_on_TR_CartDiagram = FALSE
	End if
	
		
End if


return lb_Ret


end function

public function long of_get_blob_to_file (longlong arg_lladdkey, string arg_stemppath, string arg_sfile);/*************************************************************
* Objekt : uo_cart_diagram
* Methode: of_get_blob_to_file (Function)
* Autor  : Ulrich Paudler [UP]
* Datum  : 16.04.2009
*
* Argument(e):	longlong arg_lladdkey
* Return: string
*
*
*
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
*
*************************************************************/

Blob bBlob

selectblob bbitmap
	into :bBlob
	from cen_pl_layout_add_obj
	where nadd_object_key 	= :arg_lladdkey;
	
if sqlca.sqlcode <> 0 Then
	f_db_error(sqlca, "of_get_blob_to_file()")
	return -1
End If

if Right(arg_sTemppath, 1) <> "\" Then arg_sTemppath += "\" 
this.of_blob_to_file(arg_sTemppath + arg_sFile, bBlob)

return 1

end function

on uo_cart_diagram.create
call super::create
TriggerEvent( this, "constructor" )
end on

on uo_cart_diagram.destroy
TriggerEvent( this, "destructor" )
call super::destroy
end on

event constructor;/*************************************************************
* Objekt : uo_cart_diagram
* Methode: constructor (Event)
* Autor  : Ulrich Paudler [UP]
* Datum  : 15.04.2009
*
* Argument(e):	none
* Return: long
*
*
*
*
*
*************************************************************
* Modifikationen:
* Datum    Version        Autor              Kommentar
*------------------------------------------------------------
* 15.04.2009 1.1		Ulrich Paudler		Logfile in Temppath legen
* 03.09.2009 1.2		Ulrich Paudler		Backlog hinzugef$$HEX1$$fc00$$ENDHEX$$gt
* 30.09.2009 1.3		Ulrich Paudler		Cache Objekte leeren
* 05.10.2009 1.4		Ulrich Paudler		Groessenpruefung hinzu
* 12.06.2013 1.5		Oliver H$$HEX1$$f600$$ENDHEX$$fer  		IM10379289 ExactMatch, but disregard SPML switch 
* 16.01.2014 1.6		Oliver H$$HEX1$$f600$$ENDHEX$$fer  		"Watermark" Belly
* 27.02.2014 1.7		Oliver H$$HEX1$$f600$$ENDHEX$$fer  		Allocate TR Cart to Truck, Workstation CBASE-UK-CR-2013-002
* 16.01.2014 1.6		Oliver H$$HEX1$$f600$$ENDHEX$$fer  		"Watermark" Belly
* 27.01.2020 1.7		Oliver H$$HEX1$$f600$$ENDHEX$$fer  		Log file Name
*************************************************************/
String	ls_Temp
Integer	li_Ret

// Initialisieren f$$HEX1$$fc00$$ENDHEX$$r of_generate_filename()
Randomize(0)
guoLog.uf_debug("["+ this.classname( )+".constructor] create")
this.sTemppath  = f_gettemppath()

this.is_Logfile = this.sTemppath + "cart_diagram_"+ gs_instance_name + "_" +string(today(), "yyyy-mm-dd")+".log"

dsAirlineEq = create uo_cart_datastore 
dsAirlineEq.of_set_log_file(this.is_Logfile)
dsAirlineEq.Dataobject = "dw_uo_airline_eq"
dsAirlineEq.Settransobject(sqlca)

dsLayout = create uo_cart_datastore 
dsLayout.Dataobject = "dw_uo_packinglist_layout"
dsLayout.of_set_log_file(this.is_Logfile)
dsLayout.Settransobject(sqlca)

dsLayoutDetail = create uo_cart_datastore 
dsLayoutDetail.of_set_log_file(this.is_Logfile)
dsLayoutDetail.Dataobject = "dw_uo_packinglist_layout_detail"
dsLayoutDetail.Settransobject(sqlca)
dsLayoutDetail.iDebug = 0

dsLayoutContents = create uo_cart_datastore 
dsLayoutContents.of_set_log_file(this.is_Logfile)
dsLayoutContents.Dataobject = "dw_uo_packinglist_layout_contents"
dsLayoutContents.Settransobject(sqlca)

dsLayoutDimension = create uo_cart_datastore 
dsLayoutDimension.of_set_log_file(this.is_Logfile)
dsLayoutDimension.Dataobject = "dw_uo_packinglist_layout_dimensions"
dsLayoutDimension.Settransobject(sqlca)
dsLayoutDimension.iDebug = 0

dsLayoutAddObjects = create uo_cart_datastore 
dsLayoutAddObjects.of_set_log_file(this.is_Logfile)
dsLayoutAddObjects.Dataobject = "dw_uo_packinglist_layout_add_objects"
dsLayoutAddObjects.Settransobject(sqlca)

dsPL = create uo_cart_datastore 
dsPL.of_set_log_file(this.is_Logfile)
dsPL.Dataobject = "dw_uo_packinglist"
dsPL.Settransobject(sqlca)

dsPLContents = create uo_cart_datastore 
dsPLContents.of_set_log_file(this.is_Logfile)
dsPLContents.Dataobject = "dw_uo_packinglist_detail"
dsPLContents.Settransobject(sqlca)
dsPLContents.iDebug = 0

dsObjects = create uo_cart_datastore 
dsObjects.of_set_log_file(this.is_Logfile)
dsObjects.Dataobject = "dw_uo_registered_objects"
dsObjects.Settransobject(sqlca)

// 03.09.2009 Ulrich Paudler [UP]
dsBacklog = create uo_cart_datastore 
dsBacklog.of_set_log_file(this.is_Logfile)
dsBacklog.Dataobject = "dw_uo_layout_backlog_n" 
dsBacklog.Settransobject(sqlca)

// Content Spec instead of Backlog CBASE-NAM-CR-16008
ids_CSLoadingHeader = create datastore 	 
ids_CSLoadingHeader.dataobject = "dw_loading_list_result_detail"

ids_CSLoadingContents = create datastore 	 
ids_CSLoadingContents.dataobject = "dw_loading_list_result_detail"




// 30.09.2009 Ulrich Paudler [UP]
ilCachedAirlineKey = 0
isCachedUnit = ""

// 05.10.2009 Ulrich Paudler [UP]
dsPLSize = create uo_cart_datastore 
dsPLSize.of_set_log_file(this.is_Logfile)
dsPLSize.Dataobject = "dw_uo_cart_packinglist_size" 
dsPLSize.Settransobject(sqlca)

ids_TR_Exclusions = CREATE DataStore
ids_TR_Exclusions.DataObject = "dw_ext_3_cols"

ls_Temp = f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "ExpandTRCart", "0")
If ls_Temp = "1" Then
	ib_Expand_TR_Cart = TRUE
End If

ids_Diagram_Pages								= create DataStore
ids_Diagram_Pages.DataObject 				= "dw_cen_out_cartdiagrams"
ids_Diagram_Pages.SetTransObject(SQLCA)


//Integer					ii_Barcode_X = 630
//Integer					ii_Barcode_Y = 5
//String					is_Barcode_Band = "header"
ii_Barcode_X = Integer( f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "BarcodeX", "630"))
ii_Barcode_Y = Integer( f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "BarcodeY", "5"))
ii_Barcode_W = Integer( f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "BarcodeW", "80"))
ii_Barcode_H = Integer( f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "BarcodeH", "80"))
is_Barcode_Band =  f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "BarcodeBand", "header")


// ---------------------------------------------------
// CR NAM 12008 Drei verschiedene overflow messages
// ---------------------------------------------------
// Use Content Spec to display all Items
// See Overflow for more details
// See Content Spec and Overflow Report
is_Overflow_MSG_1	= uf.translate("weitere auf Inhaltsansicht") 
is_Overflow_MSG_2 = uf.translate("$$HEX1$$dc00$$ENDHEX$$berlaufprotokoll mit weiteren Daten")
is_Overflow_MSG_3 = uf.translate("siehe $$HEX1$$dc00$$ENDHEX$$berlaufprotokoll/Inhaltsansicht") 
ls_Temp = f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "DisableContentSpecMSG", "0")
If ls_Temp = "1" Then
	ib_Disable_Content_Spec_MSG = TRUE
End If


// ---------------------------------------------------
// CR 2575 Bookmarks in Cart Diagram PDF
// ---------------------------------------------------
ls_Temp = f_mandant_profilestring(sqlca, s_app.smandant, "CartDiagram", "EnableBookmark", "0")
If ls_Temp = "1" Then
	ib_Cart_Diagram_Bookmark = TRUE
End If


// ---------------------------------------
// Secondary Distribution DataStores
// ---------------------------------------
ids_SD_Master							= CREATE uo_CBASE_DataStore
ids_SD_Master.DataObject			= "dw_uo_sec_dis_master"
ids_SD_Master.SetTransObject(SQLCA)
ids_SD_Components						= CREATE uo_CBASE_DataStore
ids_SD_Components.DataObject		= "dw_uo_sec_dis_comp"
ids_SD_Components.SetTransObject(SQLCA)
ids_SD_Cart								= CREATE uo_CBASE_DataStore	
ids_SD_Cart.DataObject				= "dw_uo_sec_dis_cart"
ids_SD_Cart.SetTransObject(SQLCA)
ids_SD_Cart_Drawer					= CREATE uo_CBASE_DataStore
ids_SD_Cart_Drawer.DataObject		= "dw_uo_sec_dis_drawer"
ids_SD_Cart_Drawer.SetTransObject(SQLCA)
ids_SD_Drawer_Content				= CREATE uo_CBASE_DataStore
ids_SD_Drawer_Content.DataObject = "dw_uo_sec_dis_content"
ids_SD_Drawer_Content.SetTransObject(SQLCA)
ids_SD_Message							= CREATE uo_CBASE_DataStore
ids_SD_Message.DataObject			= "dw_uo_sec_dis_message"
ids_SD_Message.SetTransObject(SQLCA)

If isnull( s_app.sMandant) or  s_app.sMandant = "" then 
   s_app.sMandant = "002"
End If

// -----------------------------------------------------------------
// 12.06.2013: IM10379289 ExactMatch, but disregard SPML switch 
// -----------------------------------------------------------------
ls_Temp = f_mandant_profilestring(sqlca, s_app.smandant, "CARTDIAGRAM", "EXACTMATCHIGNORESPML", "0")
If ls_Temp = "1" Then
	ib_exact_match_ignore_SPML = TRUE
Else
	ib_exact_match_ignore_SPML = FALSE
End If

// -----------------------------------------------------------------
// 16.01.2014: "Watermark" Belly
// -----------------------------------------------------------------
ls_Temp = f_mandant_profilestring(sqlca, s_app.smandant, "CARTDIAGRAM", "BELLYWATERMARK", "0")
If ls_Temp = "1" Then
	ib_Belly_Watermark = TRUE
Else
	ib_Belly_Watermark = FALSE
End If

// -----------------------------------------------------------------
// 26.02.2014: Allocate TR Cart to Truck, Workstation CBASE-UK-CR-2013-002
// -----------------------------------------------------------------
ls_Temp = f_mandant_profilestring(sqlca, s_app.smandant, "TRCARTDIAGRAM", "USEEXTENDEDALLOCATION", "0")
If ls_Temp = "1" Then
	ib_Extended_TR_Handling = TRUE
End If


end event

event destructor;/*************************************************************
* Objekt : uo_cart_diagram
* Methode: destructor (Event)
* Autor  : Ulrich Paudler [UP]
* Datum  : 03.09.2009
* Argument(e):
* none
*
* Return: long
*
*
*
*
**************************************************************
*  Modifikationen:
*  Datum    Version        Autor              Kommentar
* --------------------------------------------------------------------------------
*  05.10.2009 1.1		Ulrich Paudler	Groessenpruefung hinzu
*
*************************************************************/
Long	i

DESTROY dsAirlineEq
DESTROY dsLayout
DESTROY dsLayoutDetail
DESTROY dsLayoutContents
DESTROY dsLayoutDimension
DESTROY dsLayoutAddObjects
DESTROY dsPL
DESTROY dsPLContents
DESTROY dsObjects
DESTROY	ids_TR_Exclusions
For i = 1 to Upperbound(sRegisteredFiles)
	Filedelete(sRegisteredFiles[i])
Next

// 03.09.2009 Ulrich Paudler [UP]
DESTROY dsBacklog

// 05.10.2009 Ulrich Paudler [UP]
DESTROY dsPLSize

// ---------------------------------------
// Secondary Distribution DataStores
// ---------------------------------------
DESTROY	ids_SD_Master			
DESTROY	ids_SD_Components		
DESTROY	ids_SD_Cart				
DESTROY	ids_SD_Cart_Drawer	
DESTROY	ids_SD_Drawer_Content	
DESTROY	ids_SD_Message


DESTROY	ids_Diagram_Pages

// ------- Content Spec --------
DESTROY	ids_CSLoadingHeader
DESTROY	ids_CSLoadingContents

// 05.11.2009 Ulrich Paudler [UP]
if isvalid(iuo_CartDistribution) Then destroy iuo_CartDistribution

//if isvalid(uoDistribution) Then destroy uoDistribution

// Document Engine st$$HEX1$$fc00$$ENDHEX$$rzt bei GarbageCollect() ab
If getApplication().AppName = "cbase" Then GarbageCollect()

guoLog.uf_debug("["+ this.classname( )+".destructor] destroy")
end event

